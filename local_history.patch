Index: Build/src/main/java/com/tyron/build/log/ILogger.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/log/ILogger.java b/Build/src/main/java/com/tyron/build/log/ILogger.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/log/ILogger.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,65 +0,0 @@
-package com.tyron.build.log;
-
-import com.tyron.build.model.DiagnosticWrapper;
-
-public interface ILogger {
-
-    public static ILogger wrap(LogViewModel logViewModel) {
-        return new ILogger() {
-            @Override
-            public void info(DiagnosticWrapper wrapper) {
-
-            }
-
-            @Override
-            public void debug(DiagnosticWrapper wrapper) {
-                logViewModel.d(LogViewModel.BUILD_LOG, wrapper);
-            }
-
-            @Override
-            public void warning(DiagnosticWrapper wrapper) {
-                logViewModel.w(LogViewModel.BUILD_LOG, wrapper);
-            }
-
-            @Override
-            public void error(DiagnosticWrapper wrapper) {
-                logViewModel.e(LogViewModel.BUILD_LOG, wrapper);
-            }
-        };
-    }
-    void info(DiagnosticWrapper wrapper);
-
-    void debug(DiagnosticWrapper wrapper);
-
-    void warning(DiagnosticWrapper wrapper);
-
-    void error (DiagnosticWrapper wrapper);
-
-
-
-    default void info(String message) {
-        debug(wrap(message));
-    }
-
-    default void debug(String message) {
-        debug(wrap(message));
-    }
-
-    default void warning(String message) {
-        warning(wrap(message));
-    }
-
-    default void error(String message) {
-       error(wrap(message));
-    }
-
-    default void verbose(String message) {
-
-    }
-
-    static DiagnosticWrapper wrap(String message) {
-        DiagnosticWrapper wrapper = new DiagnosticWrapper();
-        wrapper.setMessage(message);
-        return wrapper;
-    }
-}
Index: Build/src/main/java/com/tyron/build/log/LogViewModel.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/log/LogViewModel.java b/Build/src/main/java/com/tyron/build/log/LogViewModel.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/log/LogViewModel.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,85 +0,0 @@
-package com.tyron.build.log;
-
-import android.os.Handler;
-import android.os.Looper;
-
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.ViewModel;
-
-import com.tyron.build.model.DiagnosticWrapper;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class LogViewModel extends ViewModel {
-    
-    private static int totalCount;
-    public static final int APP_LOG = totalCount++;
-    public static final int BUILD_LOG = totalCount++;
-    public static final int DEBUG = totalCount++;
-
-    private final Handler mainHandler = new Handler(Looper.getMainLooper());
-
-    private List<MutableLiveData<List<DiagnosticWrapper>>> log;
-    
-    public LiveData<List<DiagnosticWrapper>> getLogs(int id) {
-        if (log == null) {
-            log = init();
-        }
-        return log.get(id);
-    }
-    
-    private List<MutableLiveData<List<DiagnosticWrapper>>> init() {
-        List<MutableLiveData<List<DiagnosticWrapper>>> list = new ArrayList<>();
-        for (int i = 0; i < totalCount; i++) {
-            list.add(new MutableLiveData<>(new ArrayList<>()));
-        }
-        return list;
-    }
-    
-    public void clear(int id) {
-        MutableLiveData<List<DiagnosticWrapper>> data = (MutableLiveData<List<DiagnosticWrapper>>) getLogs(id);
-        data.setValue(new ArrayList<>());
-    }
-
-    public void e(int id, DiagnosticWrapper diagnostic) {
-        add(id, diagnostic);
-    }
-
-    public void d(int id, DiagnosticWrapper diagnosticWrapper) {
-        add(id, diagnosticWrapper);
-    }
-
-    public void w(int id, DiagnosticWrapper diagnosticWrapper) {
-        add(id, diagnosticWrapper);
-    }
-
-
-    /**
-     * Convenience method to add a diagnostic to a ViewModel
-     * @param id the log id to set to
-     * @param diagnosticWrapper the DiagnosticWrapper to add
-     */
-    private void add(int id, DiagnosticWrapper diagnosticWrapper) {
-        List<DiagnosticWrapper> list = getLogs(id).getValue();
-        if (list == null) {
-            list = new ArrayList<>();
-        }
-        list.add(diagnosticWrapper);
-        maybePost(id, list);
-    }
-
-    /**
-     * Checks if the current thread is the main thread and does not post it if so
-     * @param id log id to set the value to
-     * @param current Value to set to the ViewModel
-     */
-    private void maybePost(int id, List<DiagnosticWrapper> current) {
-        if (Thread.currentThread() != Looper.getMainLooper().getThread()) {
-            log.get(id).postValue(current);
-        } else {
-            log.get(id).setValue(current);
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/util/SdkUtils.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/util/SdkUtils.java b/Build/src/main/java/com/tyron/build/util/SdkUtils.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/util/SdkUtils.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,486 +0,0 @@
-package com.tyron.build.util;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import com.google.common.base.CaseFormat;
-import com.google.common.base.Charsets;
-import com.google.common.collect.ImmutableList;
-import com.google.common.io.ByteStreams;
-import com.google.common.io.Closeables;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.text.NumberFormat;
-import java.text.ParseException;
-import java.util.List;
-
-/** Miscellaneous utilities used by the Android SDK tools */
-public class SdkUtils {
-    /**
-     * Returns true if the given string ends with the given suffix, using a
-     * case-insensitive comparison.
-     *
-     * @param string the full string to be checked
-     * @param suffix the suffix to be checked for
-     * @return true if the string case-insensitively ends with the given suffix
-     */
-    public static boolean endsWithIgnoreCase(@NonNull String string, @NonNull String suffix) {
-        return string.regionMatches(true /* ignoreCase */, string.length() - suffix.length(),
-                suffix, 0, suffix.length());
-    }
-
-    /**
-     * Returns true if the given sequence ends with the given suffix (case
-     * sensitive).
-     *
-     * @param sequence the character sequence to be checked
-     * @param suffix the suffix to look for
-     * @return true if the given sequence ends with the given suffix
-     */
-    public static boolean endsWith(@NonNull CharSequence sequence, @NonNull CharSequence suffix) {
-        return endsWith(sequence, sequence.length(), suffix);
-    }
-
-    /**
-     * Returns true if the given sequence ends at the given offset with the given suffix (case
-     * sensitive)
-     *
-     * @param sequence the character sequence to be checked
-     * @param endOffset the offset at which the sequence is considered to end
-     * @param suffix the suffix to look for
-     * @return true if the given sequence ends with the given suffix
-     */
-    public static boolean endsWith(@NonNull CharSequence sequence, int endOffset,
-                                   @NonNull CharSequence suffix) {
-        if (endOffset < suffix.length()) {
-            return false;
-        }
-
-        for (int i = endOffset - 1, j = suffix.length() - 1; j >= 0; i--, j--) {
-            if (sequence.charAt(i) != suffix.charAt(j)) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Returns true if the given string starts with the given prefix, using a
-     * case-insensitive comparison.
-     *
-     * @param string the full string to be checked
-     * @param prefix the prefix to be checked for
-     * @return true if the string case-insensitively starts with the given prefix
-     */
-    public static boolean startsWithIgnoreCase(@NonNull String string, @NonNull String prefix) {
-        return string.regionMatches(true /* ignoreCase */, 0, prefix, 0, prefix.length());
-    }
-
-    /**
-     * Returns true if the given string starts at the given offset with the
-     * given prefix, case insensitively.
-     *
-     * @param string the full string to be checked
-     * @param offset the offset in the string to start looking
-     * @param prefix the prefix to be checked for
-     * @return true if the string case-insensitively starts at the given offset
-     *         with the given prefix
-     */
-    public static boolean startsWith(@NonNull String string, int offset, @NonNull String prefix) {
-        return string.regionMatches(true /* ignoreCase */, offset, prefix, 0, prefix.length());
-    }
-
-    /**
-     * Strips the whitespace from the given string
-     *
-     * @param string the string to be cleaned up
-     * @return the string, without whitespace
-     */
-    public static String stripWhitespace(@NonNull String string) {
-        StringBuilder sb = new StringBuilder(string.length());
-        for (int i = 0, n = string.length(); i < n; i++) {
-            char c = string.charAt(i);
-            if (!Character.isWhitespace(c)) {
-                sb.append(c);
-            }
-        }
-
-        return sb.toString();
-    }
-
-    /**
-     * Returns true if the given string has an upper case character.
-     *
-     * @param s the string to check
-     * @return true if it contains uppercase characters
-     */
-    public static boolean hasUpperCaseCharacter(@NonNull String s) {
-        for (int i = 0; i < s.length(); i++) {
-            if (Character.isUpperCase(s.charAt(i))) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /** For use by {@link #getLineSeparator()} */
-    private static String sLineSeparator;
-
-    /**
-     * Returns the default line separator to use.
-     * <p>
-     * NOTE: If you have an associated IDocument (Eclipse), it is better to call
-     * TextUtilities#getDefaultLineDelimiter(IDocument) since that will
-     * allow (for example) editing a \r\n-delimited document on a \n-delimited
-     * platform and keep a consistent usage of delimiters in the file.
-     *
-     * @return the delimiter string to use
-     */
-    @NonNull
-    public static String getLineSeparator() {
-        if (sLineSeparator == null) {
-            // This is guaranteed to exist:
-            sLineSeparator = System.getProperty("line.separator"); //$NON-NLS-1$
-        }
-
-        return sLineSeparator;
-    }
-
-    /**
-     * Wraps the given text at the given line width, with an optional hanging
-     * indent.
-     *
-     * @param text the text to be wrapped
-     * @param lineWidth the number of characters to wrap the text to
-     * @param hangingIndent the hanging indent (to be used for the second and
-     *            subsequent lines in each paragraph, or null if not known
-     * @return the string, wrapped
-     */
-    @NonNull
-    public static String wrap(
-            @NonNull String text,
-            int lineWidth,
-            @Nullable String hangingIndent) {
-        if (hangingIndent == null) {
-            hangingIndent = "";
-        }
-        int explanationLength = text.length();
-        StringBuilder sb = new StringBuilder(explanationLength * 2);
-        int index = 0;
-
-        while (index < explanationLength) {
-            int lineEnd = text.indexOf('\n', index);
-            int next;
-
-            if (lineEnd != -1 && (lineEnd - index) < lineWidth) {
-                next = lineEnd + 1;
-            } else {
-                // Line is longer than available width; grab as much as we can
-                lineEnd = Math.min(index + lineWidth, explanationLength);
-                if (lineEnd - index < lineWidth) {
-                    next = explanationLength;
-                } else {
-                    // then back up to the last space
-                    int lastSpace = text.lastIndexOf(' ', lineEnd);
-                    if (lastSpace > index) {
-                        lineEnd = lastSpace;
-                        next = lastSpace + 1;
-                    } else {
-                        // No space anywhere on the line: it contains something wider than
-                        // can fit (like a long URL) so just hard break it
-                        next = lineEnd + 1;
-                    }
-                }
-            }
-
-            if (sb.length() > 0) {
-                sb.append(hangingIndent);
-            } else {
-                lineWidth -= hangingIndent.length();
-            }
-
-            sb.append(text.substring(index, lineEnd));
-            sb.append('\n');
-            index = next;
-        }
-
-        return sb.toString();
-    }
-
-    /**
-     * Returns the given localized string as an int. For example, in the
-     * US locale, "1,000", will return 1000. In the French locale, "1.000" will return
-     * 1000. It will return 0 for empty strings.
-     * <p>
-     * To parse a string without catching parser exceptions, call
-     * {@link #parseLocalizedInt(String, int)} instead, passing the
-     * default value to be returned if the format is invalid.
-     *
-     * @param string the string to be parsed
-     * @return the integer value
-     * @throws ParseException if the format is not correct
-     */
-    public static int parseLocalizedInt(@NonNull String string) throws ParseException {
-        if (string.isEmpty()) {
-            return 0;
-        }
-        return NumberFormat.getIntegerInstance().parse(string).intValue();
-    }
-
-    /**
-     * Returns the given localized string as an int. For example, in the
-     * US locale, "1,000", will return 1000. In the French locale, "1.000" will return
-     * 1000.  If the format is invalid, returns the supplied default value instead.
-     *
-     * @param string the string to be parsed
-     * @param defaultValue the value to be returned if there is a parsing error
-     * @return the integer value
-     */
-    public static int parseLocalizedInt(@NonNull String string, int defaultValue) {
-        try {
-            return parseLocalizedInt(string);
-        } catch (ParseException e) {
-            return defaultValue;
-        }
-    }
-
-    /**
-     * Returns the given localized string as a double. For example, in the
-     * US locale, "3.14", will return 3.14. In the French locale, "3,14" will return
-     * 3.14. It will return 0 for empty strings.
-     * <p>
-     * To parse a string without catching parser exceptions, call
-     * {@link #parseLocalizedDouble(String, double)} instead, passing the
-     * default value to be returned if the format is invalid.
-     *
-     * @param string the string to be parsed
-     * @return the double value
-     * @throws ParseException if the format is not correct
-     */
-    public static double parseLocalizedDouble(@NonNull String string) throws ParseException {
-        if (string.isEmpty()) {
-            return 0.0;
-        }
-        return NumberFormat.getNumberInstance().parse(string).doubleValue();
-    }
-
-    /**
-     * Returns the given localized string as a double. For example, in the
-     * US locale, "3.14", will return 3.14. In the French locale, "3,14" will return
-     * 3.14. If the format is invalid, returns the supplied default value instead.
-     *
-     * @param string the string to be parsed
-     * @param defaultValue the value to be returned if there is a parsing error
-     * @return the double value
-     */
-    public static double parseLocalizedDouble(@NonNull String string, double defaultValue) {
-        try {
-            return parseLocalizedDouble(string);
-        } catch (ParseException e) {
-            return defaultValue;
-        }
-    }
-
-    /**
-     * Returns the corresponding {@link File} for the given file:// url
-     *
-     * @param url the URL string, e.g. file://foo/bar
-     * @return the corresponding {@link File} (which may or may not exist)
-     * @throws MalformedURLException if the URL string is malformed or is not a file: URL
-     */
-    @NonNull
-    public static File urlToFile(@NonNull String url) throws MalformedURLException {
-        return urlToFile(new URL(url));
-    }
-
-    @NonNull
-    public static File urlToFile(@NonNull URL url) throws MalformedURLException {
-        try {
-            return new File(url.toURI());
-        }
-        catch (IllegalArgumentException e) {
-            MalformedURLException ex = new MalformedURLException(e.getLocalizedMessage());
-            ex.initCause(e);
-            throw ex;
-        }
-        catch (URISyntaxException e) {
-            return new File(url.getPath());
-        }
-    }
-
-    /**
-     * Returns the corresponding URL string for the given {@link File}
-     *
-     * @param file the file to look up the URL for
-     * @return the corresponding URL
-     * @throws MalformedURLException in very unexpected cases
-     */
-    public static String fileToUrlString(@NonNull File file) throws MalformedURLException {
-        return fileToUrl(file).toExternalForm();
-    }
-
-    /**
-     * Returns the corresponding URL for the given {@link File}
-     *
-     * @param file the file to look up the URL for
-     * @return the corresponding URL
-     * @throws MalformedURLException in very unexpected cases
-     */
-    public static URL fileToUrl(@NonNull File file) throws MalformedURLException {
-        return file.toURI().toURL();
-    }
-
-    /** Prefix in comments which mark the source locations for merge results */
-    public static final String FILENAME_PREFIX = "From: ";
-
-    /**
-     * Creates the path comment XML string. Note that it does not escape characters
-     * such as &amp; and &lt;; those are expected to be escaped by the caller (for
-     * example, handled by a call to {@link org.w3c.dom.Document#createComment(String)})
-     *
-     *
-     * @param file the file to create a path comment for
-     * @param includePadding whether to include padding. The final comment recognized by
-     *                       error recognizers expect padding between the {@code <!--} and
-     *                       the start marker (From:); you can disable padding if the caller
-     *                       already is in a context where the padding has been added.
-     * @return the corresponding XML contents of the string
-     */
-    public static String createPathComment(@NonNull File file, boolean includePadding)
-            throws MalformedURLException {
-        String url = fileToUrlString(file);
-        int dashes = url.indexOf("--");
-        if (dashes != -1) { // Not allowed inside XML comments - for SGML compatibility. Sigh.
-            url = url.replace("--", "%2D%2D");
-        }
-
-        if (includePadding) {
-            return ' ' + FILENAME_PREFIX + url + ' ';
-        } else {
-            return FILENAME_PREFIX + url;
-        }
-    }
-
-    /**
-     * Copies the given XML file to the given new path. It also inserts a comment at
-     * the end of the file which points to the original source location. This is intended
-     * for use with error parsers which can rewrite for example AAPT error messages in
-     * say layout or manifest files, which occur in the merged (copied) output, and present
-     * it as an error pointing to one of the user's original source files.
-     */
-    public static void copyXmlWithSourceReference(@NonNull File from, @NonNull File to)
-            throws IOException {
-        copyXmlWithComment(from, to, createPathComment(from, true));
-    }
-
-    /** Copies a given XML file, and appends a given comment to the end */
-    private static void copyXmlWithComment(@NonNull File from, @NonNull File to,
-                                           @Nullable String comment) throws IOException {
-        assert endsWithIgnoreCase(from.getPath(), SdkConstants.DOT_XML) : from;
-
-        int successfulOps = 0;
-        InputStream in = new FileInputStream(from);
-        try {
-            FileOutputStream out = new FileOutputStream(to, false);
-            try {
-                ByteStreams.copy(in, out);
-                successfulOps++;
-                if (comment != null) {
-                    String commentText = "<!--" + XmlUtils.toXmlTextValue(comment) + "-->";
-                    byte[] suffix = commentText.getBytes(Charsets.UTF_8);
-                    out.write(suffix);
-                }
-            } finally {
-                Closeables.close(out, successfulOps < 1);
-                successfulOps++;
-            }
-        } finally {
-            Closeables.close(in, successfulOps < 2);
-        }
-    }
-
-    /**
-     * Translates an XML name (e.g. xml-name) into a Java / C++ constant name (e.g. XML_NAME)
-     * @param xmlName the hyphen separated lower case xml name.
-     * @return the equivalent constant name.
-     */
-    public static String xmlNameToConstantName(String xmlName) {
-        return CaseFormat.LOWER_HYPHEN.to(CaseFormat.UPPER_UNDERSCORE, xmlName);
-    }
-
-    /**
-     * Translates a camel case name (e.g. xmlName) into a Java / C++ constant name (e.g. XML_NAME)
-     * @param camelCaseName the camel case name.
-     * @return the equivalent constant name.
-     */
-    public static String camelCaseToConstantName(String camelCaseName) {
-        return CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, camelCaseName);
-    }
-
-    /**
-     * Translates a Java / C++ constant name (e.g. XML_NAME) into camel case name (e.g. xmlName)
-     * @param constantName the constant name.
-     * @return the equivalent camel case name.
-     */
-    public static String constantNameToCamelCase(String constantName) {
-        return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, constantName);
-    }
-
-    /**
-     * Translates a Java / C++ constant name (e.g. XML_NAME) into a XML case name (e.g. xml-name)
-     * @param constantName the constant name.
-     * @return the equivalent XML name.
-     */
-    public static String constantNameToXmlName(String constantName) {
-        return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_HYPHEN, constantName);
-    }
-
-
-    /**
-     * Get the R field name from a resource name, since
-     * AAPT will flatten the namespace, turning dots, dashes and colons into _
-     *
-     * @param resourceName the name to convert
-     * @return the corresponding R field name
-     */
-    @NonNull
-    public static String getResourceFieldName(@NonNull String resourceName) {
-        // AAPT will flatten the namespace, turning dots, dashes and colons into _
-        for (int i = 0, n = resourceName.length(); i < n; i++) {
-            char c = resourceName.charAt(i);
-            if (c == '.' || c == ':' || c == '-') {
-                return resourceName.replace('.', '_').replace('-', '_').replace(':', '_');
-            }
-        }
-
-        return resourceName;
-    }
-
-    public static final List<String> IMAGE_EXTENSIONS = ImmutableList.of(
-            SdkConstants.DOT_PNG, SdkConstants.DOT_9PNG, SdkConstants.DOT_GIF, SdkConstants.DOT_JPEG, SdkConstants.DOT_JPG, SdkConstants.DOT_BMP, SdkConstants.DOT_WEBP);
-
-    /**
-     * Returns true if the given file path points to an image file recognized by
-     * Android. See http://developer.android.com/guide/appendix/media-formats.html
-     * for details.
-     *
-     * @param path the filename to be tested
-     * @return true if the file represents an image file
-     */
-    public static boolean hasImageExtension(String path) {
-        for (String ext: IMAGE_EXTENSIONS) {
-            if (endsWithIgnoreCase(path, ext)) {
-                return true;
-            }
-        }
-        return false;
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/util/XmlUtils.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/util/XmlUtils.java b/Build/src/main/java/com/tyron/build/util/XmlUtils.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/util/XmlUtils.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1218 +0,0 @@
-package com.tyron.build.util;
-
-import static com.google.common.base.Charsets.UTF_16BE;
-import static com.google.common.base.Charsets.UTF_16LE;
-import static com.google.common.base.Charsets.UTF_8;
-
-import com.tyron.build.compiler.manifest.SdkConstants;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-import com.google.common.base.CharMatcher;
-import com.google.common.collect.Sets;
-import com.google.common.io.Files;
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Comment;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.w3c.dom.Text;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-
-/**
- * XML Utilities.
- * <p>
- * For Kotlin usage, many of these are exposed as more convenient extension
- * methods in DomExtensions
- */
-public class XmlUtils {
-    public static final String XML_COMMENT_BEGIN = "<!--"; //$NON-NLS-1$
-    public static final String XML_COMMENT_END = "-->";    //$NON-NLS-1$
-    public static final String XML_PROLOG =
-            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";  //$NON-NLS-1$
-
-    public static final String SAX_PARSER_FACTORY =
-            "com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl";
-
-    /**
-     * Separator for xml namespace and localname
-     */
-    public static final char NS_SEPARATOR = ':';                  //$NON-NLS-1$
-
-    private static final String SOURCE_FILE_USER_DATA_KEY = "sourcefile";
-
-    // XML parser features
-    private static final String NAMESPACE_PREFIX_FEATURE =
-            "http://xml.org/sax/features/namespace-prefixes";
-    private static final String PROVIDE_XMLNS_URIS =
-            "http://xml.org/sax/features/xmlns-uris";
-    private static final String LOAD_EXTERNAL_DTD =
-            "http://apache.org/xml/features/nonvalidating/load-external-dtd";
-    private static final String EXTERNAL_PARAMETER_ENTITIES =
-            "http://xml.org/sax/features/external-parameter-entities";
-    private static final String EXTERNAL_GENERAL_ENTITIES =
-            "http://xml.org/sax/features/external-general-entities";
-    private static final String DISALLOW_DOCTYPE_DECL =
-            "http://apache.org/xml/features/disallow-doctype-decl";
-
-    /** The first byte of a proto XML file is always 0x0A. */
-    private static final byte PROTO_XML_LEAD_BYTE = 0x0A;
-
-    private static final int MAXIMUM_XML_DEPTH = 500;
-
-    /**
-     * Returns the namespace prefix matching the requested namespace URI.
-     * If no such declaration is found, returns the default "android" prefix for
-     * the Android URI, and "app" for other URI's. By default the app namespace
-     * will be created. If this is not desirable, call
-     * {@link #lookupNamespacePrefix(Node, String, boolean)} instead.
-     *
-     * @param node The current node. Must not be null.
-     * @param nsUri The namespace URI of which the prefix is to be found,
-     *              e.g. {@link SdkConstants#ANDROID_URI}
-     * @return The first prefix declared or the default "android" prefix
-     *              (or "app" for non-Android URIs)
-     */
-    @NonNull
-    public static String lookupNamespacePrefix(@NonNull Node node, @NonNull String nsUri) {
-        String defaultPrefix = SdkConstants.ANDROID_URI.equals(nsUri) ? SdkConstants.ANDROID_NS_NAME : SdkConstants.APP_PREFIX;
-        return lookupNamespacePrefix(node, nsUri, defaultPrefix, true /*create*/);
-    }
-
-    /**
-     * Returns the namespace prefix matching the requested namespace URI. If no
-     * such declaration is found, returns the default "android" prefix for the
-     * Android URI, and "app" for other URI's.
-     *
-     * @param node The current node. Must not be null.
-     * @param nsUri The namespace URI of which the prefix is to be found, e.g.
-     *            {@link SdkConstants#ANDROID_URI}
-     * @param create whether the namespace declaration should be created, if
-     *            necessary
-     * @return The first prefix declared or the default "android" prefix (or
-     *         "app" for non-Android URIs)
-     */
-    @NonNull
-    public static String lookupNamespacePrefix(@NonNull Node node, @NonNull String nsUri,
-                                               boolean create) {
-        String defaultPrefix = SdkConstants.ANDROID_URI.equals(nsUri) ? SdkConstants.ANDROID_NS_NAME : SdkConstants.APP_PREFIX;
-        return lookupNamespacePrefix(node, nsUri, defaultPrefix, create);
-    }
-
-    /**
-     * Returns the namespace prefix matching the requested namespace URI. If no
-     * such declaration is found, returns the default "android" prefix.
-     *
-     * @param node The current node. Must not be null.
-     * @param nsUri The namespace URI of which the prefix is to be found, e.g.
-     *            {@link SdkConstants#ANDROID_URI}
-     * @param defaultPrefix The default prefix (root) to use if the namespace is
-     *            not found. If null, do not create a new namespace if this URI
-     *            is not defined for the document.
-     * @param create whether the namespace declaration should be created, if
-     *            necessary
-     * @return The first prefix declared or the provided prefix (possibly with a
-     *            number appended to avoid conflicts with existing prefixes.
-     */
-    public static String lookupNamespacePrefix(
-            @Nullable Node node, @Nullable String nsUri, @Nullable String defaultPrefix,
-            boolean create) {
-        // Note: Node.lookupPrefix is not implemented in wst/xml/core NodeImpl.java
-        // The following code emulates this simple call:
-        //   String prefix = node.lookupPrefix(NS_RESOURCES);
-
-        // if the requested URI is null, it denotes an attribute with no namespace.
-        if (nsUri == null) {
-            return null;
-        }
-
-        // per XML specification, the "xmlns" URI is reserved
-        if (SdkConstants.XMLNS_URI.equals(nsUri)) {
-            return SdkConstants.XMLNS;
-        }
-
-        HashSet<String> visited = new HashSet<>();
-        Document doc = node == null ? null : node.getOwnerDocument();
-
-        // Ask the document about it. This method may not be implemented by the Document.
-        String nsPrefix;
-        try {
-            nsPrefix = doc != null ? doc.lookupPrefix(nsUri) : null;
-            if (nsPrefix != null) {
-                return nsPrefix;
-            }
-        } catch (Throwable t) {
-            // ignore
-        }
-
-        // If that failed, try to look it up manually.
-        // This also gathers prefixed in use in the case we want to generate a new one below.
-        for (; node != null && node.getNodeType() == Node.ELEMENT_NODE;
-             node = node.getParentNode()) {
-            NamedNodeMap attrs = node.getAttributes();
-            for (int n = attrs.getLength() - 1; n >= 0; --n) {
-                Node attr = attrs.item(n);
-                if (SdkConstants.XMLNS.equals(attr.getPrefix())) {
-                    String uri = attr.getNodeValue();
-                    nsPrefix = attr.getLocalName();
-                    // Is this the URI we are looking for? If yes, we found its prefix.
-                    if (nsUri.equals(uri)) {
-                        return nsPrefix;
-                    }
-                    visited.add(nsPrefix);
-                } else if (attr.getPrefix() == null
-                        && attr.getNodeName().startsWith(SdkConstants.XMLNS_PREFIX)) {
-                    // It seems to be possible for the attribute to not have the namespace prefix
-                    // i.e. attr.getPrefix() returns null and getLocalName returns null, but the
-                    // node name is xmlns:foo. This is a ugly workaround, but it works.
-                    String uri = attr.getNodeValue();
-                    nsPrefix = attr.getNodeName().substring(SdkConstants.XMLNS_PREFIX.length());
-                    // Is this the URI we are looking for? If yes, we found its prefix.
-                    if (nsUri.equals(uri)) {
-                        return nsPrefix;
-                    }
-                    visited.add(nsPrefix);
-                }
-            }
-        }
-
-        // Failed the find a prefix. Generate a new sensible default prefix, unless
-        // defaultPrefix was null in which case the caller does not want the document
-        // modified.
-        if (defaultPrefix == null) {
-            return null;
-        }
-
-        //
-        // We need to make sure the prefix is not one that was declared in the scope
-        // visited above. Pick a unique prefix from the provided default prefix.
-        String prefix = defaultPrefix;
-        String base = prefix;
-        for (int i = 1; visited.contains(prefix); i++) {
-            prefix = base + Integer.toString(i);
-        }
-        // Also create and define this prefix/URI in the XML document as an attribute in the
-        // first element of the document.
-        if (doc != null) {
-            node = doc.getFirstChild();
-            while (node != null && node.getNodeType() != Node.ELEMENT_NODE) {
-                node = node.getNextSibling();
-            }
-            if (node != null && create) {
-                // This doesn't work:
-                //Attr attr = doc.createAttributeNS(XMLNS_URI, prefix);
-                //attr.setPrefix(XMLNS);
-                //
-                // Xerces throws
-                //org.w3c.dom.DOMException: NAMESPACE_ERR: An attempt is made to create or
-                // change an object in a way which is incorrect with regard to namespaces.
-                //
-                // Instead pass in the concatenated prefix. (This is covered by
-                // the UiElementNodeTest#testCreateNameSpace() test.)
-                Attr attr = doc.createAttributeNS(SdkConstants.XMLNS_URI, SdkConstants.XMLNS_PREFIX + prefix);
-                attr.setValue(nsUri);
-                node.getAttributes().setNamedItemNS(attr);
-            }
-        }
-
-        return prefix;
-    }
-
-    /**
-     * Converts the given attribute value to an XML-attribute-safe value, meaning that
-     * single and double quotes are replaced with their corresponding XML entities.
-     *
-     * @param attrValue the value to be escaped
-     * @return the escaped value
-     */
-    @NonNull
-    public static String toXmlAttributeValue(@NonNull String attrValue) {
-        for (int i = 0, n = attrValue.length(); i < n; i++) {
-            char c = attrValue.charAt(i);
-            if (c == '"' || c == '\'' || c == '<' || c == '>' || c == '&' || c == '\n') {
-                StringBuilder sb = new StringBuilder(2 * attrValue.length());
-                appendXmlAttributeValue(sb, attrValue);
-                return sb.toString();
-            }
-        }
-
-        return attrValue;
-    }
-
-    /**
-     * Converts the given XML-attribute-safe value to a java string
-     *
-     * @param escapedAttrValue the escaped value
-     * @return the unescaped value
-     */
-    @NonNull
-    public static String fromXmlAttributeValue(@NonNull String escapedAttrValue) {
-        // See https://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping
-        if (escapedAttrValue.indexOf('&') == -1) {
-            return escapedAttrValue;
-        }
-        String workingString = escapedAttrValue.replace(SdkConstants.QUOT_ENTITY, "\"");
-        workingString = workingString.replace(SdkConstants.LT_ENTITY, "<");
-        workingString = workingString.replace(SdkConstants.APOS_ENTITY, "'");
-        workingString = workingString.replace(SdkConstants.AMP_ENTITY, "&");
-        workingString = workingString.replace(SdkConstants.GT_ENTITY, ">");
-        workingString = workingString.replace(SdkConstants.NEWLINE_ENTITY, "\n");
-
-        return workingString;
-    }
-
-    /**
-     * Converts the given attribute value to an XML-text-safe value, meaning that
-     * less than and ampersand characters are escaped.
-     *
-     * @param textValue the text value to be escaped
-     * @return the escaped value
-     */
-    @NonNull
-    public static String toXmlTextValue(@NonNull String textValue) {
-        for (int i = 0, n = textValue.length(); i < n; i++) {
-            char c = textValue.charAt(i);
-            if (c == '<' || c == '&') {
-                StringBuilder sb = new StringBuilder(2 * textValue.length());
-                appendXmlTextValue(sb, textValue);
-                return sb.toString();
-            }
-        }
-
-        return textValue;
-    }
-
-    /**
-     * Appends text to the given {@link StringBuilder} and escapes it as required for a
-     * DOM attribute node.
-     *
-     * @param sb the string builder
-     * @param attrValue the attribute value to be appended and escaped
-     */
-    public static void appendXmlAttributeValue(@NonNull StringBuilder sb,
-                                               @NonNull String attrValue) {
-        appendXmlAttributeValue(sb, attrValue, 0, attrValue.length());
-    }
-
-    /**
-     * Appends text to the given {@link StringBuilder} and escapes it as required for a
-     * DOM attribute node.
-     *
-     * @param sb the string builder
-     * @param attrValue the attribute value to be appended and escaped
-     * @param start the starting offset in the text string
-     * @param end the ending offset in the text string
-     */
-    public static void appendXmlAttributeValue(
-            @NonNull StringBuilder sb, @NonNull String attrValue, int start, int end) {
-        // See https://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping
-        // &, ", ' and < are illegal in attributes; see http://www.w3.org/TR/REC-xml/#NT-AttValue
-        // (' legal in a " string and " is legal in a ' string but here we'll stay on the safe
-        // side)
-        char prev = 0;
-        for (int i = start; i < end; i++) {
-            char c = attrValue.charAt(i);
-            if (c == '"') {
-                sb.append(SdkConstants.QUOT_ENTITY);
-            } else if (c == '<') {
-                sb.append(SdkConstants.LT_ENTITY);
-            } else if (c == '\'') {
-                sb.append(SdkConstants.APOS_ENTITY);
-            } else if (c == '&') {
-                sb.append(SdkConstants.AMP_ENTITY);
-            } else if (c == '\n') {
-                sb.append(SdkConstants.NEWLINE_ENTITY);
-            } else if (c == '>' && prev == ']') {
-                // '>' doesn't have to be escaped in attributes, but it can be, and it *must*
-                // be if it's the end of the character sequence ]]>. (See b.android.com/231003)
-                sb.append(SdkConstants.GT_ENTITY);
-            } else {
-                sb.append(c);
-            }
-            prev = c;
-        }
-    }
-
-    /**
-     * Appends text to the given {@link StringBuilder} and escapes it as required for a
-     * DOM text node.
-     *
-     * @param sb the string builder
-     * @param textValue the text value to be appended and escaped
-     */
-    public static void appendXmlTextValue(@NonNull StringBuilder sb, @NonNull String textValue) {
-        appendXmlTextValue(sb, textValue, 0, textValue.length());
-    }
-
-    /**
-     * Appends text to the given {@link StringBuilder} and escapes it as required for a DOM text
-     * node.
-     *
-     * @param sb the string builder
-     * @param textValue the text value to be appended and escaped
-     * @param start the starting offset in the text string
-     * @param end the ending offset in the text string
-     */
-    public static void appendXmlTextValue(
-            @NonNull StringBuilder sb, @NonNull String textValue, int start, int end) {
-        for (int i = start, n = Math.min(textValue.length(), end); i < n; i++) {
-            char c = textValue.charAt(i);
-            if (c == '<') {
-                sb.append(SdkConstants.LT_ENTITY);
-            } else if (c == '&') {
-                sb.append(SdkConstants.AMP_ENTITY);
-            } else {
-                sb.append(c);
-            }
-        }
-    }
-
-    /**
-     * Returns true if the given node has one or more element children
-     *
-     * @param node the node to test for element children
-     * @return true if the node has one or more element children
-     */
-    public static boolean hasElementChildren(@NonNull Node node) {
-        NodeList children = node.getChildNodes();
-        for (int i = 0, n = children.getLength(); i < n; i++) {
-            if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * Returns a character reader for the given file, which must be a UTF encoded file.
-     * <p>
-     * The reader does not need to be closed by the caller (because the file is read in
-     * full in one shot and the resulting array is then wrapped in a byte array input stream,
-     * which does not need to be closed.)
-     */
-    @NonNull
-    public static Reader getUtfReader(@NonNull File file) throws IOException {
-        byte[] bytes = Files.toByteArray(file);
-        int length = bytes.length;
-        if (length == 0) {
-            return new StringReader("");
-        }
-
-        switch (bytes[0]) {
-            case (byte)0xEF: {
-                if (length >= 3
-                        && bytes[1] == (byte)0xBB
-                        && bytes[2] == (byte)0xBF) {
-                    // UTF-8 BOM: EF BB BF: Skip it
-                    return new InputStreamReader(new ByteArrayInputStream(bytes, 3, length - 3),
-                            Charsets.UTF_8);
-                }
-                break;
-            }
-            case (byte)0xFE: {
-                if (length >= 2
-                        && bytes[1] == (byte)0xFF) {
-                    // UTF-16 Big Endian BOM: FE FF
-                    return new InputStreamReader(new ByteArrayInputStream(bytes, 2, length - 2),
-                            Charsets.UTF_16BE);
-                }
-                break;
-            }
-            case (byte)0xFF: {
-                if (length >= 2
-                        && bytes[1] == (byte)0xFE) {
-                    if (length >= 4
-                            && bytes[2] == (byte)0x00
-                            && bytes[3] == (byte)0x00) {
-                        // UTF-32 Little Endian BOM: FF FE 00 00
-                        return new InputStreamReader(new ByteArrayInputStream(bytes, 4,
-                                length - 4), "UTF-32LE");
-                    }
-
-                    // UTF-16 Little Endian BOM: FF FE
-                    return new InputStreamReader(new ByteArrayInputStream(bytes, 2, length - 2),
-                            Charsets.UTF_16LE);
-                }
-                break;
-            }
-            case (byte)0x00: {
-                if (length >= 4
-                        && bytes[0] == (byte)0x00
-                        && bytes[1] == (byte)0x00
-                        && bytes[2] == (byte)0xFE
-                        && bytes[3] == (byte)0xFF) {
-                    // UTF-32 Big Endian BOM: 00 00 FE FF
-                    return new InputStreamReader(new ByteArrayInputStream(bytes, 4, length - 4),
-                            "UTF-32BE");
-                }
-                break;
-            }
-        }
-
-        // No byte order mark: Assume UTF-8 (where the BOM is optional).
-        return new InputStreamReader(new ByteArrayInputStream(bytes), Charsets.UTF_8);
-    }
-
-    /**
-     * Parses the given XML string as a DOM document, using the JDK parser. The parser does not
-     * validate, and is optionally namespace aware.
-     *
-     * @param xml            the XML content to be parsed (must be well formed)
-     * @param namespaceAware whether the parser is namespace aware
-     * @return the DOM document
-     */
-    @NonNull
-    public static Document parseDocument(@NonNull String xml, boolean namespaceAware)
-            throws IOException, SAXException {
-        xml = stripBom(xml);
-        return parseDocument(new StringReader(xml), namespaceAware);
-    }
-
-    /**
-     * Parses the given {@link Reader} as a DOM document, using the JDK parser. The parser does not
-     * validate, and is optionally namespace aware.
-     *
-     * @param xml            a reader for the XML content to be parsed (must be well formed)
-     * @param namespaceAware whether the parser is namespace aware
-     * @return the DOM document
-     */
-    @NonNull
-    public static Document parseDocument(@NonNull Reader xml, boolean namespaceAware)
-            throws IOException, SAXException {
-        InputSource is = new InputSource(xml);
-        return createDocumentBuilder(namespaceAware).parse(is);
-    }
-
-    /**
-     * Parses the given UTF file as a DOM document, using the JDK parser. The parser does not
-     * validate, and is optionally namespace aware.
-     *
-     * @param file           the UTF encoded file to parse
-     * @param namespaceAware whether the parser is namespace aware
-     * @return the DOM document
-     */
-    @NonNull
-    public static Document parseUtfXmlFile(@NonNull File file, boolean namespaceAware)
-            throws IOException, SAXException {
-        try (Reader reader = getUtfReader(file)) {
-            return parseDocument(reader, namespaceAware);
-        }
-    }
-
-    /** Creates and returns a new empty document. */
-    @NonNull
-    public static Document createDocument(boolean namespaceAware) {
-        return createDocumentBuilder(namespaceAware).newDocument();
-    }
-
-    /** Creates a preconfigured document builder. */
-    @NonNull
-    private static DocumentBuilder createDocumentBuilder(boolean namespaceAware) {
-        try {
-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-            factory.setNamespaceAware(namespaceAware);
-            factory.setValidating(false);
-            factory.setFeature(EXTERNAL_GENERAL_ENTITIES, false);
-            factory.setFeature(EXTERNAL_PARAMETER_ENTITIES, false);
-            factory.setFeature(LOAD_EXTERNAL_DTD, false);
-            return factory.newDocumentBuilder();
-        } catch (ParserConfigurationException e) {
-            throw new Error(e); // Impossible in the current context.
-        }
-    }
-
-    /** Strips out a leading UTF byte order mark, if present */
-    @NonNull
-    public static String stripBom(@NonNull String xml) {
-        if (!xml.isEmpty() && xml.charAt(0) == '\uFEFF') {
-            return xml.substring(1);
-        }
-        return xml;
-    }
-
-    /**
-     * Parses the given XML string as a DOM document, using the JDK parser. The parser does not
-     * validate, and is optionally namespace aware. Any parsing errors are silently ignored.
-     *
-     * @param xml            the XML content to be parsed (must be well formed)
-     * @param namespaceAware whether the parser is namespace aware
-     * @return the DOM document, or null
-     */
-    @Nullable
-    public static Document parseDocumentSilently(@NonNull String xml, boolean namespaceAware) {
-        try {
-            return parseDocument(xml, namespaceAware);
-        } catch (Exception e) {
-            // pass
-            // This method is deliberately silent; will return null
-        }
-
-        return null;
-    }
-
-    public static SAXParserFactory configureSaxFactory(@NonNull SAXParserFactory factory,
-                                                       boolean namespaceAware, boolean checkDtd) {
-        try {
-            factory.setXIncludeAware(false);
-            factory.setNamespaceAware(namespaceAware); // http://xml.org/sax/features/namespaces
-            factory.setFeature(NAMESPACE_PREFIX_FEATURE, namespaceAware);
-            factory.setFeature(PROVIDE_XMLNS_URIS, namespaceAware);
-            factory.setValidating(checkDtd);
-        } catch (ParserConfigurationException|SAXException ignore) {
-        }
-
-        return factory;
-    }
-
-    public static SAXParserFactory getConfiguredSaxFactory(
-            boolean namespaceAware, boolean checkDtd) {
-        SAXParserFactory factory = SAXParserFactory.newInstance(SAX_PARSER_FACTORY, null);
-        return configureSaxFactory(factory, namespaceAware, checkDtd);
-    }
-
-    @NonNull
-    public static SAXParser createSaxParser(@NonNull SAXParserFactory factory)
-            throws ParserConfigurationException, SAXException {
-        return createSaxParser(factory, false);
-    }
-
-    @NonNull
-    public static SAXParser createSaxParser(
-            @NonNull SAXParserFactory factory,
-            boolean allowDocTypeDeclarations) throws ParserConfigurationException, SAXException {
-        SAXParser parser = factory.newSAXParser();
-        XMLReader reader = parser.getXMLReader();
-
-        // Prevent XML External Entity attack
-        if (!allowDocTypeDeclarations) {
-            // Most secure
-            reader.setFeature(DISALLOW_DOCTYPE_DECL, true);
-        } else {
-            reader.setFeature(EXTERNAL_GENERAL_ENTITIES, false);
-            reader.setFeature(EXTERNAL_PARAMETER_ENTITIES, false);
-            reader.setFeature(LOAD_EXTERNAL_DTD, false);
-        }
-
-        return parser;
-    }
-
-    /**
-     * Dump an XML tree to string. This does not perform any pretty printing.
-     * To perform pretty printing, use {@code XmlPrettyPrinter.prettyPrint(node)} in
-     * {@code sdk-common}.
-     */
-    public static String toXml(@NonNull Node node) {
-        return toXml(node, null);
-    }
-
-    public static String toXml(
-            @NonNull Node node,
-            @Nullable Map<SourcePosition, SourceFilePosition> blame) {
-        PositionAwareStringBuilder sb = new PositionAwareStringBuilder(1000);
-        Set<Node> nodesInPath = Sets.newHashSet();
-        append(sb, node, blame, nodesInPath);
-        return sb.toString();
-    }
-
-    /** Dump node to string without indentation adjustments */
-    private static void append(
-            @NonNull PositionAwareStringBuilder sb,
-            @NonNull Node node,
-            @Nullable Map<SourcePosition, SourceFilePosition> blame,
-            @NonNull Set<Node> nodesInPath) {
-        if (!nodesInPath.add(node)) {
-            throw new RuntimeException("Circular dependency in XML " + sb.toString());
-        }
-        if (nodesInPath.size() > MAXIMUM_XML_DEPTH) {
-            throw new RuntimeException("Maximum XML depth reached " + sb.toString());
-        }
-        short nodeType = node.getNodeType();
-        int currentLine = sb.line;
-        int currentColumn = sb.column;
-        int currentOffset = sb.getOffset();
-        switch (nodeType) {
-            case Node.DOCUMENT_NODE:
-            case Node.DOCUMENT_FRAGMENT_NODE:
-            {
-                sb.append(XML_PROLOG);
-                NodeList children = node.getChildNodes();
-                for (int i = 0, n = children.getLength(); i < n; i++) {
-                    Node child = children.item(i);
-                    append(sb, child, blame, nodesInPath);
-                }
-                break;
-            }
-            case Node.COMMENT_NODE:
-                sb.append(XML_COMMENT_BEGIN);
-                sb.append(node.getNodeValue());
-                sb.append(XML_COMMENT_END);
-                break;
-            case Node.TEXT_NODE: {
-                sb.append(toXmlTextValue(node.getNodeValue()));
-                break;
-            }
-            case Node.CDATA_SECTION_NODE: {
-                sb.append("<![CDATA["); //$NON-NLS-1$
-                sb.append(node.getNodeValue());
-                sb.append("]]>");       //$NON-NLS-1$
-                break;
-            }
-            case Node.ELEMENT_NODE:
-            {
-                sb.append('<');
-                Element element = (Element) node;
-                sb.append(element.getTagName());
-
-                NamedNodeMap attributes = element.getAttributes();
-                NodeList children = element.getChildNodes();
-                int childCount = children.getLength();
-                int attributeCount = attributes.getLength();
-
-                if (attributeCount > 0) {
-                    for (int i = 0; i < attributeCount; i++) {
-                        Node attribute = attributes.item(i);
-                        sb.append(' ');
-                        sb.append(attribute.getNodeName());
-                        sb.append('=').append('"');
-                        sb.append(toXmlAttributeValue(attribute.getNodeValue()));
-                        sb.append('"');
-                    }
-                }
-
-                if (childCount == 0) {
-                    sb.append('/');
-                }
-                sb.append('>');
-                if (childCount > 0) {
-                    for (int i = 0; i < childCount; i++) {
-                        Node child = children.item(i);
-                        append(sb, child, blame, nodesInPath);
-                    }
-                    sb.append('<').append('/');
-                    sb.append(element.getTagName());
-                    sb.append('>');
-                }
-
-                if (blame != null) {
-                    SourceFilePosition position = getSourceFilePosition(node);
-                    if (!position.equals(SourceFilePosition.UNKNOWN)) {
-                        blame.put(
-                                new SourcePosition(
-                                        currentLine,
-                                        currentColumn,
-                                        currentOffset,
-                                        sb.line,
-                                        sb.column,
-                                        sb.getOffset()),
-                                position);
-                    }
-                }
-                break;
-            }
-
-            default:
-                throw new UnsupportedOperationException(
-                        "Unsupported node type " + nodeType + ": not yet implemented");
-        }
-        nodesInPath.remove(node);
-    }
-
-    /**
-     * Wraps a StringBuilder, but keeps track of the line and column of the end of the string.
-     *
-     * It implements append(String) and append(char) which as well as delegating to the underlying
-     * StringBuilder also keep track of any new lines, and set the line and column fields.
-     * The StringBuilder itself keeps track of the actual character offset.
-     */
-    private static class PositionAwareStringBuilder {
-        @SuppressWarnings("StringBufferField")
-        private final StringBuilder sb;
-        int line = 0;
-        int column = 0;
-
-        public PositionAwareStringBuilder(int size) {
-            sb = new StringBuilder(size);
-        }
-
-        public PositionAwareStringBuilder append(String text) {
-            sb.append(text);
-            // we find the last, as it might be useful later.
-            int lastNewLineIndex = text.lastIndexOf('\n');
-            if (lastNewLineIndex == -1) {
-                // If it does not contain a new line, we just increase the column number.
-                column += text.length();
-            } else {
-                // The string could contain multiple new lines.
-                line += CharMatcher.is('\n').countIn(text);
-                // But for column we only care about the number of characters after the last one.
-                column = text.length() - lastNewLineIndex - 1;
-            }
-            return this;
-        }
-
-        public PositionAwareStringBuilder append(char character) {
-            sb.append(character);
-            if (character == '\n') {
-                line += 1;
-                column = 0;
-            } else {
-                column++;
-            }
-            return this;
-        }
-
-        public int getOffset() {
-            return sb.length();
-        }
-
-        @Override
-        public String toString() {
-            return sb.toString();
-        }
-    }
-
-    public static void attachSourceFile(@NonNull Node node, @NonNull SourceFile sourceFile) {
-        node.setUserData(SOURCE_FILE_USER_DATA_KEY, sourceFile, null);
-    }
-
-    @NonNull
-    public static SourceFilePosition getSourceFilePosition(@NonNull Node node) {
-        SourceFile sourceFile = (SourceFile) node.getUserData(SOURCE_FILE_USER_DATA_KEY);
-        if (sourceFile == null) {
-            sourceFile = SourceFile.UNKNOWN;
-        }
-        return new SourceFilePosition(sourceFile, PositionXmlParser.getPosition(node));
-    }
-
-    /**
-     * Formats the number and removes trailing zeros after the decimal dot and also the dot itself
-     * if there were non-zero digits after it.
-     *
-     * @param value the value to be formatted
-     * @return the corresponding XML string for the value
-     */
-    @NonNull
-    public static String formatFloatValue(double value) {
-        if (!Double.isFinite(value)) {
-            throw new IllegalArgumentException("Invalid number: " + value);
-        }
-        // Use locale-independent conversion to make sure that the decimal separator is always dot.
-        // We use Float.toString as opposed to Double.toString to avoid writing too many
-        // insignificant digits.
-        String result = Float.toString((float) value);
-        return DecimalUtils.trimInsignificantZeros(result);
-    }
-
-    /**
-     * Returns the name of the root element tag stored in the given file, or null if it can't be
-     * determined.
-     */
-    @Nullable
-    public static String getRootTagName(@NonNull File xmlFile) {
-        try (InputStream stream = new BufferedInputStream(new FileInputStream(xmlFile))) {
-            XMLInputFactory factory = XMLInputFactory.newFactory();
-            XMLStreamReader xmlStreamReader = factory.createXMLStreamReader(stream);
-
-            while (xmlStreamReader.hasNext()) {
-                int event = xmlStreamReader.next();
-                if (event == XMLStreamReader.START_ELEMENT) {
-                    return xmlStreamReader.getLocalName();
-                }
-            }
-        } catch (XMLStreamException | IOException ignored) {
-            // Ignored.
-        }
-
-        return null;
-    }
-
-    /**
-     * Returns the name of the root element tag stored in the given file, or null if it can't be
-     * determined.
-     */
-    @Nullable
-    public static String getRootTagName(@NonNull String xmlText) {
-        XMLInputFactory factory = XMLInputFactory.newFactory();
-        try (Reader reader = new StringReader(xmlText)) {
-            XMLStreamReader xmlStreamReader = factory.createXMLStreamReader(reader);
-
-            while (xmlStreamReader.hasNext()) {
-                int event = xmlStreamReader.next();
-                if (event == XMLStreamReader.START_ELEMENT) {
-                    return xmlStreamReader.getLocalName();
-                }
-            }
-        } catch (IOException | XMLStreamException e) {
-            // Ignore.
-        }
-        return null;
-    }
-
-    /**
-     * Returns the children elements of the given node
-     *
-     * @param parent the parent node
-     * @return a list of element children, never null
-     */
-    @NonNull
-    public static List<Element> getSubTagsAsList(@NonNull Node parent) {
-        NodeList childNodes = parent.getChildNodes();
-        List<Element> children = new ArrayList<>(childNodes.getLength());
-        for (int i = 0, n = childNodes.getLength(); i < n; i++) {
-            Node child = childNodes.item(i);
-            if (child.getNodeType() == Node.ELEMENT_NODE) {
-                children.add((Element) child);
-            }
-        }
-
-        return children;
-    }
-
-    /**
-     * Returns an iterator for the children elements of the given node.
-     * If you want to access the children as a list, use
-     * {@link #getSubTagsAsList(Node)} instead.
-     * <p>
-     * <b>NOTE: The iterator() call can only be called once!</b>
-     */
-    @NonNull
-    public static Iterable<Element> getSubTags(@Nullable Node parent) {
-        return new SubTagIterator(parent);
-    }
-
-    /**
-     * Returns an iterator for the children elements of the given node matching the
-     * given tag name.
-     * <p>
-     * If you want to access the children as a list, use
-     * {@link #getSubTagsAsList(Node)} instead.
-     * <p>
-     * <b>NOTE: The iterator() call can only be called once!</b>
-     */
-    @NonNull
-    public static Iterable<Element> getSubTagsByName(@Nullable Node parent, @NonNull String tagName) {
-        return new NamedSubTagIterator(parent, tagName);
-    }
-
-    private static class SubTagIterator implements Iterator<Element>, Iterable<Element> {
-        private Element next;
-        private boolean used;
-
-        public SubTagIterator(@Nullable Node parent) {
-            this.next = getFirstSubTag(parent);
-        }
-
-        @Override
-        public boolean hasNext() {
-            return next != null;
-        }
-
-        @Override
-        public Element next() {
-            Element ret = next;
-            next = getNextTag(next);
-            return ret;
-        }
-
-        @NonNull
-        @Override
-        public Iterator<Element> iterator() {
-            assert !used;
-            used = true;
-            return this;
-        }
-    }
-
-    private static class NamedSubTagIterator implements Iterator<Element>, Iterable<Element> {
-        private final String name;
-        private Element next;
-        private boolean used;
-
-        public NamedSubTagIterator(@Nullable Node parent, @NonNull String name) {
-            this.name = name;
-            this.next = getFirstSubTagByName(parent, name);
-        }
-
-        @Override
-        public boolean hasNext() {
-            return next != null;
-        }
-
-        @Override
-        public Element next() {
-            Element ret = next;
-            next = getNextTagByName(next, name);
-            return ret;
-        }
-
-        @NonNull
-        @Override
-        public Iterator<Element> iterator() {
-            assert !used;
-            used = true;
-            return this;
-        }
-    }
-
-    /** Returns the first child element of the given node */
-    @Nullable
-    public static Element getFirstSubTag(@Nullable Node parent) {
-        if (parent == null) {
-            return null;
-        }
-        Node curr = parent.getFirstChild();
-        while (curr != null) {
-            if (curr.getNodeType() == Node.ELEMENT_NODE) {
-                return (Element) curr;
-            }
-
-            curr = curr.getNextSibling();
-        }
-
-        return null;
-    }
-
-    /** Returns the next sibling element from the given node */
-    @Nullable
-    public static Element getNextTag(@Nullable Node node) {
-        if (node == null) {
-            return null;
-        }
-        Node curr = node.getNextSibling();
-        while (curr != null) {
-            if (curr.getNodeType() == Node.ELEMENT_NODE) {
-                return (Element) curr;
-            }
-
-            curr = curr.getNextSibling();
-        }
-
-        return null;
-    }
-
-    /** Returns the previous sibling element from the given node */
-    @Nullable
-    public static Element getPreviousTag(@Nullable Node node) {
-        if (node == null) {
-            return null;
-        }
-        Node curr = node.getPreviousSibling();
-        while (curr != null) {
-            if (curr.getNodeType() == Node.ELEMENT_NODE) {
-                return (Element) curr;
-            }
-
-            curr = curr.getPreviousSibling();
-        }
-
-        return null;
-    }
-
-    /** Returns the next sibling element from the given node that matches the given name */
-    @Nullable
-    public static Element getFirstSubTagByName(@Nullable Node parent, @NonNull String name) {
-        if (parent == null) {
-            return null;
-        }
-        Node curr = parent.getFirstChild();
-        while (curr != null) {
-            if (curr.getNodeType() == Node.ELEMENT_NODE) {
-                String currName = curr.getLocalName();
-                if (currName == null) {
-                    currName = curr.getNodeName();
-                }
-                if (name.equals(currName)) {
-                    return (Element) curr;
-                }
-            }
-
-            curr = curr.getNextSibling();
-        }
-
-        return null;
-    }
-
-    /** Returns the next sibling element from the given node */
-    @Nullable
-    public static Element getNextTagByName(@Nullable Node node, @NonNull String name) {
-        if (node == null) {
-            return null;
-        }
-        Node curr = node.getNextSibling();
-        while (curr != null) {
-            if (curr.getNodeType() == Node.ELEMENT_NODE) {
-                String currName = curr.getLocalName();
-                if (currName == null) {
-                    currName = curr.getNodeName();
-                }
-                if (name.equals(currName)) {
-                    return (Element) curr;
-                }
-            }
-
-            curr = curr.getNextSibling();
-        }
-
-        return null;
-    }
-
-    @Nullable
-    public static Element getPreviousTagByName(@Nullable Node node, @NonNull String name) {
-        if (node == null) {
-            return null;
-        }
-        Node curr = node.getPreviousSibling();
-        while (curr != null) {
-            if (curr.getNodeType() == Node.ELEMENT_NODE) {
-                String currName = curr.getLocalName();
-                if (currName == null) {
-                    currName = curr.getNodeName();
-                }
-                if (name.equals(currName)) {
-                    return (Element) curr;
-                }
-            }
-
-            curr = curr.getPreviousSibling();
-        }
-
-        return null;
-    }
-
-    /**
-     * Returns the comment preceding the given element with no other elements in between, or null
-     * if the element is not preceded by a comment.
-     */
-    @Nullable
-    public static Comment getPreviousComment(@NonNull Node element) {
-        Node node = element;
-        do {
-            node = node.getPreviousSibling();
-            if (node instanceof Comment) {
-                return (Comment)node;
-            }
-        }
-        while (node instanceof Text && CharMatcher.whitespace().matchesAllOf(node.getNodeValue()));
-        return null;
-    }
-
-    /**
-     * Returns the text of the comment preceding the given element with no other elements in
-     * between, or null if the element is not preceded by a comment or if the comment is empty
-     * or consists of only whitespace characters.
-     */
-    @Nullable
-    public static String getPreviousCommentText(@NonNull Node element) {
-        Comment comment = getPreviousComment(element);
-        if (comment != null) {
-            String text = comment.getNodeValue();
-            if (!CharMatcher.whitespace().matchesAllOf(text)) {
-                return text.trim();
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Returns the number of children sub tags of the given node.
-     *
-     * @param parent the parent node
-     * @return the count of element children
-     */
-    public static int getSubTagCount(@Nullable Node parent) {
-        if (parent == null) {
-            return 0;
-        }
-        NodeList childNodes = parent.getChildNodes();
-        int childCount = 0;
-        for (int i = 0, n = childNodes.getLength(); i < n; i++) {
-            Node child = childNodes.item(i);
-            if (child.getNodeType() == Node.ELEMENT_NODE) {
-                childCount++;
-            }
-        }
-
-        return childCount;
-    }
-
-    /**
-     * Checks if the given array of bytes is likely to represent XML in a proto format.
-     *
-     * @param bytes the candidate XML contents to check
-     * @return true if the bytes are likely to represent proto XML
-     */
-    public static boolean isProtoXml(@NonNull byte[] bytes) {
-        for (int i = 0; i < bytes.length; i++) {
-            byte c = bytes[i];
-            if (i == 0 && c != PROTO_XML_LEAD_BYTE) {
-                return false;
-            } else if (!Character.isWhitespace(c)) {
-                return c != '<';
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Checks if the given input stream is likely to represent XML in a proto format.
-     *
-     * @param stream the candidate XML stream to check
-     * @return true if the stream is likely to represent proto XML
-     */
-    public static boolean isProtoXml(@NonNull InputStream stream) {
-        boolean isProto = false;
-        int readLimit = 100;
-        if (stream.markSupported()) {
-            stream.mark(readLimit);
-            try {
-                try {
-                    int c;
-                    for (int i = 0; i < readLimit && (c = stream.read()) >= 0; i++) {
-                        if (i == 0 && c != PROTO_XML_LEAD_BYTE) {
-                            break;
-                        } else if (!Character.isWhitespace(c)) {
-                            isProto = c != '<';
-                            break;
-                        }
-                    }
-                } finally {
-                    stream.reset();
-                }
-            } catch (IOException e) {
-                // Ignore and assume text XML.
-            }
-        }
-        return isProto;
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/util/DecimalUtils.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/util/DecimalUtils.java b/Build/src/main/java/com/tyron/build/util/DecimalUtils.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/util/DecimalUtils.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,77 +0,0 @@
-package com.tyron.build.util;
-
-import androidx.annotation.NonNull;
-
-import java.text.DecimalFormatSymbols;
-
-/** Static methods for dealing with floating point numbers in string decimal form. */
-public class DecimalUtils {
-    /**
-     * Removes trailing zeros after the decimal dot and also the dot itself if there are no non-zero
-     * digits after it. Use {@link #trimInsignificantZeros(String, DecimalFormatSymbols)} instead of
-     * this method if locale specific behavior is desired.
-     *
-     * @param floatingPointNumber the string representing a floating point number
-     * @return the original number with trailing zeros removed
-     */
-    @NonNull
-    public static String trimInsignificantZeros(@NonNull String floatingPointNumber) {
-        return trimInsignificantZeros(floatingPointNumber, '.', "E");
-    }
-
-    /**
-     * Removes trailing zeros after the decimal separator and also the decimal separator itself if
-     * there are no non-zero digits after it.
-     *
-     * @param floatingPointNumber the string representing a floating point number
-     * @param symbols the decimal format symbols
-     * @return the original number with trailing zeros removed
-     */
-    public static String trimInsignificantZeros(
-            @NonNull String floatingPointNumber, @NonNull DecimalFormatSymbols symbols) {
-        return trimInsignificantZeros(
-                floatingPointNumber, symbols.getDecimalSeparator(), symbols.getExponentSeparator());
-    }
-
-    /**
-     * Removes trailing zeros after the decimal separator and also the decimal separator itself if
-     * there are no non-zero digits after it.
-     *
-     * @param floatingPointNumber the string representing a floating point number
-     * @param decimalSeparator the decimal separator
-     * @param exponentialSeparator the string used to separate the mantissa from the exponent
-     * @return the original number with trailing zeros removed
-     */
-    public static String trimInsignificantZeros(
-            @NonNull String floatingPointNumber,
-            char decimalSeparator,
-            String exponentialSeparator) {
-        int pos = floatingPointNumber.lastIndexOf(decimalSeparator);
-        if (pos < 0) {
-            return floatingPointNumber;
-        }
-        if (pos == 0) {
-            pos = 2;
-        }
-
-        int exponent =
-                CharSequences.indexOfIgnoreCase(floatingPointNumber, exponentialSeparator, pos);
-        int i = exponent >= 0 ? exponent : floatingPointNumber.length();
-        while (--i > pos) {
-            if (floatingPointNumber.charAt(i) != '0') {
-                i++;
-                break;
-            }
-        }
-        if (exponent < 0) {
-            return floatingPointNumber.substring(0, i);
-        } else if (exponent == i) {
-            return floatingPointNumber;
-        } else {
-            return floatingPointNumber.substring(0, i) + floatingPointNumber.substring(exponent);
-        }
-    }
-
-    /** Do not instantiate. All methods are static. */
-    private DecimalUtils() {}
-}
Index: Build/src/main/java/com/tyron/build/util/CharSequences.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/util/CharSequences.java b/Build/src/main/java/com/tyron/build/util/CharSequences.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/util/CharSequences.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,445 +0,0 @@
-package com.tyron.build.util;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Charsets;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.util.Arrays;
-import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
-
-/**
- * A number of utility methods around {@link CharSequence} handling, which
- * adds methods that are available on Strings (such as {@code indexOf},
- * {@code startsWith} and {@code regionMatches} and provides equivalent methods
- * for character sequences.
- * <p>
- * <b>NOTE: This is not a public or final API; if you rely on this be prepared
- * to adjust your code for the next tools release.</b>
- */
-public class CharSequences {
-
-    public static int indexOf(@NonNull CharSequence sequence, char c) {
-        return indexOf(sequence, c, 0);
-    }
-
-    public static int indexOf(@NonNull CharSequence sequence, char c, int start) {
-        for (int i = start; i < sequence.length(); i++) {
-            if (sequence.charAt(i) == c) {
-                return i;
-            }
-        }
-
-        return -1;
-    }
-
-    public static int lastIndexOf(@NonNull CharSequence haystack, @NonNull String needle,
-                                  int start) {
-        int length = haystack.length();
-
-        int needleLength = needle.length();
-        if (needleLength <= length && start >= 0) {
-            if (needleLength > 0) {
-                if (start > length - needleLength) {
-                    start = length - needleLength;
-                }
-                char firstChar = needle.charAt(0);
-                while (true) {
-                    int i = lastIndexOf(haystack, firstChar, start);
-                    if (i == -1) {
-                        return -1;
-                    }
-                    int o1 = i, o2 = 0;
-
-                    //noinspection StatementWithEmptyBody
-                    while (++o2 < needleLength && haystack.charAt(++o1) == needle.charAt(o2)) {
-                    }
-                    if (o2 == needleLength) {
-                        return i;
-                    }
-                    start = i - 1;
-                }
-            }
-            return start < length ? start : length;
-        }
-
-        return -1;
-    }
-
-    public static int lastIndexOf(@NonNull CharSequence sequence, char c) {
-        return lastIndexOf(sequence, c, sequence.length());
-    }
-
-    public static int lastIndexOf(@NonNull CharSequence sequence, int c, int start) {
-        int length = sequence.length();
-        if (start >= 0) {
-            if (start >= length) {
-                start = length - 1;
-            }
-
-            for (int i = start; i >= 0; i--) {
-                if (sequence.charAt(i) == c) {
-                    return i;
-                }
-            }
-        }
-
-        return -1;
-    }
-
-    public static int lastIndexOf(@NonNull CharSequence haystack, @NonNull String needle) {
-        return lastIndexOf(haystack, needle, haystack.length());
-    }
-
-    public static boolean regionMatches(
-            @NonNull CharSequence sequence,
-            int thisStart,
-            @NonNull CharSequence string,
-            int start,
-            int length) {
-        if (start < 0 || string.length() - start < length) {
-            return false;
-        }
-        if (thisStart < 0 || sequence.length() - thisStart < length) {
-            return false;
-        }
-        if (length <= 0) {
-            return true;
-        }
-        for (int i = 0; i < length; ++i) {
-            if (sequence.charAt(thisStart + i) != string.charAt(start + i)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static boolean regionMatches(
-            @NonNull CharSequence sequence,
-            boolean ignoreCase,
-            int thisStart,
-            @NonNull CharSequence string,
-            int start,
-            int length) {
-        if (!ignoreCase) {
-            return regionMatches(sequence, thisStart, string, start, length);
-        }
-        if (thisStart < 0 || length > sequence.length() - thisStart) {
-            return false;
-        }
-        if (start < 0 || length > string.length() - start) {
-            return false;
-        }
-        int end = thisStart + length;
-        while (thisStart < end) {
-            char c1 = sequence.charAt(thisStart++);
-            char c2 = string.charAt(start++);
-            if (c1 != c2 && foldCase(c1) != foldCase(c2)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    private static char foldCase(char ch) {
-        if (ch < 128) {
-            if ('A' <= ch && ch <= 'Z') {
-                return (char) (ch + ('a' - 'A'));
-            }
-            return ch;
-        }
-        return Character.toLowerCase(Character.toUpperCase(ch));
-    }
-
-    public static boolean startsWith(@NonNull CharSequence sequence, @NonNull CharSequence prefix) {
-        return startsWith(sequence, prefix, 0);
-    }
-
-    public static boolean startsWith(@NonNull CharSequence sequence, @NonNull CharSequence prefix,
-                                     int start) {
-        int sequenceLength = sequence.length();
-        int prefixLength = prefix.length();
-        if (sequenceLength < start + prefixLength) {
-            return false;
-        }
-
-        for (int i = start, j = 0; j < prefixLength; i++, j++) {
-            if (sequence.charAt(i) != prefix.charAt(j)) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Returns true if the given character sequence ends with the given suffix
-     *
-     * @param sequence      the sequence to check
-     * @param suffix        the suffix to check for
-     * @param caseSensitive whether the check should be case sensitive
-     * @return true if the sequence ends with the given suffix
-     */
-    public static boolean endsWith(@NonNull CharSequence sequence, @NonNull CharSequence suffix,
-                                   boolean caseSensitive) {
-        if (suffix.length() > sequence.length()) {
-            return false;
-        }
-
-        int suffixLength = suffix.length();
-        int sequenceLength = sequence.length();
-
-        for (int i = sequenceLength - suffixLength, j = 0; i < sequenceLength; i++, j++) {
-            char c1 = sequence.charAt(i);
-            char c2 = suffix.charAt(j);
-            if (c1 != c2) {
-                if (caseSensitive) {
-                    return false;
-                } else if (Character.toLowerCase(c1) != Character.toLowerCase(c2)) {
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Returns true if the given sequence contains any upper case characters
-     *
-     * @param s the sequence to test
-     * @return true if there are any upper case characters in the string
-     */
-    public static boolean containsUpperCase(@Nullable CharSequence s) {
-        if (s != null) {
-            for (int i = 0, n = s.length(); i < n; i++) {
-                if (Character.isUpperCase(s.charAt(i))) {
-                    return true;
-                }
-            }
-        }
-
-        return false;
-    }
-
-    public static int indexOf(@NonNull CharSequence haystack, @NonNull CharSequence needle) {
-        return indexOf(haystack, needle, 0);
-    }
-
-    public static int indexOf(
-            @NonNull CharSequence haystack, @NonNull CharSequence needle, int start) {
-        int needleLength = needle.length();
-        if (needleLength == 0) {
-            return start;
-        }
-
-        char first = needle.charAt(0);
-
-        if (needleLength == 1) {
-            return indexOf(haystack, first, start);
-        }
-
-        search:
-        for (int i = start, max = haystack.length() - needleLength; i <= max; i++) {
-            if (haystack.charAt(i) == first) {
-                for (int h = i + 1, n = 1; n < needleLength; h++, n++) {
-                    if (haystack.charAt(h) != needle.charAt(n)) {
-                        continue search;
-                    }
-                }
-                return i;
-            }
-        }
-
-        return -1;
-    }
-
-    /** Similar to {@link String#indexOf(int, int)} but with case insensitive comparison. */
-    public static int indexOfIgnoreCase(
-            @NonNull CharSequence where, @NonNull CharSequence what, int fromIndex) {
-        int targetCount = what.length();
-        int sourceCount = where.length();
-
-        if (fromIndex >= sourceCount) {
-            return targetCount == 0 ? sourceCount : -1;
-        }
-
-        if (fromIndex < 0) {
-            fromIndex = 0;
-        }
-
-        if (targetCount == 0) {
-            return fromIndex;
-        }
-
-        char first = what.charAt(0);
-        int max = sourceCount - targetCount;
-
-        for (int i = fromIndex; i <= max; i++) {
-            /* Look for first character. */
-            if (!charsEqualIgnoreCase(where.charAt(i), first)) {
-                //noinspection StatementWithEmptyBody,AssignmentToForLoopParameter
-                while (++i <= max && !charsEqualIgnoreCase(where.charAt(i), first)) {}
-            }
-
-            /* Found first character, now look at the rest of "what". */
-            if (i <= max) {
-                int j = i + 1;
-                int end = j + targetCount - 1;
-                //noinspection StatementWithEmptyBody
-                for (int k = 1;
-                     j < end && charsEqualIgnoreCase(where.charAt(j), what.charAt(k));
-                     j++, k++) {}
-
-                if (j == end) {
-                    /* Found whole string. */
-                    return i;
-                }
-            }
-        }
-
-        return -1;
-    }
-
-    private static boolean charsEqualIgnoreCase(char c1, char c2) {
-        // Conversion to upper case alone is not sufficient, for example for Georgian alphabet.
-        return toUpperCase(c1) == toUpperCase(c2) || toLowerCase(c1) == toLowerCase(c2);
-    }
-
-    /**
-     * Converts a character to upper case. A slightly optimized version of
-     * {@link Character#toUpperCase(char)}.
-     */
-    public static char toUpperCase(char c) {
-        if (c < 'a') return c;
-        if (c <= 'z') return (char) (c + ('A' - 'a'));
-        return Character.toUpperCase(c);
-    }
-
-    /**
-     * Converts a character to lower case. A slightly optimized version of
-     * {@link Character#toLowerCase(char)}.
-     */
-    public static char toLowerCase(char c) {
-        if (c < 'A' || c >= 'a' && c <= 'z') return c;
-        if (c <= 'Z') return (char) (c + ('a' - 'A'));
-        return Character.toLowerCase(c);
-    }
-
-    @NonNull
-    public static CharSequence createSequence(@NonNull char[] data) {
-        return new ArrayBackedCharSequence(data);
-    }
-
-    @NonNull
-    public static CharSequence createSequence(@NonNull char[] data, int offset, int length) {
-        return new ArrayBackedCharSequence(data, offset, length);
-    }
-
-    @NonNull
-    public static char[] getCharArray(@NonNull CharSequence sequence) {
-        if (sequence instanceof ArrayBackedCharSequence) {
-            return ((ArrayBackedCharSequence)sequence).getCharArray();
-        }
-
-        return sequence.toString().toCharArray();
-    }
-
-    /**
-     * The {@link CharSequenceReader} returned by this method is intended for single-thread use
-     * only.
-     *
-     * @param data the character sequence to read
-     * @param stripBom whether a byte order mark at the beginning of the charachter sequence should
-     *     be skipped if present
-     * @return the reader obtaining its data from the given characher sequence
-     */
-    @NonNull
-    public static CharSequenceReader getReader(@NonNull CharSequence data, boolean stripBom) {
-        CharSequenceReader reader = new CharSequenceReader(data);
-        if (stripBom) {
-            if (data.length() > 0 && data.charAt(0) == '\uFEFF') {
-                // Skip BOM
-                //noinspection ResultOfMethodCallIgnored
-                reader.read();
-            }
-        }
-
-        return reader;
-    }
-
-    @Nullable
-    public static Document parseDocumentSilently(@NonNull CharSequence xml, boolean namespaceAware) {
-        try {
-            Reader reader = getReader(xml, true);
-            return XmlUtils.parseDocument(reader, namespaceAware);
-        } catch (SAXException | IOException e) {
-            // This method is deliberately silent; will return null.
-        }
-
-        return null;
-    }
-
-    @NonNull
-    public static InputStream getInputStream(@NonNull CharSequence text) {
-        return new ByteArrayInputStream(text.toString().getBytes(Charsets.UTF_8));
-    }
-
-    /**
-     * A {@link CharSequence} intended for use by lint; it is a char[]-backed
-     * {@linkplain CharSequence} which can provide its backing array to lint
-     * (which is useful to avoid having duplicated data, since for example the
-     * ECJ-based backend needs char[] instances of the source files instead
-     * of Strings, and the String class always insists on having its own
-     * private copy of the char array.
-     */
-    private static class ArrayBackedCharSequence implements CharSequence {
-        public final char[] data;
-        private final int offset;
-        private final int length;
-
-        public ArrayBackedCharSequence(@NonNull char[] data) {
-            this(data, 0, data.length);
-        }
-
-        public ArrayBackedCharSequence(@NonNull char[] data, int offset, int length) {
-            this.data = data;
-            this.offset = offset;
-            this.length = length;
-        }
-
-        @NonNull
-        public char[] getCharArray() {
-            if (offset == 0 && length == data.length) {
-                return data;
-            } else {
-                return Arrays.copyOfRange(data, offset, offset + length);
-            }
-        }
-
-        @Override
-        public int length() {
-            return length;
-        }
-
-        @Override
-        public char charAt(int index) {
-            return data[offset + index];
-        }
-
-        @Override
-        public CharSequence subSequence(int start, int end) {
-            return new ArrayBackedCharSequence(data, offset + start, end - start);
-        }
-
-        @NonNull
-        @Override
-        public String toString() {
-            return new String(data, offset, length);
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/util/PositionXmlParser.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/util/PositionXmlParser.java b/Build/src/main/java/com/tyron/build/util/PositionXmlParser.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/util/PositionXmlParser.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1062 +0,0 @@
-package com.tyron.build.util;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Comment;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.w3c.dom.Text;
-import org.xml.sax.Attributes;
-import org.xml.sax.InputSource;
-import org.xml.sax.Locator;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.ext.DefaultHandler2;
-import org.xml.sax.helpers.DefaultHandler;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.StringReader;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.tyron.build.compiler.manifest.SdkConstants;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-
-/**
- * A simple DOM XML parser which can retrieve exact beginning and end offsets
- * (and line and column numbers) for element nodes as well as attribute nodes.
- */
-public class PositionXmlParser {
-    private static final String UTF_16 = "UTF_16";
-    private static final String UTF_16LE = "UTF_16LE";
-    public static final String CONTENT_KEY = "contents";
-    private static final String POS_KEY = "offsets";
-    /** See http://www.w3.org/TR/REC-xml/#NT-EncodingDecl */
-    private static final Pattern ENCODING_PATTERN =
-            Pattern.compile("encoding=['\"](\\S*)['\"]");
-
-    private static final DocumentBuilderFactory DOCUMENT_BUILDER_FACTORY;
-    private static final SAXParserFactory SAX_PARSER_FACTORY;
-    private static final SAXParserFactory NAMESPACE_AWARE_SAX_PARSER_FACTORY;
-
-    static {
-        DOCUMENT_BUILDER_FACTORY = DocumentBuilderFactory.newInstance();
-        DOCUMENT_BUILDER_FACTORY.setNamespaceAware(true);
-        DOCUMENT_BUILDER_FACTORY.setValidating(false);
-        SAX_PARSER_FACTORY = SAXParserFactory.newInstance();
-        XmlUtils.configureSaxFactory(SAX_PARSER_FACTORY, false, false);
-        NAMESPACE_AWARE_SAX_PARSER_FACTORY = SAXParserFactory.newInstance();
-        XmlUtils.configureSaxFactory(NAMESPACE_AWARE_SAX_PARSER_FACTORY, true, false);
-    }
-
-    /**
-     * Parses the XML content from the given input stream and closes the stream.
-     *
-     * @param input the input stream containing the XML to be parsed
-     * @param namespaceAware whether the parser should be namespace aware
-     * @return the corresponding document
-     * @throws ParserConfigurationException if a SAX parser is not available
-     * @throws SAXException if the document contains a parsing error
-     * @throws IOException if something is seriously wrong. This should not happen since the input
-     *         source is known to be constructed from a string
-     */
-    @NonNull
-    public static Document parse(@NonNull InputStream input, boolean namespaceAware)
-            throws ParserConfigurationException, SAXException, IOException {
-        return parse(readAllBytes(input), namespaceAware);
-    }
-
-    /**
-     * Parses the XML content from the given input stream and closes the stream.
-     *
-     * <p>If a non-recoverable parser error is encountered, parsing stops, an error message is
-     * added to the {@code parseErrors} list, and the returned document contains the elements up
-     * to the one where the error was encountered.
-     *
-     * @param input the input stream containing the XML to be parsed
-     * @param namespaceAware whether the parser should be namespace aware
-     * @param parseErrors parsing errors, if any, are appended to this list
-     * @return the corresponding document
-     * @throws ParserConfigurationException if a SAX parser is not available
-     * @throws IOException if something is seriously wrong. This should not happen since the input
-     *         source is known to be constructed from a string
-     */
-    @NonNull
-    public static Document parse(
-            @NonNull InputStream input, boolean namespaceAware, @NonNull List<String> parseErrors)
-            throws ParserConfigurationException, IOException {
-        return parse(readAllBytes(input), namespaceAware, parseErrors);
-    }
-
-    /**
-     * @see #parse(InputStream, boolean)
-     */
-    @NonNull
-    public static Document parse(@NonNull InputStream input)
-            throws IOException, SAXException, ParserConfigurationException {
-        return parse(input, true);
-    }
-
-    /**
-     * @see #parse(byte[], boolean)
-     */
-    @NonNull
-    public static Document parse(@NonNull byte[] data)
-            throws ParserConfigurationException, SAXException, IOException {
-        return parse(data, true);
-    }
-
-    /**
-     * @see #parse(String, boolean)
-     */
-    @NonNull
-    public static Document parse(@NonNull String xml)
-            throws ParserConfigurationException, SAXException, IOException {
-        return parse(xml, true);
-    }
-
-    /**
-     * Parses the XML content from the given byte array.
-     *
-     * @param data the raw XML data (with unknown encoding)
-     * @param namespaceAware whether the parser should be namespace aware
-     * @return the corresponding document
-     * @throws ParserConfigurationException if a SAX parser is not available
-     * @throws SAXException if the document contains a parsing error
-     * @throws IOException if something is seriously wrong. This should not happen since the input
-     *         source is known to be constructed from a string.
-     */
-    @NonNull
-    public static Document parse(@NonNull byte[] data, boolean namespaceAware)
-            throws ParserConfigurationException, SAXException, IOException {
-        String xml = getXmlString(data);
-        xml = XmlUtils.stripBom(xml);
-        return parseInternal(xml, namespaceAware);
-    }
-
-    /**
-     * Parses the XML content from the given byte array.
-     *
-     * <p>If a non-recoverable parser error is encountered, parsing stops, an error message is
-     * added to the {@code parseErrors} list, and the returned document contains the elements up
-     * to the one where the error was encountered.
-     *
-     * @param data the raw XML data (with unknown encoding)
-     * @param namespaceAware whether the parser should be namespace aware
-     * @param parseErrors parsing errors, if any, are appended to this list
-     * @return the corresponding document
-     * @throws ParserConfigurationException if a SAX parser is not available
-     * @throws IOException if something is seriously wrong. This should not happen since the input
-     *         source is known to be constructed from a string.
-     */
-    @NonNull
-    public static Document parse(
-            @NonNull byte[] data, boolean namespaceAware, @NonNull List<String> parseErrors)
-            throws ParserConfigurationException, IOException {
-        String xml = getXmlString(data);
-        xml = XmlUtils.stripBom(xml);
-        return parseInternal(xml, namespaceAware, parseErrors);
-    }
-
-    /**
-     * Parses the given XML content.
-     *
-     * @param xml the XML string to be parsed. This must be in the correct encoding already
-     * @param namespaceAware whether the parser should be namespace aware
-     * @return the corresponding document
-     * @throws ParserConfigurationException if a SAX parser is not available
-     * @throws SAXException if the document contains a parsing error
-     * @throws IOException if something is seriously wrong. This should not happen since the input
-     *         source is known to be constructed from a string
-     */
-    @NonNull
-    public static Document parse(@NonNull String xml, boolean namespaceAware)
-            throws ParserConfigurationException, SAXException, IOException {
-        xml = XmlUtils.stripBom(xml);
-        return parseInternal(xml, namespaceAware);
-    }
-
-    @NonNull
-    private static Document parseInternal(@NonNull String xml, boolean namespaceAware)
-            throws ParserConfigurationException, SAXException, IOException {
-        DomBuilder domBuilder;
-        boolean retry = false;
-        while (true) {
-            domBuilder = new DomBuilder(xml);
-            try {
-                parseInternal(xml, namespaceAware, domBuilder);
-                break;
-            } catch (SAXException e) {
-                if (retry || !e.getMessage().contains("Content is not allowed in prolog")) {
-                    throw e;
-                }
-                // Byte order mark in the string? Skip it. There are many markers
-                // (see http://en.wikipedia.org/wiki/Byte_order_mark) so here we'll
-                // just skip those up to the XML prolog beginning character, '<'.
-                xml = xml.replaceFirst("^([\\W]+)<", "<");
-                retry = true;
-            }
-        };
-        return domBuilder.getDocument();
-    }
-
-    @NonNull
-    private static Document parseInternal(
-            @NonNull String xml, boolean namespaceAware, @NonNull List<String> parseErrors)
-            throws ParserConfigurationException, IOException {
-        DomBuilder domBuilder = null;
-        boolean retry = false;
-        while (true) {
-            domBuilder = new DomBuilder(xml);
-            try {
-                parseInternal(xml, namespaceAware, domBuilder);
-                break;
-            } catch (SAXException e) {
-                if (retry || !e.getMessage().contains("Content is not allowed in prolog")) {
-                    parseErrors.add(e.getLocalizedMessage());
-                    domBuilder.closeUnfinishedElements();
-                    break;
-                }
-                // Byte order mark in the string? Skip it. There are many markers
-                // (see http://en.wikipedia.org/wiki/Byte_order_mark) so here we'll
-                // just skip those up to the XML prolog beginning character, '<'.
-                xml = xml.replaceFirst("^([\\W]+)<", "<");
-                retry = true;
-            }
-        }
-        return domBuilder.getDocument();
-    }
-
-    private static void parseInternal(
-            @NonNull String xml, boolean namespaceAware, @NonNull DefaultHandler handler)
-            throws ParserConfigurationException, IOException, SAXException {
-        SAXParserFactory factory =
-                namespaceAware ? NAMESPACE_AWARE_SAX_PARSER_FACTORY : SAX_PARSER_FACTORY;
-        SAXParser parser = XmlUtils.createSaxParser(factory, true);
-        XMLReader xmlReader = parser.getXMLReader();
-        xmlReader.setProperty("http://xml.org/sax/properties/lexical-handler", handler);
-        parser.parse(createSource(xml), handler);
-    }
-
-    /**
-     * Reads all bytes from the given stream and closes it.
-     *
-     * @param input the stream to read from
-     * @return the contents of the stream as a byte array
-     */
-    private static byte[] readAllBytes(@NonNull InputStream input) throws IOException {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        byte[] buf = new byte[1024];
-        try (InputStream stream = input) {
-            while (true) {
-                ProgressManagerAdapter.checkCanceled();
-                int r = stream.read(buf);
-                if (r == -1) {
-                    break;
-                }
-                out.write(buf, 0, r);
-            }
-        }
-        return out.toByteArray();
-    }
-
-    private static InputSource createSource(@NonNull String xml) {
-        return new InputSource(new StringReader(xml));
-    }
-
-    /**
-     * Returns the String corresponding to the given byte array of XML data
-     * (with unknown encoding). This method attempts to guess the encoding based
-     * on the XML prologue.
-     *
-     * @param data the XML data to be decoded into a string
-     * @return a string corresponding to the XML data
-     */
-    @NonNull
-    public static String getXmlString(@NonNull byte[] data) {
-        return getXmlString(data, SdkConstants.UTF_8);
-    }
-
-    /**
-     * Returns the String corresponding to the given byte array of XML data
-     * (with unknown encoding). This method attempts to guess the encoding based
-     * on the XML prologue.
-     * @param data the XML data to be decoded into a string
-     * @param defaultCharset the default charset to use if not specified by an encoding prologue
-     *                       attribute or a byte order mark
-     * @return a string corresponding to the XML data
-     */
-    @NonNull
-    public static String getXmlString(@NonNull byte[] data, @NonNull String defaultCharset) {
-        int offset = 0;
-
-        String charset = null;
-        // Look for the byte order mark, to see if we need to remove bytes from
-        // the input stream (and to determine whether files are big endian or little endian) etc
-        // for files which do not specify the encoding.
-        // See http://unicode.org/faq/utf_bom.html#BOM for more.
-        if (data.length > 4) {
-            if (data[0] == (byte)0xef && data[1] == (byte)0xbb && data[2] == (byte)0xbf) {
-                // UTF-8
-                defaultCharset = charset = SdkConstants.UTF_8;
-                offset += 3;
-            } else if (data[0] == (byte)0xfe && data[1] == (byte)0xff) {
-                //  UTF-16, big-endian
-                defaultCharset = charset = UTF_16;
-                offset += 2;
-            } else if (data[0] == (byte)0x0 && data[1] == (byte)0x0
-                    && data[2] == (byte)0xfe && data[3] == (byte)0xff) {
-                // UTF-32, big-endian
-                defaultCharset = charset = "UTF_32";
-                offset += 4;
-            } else if (data[0] == (byte)0xff && data[1] == (byte)0xfe
-                    && data[2] == (byte)0x0 && data[3] == (byte)0x0) {
-                // UTF-32, little-endian. We must check for this *before* looking for
-                // UTF_16LE since UTF_32LE has the same prefix!
-                defaultCharset = charset = "UTF_32LE";
-                offset += 4;
-            } else if (data[0] == (byte)0xff && data[1] == (byte)0xfe) {
-                //  UTF-16, little-endian
-                defaultCharset = charset = UTF_16LE;
-                offset += 2;
-            }
-        }
-        int length = data.length - offset;
-
-        // Guess encoding by searching for an encoding= entry in the first line.
-        // The prologue, and the encoding names, will always be in ASCII - which means
-        // we don't need to worry about strange character encodings for the prologue characters.
-        // However, one wrinkle is that the whole file may be encoded in something like UTF-16
-        // where there are two bytes per character, so we can't just look for
-        //  ['e','n','c','o','d','i','n','g'] etc in the byte array since there could be
-        // multiple bytes for each character. However, since again the prologue is in ASCII,
-        // we can just drop the zeroes.
-        boolean seenOddZero = false;
-        boolean seenEvenZero = false;
-        int prologueStart = -1;
-        for (int lineEnd = offset; lineEnd < data.length; lineEnd++) {
-            if (data[lineEnd] == 0) {
-                if ((lineEnd - offset) % 2 == 0) {
-                    seenEvenZero = true;
-                } else {
-                    seenOddZero = true;
-                }
-            } else if (data[lineEnd] == '\n' || data[lineEnd] == '\r') {
-                break;
-            } else if (data[lineEnd] == '<') {
-                prologueStart = lineEnd;
-            } else if (data[lineEnd] == '>') {
-                // End of prologue. Quick check to see if this is a utf-8 file since that's
-                // common
-                for (int i = lineEnd - 4; i >= 0; i--) {
-                    if ((data[i] == 'u' || data[i] == 'U')
-                            && (data[i + 1] == 't' || data[i + 1] == 'T')
-                            && (data[i + 2] == 'f' || data[i + 2] == 'F')
-                            && (data[i + 3] == '-' || data[i + 3] == '_')
-                            && (data[i + 4] == '8')
-                    ) {
-                        charset = SdkConstants.UTF_8;
-                        break;
-                    }
-                }
-
-                if (charset == null) {
-                    StringBuilder sb = new StringBuilder();
-                    for (int i = prologueStart; i <= lineEnd; i++) {
-                        if (data[i] != 0) {
-                            sb.append((char) data[i]);
-                        }
-                    }
-                    String prologue = sb.toString();
-                    int encodingIndex = prologue.indexOf("encoding");
-                    if (encodingIndex != -1) {
-                        Matcher matcher = ENCODING_PATTERN.matcher(prologue);
-                        if (matcher.find(encodingIndex)) {
-                            charset = matcher.group(1);
-                        }
-                    }
-                }
-
-                break;
-            }
-        }
-
-        // No prologue on the first line, and no byte order mark: Assume UTF-8/16.
-        if (charset == null) {
-            charset = seenOddZero ? UTF_16LE : seenEvenZero ? UTF_16 : defaultCharset;
-        }
-
-        String xml = null;
-        try {
-            xml = new String(data, offset, length, charset);
-        } catch (UnsupportedEncodingException e) {
-            try {
-                if (!charset.equals(defaultCharset)) {
-                    xml = new String(data, offset, length, defaultCharset);
-                }
-            } catch (UnsupportedEncodingException u) {
-                // Just use the default encoding below
-            }
-        }
-        if (xml == null) {
-            xml = new String(data, offset, length);
-        }
-        return xml;
-    }
-
-    /**
-     * Returns the position for the given node. This is the start position. The end position can be
-     * obtained via {@link Position#getEnd()}.
-     *
-     * @param node the node to look up position for
-     * @return the position, or null if the node type is not supported for position info
-     */
-    @NonNull
-    public static SourcePosition getPosition(@NonNull Node node) {
-        return getPosition(node, -1, -1);
-    }
-
-    /**
-     * Returns the position for the given node. This is the start position. The end position can be
-     * obtained via {@link Position#getEnd()}. A specific range within the node can be specified
-     * with the {@code start} and {@code end} parameters.
-     *
-     * @param node the node to look up position for
-     * @param start the relative offset within the node range to use as the
-     *            starting position, inclusive, or -1 to not limit the range
-     * @param end the relative offset within the node range to use as the ending
-     *            position, or -1 to not limit the range
-     * @return the position, or null if the node type is not supported for
-     *         position info
-     */
-    @NonNull
-    public static SourcePosition getPosition(@NonNull Node node, int start, int end) {
-        Position p = getPositionHelper(node, start, end);
-        return p == null ? SourcePosition.UNKNOWN : p.toSourcePosition();
-    }
-
-    /**
-     * Finds the leaf node at the given offset.
-     *
-     * @param document root node
-     * @param offset   offset to look for
-     * @return the leaf node at that offset, if any
-     */
-    @Nullable
-    public static Node findNodeAtOffset(@NonNull Document document, int offset) {
-        Element root = document.getDocumentElement();
-        if (root != null) {
-            return findNodeAtOffset(root, offset);
-        }
-
-        return null;
-    }
-
-    @Nullable
-    private static Node findNodeAtOffset(@NonNull Node node, int offset) {
-        Position p = getPositionHelper(node, -1, -1);
-        if (p != null) {
-            if (offset < p.getOffset()) {
-                return null;
-            }
-            Position end = p.getEnd();
-            if (end != null) {
-                if (offset >= end.getOffset()) {
-                    return null;
-                }
-            }
-        } else {
-            return null;
-        }
-
-        NodeList children = node.getChildNodes();
-        for (int i = 0, n = children.getLength(); i < n; i++) {
-            Node item = children.item(i);
-            Node match = findNodeAtOffset(item, offset);
-            if (match != null) {
-                return match;
-            }
-        }
-
-        NamedNodeMap attributes = node.getAttributes();
-        if (attributes != null) {
-            for (int i = 0, n = attributes.getLength(); i < n; i++) {
-                Node item = attributes.item(i);
-                Node match = findNodeAtOffset(item, offset);
-                if (match != null) {
-                    return match;
-                }
-            }
-        }
-
-        return node;
-    }
-
-    /**
-     * Finds the leaf node at the given offset.
-     *
-     * @param document root node
-     * @param line     the line
-     * @param column   the column, or -1
-     * @return the leaf node at that offset, if any
-     */
-    @Nullable
-    public static Node findNodeAtLineAndCol(@NonNull Document document, int line, int column) {
-        Element root = document.getDocumentElement();
-        if (root != null) {
-            return findNodeAtLineAndCol(root, line, column);
-        }
-
-        return null;
-    }
-
-    @Nullable
-    private static Node findNodeAtLineAndCol(@NonNull Node node, int line, int column) {
-        Position p = getPositionHelper(node, -1, -1);
-        if (p != null) {
-            if (line < p.getLine() || line == p.getLine() && column != -1
-                    && column < p.getColumn()) {
-                return null;
-            }
-            Position end = p.getEnd();
-            if (end != null) {
-                if (line > end.getLine() || line == end.getLine() && column != -1
-                        && column >= end.getColumn()) {
-                    return null;
-                }
-            }
-        } else {
-            return null;
-        }
-
-        NodeList children = node.getChildNodes();
-        for (int i = 0, n = children.getLength(); i < n; i++) {
-            Node item = children.item(i);
-            Node match = findNodeAtLineAndCol(item, line, column);
-            if (match != null) {
-                return match;
-            }
-        }
-
-        NamedNodeMap attributes = node.getAttributes();
-        if (attributes != null) {
-            for (int i = 0, n = attributes.getLength(); i < n; i++) {
-                Node item = attributes.item(i);
-                Node match = findNodeAtLineAndCol(item, line, column);
-                if (match != null) {
-                    return match;
-                }
-            }
-        }
-
-        return node;
-    }
-
-    @Nullable
-    private static Position getPositionHelper(@NonNull Node node, int start, int end) {
-        // Look up the position information stored while parsing for the given node.
-        // Note however that we only store position information for elements (because
-        // there is no SAX callback for individual attributes).
-        // Therefore, this method special cases this:
-        //  -- First, it looks at the owner element and uses its position
-        //     information as a first approximation.
-        //  -- Second, it uses that, as well as the original XML text, to search
-        //     within the node range for an exact text match on the attribute name
-        //     and if found uses that as the exact node offsets instead.
-        if (node instanceof Attr) {
-            Attr attr = (Attr) node;
-            Position pos = (Position) attr.getOwnerElement().getUserData(POS_KEY);
-            if (pos != null) {
-                int startOffset = pos.getOffset();
-                int endOffset = pos.getEnd().getOffset();
-                if (start != -1) {
-                    startOffset += start;
-                    if (end != -1) {
-                        endOffset = startOffset + (end - start);
-                    }
-                }
-
-                // Find attribute in the text.
-                String contents = (String) node.getOwnerDocument().getUserData(CONTENT_KEY);
-                if (contents == null) {
-                    return null;
-                }
-
-                // Locate the name=value attribute in the source text.
-                // Fast string check first for the common occurrence.
-                String name = attr.getName();
-                Pattern pattern = Pattern.compile(attr.getPrefix() != null
-                        ? String.format("(%1$s\\s*=\\s*[\"'].*?[\"'])", name)
-                        : String.format("[^:](%1$s\\s*=\\s*[\"'].*?[\"'])", name));
-                Matcher matcher = pattern.matcher(contents);
-                if (matcher.find(startOffset) && matcher.start(1) <= endOffset) {
-                    int index = matcher.start(1);
-                    // Adjust the line and column to this new offset.
-                    int line = pos.getLine();
-                    int column = pos.getColumn();
-                    for (int offset = pos.getOffset(); offset < index; offset++) {
-                        char t = contents.charAt(offset);
-                        if (t == '\n') {
-                            line++;
-                            column = 0;
-                        } else {
-                            column++;
-                        }
-                    }
-
-                    Position attributePosition = new Position(line, column, index);
-                    // Also set end range for retrieval in getLocation.
-                    attributePosition.setEnd(
-                            new Position(line, column + matcher.end(1) - index, matcher.end(1)));
-                    return attributePosition;
-                } else {
-                    // No regexp match either: just fall back to element position.
-                    return pos;
-                }
-            }
-        } else if (node instanceof Text) {
-            // Position of parent element, if any.
-            Position pos = null;
-            if (node.getPreviousSibling() != null) {
-                pos = (Position) node.getPreviousSibling().getUserData(POS_KEY);
-            }
-            if (pos == null) {
-                pos = (Position) node.getParentNode().getUserData(POS_KEY);
-            }
-            if (pos != null) {
-                // Attempt to point forward to the actual text node.
-                int startOffset = pos.getOffset();
-                int endOffset = pos.getEnd().getOffset();
-                int line = pos.getLine();
-                int column = pos.getColumn();
-
-                // Find attribute in the text.
-                String contents = (String) node.getOwnerDocument().getUserData(CONTENT_KEY);
-                if (contents == null || contents.length() < endOffset) {
-                    return null;
-                }
-
-                boolean inAttribute = false;
-                for (int offset = startOffset; offset <= endOffset; offset++) {
-                    char c = contents.charAt(offset);
-                    if (c == '>' && !inAttribute) {
-                        // Found the end of the element open tag: this is where the text begins.
-
-                        // Skip >
-                        offset++;
-                        column++;
-
-                        String text = node.getNodeValue();
-                        int textIndex = 0;
-                        int textLength = text.length();
-                        int newLine = line;
-                        int newColumn = column;
-                        if (start != -1) {
-                            textLength = Math.min(textLength, start);
-                            for (; textIndex < textLength; textIndex++) {
-                                char t = text.charAt(textIndex);
-                                if (t == '\n') {
-                                    newLine++;
-                                    newColumn = 0;
-                                } else {
-                                    newColumn++;
-                                }
-                            }
-                        } else {
-                            // Skip text whitespace prefix, if the text node contains
-                            // non-whitespace characters
-                            for (; textIndex < textLength; textIndex++) {
-                                char t = text.charAt(textIndex);
-                                if (t == '\n') {
-                                    newLine++;
-                                    newColumn = 0;
-                                } else if (!Character.isWhitespace(t)) {
-                                    break;
-                                } else {
-                                    newColumn++;
-                                }
-                            }
-                        }
-                        if (textIndex == text.length()) {
-                            textIndex = 0; // Whitespace node
-                        } else {
-                            line = newLine;
-                            column = newColumn;
-                        }
-
-                        Position attributePosition = new Position(line, column, offset + textIndex);
-                        // Also set end range for retrieval in getLocation
-                        if (end != -1) {
-                            attributePosition.setEnd(new Position(line, column, offset + end));
-                        } else {
-                            // Search backwards for the last non-space character
-                            for (int i = textLength - 1; i >= 0; i--) {
-                                if (!Character.isWhitespace(text.charAt(i))) {
-                                    textLength = i + 1;
-                                    break;
-                                }
-                            }
-
-                            // Search for the end
-                            endOffset = offset + textIndex;
-                            int endLine = line;
-                            int endColumn = column;
-                            for (; textIndex < textLength; textIndex++) {
-                                char t = text.charAt(textIndex);
-                                if (t == '\n') {
-                                    endLine++;
-                                    endColumn = 0;
-                                } else {
-                                    endColumn++;
-                                }
-                                endOffset++;
-                            }
-
-                            attributePosition.setEnd(
-                                    new Position(endLine, endColumn, endOffset));
-                        }
-                        return attributePosition;
-                    } else if (c == '"') {
-                        inAttribute = !inAttribute;
-                    } else if (c == '\n') {
-                        line++;
-                        column = -1; // pre-subtract column added below
-                    }
-                    column++;
-                }
-
-                return pos;
-            }
-        }
-
-        return (Position) node.getUserData(POS_KEY);
-    }
-
-    /**
-     * SAX parser handler which incrementally builds up a DOM document as we go
-     * along, and updates position information along the way. Position
-     * information is attached to the DOM nodes by setting user data with the
-     * {@link #POS_KEY} key.
-     */
-    private static final class DomBuilder extends DefaultHandler2 {
-        private final String mXml;
-        private final Document mDocument;
-        private Locator mLocator;
-        private int mCurrentLine = 0;
-        private int mCurrentOffset;
-        private int mCurrentColumn;
-        private final List<Element> mStack = new ArrayList<>();
-        private boolean mCdata;
-        @SuppressWarnings("StringBufferField")
-        private final StringBuilder mPendingText = new StringBuilder();
-
-        DomBuilder(String xml) throws ParserConfigurationException {
-            mXml = xml;
-
-            DocumentBuilder docBuilder = DOCUMENT_BUILDER_FACTORY.newDocumentBuilder();
-            mDocument = docBuilder.newDocument();
-            mDocument.setUserData(CONTENT_KEY, xml, null);
-        }
-
-        /** Returns the document parsed by the handler. */
-        @NonNull
-        Document getDocument() {
-            closeUnfinishedElements();
-            return mDocument;
-        }
-
-        void closeUnfinishedElements() {
-            flushText();
-            while (!mStack.isEmpty()) {
-                Element element = mStack.remove(mStack.size() - 1);
-
-                Position pos = (Position) element.getUserData(POS_KEY);
-                assert pos != null;
-                pos.setEnd(getCurrentPosition());
-
-                addNodeToParent(element);
-            }
-        }
-
-        @Override
-        public void setDocumentLocator(Locator locator) {
-            this.mLocator = locator;
-        }
-
-        @Override
-        public void startElement(String uri, String localName, String qName,
-                                 Attributes attributes) throws SAXException {
-            try {
-                flushText();
-                Element element = mDocument.createElementNS(uri, qName);
-                for (int i = 0; i < attributes.getLength(); i++) {
-                    if (attributes.getURI(i) != null && !attributes.getURI(i).isEmpty()) {
-                        Attr attr = mDocument.createAttributeNS(attributes.getURI(i),
-                                attributes.getQName(i));
-                        attr.setValue(attributes.getValue(i));
-                        element.setAttributeNodeNS(attr);
-                        assert attr.getOwnerElement() == element;
-                    } else {
-                        Attr attr = mDocument.createAttribute(attributes.getQName(i));
-                        attr.setValue(attributes.getValue(i));
-                        element.setAttributeNode(attr);
-                        assert attr.getOwnerElement() == element;
-                    }
-                }
-
-                Position pos = getCurrentPosition();
-
-                // The starting position reported to us by SAX is really the END of the
-                // open tag in an element, when all the attributes have been processed.
-                // We have to scan backwards to find the real beginning. We'll do that
-                // by scanning backwards.
-                // -1: Make sure that when we have <foo></foo> we don't consider </foo>
-                // the beginning since pos.offset will typically point to the first character
-                // AFTER the element open tag, which could be a closing tag or a child open
-                // tag.
-                element.setUserData(POS_KEY, findOpeningTag(pos), null);
-                mStack.add(element);
-            } catch (Exception t) {
-                throw new SAXException(t);
-            }
-        }
-
-        @Override
-        public void endElement(String uri, String localName, String qName) {
-            flushText();
-            Element element = mStack.remove(mStack.size() - 1);
-
-            Position pos = (Position) element.getUserData(POS_KEY);
-            assert pos != null;
-            pos.setEnd(getCurrentPosition());
-
-            addNodeToParent(element);
-        }
-
-        @Override
-        public void comment(char[] chars, int start, int length) throws SAXException {
-            flushText();
-            String comment = new String(chars, start, length);
-            Comment domComment = mDocument.createComment(comment);
-
-            // current position is the closing comment tag.
-            Position currentPosition = getCurrentPosition();
-            Position startPosition = findOpeningTag(currentPosition);
-            startPosition.setEnd(currentPosition);
-
-            domComment.setUserData(POS_KEY, startPosition, null);
-            addNodeToParent(domComment);
-        }
-
-        /**
-         * Adds a node to the current parent element being visited, or to the document if there is
-         * no parent in context.
-         *
-         * @param nodeToAdd xml node to add
-         */
-        private void addNodeToParent(Node nodeToAdd) {
-            if (mStack.isEmpty()){
-                mDocument.appendChild(nodeToAdd);
-            } else {
-                Element parent = mStack.get(mStack.size() - 1);
-                parent.appendChild(nodeToAdd);
-            }
-        }
-
-        /**
-         * Find opening tags from the current position.
-         * '<' cannot appear in attribute values or anywhere else within
-         * an element open tag, so we know the first occurrence is the real
-         * element start.
-         * For comments, it is not legal to put '<' in a comment, however we are not
-         * validating so we will return an invalid column in that case.
-         *
-         * @param startingPosition the position to walk backwards until < is reached
-         * @return the opening tag position or startPosition if cannot be found
-         */
-        private Position findOpeningTag(Position startingPosition) {
-            for (int offset = startingPosition.getOffset() - 1; offset >= 0; offset--) {
-                char c = mXml.charAt(offset);
-
-                if (c == '<') {
-                    // Adjust line position
-                    int line = startingPosition.getLine();
-                    for (int i = offset, n = startingPosition.getOffset(); i < n; i++) {
-                        if (mXml.charAt(i) == '\n') {
-                            line--;
-                        }
-                    }
-
-                    // Compute new column position
-                    int column = 0;
-                    for (int i = offset - 1; i >= 0; i--, column++) {
-                        if (mXml.charAt(i) == '\n') {
-                            break;
-                        }
-                    }
-
-                    return new Position(line, column, offset);
-                }
-            }
-            // we did not find it, approximate.
-            return startingPosition;
-        }
-
-        /**
-         * Returns a position holder for the current position. The most
-         * important part of this function is to incrementally compute the
-         * offset as well, by counting forwards until it reaches the new line
-         * number and column position of the XML parser, counting characters as
-         * it goes along.
-         */
-        private Position getCurrentPosition() {
-            int line = mLocator.getLineNumber() - 1;
-            int column = mLocator.getColumnNumber() - 1;
-
-            // Compute offset incrementally now that we have the new line and column numbers.
-            int xmlLength = mXml.length();
-            while (mCurrentLine < line && mCurrentOffset < xmlLength) {
-                char c = mXml.charAt(mCurrentOffset);
-                if (c == '\r' && mCurrentOffset < xmlLength - 1) {
-                    if (mXml.charAt(mCurrentOffset + 1) != '\n') {
-                        mCurrentLine++;
-                        mCurrentColumn = 0;
-                    }
-                } else if (c == '\n') {
-                    mCurrentLine++;
-                    mCurrentColumn = 0;
-                } else {
-                    mCurrentColumn++;
-                }
-                mCurrentOffset++;
-            }
-
-            // Validity check -- the parser will sometimes pass newlines with columns that are
-            // out of bounds for the line; check for this
-            // (https://issuetracker.google.com/123835101)
-            // so instead of
-            //     mCurrentOffset += column - mCurrentColumn;
-            // we'll abort if we encounter newlines
-            for (int skip = mCurrentColumn; skip < column; skip++) {
-                if (mCurrentOffset == xmlLength) {
-                    break;
-                }
-                char c = mXml.charAt(mCurrentOffset);
-                if (c == '\n') {
-                    break;
-                }
-                mCurrentOffset++;
-            }
-
-            if (mCurrentOffset >= xmlLength) {
-                // The parser sometimes passes wrong column numbers at the
-                // end of the file: Ensure that the offset remains valid.
-                mCurrentOffset = xmlLength;
-            }
-            mCurrentColumn = column;
-
-            return new Position(mCurrentLine, mCurrentColumn, mCurrentOffset);
-        }
-
-        @Override
-        public void startCDATA() throws SAXException {
-            flushText();
-            mCdata = true;
-        }
-
-        @Override
-        public void endCDATA() throws SAXException {
-            flushText();
-            mCdata = false;
-        }
-
-        @Override
-        public void characters(char[] c, int start, int length) throws SAXException {
-            mPendingText.append(c, start, length);
-        }
-
-        private void flushText() {
-            if ((mPendingText.length() > 0 || mCdata) && !mStack.isEmpty()) {
-                Element element = mStack.get(mStack.size() - 1);
-                Node textNode;
-                if (mCdata) {
-                    textNode = mDocument.createCDATASection(mPendingText.toString());
-                } else {
-                    textNode = mDocument.createTextNode(mPendingText.toString());
-                }
-                element.appendChild(textNode);
-                mPendingText.setLength(0);
-            }
-        }
-    }
-
-    private static class Position {
-        /** The line number (0-based where the first line is line 0). */
-        private final int mLine;
-        private final int mColumn;
-        private final int mOffset;
-        private Position mEnd;
-
-        /**
-         * Creates a new position.
-         *
-         * @param line the 0-based line number, or -1 if unknown
-         * @param column the 0-based column number, or -1 if unknown
-         * @param offset the offset, or -1 if unknown
-         */
-        Position(int line, int column, int offset) {
-            this.mLine = line;
-            this.mColumn = column;
-            this.mOffset = offset;
-        }
-
-        public int getLine() {
-            return mLine;
-        }
-
-        public int getOffset() {
-            return mOffset;
-        }
-
-        public int getColumn() {
-            return mColumn;
-        }
-
-        public Position getEnd() {
-            return mEnd;
-        }
-
-        public void setEnd(@NonNull Position end) {
-            mEnd = end;
-        }
-
-        public SourcePosition toSourcePosition() {
-            int endLine = mLine, endColumn = mColumn, endOffset = mOffset;
-
-            if (mEnd != null) {
-                endLine = mEnd.getLine();
-                endColumn = mEnd.getColumn();
-                endOffset = mEnd.getOffset();
-            }
-
-            return new SourcePosition(mLine, mColumn, mOffset, endLine, endColumn, endOffset);
-        }
-    }
-
-    private PositionXmlParser() { }
-}
Index: Build/src/main/java/com/tyron/build/util/CharSequenceReader.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/util/CharSequenceReader.java b/Build/src/main/java/com/tyron/build/util/CharSequenceReader.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/util/CharSequenceReader.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,93 +0,0 @@
-package com.tyron.build.util;
-
-import androidx.annotation.NonNull;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.nio.CharBuffer;
-
-/**
- * A {@link Reader} getting its data from a {@link CharSequence}. This light-weight implementation
- * is intended for single-thread use, doesn't have any synchronization, and does not throw {@link
- * IOException}.
- */
-// This implementation is based on a package private Guava implementation (com.google.common.io),
-// minus precondition checks, synchronization, IOException, plus annotations.
-public final class CharSequenceReader extends Reader {
-    private CharSequence seq;
-    private int pos;
-    private int mark;
-
-    public CharSequenceReader(@NonNull CharSequence seq) {
-        this.seq = seq;
-    }
-
-    private boolean hasRemaining() {
-        return remaining() > 0;
-    }
-
-    private int remaining() {
-        return seq.length() - pos;
-    }
-
-    @Override
-    public int read(@NonNull CharBuffer target) {
-        if (!hasRemaining()) {
-            return -1;
-        }
-        int charsToRead = Math.min(target.remaining(), remaining());
-        for (int i = 0; i < charsToRead; i++) {
-            target.put(seq.charAt(pos++));
-        }
-        return charsToRead;
-    }
-
-    @Override
-    public int read() {
-        return hasRemaining() ? seq.charAt(pos++) : -1;
-    }
-
-    @Override
-    public int read(@NonNull char[] cbuf, int off, int len) {
-        if (!hasRemaining()) {
-            return -1;
-        }
-        int charsToRead = Math.min(len, remaining());
-        for (int i = 0; i < charsToRead; i++) {
-            cbuf[off + i] = seq.charAt(pos++);
-        }
-        return charsToRead;
-    }
-
-    @Override
-    public long skip(long n) {
-        int charsToSkip = (int) Math.min(remaining(), n);
-        pos += charsToSkip;
-        return charsToSkip;
-    }
-
-    @Override
-    public boolean ready() {
-        return true;
-    }
-
-    @Override
-    public boolean markSupported() {
-        return true;
-    }
-
-    @Override
-    public void mark(int readAheadLimit) {
-        mark = pos;
-    }
-
-    @Override
-    public void reset() {
-        pos = mark;
-    }
-
-    @Override
-    public void close() {
-        seq = null;
-    }
-}
Index: Build/src/main/java/com/tyron/build/util/ProgressManagerAdapter.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/util/ProgressManagerAdapter.java b/Build/src/main/java/com/tyron/build/util/ProgressManagerAdapter.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/util/ProgressManagerAdapter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,67 +0,0 @@
-package com.tyron.build.util;
-
-import androidx.annotation.NonNull;
-
-import com.google.common.base.Preconditions;
-import java.util.concurrent.CancellationException;
-
-/**
- * An adapter for accessing environment-dependent progress and cancellation functionality. By
- * default all public methods of this class have no effect. See subclasses for descriptions of
- * behavior in specific environments.
- */
-public abstract class ProgressManagerAdapter {
-    private static ProgressManagerAdapter ourInstance;
-
-    /**
-     * Checks if the progress indicator associated with the current thread has been canceled and, if
-     * so, throws an unchecked exception. The exact type of the exception is environment-dependent.
-     */
-    public static void checkCanceled() {
-        ProgressManagerAdapter instance = ourInstance;
-        if (instance != null) {
-            instance.doCheckCanceled();
-        }
-    }
-
-    /**
-     * Rethrows the given exception if it means that the current computation was cancelled. This
-     * method is intended to be used in the following context:
-     *
-     * <pre>
-     *     try {
-     *         // Code that calls ProgressManagerAdapter.checkCancelled()
-     *     }
-     *     catch (Exception e) {
-     *         ProgressManagerAdapter.throwIfCancellation(e);
-     *         // Handle other exceptions.
-     *     }
-     * </pre>
-     */
-    public static void throwIfCancellation(@NonNull Throwable t) {
-        ProgressManagerAdapter instance = ourInstance;
-        if (instance == null) {
-            throwIfCancellationException(t);
-        } else {
-            instance.doThrowIfCancellation(t);
-        }
-    }
-
-    protected abstract void doCheckCanceled();
-
-    protected void doThrowIfCancellation(@NonNull Throwable t) {
-        throwIfCancellationException(t);
-    }
-
-    private static void throwIfCancellationException(@NonNull Throwable t) {
-        if (t instanceof CancellationException) {
-            throw (CancellationException) t;
-        }
-    }
-
-    protected static void setInstance(@NonNull ProgressManagerAdapter instance) {
-        Preconditions.checkState(ourInstance == null);
-        ourInstance = instance;
-    }
-}
-
Index: Build/src/main/java/com/tyron/build/model/Project.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/model/Project.java b/Build/src/main/java/com/tyron/build/model/Project.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/model/Project.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,228 +0,0 @@
-package com.tyron.build.model;
-
-import android.util.Log;
-
-import com.tyron.build.BuildModule;
-import com.tyron.build.compiler.resource.AAPT2Compiler;
-import com.tyron.build.compiler.LibraryChecker;
-import com.tyron.common.util.Decompress;
-import com.tyron.common.util.StringSearch;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.lang.model.SourceVersion;
-
-/**
- * Class for storing project data, directories and files
- */
-public class Project {
-    
-    public final File mRoot;
-    
-    public Map<String, File> javaFiles = new HashMap<>();
-    public List<String> jarFiles = new ArrayList<>();
-
-    private final Set<File> libraries = new HashSet<>();
-    private final Map<String, File> RJavaFiles = new HashMap<>();
-
-    //TODO: Adjust these values according to build.gradle or manifest
-    private final int minSdk = 21;
-    private final int targetSdk = 31;
-
-    private String packageName;
-
-    /**
-     * Creates a project object from specified root
-     */
-    public Project(File root) {
-        mRoot = root;
-        
-        findJavaFiles(new File(root, "app/src/main/java"));
-    }
-    
-    private void findJavaFiles(File file) {
-        File[] files = file.listFiles();
-        
-        if (files != null) {
-            for (File child : files) {
-                if (child.isDirectory()) {
-                    findJavaFiles(child);
-                } else {
-                    if (child.getName().endsWith(".java")) {
-                        String packageName = StringSearch.packageName(child);
-                        Log.d("PROJECT FIND JAVA", "Found " + child.getAbsolutePath());
-                        if (packageName.isEmpty()) {
-                            Log.d("Error package empty", child.getAbsolutePath());
-                        } else {
-                            if (SourceVersion.isName(packageName + "." + child.getName().replace(".java", ""))) {
-                                javaFiles.put(packageName + "." + child.getName().replace(".java", ""), child);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    public String getPackageName() {
-        if (packageName == null) {
-            loadPackageName();
-        }
-        return packageName;
-    }
-
-    private void loadPackageName() {
-        packageName = AAPT2Compiler.getPackageName(getManifestFile());
-    }
-    
-    public Map<String, File> getJavaFiles() {
-        if (javaFiles.isEmpty()) {
-            findJavaFiles(getJavaDirectory());
-        }
-        return javaFiles;
-    }
-
-    private void searchRJavaFiles(File root) {
-        File[] files = root.listFiles();
-        if (files != null) {
-            for (File file : files) {
-                if (file.isDirectory()) {
-                    searchRJavaFiles(file);
-                } else {
-                    String packageName = StringSearch.packageName(file);
-                    if (!packageName.isEmpty()) {
-                        packageName = packageName + "." + file.getName().substring(0, file.getName().lastIndexOf("."));
-                        RJavaFiles.put(packageName, file);
-                    }
-                }
-            }
-        }
-    }
-    public Map<String, File> getRJavaFiles() {
-        if (RJavaFiles.isEmpty()) {
-            searchRJavaFiles(new File(getBuildDirectory(), "gen"));
-        }
-        return RJavaFiles;
-    }
-
-    public void searchLibraries() {
-        libraries.clear();
-
-        File libPath = new File(getBuildDirectory(), "libs");
-        File[] files = libPath.listFiles();
-        if (files != null) {
-            for (File lib : files) {
-                if (lib.isDirectory()) {
-                    File check = new File(lib, "classes.jar");
-                    if (check.exists()) {
-                        libraries.add(check);
-                    }
-                }
-            }
-        }
-    }
-    public Set<File> getLibraries() {
-        if (libraries.isEmpty()) {
-            LibraryChecker checker = new LibraryChecker(this);
-            checker.check();
-
-            searchLibraries();
-        }
-        return libraries;
-    }
-
-    /**
-     * Clears all the cached files stored in this project, the next time ths project
-     * is opened, it will get loaded again
-     */
-    public void clear() {
-        packageName = null;
-
-        RJavaFiles.clear();
-        libraries.clear();
-        javaFiles.clear();
-        libraries.clear();
-    }
-    /**
-     * Used to check if this project contains the required directories
-     * such as app/src/main/java, resources and others
-     */
-    public boolean isValidProject() {
-        File check = new File(mRoot, "app/src/main/java");
-
-        if (!check.exists()) {
-            return false;
-        }
-
-        if (!getResourceDirectory().exists()) {
-            return false;
-        }
-
-        return true;
-    }
-    
-    /**
-     * Creates a new project configured at mRoot, returns true if the project
-     * has been created, false if not.
-     */
-    public boolean create() {
-        
-        // this project already exists
-        if (isValidProject()) {
-            return false;
-        }
-        
-        File java = getJavaDirectory();
-        
-        if (!java.mkdirs()) {
-            return false;
-        }
-        
-		if (!getResourceDirectory().mkdirs()) {
-			return false;
-		}
-		
-        Decompress.unzipFromAssets(BuildModule.getContext(), "test_project.zip",
-                java.getAbsolutePath());
-		
-        if (!getLibraryDirectory().mkdirs()) {
-            return false;
-        }
-
-        return getBuildDirectory().mkdirs();
-    }
-
-    public int getMinSdk() {
-        return minSdk;
-    }
-
-    public int getTargetSdk() {
-        return targetSdk;
-    }
-	
-	public File getResourceDirectory() {
-		return new File(mRoot, "app/src/main/res");
-	}
-    
-    public File getJavaDirectory() {
-        return new File(mRoot, "app/src/main/java");
-    }
-    
-    public File getLibraryDirectory() {
-        return new File(mRoot, "app/libs");
-    }
-    
-    public File getBuildDirectory() {
-        return new File(mRoot, "app/build");
-    }
-
-    public File getManifestFile() {
-        return new File(mRoot, "app/src/main/AndroidManifest.xml");
-    }
-}
Index: Build/src/main/java/com/tyron/build/model/FileAndLine.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/model/FileAndLine.java b/Build/src/main/java/com/tyron/build/model/FileAndLine.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/model/FileAndLine.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,46 +0,0 @@
-package com.tyron.build.model;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.tyron.build.compiler.manifest.IMergerLog;
-
-/**
- * Information about the file and line number where an error occurred.
- */
-public class FileAndLine {
-    private final String mFilePath;
-    private final int mLine;
-
-    public FileAndLine(@Nullable String filePath, int line) {
-        mFilePath = filePath;
-        mLine = line;
-    }
-
-    @Nullable
-    public String getFileName() {
-        return mFilePath;
-    }
-
-    public int getLine() {
-        return mLine;
-    }
-
-    @NonNull
-    @Override
-    public String toString() {
-        String name = mFilePath;
-        if (IMergerLog.MAIN_MANIFEST.equals(name)) {
-            name = "main manifest";
-        } else if (IMergerLog.LIBRARY.equals(name)) {
-            name = "library";
-        } else if (name == null) {
-            name = "(Unknown)";
-        }
-        if (mLine <= 0) {
-            return name;
-        } else {
-            return name + ':' + mLine;
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/model/SourceFileObject.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/model/SourceFileObject.java b/Build/src/main/java/com/tyron/build/model/SourceFileObject.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/model/SourceFileObject.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,98 +0,0 @@
-package com.tyron.build.model;
-
-import android.annotation.SuppressLint;
-
-import androidx.annotation.NonNull;
-
-import com.tyron.build.parser.FileManager;
-
-import java.io.IOException;
-import java.net.URI;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.time.Instant;
-
-import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-
-@SuppressLint("NewApi")
-public class SourceFileObject extends SimpleJavaFileObject {
-
-	public Path mFile;
-	private final Instant modified;
-	private String mContents;
-	
-	public SourceFileObject(Path file) {
-		this(file, null, null);
-	}
-	
-	public SourceFileObject(Path file, String contents, Instant modified) {
-		super(file.toUri(), JavaFileObject.Kind.SOURCE);
-		mContents = contents;
-		mFile = file;
-		this.modified = modified;
-	}
-
-	@Override
-	public CharSequence getCharContent(boolean ignoreEncodingErrors) {
-		if (mContents != null) {
-			return mContents;
-		}
-		return FileManager.readFile(mFile.toFile());
-	}
-	
-	@Override
-    public Kind getKind() {
-        String name = mFile.getFileName().toString();
-        return kindFromExtension(name);
-    }
-
-    private static Kind kindFromExtension(String name) {
-        for (Kind candidate : Kind.values()) {
-            if (name.endsWith(candidate.extension)) {
-                return candidate;
-            }
-        }
-        return null;
-    }
-	
-	@Override
-    public boolean isNameCompatible(String simpleName, Kind kind) {
-        return mFile.getFileName().toString().equals(simpleName + kind.extension);
-    }
-	
-	@Override
-	public URI toUri() {
-		return mFile.toUri();
-	}
-
-	@Override
-	public long getLastModified() {
-		if (modified == null) {
-			try {
-				return Files.getLastModifiedTime(mFile).toMillis();
-			} catch (IOException e) {
-				return Instant.EPOCH.toEpochMilli();
-			}
-		}
-		return modified.toEpochMilli();
-	}
-	
-	@NonNull
-	@Override
-	public String toString() {
-		return mFile.toString();
-	}
-
-	@Override
-	public boolean equals(Object o) {
-		if (getClass() != o.getClass()) return false;
-		SourceFileObject that = (SourceFileObject) o;
-		return this.mFile.equals(that.mFile);
-	}
-
-	@Override
-	public int hashCode() {
-		return mFile.hashCode();
-	}
-}
Index: Build/src/main/java/com/tyron/build/model/DiagnosticWrapper.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/model/DiagnosticWrapper.java b/Build/src/main/java/com/tyron/build/model/DiagnosticWrapper.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/model/DiagnosticWrapper.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,123 +0,0 @@
-package com.tyron.build.model;
-
-import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
-
-import java.io.File;
-import java.util.Locale;
-
-public class DiagnosticWrapper implements Diagnostic<File> {
-    
-    private String code;
-    private File source;
-    private Kind kind;
-    
-    private long position;
-    private long startPosition;
-    private long endPosition;
-
-    private long lineNumber;
-    private long columnNumber;
-    
-    private String message;
-    
-    public DiagnosticWrapper() {
-
-    }
-
-    public DiagnosticWrapper(Diagnostic<? extends JavaFileObject> obj) {
-        this.code = obj.getCode();
-        this.source = new File(obj.getSource().toUri());
-        this.kind = obj.getKind();
-
-        this.position = obj.getPosition();
-        this.startPosition = obj.getStartPosition();
-        this.endPosition = obj.getEndPosition();
-
-        this.lineNumber = obj.getLineNumber();
-        this.columnNumber = obj.getColumnNumber();
-
-        this.message = obj.getMessage(Locale.getDefault());
-    }
-    
-    @Override
-    public Kind getKind() {
-        return kind;
-    }
-
-    @Override
-    public File getSource() {
-        return source;
-    }
-
-    @Override
-    public long getPosition() {
-        return position;
-    }
-
-    @Override
-    public long getStartPosition() {
-        return startPosition;
-    }
-
-    @Override
-    public long getEndPosition() {
-        return endPosition;
-    }
-
-    @Override
-    public long getLineNumber() {
-        return lineNumber;
-    }
-
-    @Override
-    public long getColumnNumber() {
-        return columnNumber;
-    }
-
-    @Override
-    public String getCode() {
-        return code;
-    }
-
-    @Override
-    public String getMessage(Locale locale) {
-        return message;
-    }
-
-    public void setCode(String code) {
-        this.code = code;
-    }
-
-    public void setSource(File source) {
-        this.source = source;
-    }
-
-    public void setKind(Kind kind) {
-        this.kind = kind;
-    }
-
-    public void setPosition(long position) {
-        this.position = position;
-    }
-
-    public void setStartPosition(long startPosition) {
-        this.startPosition = startPosition;
-    }
-
-    public void setEndPosition(long endPosition) {
-        this.endPosition = endPosition;
-    }
-
-    public void setMessage(String message) {
-        this.message = message;
-    }
-
-    public void setLineNumber(long lineNumber) {
-        this.lineNumber = lineNumber;
-    }
-
-    public void setColumnNumber(long columnNumber) {
-        this.columnNumber = columnNumber;
-    }
-}
Index: Build/src/main/java/com/tyron/build/parser/JavaParser.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/parser/JavaParser.java b/Build/src/main/java/com/tyron/build/parser/JavaParser.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/parser/JavaParser.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,131 +0,0 @@
-package com.tyron.build.parser;
-
-import com.tyron.build.log.LogViewModel;
-import com.tyron.common.util.StringSearch;
-
-import com.sun.source.tree.CompilationUnitTree;
-import com.sun.source.util.JavacTask;
-import com.sun.tools.javac.api.JavacTool;
-import com.sun.tools.javac.file.JavacFileManager;
-import com.sun.tools.javac.util.Context;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Locale;
-
-import javax.tools.Diagnostic;
-import javax.tools.DiagnosticCollector;
-import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-import javax.tools.StandardLocation;
-
-
-/**
- * @Deprecated use JavaCompilerService instead
- */
-public class JavaParser {
-
-    private static final String TAG = "JavaParser";
-    private static final String DOT = ".";
-    private static final String CONSTRUCTOR_NAME = "<init>";
-    
-    private final JavacTool mTool = JavacTool.create();
-    private final Context context;
-    
-    private final JavacFileManager fileManager;
-   
-    private final DiagnosticCollector<JavaFileObject> diagnostics;
-    private boolean canParse = true;
-    
-    private JavacTask task;
-    
-    private final LogViewModel log;
-   
-    public JavaParser(LogViewModel log) {
-        this.log = log;
-        context = new Context();
-        diagnostics = new DiagnosticCollector<>();
-        
-        fileManager = mTool.getStandardFileManager(diagnostics, Locale.ENGLISH, Charset.defaultCharset());
-        try {
-            File file = new File(FileManager.getInstance().getAndroidJar().getAbsolutePath());
-            fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, List.of(file, FileManager.getInstance().getLambdaStubs()));
-            
-            
-            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, List.of(FileManager.getInstance().getCurrentProject().getBuildDirectory()));
-            fileManager.setLocation(StandardLocation.CLASS_PATH, classpath());
-        } catch (IOException e) {
-           // log.d(LogViewModel.DEBUG, e.getMessage());
-            // impossible
-            canParse = false;
-        }
-                     
-    }
-
-    public CompilationUnitTree parse(File file, String src, int pos) {
-        if (!canParse) return null;
-        long time = System.currentTimeMillis();
-        
-       // log.d(LogViewModel.DEBUG, "Parsing source: " + file.getName());
-        final StringBuilder fix = new StringBuilder(src);
-        
-        // We add an extra ';' to the end of the line so parsing will produce the right tokens
-        if (pos != -1) {
-            int end = StringSearch.endOfLine(src, pos);
-            fix.insert(end, ';');
-        }
-        
-        SimpleJavaFileObject source = new SimpleJavaFileObject(file.toURI(), JavaFileObject.Kind.SOURCE) {
-            @Override
-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {
-                return fix;          
-            }
-        }; 
-        
-        
-        task = mTool.getTask(null, fileManager,
-                                          diagnostics, List.of("-g", "-parameters"), null, List.of(source));                                  
-       
-        CompilationUnitTree unit = null;
-        try {
-            unit = task.parse().iterator().next();
-            task.analyze();
-            //task.generate();
-        } catch (IOException e) {}
-        return unit;
-    }
-    
-    public List<Diagnostic<? extends JavaFileObject>> getDiagnostics() {
-        return diagnostics.getDiagnostics();
-    }
-    
-    public JavacTask getTask() {
-        return task;
-    }
-    
-    public Context getContext() {
-        return context;
-    }
-    
-    public List<String> packagePrivateTopLevelTypes(String packageName) {
-        return Collections.emptyList();
-    }
-    
-    public List<String> publicTopLevelTypes() {
-        List<String> all = new ArrayList<>();
-        all.addAll(FileManager.getInstance().all());
-        return all;
-    }
-    
-    private List<File> classpath() {
-        List<File> files = new ArrayList<>();
-        files.addAll(FileManager.getInstance().getLibraries());
-        files.add(FileManager.getInstance().getLambdaStubs());
-        files.add(FileManager.getInstance().getCurrentProject().getJavaDirectory());
-        return files;
-    }
-}
Index: Build/src/main/java/com/tyron/build/parser/FileManager.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/parser/FileManager.java b/Build/src/main/java/com/tyron/build/parser/FileManager.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/parser/FileManager.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,331 +0,0 @@
-package com.tyron.build.parser;
-
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-
-import com.tyron.build.BuildModule;
-import com.tyron.build.model.Project;
-import com.tyron.common.util.Decompress;
-import com.tyron.common.util.StringSearch;
-import org.apache.commons.io.FileUtils;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-
-/**
- * Class responsible for caching java files for fast
- * lookup later whenever we need to.
- */
-public class FileManager {
-
-    private static FileManager INSTANCE = null;
-    private final ExecutorService service = Executors.newFixedThreadPool(4);
-
-    public static FileManager getInstance() {
-        if (INSTANCE == null) {
-            INSTANCE = new FileManager();
-        }
-        return INSTANCE;
-    }
-
-    FileManager() {
-        try {
-            putJar(getAndroidJar());
-        } catch (IOException ignore) {}
-    }
-    
-    private Project mCurrentProject;
-    
-    // Map of compiled (.class) files with their fully qualified name as key
-    private final Map<String, File> classFiles = new HashMap<>();
-    private final Map<String, File> javaFiles = new HashMap<>();
-
-    public List<File> list(String packageName) {
-        List<File> list = new ArrayList<>();
-        for (String file : javaFiles.keySet()) {
-            if (file.substring(0, file.lastIndexOf(".")).equals(packageName)) {
-                list.add(javaFiles.get(file));
-            }
-        }
-        return list;
-    }
-
-    public void addJavaFile(File javaFile) {
-        String packageName = StringSearch.packageName(javaFile);
-
-        if (packageName != null) {
-            javaFiles.put(packageName, javaFile);
-        }
-    }
-
-    /**
-     * Removes a java file from the indices
-     * @param packageName fully qualified name of the class
-     */
-    public void removeJavaFile(@NonNull String packageName) {
-        javaFiles.remove(packageName);
-    }
-
-    /**
-     * Removes all the java files from the directory on the index and deletes the file
-     * @param directory The directory to delete
-     * @throws IOException if the directory cannot be deleted
-     * @return The files that are deleted
-     */
-    public List<File> deleteDirectory(File directory) throws IOException {
-        List<File> javaFiles = findFilesWithExtension(directory, ".java");
-        for (File file : javaFiles) {
-            String packageName = StringSearch.packageName(file);
-            if (packageName != null) {
-                this.javaFiles.remove(packageName);
-                FileUtils.delete(file);
-            }
-        }
-
-        FileUtils.deleteDirectory(directory);
-
-        return javaFiles;
-    }
-
-    public void openProject(Project project) {
-        if (!project.isValidProject()) {
-            //TODO: throw exception
-            return;
-        }
-        
-        mCurrentProject = project;
-        classFiles.clear();
-        javaFiles.clear();
-        
-        try {
-            putJar(getAndroidJar());
-        } catch (IOException ignore) {}
-        
-        javaFiles.putAll(project.getJavaFiles());
-        
-        for (File file : project.getLibraries()) {
-            try {
-                putJar(file);
-            } catch (IOException ignore) {}
-        }
-    }
-    
-    public Project getCurrentProject() {
-        return mCurrentProject;
-    }
-    
-    public Set<File> getLibraries() {
-        return mCurrentProject.getLibraries();
-    }
-    
-    public Set<String> classpath() {
-        Set<String> classpaths = new HashSet<>();
-        classpaths.addAll(javaFiles.keySet());
-        classpaths.addAll(Collections.emptySet());
-        return classpaths;
-    }
-
-    public Set<File> fileClasspath() {
-        Set<File> classpath = new HashSet<>();
-        classpath.addAll(javaFiles.values());
-        classpath.addAll(mCurrentProject.getLibraries());
-        classpath.addAll(mCurrentProject.getRJavaFiles().values());
-        return classpath;
-    }
-    
-    public List<String> all() {
-        List<String> files = new ArrayList<>();
-        files.addAll(javaFiles.keySet());
-        files.addAll(classFiles.keySet());
-        files.addAll(mCurrentProject.getRJavaFiles().keySet());
-        return files;
-    }
-
-    private void putJar(File file) throws IOException {
-        JarFile jar = new JarFile(file);
-        Enumeration<JarEntry> entries = jar.entries();
-        while (entries.hasMoreElements()) {
-            JarEntry entry = entries.nextElement();
-
-            if (!entry.getName().endsWith(".class")) {
-                continue;
-            }
-
-            // We only want top level classes, if it contains $ then 
-            // its an inner class, we ignore it
-            if (entry.getName().contains("$")) {
-                continue;
-            }
-
-            String packageName = entry.getName().replace("/", ".")
-                .substring(0, entry.getName().length() - ".class".length());                   
-
-
-            classFiles.put(packageName, file);
-        }
-    }
-    
-    public void save(final File file, final String contents) {
-        service.submit(() -> writeFile(file, contents));
-    }
-    
-    public static String readFile(File file) {
-        createNewFile(file);
-
-        StringBuilder sb = new StringBuilder();
-        BufferedReader fr = null;
-        try {
-            fr = bufferedReader(file);
-            
-            String str;
-            while ((str = fr.readLine()) != null) {
-                sb.append(str).append("\n");
-            }
-        } catch (IOException e) {
-            Log.e("FileManager", e.getMessage());
-        } finally {
-            if (fr != null) {
-                try {
-                    fr.close();
-                } catch (Exception e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-
-        return sb.toString();
-    }
-    
-    private static void createNewFile(File file) {
-        
-        if (file.exists()) {
-            return;
-        }
-        
-        String path = file.getAbsolutePath();
-        int lastSep = path.lastIndexOf(File.separator);
-        if (lastSep > 0) {
-            String dirPath = path.substring(0, lastSep);
-            makeDir(new File(dirPath));
-        }
-        try {
-            if (!file.exists())
-                file.createNewFile();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-	}
-    
-    
-    public static void makeDir(File file) {
-        if (!file.exists()) {
-            file.mkdirs();
-        }
-    }
-
-    public static void writeFile(File file, String str) {
-        createNewFile(file);
-        FileWriter fileWriter = null;
-
-        try {
-            fileWriter = new FileWriter(file, false);
-            fileWriter.write(str);
-            fileWriter.flush();
-        } catch (IOException e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                if (fileWriter != null)
-                    fileWriter.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-	    }
-    }
-
-    public static BufferedReader bufferedReader(File file) {
-        try {
-            return new BufferedReader(new InputStreamReader(new FileInputStream(file)));
-        } catch (FileNotFoundException e) {
-            Log.e("FileManager", Log.getStackTraceString(e));
-            return new BufferedReader(new StringReader(""));
-        }
-    }
-
-    public static List<File> findFilesWithExtension(File directory, String extension) {
-        List<File> files = new ArrayList<>();
-        File[] children = directory.listFiles();
-        if (children != null) {
-            for (File child : children) {
-                if (child.isDirectory()) {
-                    files.addAll(findFilesWithExtension(child, extension));
-                } else {
-                    if (child.getName().endsWith(extension)) {
-                        files.add(child);
-                    }
-                }
-            }
-        }
-
-        return files;
-    }
-
-    public static boolean deleteDir(File dir) {
-        if (dir.isDirectory()) {
-            String[] children = dir.list();
-            if (children != null) {
-                for (String child : children) {
-                    boolean success = deleteDir(new File(dir, child));
-                    if (!success) {
-                        return false;
-                    }
-                }
-            }
-        }
-
-        return dir.delete();
-    }
-
-    public static BufferedReader lines(File file) {
-        return bufferedReader(file);
-    }
-
-    public File getAndroidJar() {
-        File jarFile = new File(BuildModule.getContext()
-                                .getFilesDir(), "rt.jar");
-        if (!jarFile.exists()) {
-            Decompress.unzipFromAssets(BuildModule.getContext(),
-                    "rt.zip",
-                    jarFile.getParentFile().getAbsolutePath());
-        }
-        return jarFile;
-    }
-    
-    public File getLambdaStubs() {
-        File lambdaStubs = new File(BuildModule.getContext().getFilesDir(), "core-lambda-stubs.jar");
-        
-        if (!lambdaStubs.exists()) {
-            Decompress.unzipFromAssets(BuildModule.getContext(), "lambda-stubs.zip", lambdaStubs.getParentFile().getAbsolutePath());
-        }
-        return lambdaStubs;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/apk/SignTask.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/apk/SignTask.java b/Build/src/main/java/com/tyron/build/compiler/apk/SignTask.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/apk/SignTask.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,44 +0,0 @@
-package com.tyron.build.compiler.apk;
-
-import com.tyron.build.compiler.ApkSigner;
-import com.tyron.build.compiler.Task;
-import com.tyron.build.model.Project;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import java.io.File;
-import java.io.IOException;
-
-public class SignTask extends Task {
-
-    private File mInputApk;
-    private File mOutputApk;
-
-    @Override
-    public String getName() {
-        return "Sign";
-    }
-
-    @Override
-    public void prepare(Project project, ILogger logger) throws IOException {
-        mInputApk = new File(project.getBuildDirectory(), "bin/generated.apk");
-        mOutputApk = new File(project.getBuildDirectory(), "bin/signed.apk");
-        if (!mInputApk.exists()) {
-            throw new IOException("Unable to find generated apk file.");
-        }
-
-        logger.debug("Signing APK.");
-    }
-
-    @Override
-    public void run() throws IOException, CompilationFailedException {
-        ApkSigner signer = new ApkSigner(mInputApk.getAbsolutePath(),
-                mOutputApk.getAbsolutePath(), ApkSigner.Mode.TEST);
-
-        try {
-            signer.sign();
-        } catch (Exception e) {
-            throw new CompilationFailedException(e);
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/apk/PackageTask.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/apk/PackageTask.java b/Build/src/main/java/com/tyron/build/compiler/apk/PackageTask.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/apk/PackageTask.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,84 +0,0 @@
-package com.tyron.build.compiler.apk;
-
-import android.net.Uri;
-
-import com.android.sdklib.build.ApkBuilder;
-import com.android.sdklib.build.ApkCreationException;
-import com.android.sdklib.build.DuplicateFileException;
-import com.android.sdklib.build.SealedApkException;
-import com.tyron.build.compiler.Task;
-import com.tyron.build.model.Project;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-public class PackageTask extends Task {
-
-    /** List of extra dex files not including the main dex file */
-    private final List<File> mDexFiles = new ArrayList<>();
-    /** List of each jar files of libraries */
-    private final List<File> mLibraries = new ArrayList<>();
-    /** Main dex file */
-    private File mDexFile;
-    /** The generated.apk.res file */
-    private File mGeneratedRes;
-    /** The output apk file */
-    private File mApk;
-
-    @Override
-    public String getName() {
-        return "Package";
-    }
-
-    @Override
-    public void prepare(Project project, ILogger logger) throws IOException {
-        File mBinDir = new File(project.getBuildDirectory(), "bin");
-
-        mApk = new File(mBinDir, "generated.apk");
-        mDexFile = new File(mBinDir, "classes.dex");
-        mGeneratedRes = new File(mBinDir, "generated.apk.res");
-        File[] binFiles = mBinDir.listFiles();
-        if (binFiles != null) {
-            for (File child : binFiles) {
-                if (!child.isFile()) {
-                    continue;
-                }
-                if (!child.getName().equals("classes.dex") && child.getName().endsWith(".dex")) {
-                    mDexFiles.add(child);
-                }
-            }
-        }
-
-        mLibraries.addAll(project.getLibraries());
-
-        logger.debug("Packaging APK.");
-    }
-
-    @Override
-    public void run() throws IOException, CompilationFailedException {
-        try {
-            ApkBuilder builder = new ApkBuilder(
-                    mApk.getAbsolutePath(),
-                    mGeneratedRes.getAbsolutePath(),
-                    mDexFile.getAbsolutePath(),
-                    null,
-                    null);
-
-            for (File extraDex : mDexFiles) {
-                builder.addFile(extraDex, Uri.parse(extraDex.getAbsolutePath()).getLastPathSegment());
-            }
-
-            for (File library : mLibraries) {
-                builder.addResourcesFromJar(library);
-            }
-            builder.setDebugMode(true);
-            builder.sealApk();
-        } catch (ApkCreationException | SealedApkException | DuplicateFileException e) {
-            throw new CompilationFailedException(e);
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/dex/D8Task.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/dex/D8Task.java b/Build/src/main/java/com/tyron/build/compiler/dex/D8Task.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/dex/D8Task.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,195 +0,0 @@
-package com.tyron.build.compiler.dex;
-
-import android.util.Log;
-
-import com.android.tools.r8.CompilationMode;
-import com.android.tools.r8.D8;
-import com.android.tools.r8.D8Command;
-import com.android.tools.r8.Diagnostic;
-import com.android.tools.r8.DiagnosticsHandler;
-import com.android.tools.r8.DiagnosticsLevel;
-import com.android.tools.r8.OutputMode;
-import com.tyron.build.compiler.Task;
-import com.tyron.code.model.DiagnosticWrapper;
-import com.tyron.build.model.Project;
-import com.tyron.build.parser.FileManager;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-/**
- * Converts class files into dex files and merges them in the process
- */
-@SuppressWarnings("NewApi")
-public class D8Task extends Task {
-
-	private static final String TAG = D8Task.class.getSimpleName();
-
-	private final DiagnosticsHandler diagnosticsHandler = new DiagnosticHandler();
-
-	private ILogger logViewModel;
-	private Project mProject;
-
-	@Override
-	public String getName() {
-		return TAG;
-	}
-
-	@Override
-	public void prepare(Project project, ILogger logger) throws IOException {
-		mProject = project;
-		logViewModel = logger;
-	}
-
-	@Override
-	public void run() throws IOException, CompilationFailedException {
-		compile();
-	}
-
-	public void compile() throws CompilationFailedException {
-		try {
-			logViewModel.debug("Dexing libraries.");
-			long startTime = System.currentTimeMillis();
-			ensureDexedLibraries();
-			Log.d("D8Compiler", "Dexing libraries took " + (System.currentTimeMillis() - startTime) + " ms");
-
-			logViewModel.debug("Merging dexes and source files");
-
-			startTime = System.currentTimeMillis();
-			List<Path> libraryDexes = getLibraryDexes();
-
-			D8Command command = D8Command.builder(diagnosticsHandler)
-					.addClasspathFiles(mProject.getLibraries().stream().map(File::toPath).collect(Collectors.toList()))
-					.setMinApiLevel(21)
-					.addLibraryFiles(getLibraryFiles())
-					.addProgramFiles(getClassFiles(new File(mProject.getBuildDirectory(), "bin/classes")))
-					.addProgramFiles(libraryDexes)
-					.setOutput(new File(mProject.getBuildDirectory(), "bin").toPath(), OutputMode.DexIndexed)
-					.build();
-			D8.run(command);
-
-			Log.d("D8Compiler", "Merging dex files took " + (System.currentTimeMillis() - startTime) + " ms");
-
-		} catch (com.android.tools.r8.CompilationFailedException e) {
-			throw new com.tyron.code.util.exception.CompilationFailedException(e);
-		}
-	}
-
-	/**
-	 * Ensures that all libraries of the project has been dex-ed
-	 * @throws com.android.tools.r8.CompilationFailedException if the compilation has failed
-	 */
-	private void ensureDexedLibraries() throws com.android.tools.r8.CompilationFailedException {
-		Set<File> libraries = mProject.getLibraries();
-
-		Log.d(TAG, "Dexing libraries");
-
-		for (File lib : libraries) {
-			File parentFile = lib.getParentFile();
-			if (parentFile == null) {
-				continue;
-			}
-			File[] libFiles = lib.getParentFile().listFiles();
-			if (libFiles == null) {
-				if (!lib.delete()) {
-					logViewModel.warning("Failed to delete " + lib.getAbsolutePath());
-				}
-			} else {
-				File dex = new File(lib.getParentFile(), "classes.dex");
-				if (dex.exists()) {
-					continue;
-				}
-				if (lib.exists()) {
-					logViewModel.debug("Dexing jar " + parentFile.getName());
-					D8Command command = D8Command.builder(diagnosticsHandler)
-							.addLibraryFiles(getLibraryFiles())
-							.addClasspathFiles(libraries.stream().map(File::toPath).collect(Collectors.toList()))
-							.setMinApiLevel(21)
-							.addProgramFiles(lib.toPath())
-							.setMode(CompilationMode.RELEASE)
-							.setOutput(lib.getParentFile().toPath(), OutputMode.DexIndexed)
-							.build();
-					D8.run(command);
-				}
-			}
-		}
-	}
-
-	private List<Path> getLibraryFiles() {
-		List<Path> path = new ArrayList<>();
-		path.add(FileManager.getInstance().getAndroidJar().toPath());
-		path.add(FileManager.getInstance().getLambdaStubs().toPath());
-		return path;
-	}
-
-	/**
-	 * Retrieves a list of all libraries dexes including the extra dex files if it has one
-	 * @return list of all dex files
-	 */
-	private	 List<Path> getLibraryDexes() {
-		List<Path> dexes = new ArrayList<>();
-		for (File file : mProject.getLibraries()) {
-			File parent = file.getParentFile();
-			if (parent != null) {
-				File[] dexFiles = parent.listFiles(file1 -> file1.getName().endsWith(".dex"));
-				if (dexFiles != null) {
-					dexes.addAll(Arrays.stream(dexFiles).map(File::toPath).collect(Collectors.toList()));
-				}
-			}
-		}
-		return dexes;
-	}
-
-	private List<Path> getClassFiles(File root) {
-		List<Path> paths = new ArrayList<>();
-
-		File[] files = root.listFiles();
-		if (files != null) {
-			for (File file : files) {
-				if (file.isDirectory()) {
-					paths.addAll(getClassFiles(file));
-				} else {
-					paths.add(file.toPath());
-				}
-			}
-		}
-		return paths;
-	}
-
-	private class DiagnosticHandler implements DiagnosticsHandler {
-		@Override
-		public void error(Diagnostic diagnostic) {
-			logViewModel.error(wrap(diagnostic));
-		}
-
-		@Override
-		public void warning(Diagnostic diagnostic) {
-			logViewModel.warning(wrap(diagnostic));
-		}
-
-		@Override
-		public void info(Diagnostic diagnostic) {
-			logViewModel.info(wrap(diagnostic));
-		}
-
-		@Override
-		public DiagnosticsLevel modifyDiagnosticsLevel(DiagnosticsLevel diagnosticsLevel, Diagnostic diagnostic) {
-			Log.d("DiagnosticHandler", diagnostic.getDiagnosticMessage());
-			return null;
-		}
-
-		private DiagnosticWrapper wrap(Diagnostic diagnostic) {
-			DiagnosticWrapper wrapper = new DiagnosticWrapper();
-			wrapper.setMessage(diagnostic.getDiagnosticMessage());
-			return wrapper;
-		}
-	}
-}
Index: Build/src/main/java/com/tyron/build/compiler/java/JavaTask.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/java/JavaTask.java b/Build/src/main/java/com/tyron/build/compiler/java/JavaTask.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/java/JavaTask.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,148 +0,0 @@
-package com.tyron.build.compiler.java;
-
-
-import android.annotation.SuppressLint;
-import android.util.Log;
-
-import com.sun.source.util.JavacTask;
-import com.sun.tools.javac.api.JavacTool;
-
-import com.tyron.build.compiler.Task;
-import com.tyron.build.model.DiagnosticWrapper;
-import com.tyron.build.model.Project;
-import com.tyron.build.model.SourceFileObject;
-import com.tyron.build.parser.FileManager;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Locale;
-
-import javax.tools.Diagnostic;
-import javax.tools.DiagnosticListener;
-import javax.tools.JavaFileObject;
-import javax.tools.StandardJavaFileManager;
-import javax.tools.StandardLocation;
-
-public class JavaTask extends Task {
-
-    private ILogger logViewModel;
-    private Project mProject;
-
-    @Override
-    public String getName() {
-        return "Java Compiler";
-    }
-
-    @Override
-    public void prepare(Project project, ILogger logger) throws IOException {
-        mProject = project;
-        logViewModel = logger;
-    }
-
-    @Override
-    public void run() throws IOException, CompilationFailedException {
-        compile();
-    }
-
-    private final List<Diagnostic<? extends JavaFileObject>> diagnostics = new ArrayList<>();
-
-    @SuppressLint("NewApi")
-    public void compile() throws CompilationFailedException {
-
-        long startTime = System.currentTimeMillis();
-        logViewModel.debug("Compiling java files.");
-
-        File outputDir = new File(mProject.getBuildDirectory(), "bin/classes");
-        if (outputDir.exists()) {
-            FileManager.deleteDir(outputDir);
-        }
-        if(!outputDir.mkdirs()) {
-            throw new CompilationFailedException("Cannot create output directory");
-        }
-
-        mProject.clear();
-        List<File> javaFiles = new ArrayList<>(mProject.getJavaFiles().values());
-        javaFiles.addAll(getJavaFiles(new File(mProject.getBuildDirectory(), "gen")));
-
-        DiagnosticListener<JavaFileObject> diagnosticCollector = diagnostic -> {
-            switch (diagnostic.getKind()) {
-                case ERROR:
-                    logViewModel.error(new DiagnosticWrapper(diagnostic));
-                    break;
-                case WARNING:
-                    logViewModel.warning(new DiagnosticWrapper(diagnostic));
-            }
-        };
-
-        JavacTool tool = JavacTool.create();
-
-        StandardJavaFileManager standardJavaFileManager = tool.getStandardFileManager(
-                diagnosticCollector,
-                Locale.getDefault(),
-                Charset.defaultCharset()
-        );
-        try {
-            standardJavaFileManager.setLocation(StandardLocation.CLASS_OUTPUT, Collections.singletonList(outputDir));
-            standardJavaFileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, Arrays.asList(
-                    FileManager.getInstance().getAndroidJar(),
-                    FileManager.getInstance().getLambdaStubs()
-            ));
-            standardJavaFileManager.setLocation(StandardLocation.CLASS_PATH, FileManager.getInstance().getLibraries());
-            standardJavaFileManager.setLocation(StandardLocation.SOURCE_PATH, javaFiles);
-        } catch (IOException e) {
-            throw new CompilationFailedException(e);
-        }
-
-        List<JavaFileObject> javaFileObjects = new ArrayList<>();
-        for (File file : javaFiles) {
-            javaFileObjects.add(new SourceFileObject(file.toPath()));
-        }
-
-        JavacTask task = tool.getTask(
-                null,
-                standardJavaFileManager,
-                diagnosticCollector,
-                null,
-                null,
-                javaFileObjects
-        );
-
-        if (!task.call()) {
-            throw new CompilationFailedException("Compilation failed. Check diagnostics for more information.");
-        }
-
-        Log.d("JavaCompiler", "Compilation took: " + (System.currentTimeMillis() - startTime) + " ms");
-    }
-
-    private List<File> getJavaFiles(File dir) {
-        List<File> javaFiles = new ArrayList<>();
-
-        File[] files = dir.listFiles();
-        if (files == null) {
-            return Collections.emptyList();
-        }
-
-        for (File file : files) {
-            if (file.isDirectory()) {
-                javaFiles.addAll(getJavaFiles(file));
-            } else {
-                if (file.getName().endsWith(".java")) {
-                    javaFiles.add(file);
-                }
-            }
-        }
-
-        return javaFiles;
-    }
-
-    public List<Diagnostic<? extends JavaFileObject>> getDiagnostics() {
-        return diagnostics;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/symbol/SymbolLoader.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/symbol/SymbolLoader.java b/Build/src/main/java/com/tyron/build/compiler/symbol/SymbolLoader.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/symbol/SymbolLoader.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,86 +0,0 @@
-package com.tyron.build.compiler.symbol;
-
-import com.google.common.base.Charsets;
-import com.google.common.collect.HashBasedTable;
-import com.google.common.collect.Table;
-import com.google.common.io.Files;
-import com.tyron.build.log.ILogger;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import java.util.Locale;
-
-public class SymbolLoader {
-
-    private final File mSymbolFile;
-    private Table<String, String, SymbolEntry> mSymbols;
-    private final ILogger mLogger;
-
-    public static class SymbolEntry {
-        private final String mName;
-        private final String mType;
-        private final String mValue;
-
-        public SymbolEntry(String name, String type, String value) {
-            mName = name;
-            mType = type;
-            mValue = value;
-        }
-
-        public String getValue() {
-            return mValue;
-        }
-
-        public String getName() {
-            return mName;
-        }
-
-        public String getType() {
-            return mType;
-        }
-    }
-
-    public SymbolLoader(File symbolFile, ILogger logger) {
-        mSymbolFile = symbolFile;
-        mLogger = logger;
-    }
-
-    public void load() throws IOException {
-        List<String> lines = Files.readLines(mSymbolFile, Charsets.UTF_8);
-
-        mSymbols = HashBasedTable.create();
-
-        int lineIndex = 1;
-        String line = null;
-
-        try {
-            final int count = lines.size();
-
-            for (; lineIndex <= count ; lineIndex++) {
-                line = lines.get(lineIndex-1);
-
-                // format is "<type> <class> <name> <value>"
-                // don't want to split on space as value could contain spaces.
-                int pos = line.indexOf(' ');
-                String type = line.substring(0, pos);
-                int pos2 = line.indexOf(' ', pos + 1);
-                String className = line.substring(pos + 1, pos2);
-                int pos3 = line.indexOf(' ', pos2 + 1);
-                String name = line.substring(pos2 + 1, pos3);
-                String value = line.substring(pos3 + 1);
-
-                mSymbols.put(className, name, new SymbolEntry(name, type, value));
-            }
-        } catch (IndexOutOfBoundsException e) {
-            String s = String.format(Locale.ENGLISH, "File format error reading %s\tline %d: '%s'",
-                    mSymbolFile.getAbsolutePath(), lineIndex, line);
-            mLogger.error(s);
-            throw new IOException(s, e);
-        }
-    }
-
-    Table<String, String, SymbolEntry> getSymbols() {
-        return mSymbols;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/symbol/SymbolWriter.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/symbol/SymbolWriter.java b/Build/src/main/java/com/tyron/build/compiler/symbol/SymbolWriter.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/symbol/SymbolWriter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,123 +0,0 @@
-package com.tyron.build.compiler.symbol;
-
-
-import com.google.common.base.Charsets;
-import com.google.common.base.Splitter;
-import com.google.common.collect.HashBasedTable;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Table;
-import com.google.common.io.Files;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * A class to write R.java classes based on data read from text symbol files generated by
- * AAPT/AAPT2 with the --output-text-symbols option.
- */
-public class SymbolWriter {
-
-    private final String mOutFolder;
-    private final String mPackageName;
-    private final List<SymbolLoader> mSymbols = Lists.newArrayList();
-    private final SymbolLoader mValues;
-
-    public SymbolWriter(String outFolder, String packageName, SymbolLoader values) {
-        mOutFolder = outFolder;
-        mPackageName = packageName;
-        mValues = values;
-    }
-
-    public void addSymbolsToWrite(SymbolLoader symbols) {
-        mSymbols.add(symbols);
-    }
-
-    private Table<String, String, SymbolLoader.SymbolEntry> getAllSymbols() {
-        Table<String, String, SymbolLoader.SymbolEntry> symbols = HashBasedTable.create();
-
-        for (SymbolLoader symbolLoader : mSymbols) {
-            symbols.putAll(symbolLoader.getSymbols());
-        }
-
-        return symbols;
-    }
-
-    public void write() throws IOException {
-        Splitter splitter = Splitter.on('.');
-        Iterable<String> folders = splitter.split(mPackageName);
-        File file = new File(mOutFolder);
-        for (String folder : folders) {
-            file = new File(file, folder);
-        }
-        if (!file.exists() && !file.mkdirs()) {
-            throw new IOException("Unable to create resource directories for " + file);
-        }
-        file = new File(file, "R.java");
-
-        BufferedWriter writer = null;
-        try {
-            writer = Files.newWriter(file, Charsets.UTF_8);
-
-            writer.write("/* AUTO-GENERATED FILE. DO NOT MODIFY. \n");
-            writer.write(" *\n");
-            writer.write(" * This class was automatically generated by the\n");
-            writer.write(" * aapt tool from the resource data it found.  It\n");
-            writer.write(" * should not be modified by hand.\n");
-            writer.write(" */\n");
-
-            writer.write("package ");
-            writer.write(mPackageName);
-            writer.write(";\n\npublic final class R {\n");
-
-            Table<String, String, SymbolLoader.SymbolEntry> symbols = getAllSymbols();
-            Table<String, String, SymbolLoader.SymbolEntry> values = mValues.getSymbols();
-
-            Set<String> rowSet = symbols.rowKeySet();
-            List<String> rowList = Lists.newArrayList(rowSet);
-            Collections.sort(rowList);
-
-            for (String row : rowList) {
-                writer.write("\tpublic static final class ");
-                writer.write(row);
-                writer.write(" {\n");
-
-                Map<String, SymbolLoader.SymbolEntry> rowMap = symbols.row(row);
-                Set<String> symbolSet = rowMap.keySet();
-                ArrayList<String> symbolList = Lists.newArrayList(symbolSet);
-                Collections.sort(symbolList);
-
-                for (String symbolName : symbolList) {
-                    // get the matching SymbolEntry from the values Table.
-                    SymbolLoader.SymbolEntry value = values.get(row, symbolName);
-                    if (value != null) {
-                        writer.write("\t\tpublic static final ");
-                        writer.write(value.getType());
-                        writer.write(" ");
-                        writer.write(value.getName());
-                        writer.write(" = ");
-                        writer.write(value.getValue());
-                        writer.write(";\n");
-                    }
-                }
-
-                writer.write("\t}\n");
-            }
-
-            writer.write("}\n");
-        } finally {
-            try {
-                if (writer != null) {
-                    writer.close();
-                }
-            } catch (IOException ignore) {
-
-            }
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/symbol/MergeSymbolsTask.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/symbol/MergeSymbolsTask.java b/Build/src/main/java/com/tyron/build/compiler/symbol/MergeSymbolsTask.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/symbol/MergeSymbolsTask.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,93 +0,0 @@
-package com.tyron.build.compiler.symbol;
-
-import android.util.Log;
-
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.Multimap;
-import com.tyron.build.compiler.Task;
-import com.tyron.build.compiler.resource.AAPT2Compiler;
-import com.tyron.build.model.Project;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Collection;
-
-/**
- * Class that loads R.txt files generated by AAPT/AAPT2  and converts them
- * to R.java class files
- */
-public class MergeSymbolsTask extends Task {
-
-    private File mSymbolOutputDir;
-    private File mFullResourceFile;
-    private Project mProject;
-    private ILogger mLogger;
-
-    @Override
-    public String getName() {
-        return "SymbolProcessor";
-    }
-
-    @Override
-    public void prepare(Project project, ILogger logger) throws IOException {
-        mProject = project;
-        mLogger = logger;
-        mSymbolOutputDir = new File(project.getBuildDirectory(), "gen");
-        mFullResourceFile = new File(project.getBuildDirectory(), "bin/res/R.txt");
-    }
-
-    @Override
-    public void run() throws IOException, CompilationFailedException {
-
-        long start = System.currentTimeMillis();
-        
-        SymbolLoader fullSymbolValues = null;
-        Multimap<String, SymbolLoader> libMap = ArrayListMultimap.create();
-
-        for (File library : mProject.getLibraries()) {
-            File parent = library.getParentFile();
-            Preconditions.checkNotNull(parent, "Unable to access parent directory for " + library);
-
-            String packageName = AAPT2Compiler.getPackageName(new File(parent, "AndroidManifest.xml"));
-            if (packageName == null) {
-                continue;
-            }
-
-            if (packageName.equals(mProject.getPackageName())) {
-                // only generate libraries
-                continue;
-            }
-
-            File rFile = new File(parent, "R.txt");
-            if (!rFile.exists()) {
-                continue;
-            }
-
-            if (fullSymbolValues == null) {
-                fullSymbolValues = new SymbolLoader(mFullResourceFile, mLogger);
-                fullSymbolValues.load();
-            }
-            SymbolLoader libSymbols = new SymbolLoader(rFile, mLogger);
-            libSymbols.load();
-
-            libMap.put(packageName, libSymbols);
-        }
-
-        // now loop on all the package name, merge all the symbols to write, and write them
-        for (String packageName : libMap.keySet()) {
-            Collection<SymbolLoader> symbols = libMap.get(packageName);
-
-            SymbolWriter writer = new SymbolWriter(mSymbolOutputDir.getAbsolutePath(), packageName,
-                    fullSymbolValues);
-            for (SymbolLoader loader : symbols) {
-                writer.addSymbolsToWrite(loader);
-            }
-            writer.write();
-        }
-
-        Log.d("SymbolProcessor", "Generating symbols took " + (System.currentTimeMillis() - start) + " ms");
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/ManifestData.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/ManifestData.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/ManifestData.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/ManifestData.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,803 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.collect.ImmutableList;
-import com.tyron.build.compiler.manifest.resources.Keyboard;
-import com.tyron.build.compiler.manifest.resources.Navigation;
-import com.tyron.build.compiler.manifest.resources.TouchScreen;
-
-import java.util.ArrayList;
-import java.util.Set;
-import java.util.TreeSet;
-
-/**
- * Class containing the manifest info obtained during the parsing.
- */
-public final class ManifestData {
-
-    /**
-     * Value returned by {@link #getMinSdkVersion()} when the value of the minSdkVersion attribute
-     * in the manifest is a codename and not an integer value.
-     */
-    public static final int MIN_SDK_CODENAME = 0;
-
-    /**
-     * Value returned by {@link #getGlEsVersion()} when there are no {@code <uses-feature>} node
-     * with the attribute glEsVersion set.
-     */
-    public static final int GL_ES_VERSION_NOT_SET = -1;
-
-    /** Application package */
-    String mPackage;
-    /** Application version code, null if the attribute is not present. */
-    Integer mVersionCode = null;
-    /** Application version name, null if the attribute is not present. */
-    String mVersionName = null;
-    /** Default Dex process */
-    String mDefaultProcess;
-    /** List of all activities */
-    final ArrayList<Activity> mActivities = new ArrayList<Activity>();
-    /** List of all activities, services, receivers and providers to keep for Proguard and Dex * */
-    final ArrayList<KeepClass> mKeepClasses = new ArrayList<KeepClass>();
-    /** Launcher activity */
-    Activity mLauncherActivity = null;
-    /** list of process names declared by the manifest */
-    Set<String> mProcesses = null;
-    /** debuggable attribute value. If null, the attribute is not present. */
-    Boolean mDebuggable = null;
-    /** API level requirement. if null the attribute was not present. */
-    private String mMinSdkVersionString = null;
-    /** API level requirement. Default is 1 even if missing. If value is a codename, then it'll be
-     * 0 instead. */
-    private int mMinSdkVersion = 1;
-    private int mTargetSdkVersion = 0;
-    /** List of all instrumentations declared by the manifest */
-    final ArrayList<Instrumentation> mInstrumentations =
-            new ArrayList<Instrumentation>();
-    /** List of all libraries in use declared by the manifest */
-    final ArrayList<UsesLibrary> mLibraries = new ArrayList<UsesLibrary>();
-    /** List of all feature in use declared by the manifest */
-    final ArrayList<UsesFeature> mFeatures = new ArrayList<UsesFeature>();
-    /** List of all the custom permissions declared in the manifest */
-    final ArrayList<String> mCustomPermissions = new ArrayList<>();
-
-    SupportsScreens mSupportsScreensFromManifest;
-    SupportsScreens mSupportsScreensValues;
-    UsesConfiguration mUsesConfiguration;
-
-    /**
-     * Instrumentation info obtained from manifest
-     */
-    public static final class Instrumentation {
-        private final String mName;
-        private final String mTargetPackage;
-
-        Instrumentation(String name, String targetPackage) {
-            mName = name;
-            mTargetPackage = targetPackage;
-        }
-
-        /**
-         * Returns the fully qualified instrumentation class name
-         */
-        public String getName() {
-            return mName;
-        }
-
-        /**
-         * Returns the Android app package that is the target of this instrumentation
-         */
-        public String getTargetPackage() {
-            return mTargetPackage;
-        }
-    }
-
-    /**
-     * Activity info obtained from the manifest.
-     */
-    public static final class Activity {
-        private final String mName;
-        private final boolean mIsExported;
-        private boolean mHasAction = false;
-        private boolean mHasMainAction = false;
-        private boolean mHasLauncherCategory = false;
-
-        public Activity(String name, boolean exported) {
-            mName = name;
-            mIsExported = exported;
-        }
-
-        public String getName() {
-            return mName;
-        }
-
-        public boolean isExported() {
-            return mIsExported;
-        }
-
-        public boolean hasAction() {
-            return mHasAction;
-        }
-
-        public boolean isHomeActivity() {
-            return mHasMainAction && mHasLauncherCategory;
-        }
-
-        void setHasAction(boolean hasAction) {
-            mHasAction = hasAction;
-        }
-
-        /** If the activity doesn't yet have a filter set for the launcher, this resets both
-         * flags. This is to handle multiple intent-filters where one could have the valid
-         * action, and another one of the valid category.
-         */
-        void resetIntentFilter() {
-            if (isHomeActivity() == false) {
-                mHasMainAction = mHasLauncherCategory = false;
-            }
-        }
-
-        void setHasMainAction(boolean hasMainAction) {
-            mHasMainAction = hasMainAction;
-        }
-
-        void setHasLauncherCategory(boolean hasLauncherCategory) {
-            mHasLauncherCategory = hasLauncherCategory;
-        }
-    }
-
-    public static final class KeepClass {
-        @NonNull
-        private final String name;
-        @Nullable
-        private final String process;
-        @NonNull private final String type;
-
-        public KeepClass(@NonNull String name, @Nullable String process, @NonNull String type) {
-            this.name = name;
-            this.process = process;
-            this.type = type;
-        }
-
-        @NonNull
-        public String getName() {
-            return name;
-        }
-
-        @Nullable
-        public String getProcess() {
-            return process;
-        }
-
-        @NonNull
-        public String getType() {
-            return type;
-        }
-    }
-
-    /**
-     * Class representing the <code>supports-screens</code> node in the manifest.
-     * By default, all the getters will return null if there was no value defined in the manifest.
-     *
-     * To get an instance with all the actual values, use {@link #resolveSupportsScreensValues(int)}
-     */
-    public static final class SupportsScreens {
-        private Boolean mResizeable;
-        private Boolean mAnyDensity;
-        private Boolean mSmallScreens;
-        private Boolean mNormalScreens;
-        private Boolean mLargeScreens;
-
-        public SupportsScreens() {
-        }
-
-        /**
-         * Instantiate an instance from a string. The string must have been created with
-         * {@link #getEncodedValues()}.
-         * @param value the string.
-         */
-        public SupportsScreens(String value) {
-            String[] values = value.split("\\|");
-
-            mAnyDensity = Boolean.valueOf(values[0]);
-            mResizeable = Boolean.valueOf(values[1]);
-            mSmallScreens = Boolean.valueOf(values[2]);
-            mNormalScreens = Boolean.valueOf(values[3]);
-            mLargeScreens = Boolean.valueOf(values[4]);
-        }
-
-        /**
-         * Returns an instance of {@link SupportsScreens} initialized with the default values
-         * based on the given targetSdkVersion.
-         * @param targetSdkVersion
-         */
-        public static SupportsScreens getDefaultValues(int targetSdkVersion) {
-            SupportsScreens result = new SupportsScreens();
-
-            result.mNormalScreens = Boolean.TRUE;
-            // Screen size and density became available in Android 1.5/API3, so before that
-            // non normal screens were not supported by default. After they are considered
-            // supported.
-            result.mResizeable = result.mAnyDensity = result.mSmallScreens = result.mLargeScreens =
-                    targetSdkVersion <= 3 ? Boolean.FALSE : Boolean.TRUE;
-
-            return result;
-        }
-
-        /**
-         * Returns a version of the receiver for which all values have been set, even if they
-         * were not present in the manifest.
-         * @param targetSdkVersion the target api level of the app, since this has an effect
-         * on default values.
-         */
-        public SupportsScreens resolveSupportsScreensValues(int targetSdkVersion) {
-            SupportsScreens result = getDefaultValues(targetSdkVersion);
-
-            // Override the default with the existing values:
-            if (mResizeable != null) result.mResizeable = mResizeable;
-            if (mAnyDensity != null) result.mAnyDensity = mAnyDensity;
-            if (mSmallScreens != null) result.mSmallScreens = mSmallScreens;
-            if (mNormalScreens != null) result.mNormalScreens = mNormalScreens;
-            if (mLargeScreens != null) result.mLargeScreens = mLargeScreens;
-
-            return result;
-        }
-
-        /**
-         * returns the value of the <code>resizeable</code> attribute or null if not present.
-         */
-        public Boolean getResizeable() {
-            return mResizeable;
-        }
-
-        void setResizeable(Boolean resizeable) {
-            mResizeable = getConstantBoolean(resizeable);
-        }
-
-        /**
-         * returns the value of the <code>anyDensity</code> attribute or null if not present.
-         */
-        public Boolean getAnyDensity() {
-            return mAnyDensity;
-        }
-
-        void setAnyDensity(Boolean anyDensity) {
-            mAnyDensity = getConstantBoolean(anyDensity);
-        }
-
-        /**
-         * returns the value of the <code>smallScreens</code> attribute or null if not present.
-         */
-        public Boolean getSmallScreens() {
-            return mSmallScreens;
-        }
-
-        void setSmallScreens(Boolean smallScreens) {
-            mSmallScreens = getConstantBoolean(smallScreens);
-        }
-
-        /**
-         * returns the value of the <code>normalScreens</code> attribute or null if not present.
-         */
-        public Boolean getNormalScreens() {
-            return mNormalScreens;
-        }
-
-        void setNormalScreens(Boolean normalScreens) {
-            mNormalScreens = getConstantBoolean(normalScreens);
-        }
-
-        /**
-         * returns the value of the <code>largeScreens</code> attribute or null if not present.
-         */
-        public Boolean getLargeScreens() {
-            return mLargeScreens;
-        }
-
-        void setLargeScreens(Boolean largeScreens) {
-            mLargeScreens = getConstantBoolean(largeScreens);
-        }
-
-        /**
-         * Returns either {@link Boolean#TRUE} or {@link Boolean#FALSE} based on the value of
-         * the given Boolean object.
-         */
-        private Boolean getConstantBoolean(Boolean v) {
-            if (v != null) {
-                if (v.equals(Boolean.TRUE)) {
-                    return Boolean.TRUE;
-                } else {
-                    return Boolean.FALSE;
-                }
-            }
-
-            return null;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj instanceof SupportsScreens) {
-                SupportsScreens support = (SupportsScreens) obj;
-                // since all the fields are guaranteed to be either Boolean.TRUE or Boolean.FALSE
-                // (or null), we can simply check they are identical and not bother with
-                // calling equals (which would require to check != null.
-                // see #getConstanntBoolean(Boolean)
-                return mResizeable    == support.mResizeable &&
-                        mAnyDensity    == support.mAnyDensity &&
-                        mSmallScreens  == support.mSmallScreens &&
-                        mNormalScreens == support.mNormalScreens &&
-                        mLargeScreens  == support.mLargeScreens;
-            }
-
-            return false;
-        }
-
-        /* Override hashCode, mostly to make Eclipse happy and not warn about it.
-         * And if you ever put this in a Map or Set, it will avoid surprises. */
-        @Override
-        public int hashCode() {
-            final int prime = 31;
-            int result = 1;
-            result = prime * result + ((mAnyDensity    == null) ? 0 : mAnyDensity.hashCode());
-            result = prime * result + ((mLargeScreens  == null) ? 0 : mLargeScreens.hashCode());
-            result = prime * result + ((mNormalScreens == null) ? 0 : mNormalScreens.hashCode());
-            result = prime * result + ((mResizeable    == null) ? 0 : mResizeable.hashCode());
-            result = prime * result + ((mSmallScreens  == null) ? 0 : mSmallScreens.hashCode());
-            return result;
-        }
-
-        /**
-         * Returns true if the two instances support the same screen sizes.
-         * This is similar to {@link #equals(Object)} except that it ignores the values of
-         * {@link #getAnyDensity()} and {@link #getResizeable()}.
-         * @param support the other instance to compare to.
-         * @return true if the two instances support the same screen sizes.
-         */
-        public boolean hasSameScreenSupportAs(SupportsScreens support) {
-            // since all the fields are guaranteed to be either Boolean.TRUE or Boolean.FALSE
-            // (or null), we can simply check they are identical and not bother with
-            // calling equals (which would require to check != null.
-            // see #getConstanntBoolean(Boolean)
-
-            // This only checks that matter here are the screen sizes. resizeable and anyDensity
-            // are not checked.
-            return  mSmallScreens == support.mSmallScreens &&
-                    mNormalScreens == support.mNormalScreens &&
-                    mLargeScreens == support.mLargeScreens;
-        }
-
-        /**
-         * Returns true if the two instances have strictly different screen size support.
-         * This means that there is no screen size that they both support.
-         * @param support the other instance to compare to.
-         * @return true if they are strictly different.
-         */
-        public boolean hasStrictlyDifferentScreenSupportAs(SupportsScreens support) {
-            // since all the fields are guaranteed to be either Boolean.TRUE or Boolean.FALSE
-            // (or null), we can simply check they are identical and not bother with
-            // calling equals (which would require to check != null.
-            // see #getConstanntBoolean(Boolean)
-
-            // This only checks that matter here are the screen sizes. resizeable and anyDensity
-            // are not checked.
-            return (mSmallScreens != Boolean.TRUE || support.mSmallScreens != Boolean.TRUE) &&
-                    (mNormalScreens != Boolean.TRUE || support.mNormalScreens != Boolean.TRUE) &&
-                    (mLargeScreens != Boolean.TRUE || support.mLargeScreens != Boolean.TRUE);
-        }
-
-        /**
-         * Comparison of 2 Supports-screens. This only uses screen sizes (ignores resizeable and
-         * anyDensity), and considers that
-         * {@link #hasStrictlyDifferentScreenSupportAs(SupportsScreens)} returns true and
-         * {@link #overlapWith(SupportsScreens)} returns false.
-         * @throws IllegalArgumentException if the two instanced are not strictly different or
-         * overlap each other
-         * @see #hasStrictlyDifferentScreenSupportAs(SupportsScreens)
-         * @see #overlapWith(SupportsScreens)
-         */
-        public int compareScreenSizesWith(SupportsScreens o) {
-            if (hasStrictlyDifferentScreenSupportAs(o) == false) {
-                throw new IllegalArgumentException("The two instances are not strictly different.");
-            }
-            if (overlapWith(o)) {
-                throw new IllegalArgumentException("The two instances overlap each other.");
-            }
-
-            int comp = mLargeScreens.compareTo(o.mLargeScreens);
-            if (comp != 0) return comp;
-
-            comp = mNormalScreens.compareTo(o.mNormalScreens);
-            if (comp != 0) return comp;
-
-            comp = mSmallScreens.compareTo(o.mSmallScreens);
-            if (comp != 0) return comp;
-
-            return 0;
-        }
-
-        /**
-         * Returns a string encoding of the content of the instance. This string can be used to
-         * instantiate a {@link SupportsScreens} object through
-         * {@link #SupportsScreens(String)}.
-         */
-        public String getEncodedValues() {
-            return String.format("%1$s|%2$s|%3$s|%4$s|%5$s",
-                    mAnyDensity, mResizeable, mSmallScreens, mNormalScreens, mLargeScreens);
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-
-            boolean alreadyOutputSomething = false;
-
-            if (Boolean.TRUE.equals(mSmallScreens)) {
-                alreadyOutputSomething = true;
-                sb.append("small");
-            }
-
-            if (Boolean.TRUE.equals(mNormalScreens)) {
-                if (alreadyOutputSomething) {
-                    sb.append(", ");
-                }
-                alreadyOutputSomething = true;
-                sb.append("normal");
-            }
-
-            if (Boolean.TRUE.equals(mLargeScreens)) {
-                if (alreadyOutputSomething) {
-                    sb.append(", ");
-                }
-                alreadyOutputSomething = true;
-                sb.append("large");
-            }
-
-            if (alreadyOutputSomething == false) {
-                sb.append("<none>");
-            }
-
-            return sb.toString();
-        }
-
-        /**
-         * Returns true if the two instance overlap with each other.
-         * This can happen if one instances supports a size, when the other instance doesn't while
-         * supporting a size above and a size below.
-         * @param otherSS the other supports-screens to compare to.
-         */
-        public boolean overlapWith(SupportsScreens otherSS) {
-            if (mSmallScreens == null || mNormalScreens == null || mLargeScreens == null ||
-                    otherSS.mSmallScreens == null || otherSS.mNormalScreens == null ||
-                    otherSS.mLargeScreens == null) {
-                throw new IllegalArgumentException("Some screen sizes Boolean are not initialized");
-            }
-
-            if (mSmallScreens == Boolean.TRUE && mNormalScreens == Boolean.FALSE &&
-                    mLargeScreens == Boolean.TRUE) {
-                return otherSS.mNormalScreens == Boolean.TRUE;
-            }
-
-            if (otherSS.mSmallScreens == Boolean.TRUE && otherSS.mNormalScreens == Boolean.FALSE &&
-                    otherSS.mLargeScreens == Boolean.TRUE) {
-                return mNormalScreens == Boolean.TRUE;
-            }
-
-            return false;
-        }
-    }
-
-    /**
-     * Class representing a <code>uses-library</code> node in the manifest.
-     */
-    public static final class UsesLibrary {
-        String mName;
-        Boolean mRequired = Boolean.TRUE; // default is true even if missing
-
-        public String getName() {
-            return mName;
-        }
-
-        public Boolean getRequired() {
-            return mRequired;
-        }
-    }
-
-    /**
-     * Class representing a <code>uses-feature</code> node in the manifest.
-     */
-    public static final class UsesFeature {
-        String mName;
-        int mGlEsVersion = 0;
-        Boolean mRequired = Boolean.TRUE;  // default is true even if missing
-
-        public String getName() {
-            return mName;
-        }
-
-        /**
-         * Returns the value of the glEsVersion attribute, or 0 if the attribute was not present.
-         */
-        public int getGlEsVersion() {
-            return mGlEsVersion;
-        }
-
-        public Boolean getRequired() {
-            return mRequired;
-        }
-    }
-
-    /**
-     * Class representing the <code>uses-configuration</code> node in the manifest.
-     */
-    public static final class UsesConfiguration {
-        Boolean mReqFiveWayNav;
-        Boolean mReqHardKeyboard;
-        Keyboard mReqKeyboardType;
-        TouchScreen mReqTouchScreen;
-        Navigation mReqNavigation;
-
-        /**
-         * returns the value of the <code>reqFiveWayNav</code> attribute or null if not present.
-         */
-        public Boolean getReqFiveWayNav() {
-            return mReqFiveWayNav;
-        }
-
-        /**
-         * returns the value of the <code>reqNavigation</code> attribute or null if not present.
-         */
-        public Navigation getReqNavigation() {
-            return mReqNavigation;
-        }
-
-        /**
-         * returns the value of the <code>reqHardKeyboard</code> attribute or null if not present.
-         */
-        public Boolean getReqHardKeyboard() {
-            return mReqHardKeyboard;
-        }
-
-        /**
-         * returns the value of the <code>reqKeyboardType</code> attribute or null if not present.
-         */
-        public Keyboard getReqKeyboardType() {
-            return mReqKeyboardType;
-        }
-
-        /**
-         * returns the value of the <code>reqTouchScreen</code> attribute or null if not present.
-         */
-        public TouchScreen getReqTouchScreen() {
-            return mReqTouchScreen;
-        }
-    }
-
-    /**
-     * Returns the package defined in the manifest, if found.
-     * @return The package name or null if not found.
-     */
-    public String getPackage() {
-        return mPackage;
-    }
-
-    /**
-     * Returns the versionCode value defined in the manifest, if found, null otherwise.
-     * @return the versionCode or null if not found.
-     */
-    public Integer getVersionCode() {
-        return mVersionCode;
-    }
-
-    /**
-     * Returns the versionName value defined in the manifest, if found, null otherwise.
-     *
-     * @return the versionName or null if not found.
-     */
-    public String getVersionName() {
-        return mVersionName;
-    }
-
-    /**
-     * Returns the list of activities found in the manifest.
-     * @return An array of fully qualified class names, or empty if no activity were found.
-     */
-    public Activity[] getActivities() {
-        return mActivities.toArray(new Activity[0]);
-    }
-
-    /**
-     * Returns the list of activities, services, receivers and providers found in the manifest.
-     *
-     * @return An array of fully qualified class names, or empty if no classes to keep were found.
-     */
-    public KeepClass[] getKeepClasses() {
-        return mKeepClasses.toArray(new KeepClass[0]);
-    }
-
-    /**
-     * Returns the name of one activity found in the manifest, that is configured to show up in the
-     * HOME screen.
-     *
-     * @return the fully qualified name of a HOME activity or null if none were found.
-     */
-    public Activity getLauncherActivity() {
-        return mLauncherActivity;
-    }
-
-    /**
-     * Returns the list of process names declared by the manifest.
-     */
-    public String[] getProcesses() {
-        if (mProcesses != null) {
-            return mProcesses.toArray(new String[0]);
-        }
-
-        return new String[0];
-    }
-
-    @Nullable
-    public String getDefaultProcess() {
-        return mDefaultProcess;
-    }
-
-    /**
-     * Returns the <code>debuggable</code> attribute value or null if it is not set.
-     */
-    public Boolean getDebuggable() {
-        return mDebuggable;
-    }
-
-    /**
-     * Returns the <code>minSdkVersion</code> attribute, or null if it's not set.
-     */
-    public String getMinSdkVersionString() {
-        return mMinSdkVersionString;
-    }
-
-    /**
-     * Sets the value of the <code>minSdkVersion</code> attribute.
-     * @param minSdkVersion the string value of the attribute in the manifest.
-     */
-    public void setMinSdkVersionString(String minSdkVersion) {
-        mMinSdkVersionString = minSdkVersion;
-        if (mMinSdkVersionString != null) {
-            try {
-                mMinSdkVersion = Integer.parseInt(mMinSdkVersionString);
-            } catch (NumberFormatException e) {
-                mMinSdkVersion = MIN_SDK_CODENAME;
-            }
-        }
-    }
-
-    /**
-     * Returns the <code>minSdkVersion</code> attribute, or 0 if it's not set or is a codename.
-     * @see #getMinSdkVersionString()
-     */
-    public int getMinSdkVersion() {
-        return mMinSdkVersion;
-    }
-
-
-    /**
-     * Sets the value of the <code>minSdkVersion</code> attribute.
-     * @param targetSdkVersion the string value of the attribute in the manifest.
-     */
-    public void setTargetSdkVersionString(String targetSdkVersion) {
-        if (targetSdkVersion != null) {
-            try {
-                mTargetSdkVersion = Integer.parseInt(targetSdkVersion);
-            } catch (NumberFormatException e) {
-                // keep the value at 0.
-            }
-        }
-    }
-
-    /**
-     * Returns the <code>targetSdkVersion</code> attribute, or the same value as
-     * {@link #getMinSdkVersion()} if it was not set in the manifest.
-     */
-    public int getTargetSdkVersion() {
-        if (mTargetSdkVersion == 0) {
-            return getMinSdkVersion();
-        }
-
-        return mTargetSdkVersion;
-    }
-
-    /**
-     * Returns the list of instrumentations found in the manifest.
-     * @return An array of {@link Instrumentation}, or empty if no instrumentations were
-     * found.
-     */
-    public Instrumentation[] getInstrumentations() {
-        return mInstrumentations.toArray(new Instrumentation[0]);
-    }
-
-    /**
-     * Returns the list of libraries in use found in the manifest.
-     * @return An array of {@link UsesLibrary} objects, or empty if no libraries were found.
-     */
-    public UsesLibrary[] getUsesLibraries() {
-        return mLibraries.toArray(new UsesLibrary[0]);
-    }
-
-    /**
-     * Returns the list of features in use found in the manifest.
-     * @return An array of {@link UsesFeature} objects, or empty if no libraries were found.
-     */
-    public UsesFeature[] getUsesFeatures() {
-        return mFeatures.toArray(new UsesFeature[0]);
-    }
-
-    /** Returns the set of custom permissions declared in the manifest. */
-    public ImmutableList<String> getCustomPermissions() {
-        return ImmutableList.copyOf(mCustomPermissions);
-    }
-
-    /**
-     * Returns the glEsVersion from a {@code <uses-feature>} or {@link #GL_ES_VERSION_NOT_SET}
-     * if not set.
-     */
-    public int getGlEsVersion() {
-        for (UsesFeature feature : mFeatures) {
-            if (feature.mGlEsVersion > 0) {
-                return feature.mGlEsVersion;
-            }
-        }
-        return GL_ES_VERSION_NOT_SET;
-    }
-
-    /**
-     * Returns the {@link SupportsScreens} object representing the <code>supports-screens</code>
-     * node, or null if the node doesn't exist at all.
-     * Some values in the {@link SupportsScreens} instance maybe null, indicating that they
-     * were not present in the manifest. To get an instance that contains the values, as seen
-     * by the Android platform when the app is running, use {@link #getSupportsScreensValues()}.
-     */
-    public SupportsScreens getSupportsScreensFromManifest() {
-        return mSupportsScreensFromManifest;
-    }
-
-    /**
-     * Returns an always non-null instance of {@link SupportsScreens} that's been initialized with
-     * the default values, and the values from the manifest.
-     * The default values depends on the manifest values for minSdkVersion and targetSdkVersion.
-     */
-    public synchronized SupportsScreens getSupportsScreensValues() {
-        if (mSupportsScreensValues == null) {
-            if (mSupportsScreensFromManifest == null) {
-                mSupportsScreensValues = SupportsScreens.getDefaultValues(getTargetSdkVersion());
-            } else {
-                // get a SupportsScreen that replace the missing values with default values.
-                mSupportsScreensValues = mSupportsScreensFromManifest.resolveSupportsScreensValues(
-                        getTargetSdkVersion());
-            }
-        }
-
-        return mSupportsScreensValues;
-    }
-
-    /**
-     * Returns the {@link UsesConfiguration} object representing the <code>uses-configuration</code>
-     * node, or null if the node doesn't exist at all.
-     */
-    public UsesConfiguration getUsesConfiguration() {
-        return mUsesConfiguration;
-    }
-
-    void addProcessName(String processName) {
-        if (mProcesses == null) {
-            mProcesses = new TreeSet<String>();
-        }
-
-        if (processName.startsWith(":")) {
-            mProcesses.add(mPackage + processName);
-        } else {
-            mProcesses.add(processName);
-        }
-    }
-
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFile.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFile.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFile.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFile.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,20 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-import java.io.InputStream;
-import java.io.OutputStream;
-
-public interface IAbstractFile extends IAbstractResource {
-    enum PreferredWriteMode {
-        INPUTSTREAM, OUTPUTSTREAM
-    }
-
-    InputStream getContents() throws StreamException;
-
-    void setContents(InputStream contents) throws StreamException;
-
-    OutputStream getOutputStream() throws StreamException;
-
-    PreferredWriteMode getPreferredWriteMode();
-
-    long getModificationStamp();
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatStyle.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatStyle.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatStyle.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatStyle.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,70 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.tyron.build.compiler.manifest.SdkConstants;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-
-/**
- * Style to use when printing the XML. Different types of Android XML files use slightly
- * different preferred formats. For example, in layout files there is typically always a
- * newline between successive elements, whereas in a manifest file there is typically only
- * newlines between different types of elements. As another example, in resource files,
- * the format is typically much more compact: the text content of {@code <item>} tags is
- * included on the same line whereas for other layout styles the children are typically
- * placed on a line of their own.
- */
-public enum XmlFormatStyle {
-    /** Layout formatting style: blank lines between elements, attributes on separate lines */
-    LAYOUT,
-
-    /** Similar to layout formatting style, but no blank lines inside opening elements */
-    FILE,
-
-    /** Resource style: one line per complete element including text child content */
-    RESOURCE,
-
-    /**
-     * Similar to layout style, but no newlines between related elements such as
-     * successive {@code <uses-permission>} declarations, and no newlines inside
-     * the second level elements (so an {@code <activity>} declaration appears as a
-     * single block with no whitespace within it)
-     */
-    MANIFEST;
-
-    @NonNull
-    public static XmlFormatStyle get(@Nullable Node node) {
-        if (node != null) {
-            Document doc = (node.getNodeType() == Node.DOCUMENT_NODE)
-                    ? (Document) node : node.getOwnerDocument();
-            if (doc != null) {
-                Element root = doc.getDocumentElement();
-                if (root != null) {
-                    String tag = root.getTagName();
-                    if (tag.equals(SdkConstants.TAG_RESOURCES)) {
-                        return RESOURCE;
-                    } else if (tag.equals(AndroidManifest.NODE_MANIFEST)) {
-                        return MANIFEST;
-                    }
-
-                    // How do we detect a layout vs other files such as drawables??
-                    // For now, assume that capitalized tags are view names, or names
-                    // with package components are custom views
-                    if (Character.isUpperCase(tag.charAt(0))
-                            || SdkConstants.VIEW_TAG.equals(tag)
-                            || SdkConstants.VIEW_INCLUDE.equals(tag)
-                            || SdkConstants.VIEW_MERGE.equals(tag)
-                            || tag.indexOf('.') != -1) {
-                        return LAYOUT;
-                    }
-                }
-            }
-        }
-
-        return FILE;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifest.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifest.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifest.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifest.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,86 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-
-import com.tyron.build.compiler.manifest.SdkConstants;
-
-/** Constants for the AndroidManifest.xml file. */
-public final class AndroidManifest {
-
-    public static final String NODE_MANIFEST = "manifest";
-    public static final String NODE_APPLICATION = "application";
-    public static final String NODE_ACTIVITY = "activity";
-    public static final String NODE_ACTIVITY_ALIAS = "activity-alias";
-    public static final String NODE_SERVICE = "service";
-    public static final String NODE_RECEIVER = "receiver";
-    public static final String NODE_PROVIDER = "provider";
-    public static final String NODE_INTENT = "intent-filter";
-    public static final String NODE_ACTION = "action";
-    public static final String NODE_CATEGORY = "category";
-    public static final String NODE_USES_SDK = "uses-sdk";
-    public static final String NODE_PERMISSION = "permission";
-    public static final String NODE_PERMISSION_TREE = "permission-tree";
-    public static final String NODE_PERMISSION_GROUP = "permission-group";
-    public static final String NODE_USES_PERMISSION = "uses-permission";
-    public static final String NODE_INSTRUMENTATION = "instrumentation";
-    public static final String NODE_USES_LIBRARY = "uses-library";
-    public static final String NODE_SUPPORTS_SCREENS = "supports-screens";
-    public static final String NODE_COMPATIBLE_SCREENS = "compatible-screens";
-    public static final String NODE_USES_CONFIGURATION = "uses-configuration";
-    public static final String NODE_USES_FEATURE = "uses-feature";
-    public static final String NODE_METADATA = "meta-data";
-    public static final String NODE_DATA = "data";
-    public static final String NODE_GRANT_URI_PERMISSION = "grant-uri-permission";
-    public static final String NODE_PATH_PERMISSION = "path-permission";
-    public static final String NODE_SUPPORTS_GL_TEXTURE = "supports-gl-texture";
-
-    public static final String ATTRIBUTE_PACKAGE = "package";
-    public static final String ATTRIBUTE_VERSIONCODE = "versionCode";
-    public static final String ATTRIBUTE_VERSIONNAME = "versionName";
-    public static final String ATTRIBUTE_NAME = "name";
-    public static final String ATTRIBUTE_MIME_TYPE = "mimeType";
-    public static final String ATTRIBUTE_PORT = "port";
-    public static final String ATTRIBUTE_REQUIRED = "required";
-    public static final String ATTRIBUTE_GLESVERSION = "glEsVersion";
-    public static final String ATTRIBUTE_PROCESS = "process";
-    public static final String ATTRIBUTE_DEBUGGABLE = "debuggable";
-    public static final String ATTRIBUTE_HASCODE = "hasCode";
-    public static final String ATTRIBUTE_LABEL = "label";
-    public static final String ATTRIBUTE_ICON = "icon";
-    public static final String ATTRIBUTE_MIN_SDK_VERSION = "minSdkVersion";
-    public static final String ATTRIBUTE_TARGET_SDK_VERSION = "targetSdkVersion";
-    public static final String ATTRIBUTE_TARGET_PACKAGE = "targetPackage";
-    public static final String ATTRIBUTE_FUNCTIONAL_TEST = "functionalTest";
-    public static final String ATTRIBUTE_HANDLE_PROFILING = "handleProfiling";
-    public static final String ATTRIBUTE_INSTRUMENTATION_LABEL = "label";
-    public static final String ATTRIBUTE_TARGET_ACTIVITY = "targetActivity";
-    public static final String ATTRIBUTE_MANAGE_SPACE_ACTIVITY = "manageSpaceActivity";
-    public static final String ATTRIBUTE_EXPORTED = "exported";
-    public static final String ATTRIBUTE_RESIZEABLE = "resizeable";
-    public static final String ATTRIBUTE_ANYDENSITY = "anyDensity";
-    public static final String ATTRIBUTE_SMALLSCREENS = "smallScreens";
-    public static final String ATTRIBUTE_NORMALSCREENS = "normalScreens";
-    public static final String ATTRIBUTE_LARGESCREENS = "largeScreens";
-    public static final String ATTRIBUTE_REQ_5WAYNAV = "reqFiveWayNav";
-    public static final String ATTRIBUTE_REQ_NAVIGATION = "reqNavigation";
-    public static final String ATTRIBUTE_REQ_HARDKEYBOARD = "reqHardKeyboard";
-    public static final String ATTRIBUTE_REQ_KEYBOARDTYPE = "reqKeyboardType";
-    public static final String ATTRIBUTE_REQ_TOUCHSCREEN = "reqTouchScreen";
-    public static final String ATTRIBUTE_THEME = "theme";
-    public static final String ATTRIBUTE_BACKUP_AGENT = "backupAgent";
-    public static final String ATTRIBUTE_PARENT_ACTIVITY_NAME = "parentActivityName";
-    public static final String ATTRIBUTE_SUPPORTS_RTL = "supportsRtl";
-    public static final String ATTRIBUTE_UI_OPTIONS = "uiOptions";
-    public static final String ATTRIBUTE_VALUE = "value";
-    public static final String ATTRIBUTE_EXTRACT_NATIVE_LIBS = "extractNativeLibs";
-    public static final String ATTRIBUTE_SPLIT = "split";
-    public static final String ATTRIBUTE_RESIZEABLE_ACTIVITY = "resizeableActivity";
-    public static final String ATTRIBUTE_SCREEN_ORIENTATION = "screenOrientation";
-    public static final String ATTRIBUTE_ISOLATED_PROCESS = "isolatedProcess";
-    public static final String ATTRIBUTE_ENABLED = "enabled";
-
-    public static final String ATTRIBUTE_PERMISSION = "permission";
-
-    public static final String VALUE_PARENT_ACTIVITY =
-            SdkConstants.ANDROID_SUPPORT_PKG_PREFIX + "PARENT_ACTIVITY";
-
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFolder.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFolder.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFolder.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractFolder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,18 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-public interface IAbstractFolder extends IAbstractResource {
-
-    interface FilenameFilter {
-        boolean accept(IAbstractFolder dir, String name);
-    }
-
-    boolean hasFile(String name);
-
-    IAbstractFile getFile(String name);
-
-    IAbstractFolder getFolder(String name);
-
-    IAbstractResource[] listMembers();
-
-    String[] list(FilenameFilter filter);
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/StreamException.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/StreamException.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/StreamException.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/StreamException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,31 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-public class StreamException extends Exception {
-
-    private static final long serialVersionId = 1L;
-
-    public enum Error {
-        DEFAULT, OUTOFSYNC, FILENOTFOUND
-    }
-
-    private final Error mError;
-    private final IAbstractFile mFile;
-
-    public StreamException(Exception e, IAbstractFile file) {
-        this (e, file, Error.DEFAULT);
-    }
-
-    public StreamException(Exception e, IAbstractFile file, Error error) {
-        super(e);
-        mError = error;
-        mFile = file;
-    }
-
-    public Error getError() {
-        return mError;
-    }
-
-    public IAbstractFile getFile() {
-        return mFile;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlPrettyPrinter.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlPrettyPrinter.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlPrettyPrinter.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlPrettyPrinter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1265 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-import static com.tyron.build.compiler.manifest.SdkConstants.DOT_XML;
-import static com.tyron.build.compiler.manifest.SdkConstants.TAG_COLOR;
-import static com.tyron.build.compiler.manifest.SdkConstants.TAG_DIMEN;
-import static com.tyron.build.compiler.manifest.SdkConstants.TAG_ITEM;
-import static com.tyron.build.compiler.manifest.SdkConstants.TAG_STRING;
-import static com.tyron.build.compiler.manifest.SdkConstants.TAG_STYLE;
-import static com.tyron.build.compiler.manifest.SdkConstants.XMLNS;
-import static com.tyron.code.util.XmlUtils.XML_COMMENT_BEGIN;
-import static com.tyron.code.util.XmlUtils.XML_COMMENT_END;
-import static com.tyron.code.util.XmlUtils.XML_PROLOG;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.tyron.build.compiler.manifest.SdkConstants;
-import com.tyron.build.compiler.manifest.resources.ResourceFolderType;
-import com.tyron.build.util.SdkUtils;
-import com.tyron.build.util.XmlUtils;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Charsets;
-import com.google.common.collect.Lists;
-import com.google.common.io.Files;
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import org.w3c.dom.Attr;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-/**
- * Visitor which walks over the subtree of the DOM to be formatted and pretty prints
- * the DOM into the given {@link StringBuilder}
- */
-public class XmlPrettyPrinter {
-
-    /** The style to print the XML in */
-    private final XmlFormatStyle mStyle;
-
-    /** Formatting preferences to use when formatting the XML */
-    private final XmlFormatPreferences mPrefs;
-    /** Start node to start formatting at */
-    private Node mStartNode;
-    /** Start node to stop formatting after */
-    private Node mEndNode;
-    /** Whether the visitor is currently in range */
-    private boolean mInRange;
-    /** Output builder */
-    @SuppressWarnings("StringBufferField")
-    private StringBuilder mOut;
-    /** String to insert for a single indentation level */
-    private String mIndentString;
-    /** Line separator to use */
-    private String mLineSeparator;
-    /** If true, we're only formatting an open tag */
-    private boolean mOpenTagOnly;
-    /** List of indentation to use for each given depth */
-    private String[] mIndentationLevels;
-    /** Whether the formatter should end the document with a newline */
-    private boolean mEndWithNewline;
-
-    /**
-     * Creates a new {@link XmlPrettyPrinter}
-     *
-     * @param prefs the preferences to format with
-     * @param style the style to format with
-     * @param lineSeparator the line separator to use, such as "\n" (can be null, in which
-     *            case the system default is looked up via the line.separator property)
-     */
-    public XmlPrettyPrinter(XmlFormatPreferences prefs, XmlFormatStyle style,
-                            String lineSeparator) {
-        mPrefs = prefs;
-        mStyle = style;
-        if (lineSeparator == null) {
-            lineSeparator = System.lineSeparator();
-        }
-        mLineSeparator = lineSeparator;
-    }
-
-    /**
-     * Sets whether the document should end with a newline/ line separator
-     *
-     * @param endWithNewline if true, ensure that the document ends with a newline
-     * @return this, for constructor chaining
-     */
-    public XmlPrettyPrinter setEndWithNewline(boolean endWithNewline) {
-        mEndWithNewline = endWithNewline;
-        return this;
-    }
-
-    /**
-     * Sets the indentation levels to use (indentation string to use for each depth,
-     * indexed by depth
-     *
-     * @param indentationLevels an array of strings to use for the various indentation
-     *            levels
-     */
-    public void setIndentationLevels(String[] indentationLevels) {
-        mIndentationLevels = indentationLevels;
-    }
-
-    @NonNull
-    private String getLineSeparator() {
-        return mLineSeparator;
-    }
-
-    /**
-     * Pretty-prints the given XML document, which must be well-formed. If it is not,
-     * the original unformatted XML document is returned
-     *
-     * @param xml the XML content to format
-     * @param prefs the preferences to format with
-     * @param style the style to format with
-     * @param lineSeparator the line separator to use, such as "\n" (can be null, in which
-     *     case the system default is looked up via the line.separator property)
-     * @return the formatted document (or if a parsing error occurred, returns the
-     *     unformatted document)
-     */
-    @NonNull
-    public static String prettyPrint(
-            @NonNull String xml,
-            @NonNull XmlFormatPreferences prefs,
-            @NonNull XmlFormatStyle style,
-            @Nullable String lineSeparator) {
-        Document document = XmlUtils.parseDocumentSilently(xml, true);
-        if (document != null) {
-            XmlPrettyPrinter printer = new XmlPrettyPrinter(prefs, style, lineSeparator);
-            printer.setEndWithNewline(xml.endsWith(printer.getLineSeparator()));
-            StringBuilder sb = new StringBuilder(3 * xml.length() / 2);
-            printer.prettyPrint(-1, document, null, null, sb, false /*openTagOnly*/);
-            return sb.toString();
-        } else {
-            // Parser error: just return the unformatted content
-            return xml;
-        }
-    }
-
-    /**
-     * Pretty prints the given node
-     *
-     * @param node the node, usually a document, to be printed
-     * @param prefs the formatting preferences
-     * @param style the formatting style to use
-     * @param lineSeparator the line separator to use, or null to use the
-     *            default
-     * @return a formatted string
-     * @deprecated Use {@link #prettyPrint(org.w3c.dom.Node, XmlFormatPreferences,
-     *      XmlFormatStyle, String, boolean)} instead
-     */
-    @NonNull
-    @Deprecated
-    public static String prettyPrint(
-            @NonNull Node node,
-            @NonNull XmlFormatPreferences prefs,
-            @NonNull XmlFormatStyle style,
-            @Nullable String lineSeparator) {
-        return prettyPrint(node, prefs, style, lineSeparator, false);
-    }
-
-    /**
-     * Pretty prints the given node
-     *
-     * @param node the node, usually a document, to be printed
-     * @param prefs the formatting preferences
-     * @param style the formatting style to use
-     * @param lineSeparator the line separator to use, or null to use the
-     *            default
-     * @param endWithNewline if true, ensure that the printed output ends with a newline
-     * @return a formatted string
-     */
-    @NonNull
-    public static String prettyPrint(
-            @NonNull Node node,
-            @NonNull XmlFormatPreferences prefs,
-            @NonNull XmlFormatStyle style,
-            @Nullable String lineSeparator,
-            boolean endWithNewline) {
-        XmlPrettyPrinter printer = new XmlPrettyPrinter(prefs, style, lineSeparator);
-        printer.setEndWithNewline(endWithNewline);
-        StringBuilder sb = new StringBuilder(1000);
-        printer.prettyPrint(-1, node, null, null, sb, false /*openTagOnly*/);
-        String xml = sb.toString();
-        if (node.getNodeType() == Node.DOCUMENT_NODE && !xml.startsWith("<?")) { //$NON-NLS-1$
-            xml = XML_PROLOG + xml;
-        }
-        return xml;
-    }
-
-    /**
-     * Pretty prints the given node using default styles
-     *
-     * @param node the node, usually a document, to be printed
-     * @return the resulting formatted string
-     * @deprecated Use {@link #prettyPrint(org.w3c.dom.Node, boolean)} instead
-     */
-    @NonNull
-    @Deprecated
-    public static String prettyPrint(@NonNull Node node) {
-        return prettyPrint(node, false);
-    }
-
-    /**
-     * Pretty prints the given node using default styles
-     *
-     * @param node the node, usually a document, to be printed
-     * @param endWithNewline if true, ensure that the printed output ends with a newline
-     * @return the resulting formatted string
-     */
-    @NonNull
-    public static String prettyPrint(@NonNull Node node, boolean endWithNewline) {
-        return prettyPrint(
-                node,
-                XmlFormatPreferences.defaults(),
-                XmlFormatStyle.get(node),
-                System.lineSeparator(),
-                endWithNewline);
-    }
-
-    /**
-     * Start pretty-printing at the given node, which must either be the
-     * startNode or contain it as a descendant.
-     *
-     * @param rootDepth the depth of the given node, used to determine indentation
-     * @param root the node to start pretty printing from (which may not itself be
-     *            included in the start to end node range but should contain it)
-     * @param startNode the node to start formatting at
-     * @param endNode the node to end formatting at
-     * @param out the {@link StringBuilder} to pretty print into
-     * @param openTagOnly if true, only format the open tag of the startNode (and nothing
-     *     else)
-     */
-    public void prettyPrint(int rootDepth, Node root, Node startNode, Node endNode,
-                            StringBuilder out, boolean openTagOnly) {
-        if (startNode == null) {
-            startNode = root;
-        }
-        if (endNode == null) {
-            endNode = root;
-        }
-        assert !openTagOnly || startNode == endNode;
-
-        mStartNode = startNode;
-        mOpenTagOnly = openTagOnly;
-        mEndNode = endNode;
-        mOut = out;
-        mInRange = false;
-        mIndentString = mPrefs.getOneIndentUnit();
-
-        visitNode(rootDepth, root);
-
-        if (mEndWithNewline && !endsWithLineSeparator()) {
-            mOut.append(mLineSeparator);
-        }
-    }
-
-    /** Visit the given node at the given depth */
-    private void visitNode(int depth, Node node) {
-        if (node == mStartNode) {
-            mInRange = true;
-        }
-
-        if (mInRange) {
-            visitBeforeChildren(depth, node);
-            if (mOpenTagOnly && mStartNode == node) {
-                mInRange = false;
-                return;
-            }
-        }
-
-        NodeList children = node.getChildNodes();
-        for (int i = 0, n = children.getLength(); i < n; i++) {
-            Node child = children.item(i);
-            visitNode(depth + 1, child);
-        }
-
-        if (mInRange) {
-            visitAfterChildren(depth, node);
-        }
-
-        if (node == mEndNode) {
-            mInRange = false;
-        }
-    }
-
-    private void visitBeforeChildren(int depth, Node node) {
-        short type = node.getNodeType();
-        switch (type) {
-            case Node.DOCUMENT_NODE:
-            case Node.DOCUMENT_FRAGMENT_NODE:
-                // Nothing to do
-                break;
-
-            case Node.ATTRIBUTE_NODE:
-                // Handled as part of processing elements
-                break;
-
-            case Node.ELEMENT_NODE: {
-                printOpenElementTag(depth, node);
-                break;
-            }
-
-            case Node.TEXT_NODE: {
-                printText(node);
-                break;
-            }
-
-            case Node.CDATA_SECTION_NODE:
-                printCharacterData(node);
-                break;
-
-            case Node.PROCESSING_INSTRUCTION_NODE:
-                printProcessingInstruction(node);
-                break;
-
-            case Node.COMMENT_NODE: {
-                printComment(depth, node);
-                break;
-            }
-
-            case Node.DOCUMENT_TYPE_NODE:
-                printDocType(node);
-                break;
-
-            case Node.ENTITY_REFERENCE_NODE:
-            case Node.ENTITY_NODE:
-            case Node.NOTATION_NODE:
-                break;
-            default:
-                assert false : type;
-        }
-    }
-
-    private void visitAfterChildren(int depth, Node node) {
-        short type = node.getNodeType();
-        switch (type) {
-            case Node.ATTRIBUTE_NODE:
-                // Handled as part of processing elements
-                break;
-            case Node.ELEMENT_NODE: {
-                printCloseElementTag(depth, node);
-                break;
-            }
-        }
-    }
-
-    private void printProcessingInstruction(Node node) {
-        mOut.append("<?xml "); //$NON-NLS-1$
-        mOut.append(node.getNodeValue().trim());
-        mOut.append('?').append('>').append(mLineSeparator);
-    }
-
-    @Nullable
-    @SuppressWarnings("MethodMayBeStatic") // Intentionally instance method so it can be overridden
-    protected String getSource(@NonNull Node node) {
-        return null;
-    }
-
-    private void printDocType(Node node) {
-        String content = getSource(node);
-        if (content != null) {
-            mOut.append(content);
-            mOut.append(mLineSeparator);
-        }
-    }
-
-    private void printCharacterData(Node node) {
-        String nodeValue = node.getNodeValue();
-        boolean separateLine = nodeValue.indexOf('\n') != -1;
-        if (separateLine && !endsWithLineSeparator()) {
-            mOut.append(mLineSeparator);
-        }
-        mOut.append("<![CDATA["); //$NON-NLS-1$
-        mOut.append(nodeValue);
-        mOut.append("]]>");       //$NON-NLS-1$
-        if (separateLine) {
-            mOut.append(mLineSeparator);
-        }
-    }
-
-    private void printText(Node node) {
-        boolean escape = true;
-        String text = node.getNodeValue();
-
-        String source = getSource(node);
-        if (source != null) {
-            // Get the original source string. This will contain the actual entities
-            // such as "&gt;" instead of ">" which it gets turned into for the DOM nodes.
-            // By operating on source we can preserve the user's entities rather than
-            // having &gt; for example always turned into >.
-            text = source;
-            escape = false;
-        }
-
-        // Most text nodes are just whitespace for formatting (which we're replacing)
-        // so look for actual text content and extract that part out
-        String trimmed = text.trim();
-        if (!trimmed.isEmpty()) {
-            // TODO: Reformat the contents if it is too wide?
-
-            // Note that we append the actual text content, NOT the trimmed content,
-            // since the whitespace may be significant, e.g.
-            // <string name="toast_sync_error">Sync error: <xliff:g id="error">%1$s</xliff:g>...
-
-            // However, we should remove all blank lines in the prefix and suffix of the
-            // text node, or we will end up inserting additional blank lines each time you're
-            // formatting a text node within an outer element (which also adds spacing lines)
-            int lastPrefixNewline = -1;
-            for (int i = 0, n = text.length(); i < n; i++) {
-                char c = text.charAt(i);
-                if (c == '\n') {
-                    lastPrefixNewline = i;
-                } else if (!Character.isWhitespace(c)) {
-                    break;
-                }
-            }
-            int firstSuffixNewline = -1;
-            for (int i = text.length() - 1; i >= 0; i--) {
-                char c = text.charAt(i);
-                if (c == '\n') {
-                    firstSuffixNewline = i;
-                } else if (!Character.isWhitespace(c)) {
-                    break;
-                }
-            }
-            if (lastPrefixNewline != -1 || firstSuffixNewline != -1) {
-                boolean stripSuffix;
-                if (firstSuffixNewline == -1) {
-                    firstSuffixNewline = text.length();
-                    stripSuffix = false;
-                } else {
-                    stripSuffix = true;
-                }
-
-                int stripFrom = lastPrefixNewline + 1;
-                if (firstSuffixNewline >= stripFrom) {
-                    text = text.substring(stripFrom, firstSuffixNewline);
-
-                    // In markup strings we may need to preserve spacing on the left and/or
-                    // right if we're next to a markup string on the given side
-                    if (lastPrefixNewline != -1) {
-                        Node left = node.getPreviousSibling();
-                        if (isMarkupNode(left)) {
-                            text = ' ' + text;
-                        }
-                    }
-                    if (stripSuffix) {
-                        Node right = node.getNextSibling();
-                        if (isMarkupNode(right)) {
-                            text += ' ';
-                        }
-                    }
-                }
-            }
-
-            if (escape) {
-                XmlUtils.appendXmlTextValue(mOut, text);
-            } else {
-                // Text is already escaped
-                mOut.append(text);
-            }
-
-            if (mStyle != XmlFormatStyle.RESOURCE) {
-                mOut.append(mLineSeparator);
-            }
-        } else {
-            // Ensure that if we're in the middle of a markup string, we preserve spacing.
-            // In other words, "<b>first</b> <b>second</b>" - we don't want that middle
-            // space to disappear, but we do want repeated spaces to collapse into one.
-            Node left = node.getPreviousSibling();
-            Node right = node.getNextSibling();
-            if (isMarkupNode(left) && isMarkupNode(right)) {
-                mOut.append(' ');
-            }
-        }
-    }
-
-    private boolean isMarkupNode(@Nullable Node node) {
-        if (node == null) {
-            return false;
-        }
-        if (node.getNodeType() == Node.ELEMENT_NODE) {
-            return isMarkupElement((Element) node);
-        }
-        return node.getNodeType() == Node.CDATA_SECTION_NODE;
-    }
-
-    private void printComment(int depth, Node node) {
-        String comment = node.getNodeValue();
-        boolean multiLine = comment.indexOf('\n') != -1;
-        String trimmed = comment.trim();
-
-        // See if this is an "end-of-the-line" comment, e.g. it is not a multi-line
-        // comment and it appears on the same line as an opening or closing element tag;
-        // if so, continue to place it as a suffix comment
-        boolean isSuffixComment = false;
-        if (!multiLine) {
-            Node previous = node.getPreviousSibling();
-            isSuffixComment = true;
-            if (previous == null && node.getParentNode().getNodeType() == Node.DOCUMENT_NODE) {
-                isSuffixComment = false;
-            }
-            while (previous != null) {
-                short type = previous.getNodeType();
-                if (type == Node.COMMENT_NODE) {
-                    isSuffixComment = false;
-                    break;
-                } else if (type == Node.TEXT_NODE) {
-                    if (previous.getNodeValue().indexOf('\n') != -1) {
-                        isSuffixComment = false;
-                        break;
-                    }
-                } else {
-                    break;
-                }
-                previous = previous.getPreviousSibling();
-            }
-            if (isSuffixComment) {
-                // Remove newline added by element open tag or element close tag
-                if (endsWithLineSeparator()) {
-                    removeLastLineSeparator();
-                }
-                mOut.append(' ');
-            }
-        }
-
-        // Put the comment on a line on its own? Only if it was separated by a blank line
-        // in the previous version of the document. In other words, if the document
-        // adds blank lines between comments this formatter will preserve that fact, and vice
-        // versa for a tightly formatted document it will preserve that convention as well.
-        if (!mPrefs.removeEmptyLines && !isSuffixComment) {
-            Node curr = node.getPreviousSibling();
-            if (curr == null) {
-                if (mOut.length() > 0 && !endsWithLineSeparator()) {
-                    mOut.append(mLineSeparator);
-                }
-            } else if (curr.getNodeType() == Node.TEXT_NODE) {
-                String text = curr.getNodeValue();
-                // Count how many newlines we find in the trailing whitespace of the
-                // text node
-                int newLines = 0;
-                for (int i = text.length() - 1; i >= 0; i--) {
-                    char c = text.charAt(i);
-                    if (Character.isWhitespace(c)) {
-                        if (c == '\n') {
-                            newLines++;
-                            if (newLines == 2) {
-                                break;
-                            }
-                        }
-                    } else {
-                        break;
-                    }
-                }
-                if (newLines >= 2) {
-                    mOut.append(mLineSeparator);
-                } else if (text.trim().isEmpty() && curr.getPreviousSibling() == null) {
-                    // Comment before first child in node
-                    mOut.append(mLineSeparator);
-                }
-            }
-        }
-
-
-        // TODO: Reformat the comment text?
-        if (!multiLine) {
-            if (!isSuffixComment) {
-                indent(depth);
-            }
-            mOut.append(XML_COMMENT_BEGIN).append(' ');
-            mOut.append(trimmed);
-            mOut.append(' ').append(XML_COMMENT_END);
-            mOut.append(mLineSeparator);
-        } else {
-            // Strip off blank lines at the beginning and end of the comment text.
-            // Find last newline at the beginning of the text:
-            int index = 0;
-            int end = comment.length();
-            int recentNewline = -1;
-            while (index < end) {
-                char c = comment.charAt(index);
-                if (c == '\n') {
-                    recentNewline = index;
-                }
-                if (!Character.isWhitespace(c)) {
-                    break;
-                }
-                index++;
-            }
-
-            int start = recentNewline + 1;
-
-            // Find last newline at the end of the text
-            index = end - 1;
-            recentNewline = -1;
-            while (index > start) {
-                char c = comment.charAt(index);
-                if (c == '\n') {
-                    recentNewline = index;
-                }
-                if (!Character.isWhitespace(c)) {
-                    break;
-                }
-                index--;
-            }
-
-            end = recentNewline == -1 ? index + 1 : recentNewline;
-            if (start >= end) {
-                // It's a blank comment like <!-- \n\n--> - just clean it up
-                if (!isSuffixComment) {
-                    indent(depth);
-                }
-                mOut.append(XML_COMMENT_BEGIN).append(' ').append(XML_COMMENT_END);
-                mOut.append(mLineSeparator);
-                return;
-            }
-
-            trimmed = comment.substring(start, end);
-
-            // When stripping out prefix and suffix blank lines we might have ended up
-            // with a single line comment again so check and format single line comments
-            // without newlines inside the <!-- --> delimiters
-            multiLine = trimmed.indexOf('\n') != -1;
-            if (multiLine) {
-                indent(depth);
-                mOut.append(XML_COMMENT_BEGIN);
-                mOut.append(mLineSeparator);
-
-                // See if we need to add extra spacing to keep alignment. Consider a comment
-                // like this:
-                // <!-- Deprecated strings - Move the identifiers to this section,
-                //      and remove the actual text. -->
-                // This String will be
-                // " Deprecated strings - Move the identifiers to this section,\n" +
-                // "     and remove the actual text. -->"
-                // where the left side column no longer lines up.
-                // To fix this, we need to insert some extra whitespace into the first line
-                // of the string; in particular, the exact number of characters that the
-                // first line of the comment was indented with!
-
-                // However, if the comment started like this:
-                // <!--
-                // /** Copyright
-                // -->
-                // then obviously the align-indent is 0, so we only want to compute an
-                // align indent when we don't find a newline before the content
-                boolean startsWithNewline = false;
-                for (int i = 0; i < start; i++) {
-                    if (comment.charAt(i) == '\n') {
-                        startsWithNewline = true;
-                        break;
-                    }
-                }
-                if (!startsWithNewline) {
-                    Node previous = node.getPreviousSibling();
-                    if (previous != null && previous.getNodeType() == Node.TEXT_NODE) {
-                        String prevText = previous.getNodeValue();
-                        int indentation = XML_COMMENT_BEGIN.length();
-                        for (int i = prevText.length() - 1; i >= 0; i--) {
-                            char c = prevText.charAt(i);
-                            if (c == '\n') {
-                                break;
-                            } else {
-                                indentation += (c == '\t') ? mPrefs.getTabWidth() : 1;
-                            }
-                        }
-
-                        // See if the next line after the newline has indentation; if it doesn't,
-                        // leave things alone. This fixes a case like this:
-                        //     <!-- This is the
-                        //     comment block -->
-                        // such that it doesn't turn it into
-                        //     <!--
-                        //          This is the
-                        //     comment block
-                        //     -->
-                        // In this case we instead want
-                        //     <!--
-                        //     This is the
-                        //     comment block
-                        //     -->
-                        int minIndent = Integer.MAX_VALUE;
-                        String[] lines = trimmed.split("\n"); //$NON-NLS-1$
-                        // Skip line 0 since we know that it doesn't start with a newline
-                        for (int i = 1; i < lines.length; i++) {
-                            int indent = 0;
-                            String line = lines[i];
-                            for (int j = 0; j < line.length(); j++) {
-                                char c = line.charAt(j);
-                                if (!Character.isWhitespace(c)) {
-                                    // Only set minIndent if there's text content on the line;
-                                    // blank lines can exist in the comment without affecting
-                                    // the overall minimum indentation boundary.
-                                    if (indent < minIndent) {
-                                        minIndent = indent;
-                                    }
-                                    break;
-                                } else {
-                                    indent += (c == '\t') ? mPrefs.getTabWidth() : 1;
-                                }
-                            }
-                        }
-
-                        if (minIndent < indentation) {
-                            indentation = minIndent;
-
-                            // Subtract any indentation that is already present on the line
-                            String line = lines[0];
-                            for (int j = 0; j < line.length(); j++) {
-                                char c = line.charAt(j);
-                                if (!Character.isWhitespace(c)) {
-                                    break;
-                                } else {
-                                    indentation -= (c == '\t') ? mPrefs.getTabWidth() : 1;
-                                }
-                            }
-                        }
-
-                        for (int i = 0; i < indentation; i++) {
-                            mOut.append(' ');
-                        }
-
-                        if (indentation < 0) {
-                            boolean prefixIsSpace = true;
-                            for (int i = 0; i < -indentation && i < trimmed.length(); i++) {
-                                if (!Character.isWhitespace(trimmed.charAt(i))) {
-                                    prefixIsSpace = false;
-                                    break;
-                                }
-                            }
-                            if (prefixIsSpace) {
-                                trimmed = trimmed.substring(-indentation);
-                            }
-                        }
-                    }
-                }
-                if (!mLineSeparator.equals("\n")) {
-                    trimmed = trimmed.replace("\n", mLineSeparator);
-                }
-                mOut.append(trimmed);
-                mOut.append(mLineSeparator);
-                indent(depth);
-                mOut.append(XML_COMMENT_END);
-                mOut.append(mLineSeparator);
-            } else {
-                mOut.append(XML_COMMENT_BEGIN).append(' ');
-                mOut.append(trimmed);
-                mOut.append(' ').append(XML_COMMENT_END);
-                mOut.append(mLineSeparator);
-            }
-        }
-
-        // Preserve whitespace after comment: See if the original document had two or
-        // more newlines after the comment, and if so have a blank line between this
-        // comment and the next
-        Node next = node.getNextSibling();
-        if (!mPrefs.removeEmptyLines && (next != null)
-                && (next.getNodeType() == Node.TEXT_NODE)) {
-            String text = next.getNodeValue();
-            int newLinesBeforeText = 0;
-            for (int i = 0, n = text.length(); i < n; i++) {
-                char c = text.charAt(i);
-                if (c == '\n') {
-                    newLinesBeforeText++;
-                    if (newLinesBeforeText == 2) {
-                        // Yes
-                        mOut.append(mLineSeparator);
-                        break;
-                    }
-                } else if (!Character.isWhitespace(c)) {
-                    break;
-                }
-            }
-        }
-    }
-
-    private boolean endsWithLineSeparator() {
-        int separatorLength = mLineSeparator.length();
-        if (mOut.length() >= separatorLength) {
-            for (int i = 0, j = mOut.length() - separatorLength; i < separatorLength; i++, j++) {
-                if (mOut.charAt(j) != mLineSeparator.charAt(i)) {
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    private void removeLastLineSeparator() {
-        int newLength = mOut.length() - mLineSeparator.length();
-        if (newLength >= 0) {
-            mOut.setLength(newLength);
-        }
-    }
-
-    private void printOpenElementTag(int depth, Node node) {
-        Element element = (Element) node;
-        if (newlineBeforeElementOpen(element, depth)) {
-            mOut.append(mLineSeparator);
-        }
-        if (indentBeforeElementOpen(element, depth)) {
-            indent(depth);
-        }
-        mOut.append('<').append(element.getTagName());
-
-        NamedNodeMap attributes = element.getAttributes();
-        int attributeCount = attributes.getLength();
-        if (attributeCount > 0) {
-            // Sort the attributes
-            List<Attr> attributeList = new ArrayList<Attr>();
-            for (int i = 0; i < attributeCount; i++) {
-                attributeList.add((Attr) attributes.item(i));
-            }
-            Comparator<Attr> comparator = mPrefs.getAttributeComparator();
-            if (comparator != null) {
-                Collections.sort(attributeList, comparator);
-            }
-
-            // Put the single attribute on the same line as the element tag?
-            boolean singleLine = mPrefs.oneAttributeOnFirstLine && attributeCount == 1
-                    // In resource files we always put all the attributes (which is
-                    // usually just zero, one or two) on the same line
-                    || mStyle == XmlFormatStyle.RESOURCE;
-
-            // We also place the namespace declaration on the same line as the root element,
-            // but this doesn't also imply singleLine handling; subsequent attributes end up
-            // on their own lines
-            boolean indentNextAttribute;
-            if (singleLine || (depth == 0 && XMLNS.equals(attributeList.get(0).getPrefix()))) {
-                mOut.append(' ');
-                indentNextAttribute = false;
-            } else {
-                mOut.append(mLineSeparator);
-                indentNextAttribute = true;
-            }
-
-            Attr last = attributeList.get(attributeCount - 1);
-            for (Attr attribute : attributeList) {
-                if (indentNextAttribute) {
-                    indent(depth + 1);
-                }
-                mOut.append(attribute.getName());
-                mOut.append('=').append('"');
-                XmlUtils.appendXmlAttributeValue(mOut, attribute.getValue());
-                mOut.append('"');
-
-                // Don't add a newline at the last attribute line; the > should
-                // immediately follow the last attribute
-                if (attribute != last) {
-                    mOut.append(singleLine ? " " : mLineSeparator); //$NON-NLS-1$
-                    indentNextAttribute = !singleLine;
-                }
-            }
-        }
-
-        boolean isClosed = isEmptyTag(element);
-
-        // Add a space before the > or /> ? In resource files, only do this when closing the
-        // element
-        if (mPrefs.spaceBeforeClose && (mStyle != XmlFormatStyle.RESOURCE || isClosed)
-                // in <selector> files etc still treat the <item> entries as in resource files
-                && !TAG_ITEM.equals(element.getTagName())
-                && (isClosed || element.getAttributes().getLength() > 0)) {
-            mOut.append(' ');
-        }
-
-        if (isClosed) {
-            mOut.append('/');
-        }
-
-        mOut.append('>');
-
-        if (newlineAfterElementOpen(element, depth, isClosed)) {
-            mOut.append(mLineSeparator);
-        }
-    }
-
-    private void printCloseElementTag(int depth, Node node) {
-        Element element = (Element) node;
-        if (isEmptyTag(element)) {
-            // Empty tag: Already handled as part of opening tag
-            return;
-        }
-
-        // Put the closing declaration on its own line - unless it's a compact
-        // resource file format
-        // If the element had element children, separate the end tag from them
-        if (newlineBeforeElementClose(element, depth)) {
-            mOut.append(mLineSeparator);
-        }
-        if (indentBeforeElementClose(element, depth)) {
-            indent(depth);
-        }
-        mOut.append('<').append('/');
-        mOut.append(node.getNodeName());
-        mOut.append('>');
-
-        if (newlineAfterElementClose(element, depth)) {
-            mOut.append(mLineSeparator);
-        }
-    }
-
-    private boolean newlineBeforeElementOpen(Element element, int depth) {
-        if (hasBlankLineAbove()) {
-            return false;
-        }
-
-        if (mPrefs.removeEmptyLines || depth <= 0) {
-            return false;
-        }
-
-        if (isMarkupElement(element)) {
-            return false;
-        }
-
-        // See if this element should be separated from the previous element.
-        // This is the case if we are not compressing whitespace (checked above),
-        // or if we are not immediately following a comment (in which case the
-        // newline would have been added above it), or if we are not in a formatting
-        // style where
-        if (mStyle == XmlFormatStyle.LAYOUT) {
-            // In layouts we always separate elements
-            return true;
-        }
-
-        if (mStyle == XmlFormatStyle.MANIFEST || mStyle == XmlFormatStyle.RESOURCE
-                || mStyle == XmlFormatStyle.FILE) {
-            Node curr = element.getPreviousSibling();
-
-            // <style> elements are traditionally separated unless it follows a comment
-            if (TAG_STYLE.equals(element.getTagName())) {
-                if (curr == null
-                        || curr.getNodeType() == Node.ELEMENT_NODE
-                        || (curr.getNodeType() == Node.TEXT_NODE
-                        && curr.getNodeValue().trim().isEmpty()
-                        && (curr.getPreviousSibling() == null
-                        || curr.getPreviousSibling().getNodeType()
-                        == Node.ELEMENT_NODE))) {
-                    return true;
-                }
-            }
-
-            // In all other styles, we separate elements if they have a different tag than
-            // the previous one (but we don't insert a newline inside tags)
-            while (curr != null) {
-                short nodeType = curr.getNodeType();
-                if (nodeType == Node.ELEMENT_NODE) {
-                    Element sibling = (Element) curr;
-                    if (!element.getTagName().equals(sibling.getTagName())) {
-                        return true;
-                    }
-                    break;
-                } else if (nodeType == Node.TEXT_NODE) {
-                    String text = curr.getNodeValue();
-                    if (!text.trim().isEmpty()) {
-                        break;
-                    }
-                    // If there is just whitespace, continue looking for a previous sibling
-                } else {
-                    // Any other previous node type, such as a comment, means we don't
-                    // continue looking: this element should not be separated
-                    break;
-                }
-                curr = curr.getPreviousSibling();
-            }
-            if (curr == null && depth <= 1) {
-                // Insert new line inside tag if it's the first element inside the root tag
-                return true;
-            }
-
-            return false;
-        }
-
-        return false;
-    }
-
-    private boolean indentBeforeElementOpen(Element element, int depth) {
-        if (isMarkupElement(element)) {
-            return false;
-        }
-
-        if (element.getParentNode().getNodeType() == Node.ELEMENT_NODE
-                && keepElementAsSingleLine(depth - 1, (Element) element.getParentNode())) {
-            return false;
-        }
-
-        return true;
-    }
-
-    private boolean indentBeforeElementClose(Element element, int depth) {
-        if (isMarkupElement(element)) {
-            return false;
-        }
-
-        char lastOutChar = mOut.charAt(mOut.length() - 1);
-        char lastDelimiterChar = mLineSeparator.charAt(mLineSeparator.length() - 1);
-        return lastOutChar == lastDelimiterChar;
-    }
-
-    private boolean newlineAfterElementOpen(Element element, int depth, boolean isClosed) {
-        if (hasBlankLineAbove()) {
-            return false;
-        }
-
-        if (isMarkupElement(element)) {
-            return false;
-        }
-
-        // In resource files we keep the child content directly on the same
-        // line as the element (unless it has children). in other files, separate them
-        return isClosed || !keepElementAsSingleLine(depth, element);
-    }
-
-    private boolean newlineBeforeElementClose(Element element, int depth) {
-        if (hasBlankLineAbove()) {
-            return false;
-        }
-
-        if (isMarkupElement(element)) {
-            return false;
-        }
-
-        return depth == 0 && !mPrefs.removeEmptyLines;
-    }
-
-    private boolean hasBlankLineAbove() {
-        if (mOut.length() < 2 * mLineSeparator.length()) {
-            return false;
-        }
-
-        return SdkUtils.endsWith(mOut, mLineSeparator) &&
-                SdkUtils.endsWith(mOut, mOut.length() - mLineSeparator.length(), mLineSeparator);
-    }
-
-    private boolean newlineAfterElementClose(Element element, int depth) {
-        if (hasBlankLineAbove()) {
-            return false;
-        }
-
-        if (isMarkupElement(element)) {
-            return false;
-        }
-
-        return element.getParentNode().getNodeType() == Node.ELEMENT_NODE
-                && !keepElementAsSingleLine(depth - 1, (Element) element.getParentNode());
-    }
-
-    private boolean isMarkupElement(Element element) {
-        // The documentation suggests that the allowed tags are <u>, <b> and <i>:
-        //   developer.android.com/guide/topics/resources/string-resource.html#FormattingAndStyling
-        // However, the full set of tags accepted by Html.fromHtml is much larger. Therefore,
-        // instead consider *any* element nested inside a <string> definition to be a markup
-        // element. See frameworks/base/core/java/android/text/Html.java and look for
-        // HtmlToSpannedConverter#handleStartTag.
-
-        if (mStyle != XmlFormatStyle.RESOURCE) {
-            return false;
-        }
-
-        Node curr = element.getParentNode();
-        while (curr != null) {
-            if (TAG_STRING.equals(curr.getNodeName())) {
-                return true;
-            }
-
-            curr = curr.getParentNode();
-        }
-
-        return false;
-    }
-
-    /**
-     * TODO: Explain why we need to do per-tag decisions on whether to keep them on the
-     * same line or not. Show that we can't just do it by depth, or by file type.
-     * (style versus plurals example)
-     * @param element the element whose tag we want to check
-     * @return true if the element is a single line tag
-     */
-    private boolean isSingleLineTag(Element element) {
-        String tag = element.getTagName();
-
-        return (tag.equals(TAG_ITEM) && mStyle == XmlFormatStyle.RESOURCE)
-                || tag.equals(TAG_STRING)
-                || tag.equals(TAG_DIMEN)
-                || tag.equals(TAG_COLOR);
-    }
-
-    private boolean keepElementAsSingleLine(int depth, Element element) {
-        if (depth == 0) {
-            return false;
-        }
-
-        return isSingleLineTag(element)
-                || (mStyle == XmlFormatStyle.RESOURCE
-                && !XmlUtils.hasElementChildren(element));
-    }
-
-    private void indent(int depth) {
-        int i = 0;
-
-        if (mIndentationLevels != null) {
-            for (int j = Math.min(depth, mIndentationLevels.length - 1); j >= 0; j--) {
-                String indent = mIndentationLevels[j];
-                if (indent != null) {
-                    mOut.append(indent);
-                    i = j;
-                    break;
-                }
-            }
-        }
-
-        for (; i < depth; i++) {
-            mOut.append(mIndentString);
-        }
-    }
-
-    /**
-     * Returns true if the given element should be an empty tag
-     *
-     * @param element the element to test
-     * @return true if this element should be an empty tag
-     */
-    @SuppressWarnings("MethodMayBeStatic") // Intentionally instance method so it can be overridden
-    protected boolean isEmptyTag(Element element) {
-        if (element.getFirstChild() != null) {
-            return false;
-        }
-
-        String tag = element.getTagName();
-        if (TAG_STRING.equals(tag)) {
-            return false;
-        }
-
-        return true;
-    }
-
-    private static void printUsage() throws ExitWithErrorStatusException {
-        System.out.println("Usage: " + XmlPrettyPrinter.class.getSimpleName() +
-                " <options>... <files or directories...>");
-        System.out.println("OPTIONS:");
-        System.out.println("--stdout");
-        System.out.println("--removeEmptyLines");
-        System.out.println("--noAttributeOnFirstLine");
-        System.out.println("--noSpaceBeforeClose");
-        throw new ExitWithErrorStatusException();
-    }
-
-    /** Command line driver */
-    public static void main(String[] args) {
-        try {
-            mainThrowOnFailure(args);
-        } catch (ExitWithErrorStatusException e) {
-            System.exit(1);
-        }
-        System.exit(0);
-    }
-
-    @VisibleForTesting
-    static void mainThrowOnFailure(@NonNull String[] args) throws ExitWithErrorStatusException {
-        if (args.length == 0) {
-            printUsage();
-        }
-
-        List<File> files = Lists.newArrayList();
-
-        XmlFormatPreferences prefs = XmlFormatPreferences.defaults();
-        boolean stdout = false;
-
-        for (String arg : args) {
-            if (arg.startsWith("--")) {
-                if ("--stdout".equals(arg)) {
-                    stdout = true;
-                } else if ("--removeEmptyLines".equals(arg)) {
-                    prefs.removeEmptyLines = true;
-                } else if ("--noAttributeOnFirstLine".equals(arg)) {
-                    prefs.oneAttributeOnFirstLine = false;
-                } else if ("--noSpaceBeforeClose".equals(arg)) {
-                    prefs.spaceBeforeClose = false;
-                } else {
-                    System.err.println("Unknown flag " + arg);
-                    printUsage();
-                }
-            } else {
-                File file = new File(arg).getAbsoluteFile();
-                if (!file.exists()) {
-                    System.err.println("Can't find file " + file);
-                    throw new ExitWithErrorStatusException();
-                } else {
-                    files.add(file);
-                }
-            }
-        }
-
-        for (File file : files) {
-            formatFile(prefs, file, stdout);
-        }
-    }
-
-    private static void formatFile(@NonNull XmlFormatPreferences prefs, File file,
-                                   boolean stdout) throws ExitWithErrorStatusException {
-        if (file.isDirectory()) {
-            File[] files = file.listFiles();
-            if (files != null) {
-                for (File child : files) {
-                    formatFile(prefs, child, stdout);
-                }
-            }
-        } else if (file.isFile() && SdkUtils.endsWithIgnoreCase(file.getName(), DOT_XML)) {
-            XmlFormatStyle style = null;
-            if (file.getName().equals(SdkConstants.ANDROID_MANIFEST_XML)) {
-                style = XmlFormatStyle.MANIFEST;
-            } else {
-                File parent = file.getParentFile();
-                if (parent != null) {
-                    String parentName = parent.getName();
-                    ResourceFolderType folderType = ResourceFolderType.getFolderType(parentName);
-                    if (folderType == ResourceFolderType.LAYOUT) {
-                        style = XmlFormatStyle.LAYOUT;
-                    } else if (folderType == ResourceFolderType.VALUES) {
-                        style = XmlFormatStyle.RESOURCE;
-                    }
-                }
-            }
-
-            try {
-                String xml = Files.toString(file, Charsets.UTF_8);
-                Document document = XmlUtils.parseDocumentSilently(xml, true);
-                if (document == null) {
-                    System.err.println("Could not parse " + file);
-                    throw new ExitWithErrorStatusException();
-                }
-
-                if (style == null) {
-                    style = XmlFormatStyle.get(document);
-                }
-                boolean endWithNewline = xml.endsWith("\n");
-                int firstNewLine = xml.indexOf('\n');
-                String lineSeparator = firstNewLine > 0 && xml.charAt(firstNewLine - 1) == '\r' ?
-                        "\r\n" : "\n";
-                String formatted = XmlPrettyPrinter.prettyPrint(document, prefs, style,
-                        lineSeparator, endWithNewline);
-                if (stdout) {
-                    System.out.println(formatted);
-                } else {
-                    Files.asCharSink(file, Charsets.UTF_8).write(formatted);
-                }
-            } catch (IOException e) {
-                System.err.println("Could not read " + file);
-                throw new ExitWithErrorStatusException();
-            }
-        }
-    }
-
-    @VisibleForTesting
-    static final class ExitWithErrorStatusException extends Exception {
-    }
-
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractResource.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractResource.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractResource.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/IAbstractResource.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,14 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-public interface IAbstractResource {
-
-    String getName();
-
-    String getLocation();
-
-    boolean exists();
-
-    IAbstractFolder getParentFolder();
-
-    boolean delete();
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatPreferences.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatPreferences.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatPreferences.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlFormatPreferences.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,79 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.annotations.VisibleForTesting;
-import java.util.Comparator;
-import org.w3c.dom.Attr;
-
-/**
- * Formatting preferences used by the Android XML formatter.
- */
-public class XmlFormatPreferences {
-    /** Use the Eclipse indent (tab/space, indent size) settings? */
-    public boolean useEclipseIndent = false;
-
-    /** Remove empty lines in all cases? */
-    public boolean removeEmptyLines = false;
-
-    /** Reformat the text and comment blocks? */
-    public boolean reflowText = false;
-
-    /** Join lines when reformatting text and comment blocks? */
-    public boolean joinLines = false;
-
-    /** Can attributes appear on the same line as the opening line if there is just one of them? */
-    public boolean oneAttributeOnFirstLine = true;
-
-    /** The sorting order to use when formatting */
-    public XmlAttributeSortOrder sortAttributes = XmlAttributeSortOrder.LOGICAL;
-
-    /** Returns the comparator to use when formatting, or null for no sorting */
-    @Nullable
-    public Comparator<Attr> getAttributeComparator() {
-        return sortAttributes.getAttributeComparator();
-    }
-
-    /** Should there be a space before the closing {@code >}; or {@code >/;} ? */
-    public boolean spaceBeforeClose = true;
-
-    /** The string to insert for each indentation level */
-    protected String mOneIndentUnit = "    "; //$NON-NLS-1$
-
-    /** Tab width (number of spaces to display for a tab) */
-    protected int mTabWidth = -1; // -1: uninitialized
-
-    @VisibleForTesting
-    protected XmlFormatPreferences() {
-    }
-
-    /**
-     * Returns a new preferences object initialized with the defaults
-     *
-     * @return an {@link XmlFormatPreferences} object
-     */
-    @NonNull
-    public static XmlFormatPreferences defaults() {
-        return new XmlFormatPreferences();
-    }
-
-    public String getOneIndentUnit() {
-        return mOneIndentUnit;
-    }
-
-    /**
-     * Returns the number of spaces used to display a single tab character
-     *
-     * @return the number of spaces used to display a single tab character
-     */
-    @SuppressWarnings("restriction") // Editor settings
-    public int getTabWidth() {
-        if (mTabWidth == -1) {
-            mTabWidth = 4;
-        }
-
-        return mTabWidth;
-    }
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifestParser.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifestParser.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifestParser.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/AndroidManifestParser.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,779 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-import com.tyron.build.compiler.manifest.SdkConstants;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.tyron.build.compiler.manifest.resources.Keyboard;
-import com.tyron.build.compiler.manifest.resources.Navigation;
-import com.tyron.build.compiler.manifest.resources.TouchScreen;
-import com.tyron.build.compiler.manifest.xml.ManifestData.Activity;
-import com.tyron.build.compiler.manifest.xml.ManifestData.Instrumentation;
-import com.tyron.build.compiler.manifest.xml.ManifestData.SupportsScreens;
-import com.tyron.build.compiler.manifest.xml.ManifestData.UsesConfiguration;
-import com.tyron.build.compiler.manifest.xml.ManifestData.UsesFeature;
-import com.tyron.build.compiler.manifest.xml.ManifestData.UsesLibrary;
-import com.tyron.build.util.XmlUtils;
-
-import java.io.BufferedInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.Locale;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import org.xml.sax.Attributes;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.Locator;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXParseException;
-import org.xml.sax.helpers.DefaultHandler;
-
-/**
- * Full Manifest parser that parses the manifest in details, including activities, instrumentations,
- * support-screens, and uses-configuration.
- */
-public class AndroidManifestParser {
-
-    private static final int LEVEL_TOP = 0;
-    private static final int LEVEL_INSIDE_MANIFEST = 1;
-    private static final int LEVEL_INSIDE_APPLICATION = 2;
-    private static final int LEVEL_INSIDE_APP_COMPONENT = 3;
-    private static final int LEVEL_INSIDE_INTENT_FILTER = 4;
-
-    private static final String ACTION_MAIN = "android.intent.action.MAIN"; //$NON-NLS-1$
-    private static final String CATEGORY_LAUNCHER = "android.intent.category.LAUNCHER"; //$NON-NLS-1$
-
-    public interface ManifestErrorHandler extends ErrorHandler {
-        /**
-         * Handles a parsing error and an optional line number.
-         */
-        void handleError(Exception exception, int lineNumber);
-
-        /**
-         * Checks that a class is valid and can be used in the Android Manifest.
-         * <p>
-         * Errors are put as {@code org.eclipse.core.resources.IMarker} on the manifest file.
-         *
-         * @param className the fully qualified name of the class to test.
-         * @param superClassName the fully qualified name of the class it is supposed to extend.
-         * @param testVisibility if <code>true</code>, the method will check the visibility of
-         * the class or of its constructors.
-         */
-        void checkClass(Locator locator, String className, String superClassName,
-                        boolean testVisibility);
-    }
-
-    /**
-     * XML error and data handler used when parsing the AndroidManifest.xml file.
-     * <p>
-     * During parsing this will fill up the {@link ManifestData} object given to the constructor
-     * and call out errors to the given {@link ManifestErrorHandler}.
-     */
-    private static class ManifestHandler extends DefaultHandler {
-
-        // --- temporary data/flags used during parsing
-        @Nullable private final ManifestData mManifestData;
-        @Nullable private final ManifestErrorHandler mErrorHandler;
-        private int mCurrentLevel = 0;
-        private int mValidLevel = 0;
-        private Activity mCurrentActivity = null;
-        private Locator mLocator;
-
-        /**
-         * Creates a new {@link ManifestHandler}.
-         *
-         * @param manifestData Class containing the manifest info obtained during the parsing.
-         * @param errorHandler An optional error handler.
-         */
-        ManifestHandler(
-                @Nullable ManifestData manifestData, @Nullable ManifestErrorHandler errorHandler) {
-            super();
-            mManifestData = manifestData;
-            mErrorHandler = errorHandler;
-        }
-
-        /* (non-Javadoc)
-         * @see org.xml.sax.helpers.DefaultHandler#setDocumentLocator(org.xml.sax.Locator)
-         */
-        @Override
-        public void setDocumentLocator(Locator locator) {
-            mLocator = locator;
-            super.setDocumentLocator(locator);
-        }
-
-        /* (non-Javadoc)
-         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String,
-         * java.lang.String, org.xml.sax.Attributes)
-         */
-        @Override
-        public void startElement(String uri, String localName, String name, Attributes attributes)
-                throws SAXException {
-            try {
-                if (mManifestData == null) {
-                    return;
-                }
-
-                // if we're at a valid level
-                if (mValidLevel == mCurrentLevel) {
-                    String value;
-                    switch (mValidLevel) {
-                        case LEVEL_TOP:
-                            if (AndroidManifest.NODE_MANIFEST.equals(localName)) {
-                                // lets get the package name.
-                                mManifestData.mPackage =
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_PACKAGE,
-                                                false /* hasNamespace */);
-
-                                // and the versionCode
-                                String tmp =
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_VERSIONCODE,
-                                                true);
-                                if (tmp != null) {
-                                    try {
-                                        mManifestData.mVersionCode = Integer.valueOf(tmp);
-                                    } catch (NumberFormatException e) {
-                                        // keep null in the field.
-                                    }
-                                }
-                                // and the versionName
-                                mManifestData.mVersionName =
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_VERSIONNAME,
-                                                true /* hasNamespace */);
-                                mValidLevel++;
-                            }
-                            break;
-                        case LEVEL_INSIDE_MANIFEST:
-                            if (AndroidManifest.NODE_APPLICATION.equals(localName)) {
-                                processApplicationNode(attributes);
-                                mValidLevel++;
-                            } else if (AndroidManifest.NODE_USES_SDK.equals(localName)) {
-                                mManifestData.setMinSdkVersionString(
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_MIN_SDK_VERSION,
-                                                true /* hasNamespace */));
-                                mManifestData.setTargetSdkVersionString(
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_TARGET_SDK_VERSION,
-                                                true /* hasNamespace */));
-                            } else if (AndroidManifest.NODE_INSTRUMENTATION.equals(localName)) {
-                                processInstrumentationNode(attributes);
-
-                            } else if (AndroidManifest.NODE_SUPPORTS_SCREENS.equals(localName)) {
-                                processSupportsScreensNode(attributes);
-
-                            } else if (AndroidManifest.NODE_USES_CONFIGURATION.equals(localName)) {
-                                processUsesConfiguration(attributes);
-
-                            } else if (AndroidManifest.NODE_USES_FEATURE.equals(localName)) {
-                                UsesFeature feature = new UsesFeature();
-
-                                // get the name
-                                value =
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_NAME,
-                                                true /* hasNamespace */);
-                                if (value != null) {
-                                    feature.mName = value;
-                                }
-
-                                // read the required attribute
-                                value =
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_REQUIRED,
-                                                true /*hasNamespace*/);
-                                if (value != null) {
-                                    Boolean b = Boolean.valueOf(value);
-                                    if (b != null) {
-                                        feature.mRequired = b;
-                                    }
-                                }
-
-                                // read the gl es attribute
-                                value =
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_GLESVERSION,
-                                                true /*hasNamespace*/);
-                                if (value != null) {
-                                    try {
-                                        int version = Integer.decode(value);
-                                        feature.mGlEsVersion = version;
-                                    } catch (NumberFormatException e) {
-                                        // ignore
-                                    }
-                                }
-
-                                mManifestData.mFeatures.add(feature);
-                            } else if (AndroidManifest.NODE_PERMISSION.equals(localName)) {
-                                processPermissionNode(attributes);
-                            }
-                            break;
-                        case LEVEL_INSIDE_APPLICATION:
-                            if (AndroidManifest.NODE_ACTIVITY.equals(localName)
-                                    || AndroidManifest.NODE_ACTIVITY_ALIAS.equals(localName)) {
-                                processActivityNode(attributes);
-                                mValidLevel++;
-                            } else if (AndroidManifest.NODE_SERVICE.equals(localName)) {
-                                processNode(attributes, SdkConstants.CLASS_SERVICE, localName);
-                                mValidLevel++;
-                            } else if (AndroidManifest.NODE_RECEIVER.equals(localName)) {
-                                processNode(
-                                        attributes,
-                                        SdkConstants.CLASS_BROADCASTRECEIVER,
-                                        localName);
-                                mValidLevel++;
-                            } else if (AndroidManifest.NODE_PROVIDER.equals(localName)) {
-                                processNode(
-                                        attributes, SdkConstants.CLASS_CONTENTPROVIDER, localName);
-                                mValidLevel++;
-                            } else if (AndroidManifest.NODE_USES_LIBRARY.equals(localName)) {
-                                value =
-                                        getAttributeValue(
-                                                attributes,
-                                                AndroidManifest.ATTRIBUTE_NAME,
-                                                true /* hasNamespace */);
-                                if (value != null) {
-                                    UsesLibrary library = new UsesLibrary();
-                                    library.mName = value;
-
-                                    // read the required attribute
-                                    value =
-                                            getAttributeValue(
-                                                    attributes,
-                                                    AndroidManifest.ATTRIBUTE_REQUIRED,
-                                                    true /*hasNamespace*/);
-                                    if (value != null) {
-                                        Boolean b = Boolean.valueOf(value);
-                                        if (b != null) {
-                                            library.mRequired = b;
-                                        }
-                                    }
-
-                                    mManifestData.mLibraries.add(library);
-                                }
-                            }
-                            break;
-                        case LEVEL_INSIDE_APP_COMPONENT:
-                            // only process this level if we are in an activity
-                            if (mCurrentActivity != null &&
-                                    AndroidManifest.NODE_INTENT.equals(localName)) {
-                                mCurrentActivity.resetIntentFilter();
-                                mValidLevel++;
-                            }
-                            break;
-                        case LEVEL_INSIDE_INTENT_FILTER:
-                            if (mCurrentActivity != null) {
-                                if (AndroidManifest.NODE_ACTION.equals(localName)) {
-                                    // get the name attribute
-                                    String action = getAttributeValue(attributes,
-                                            AndroidManifest.ATTRIBUTE_NAME,
-                                            true /* hasNamespace */);
-                                    if (action != null) {
-                                        mCurrentActivity.setHasAction(true);
-                                        mCurrentActivity.setHasMainAction(
-                                                ACTION_MAIN.equals(action));
-                                    }
-                                } else if (AndroidManifest.NODE_CATEGORY.equals(localName)) {
-                                    String category = getAttributeValue(attributes,
-                                            AndroidManifest.ATTRIBUTE_NAME,
-                                            true /* hasNamespace */);
-                                    if (CATEGORY_LAUNCHER.equals(category)) {
-                                        mCurrentActivity.setHasLauncherCategory(true);
-                                    }
-                                }
-
-                                // no need to increase mValidLevel as we don't process anything
-                                // below this level.
-                            }
-                            break;
-                    }
-                }
-
-                mCurrentLevel++;
-            } finally {
-                super.startElement(uri, localName, name, attributes);
-            }
-        }
-
-        /* (non-Javadoc)
-         * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String, java.lang.String,
-         * java.lang.String)
-         */
-        @Override
-        public void endElement(String uri, String localName, String name) throws SAXException {
-            try {
-                if (mManifestData == null) {
-                    return;
-                }
-
-                // decrement the levels.
-                if (mValidLevel == mCurrentLevel) {
-                    mValidLevel--;
-                }
-                mCurrentLevel--;
-
-                // if we're at a valid level
-                // process the end of the element
-                if (mValidLevel == mCurrentLevel) {
-                    switch (mValidLevel) {
-                        case LEVEL_INSIDE_APPLICATION:
-                            mCurrentActivity = null;
-                            break;
-                        case LEVEL_INSIDE_APP_COMPONENT:
-                            // if we found both a main action and a launcher category, this is our
-                            // launcher activity!
-                            if (mManifestData.mLauncherActivity == null &&
-                                    mCurrentActivity != null &&
-                                    mCurrentActivity.isHomeActivity() &&
-                                    mCurrentActivity.isExported()) {
-                                mManifestData.mLauncherActivity = mCurrentActivity;
-                            }
-                            break;
-                        default:
-                            break;
-                    }
-
-                }
-            } finally {
-                super.endElement(uri, localName, name);
-            }
-        }
-
-        /* (non-Javadoc)
-         * @see org.xml.sax.helpers.DefaultHandler#error(org.xml.sax.SAXParseException)
-         */
-        @Override
-        public void error(SAXParseException e) {
-            if (mErrorHandler != null) {
-                mErrorHandler.handleError(e, e.getLineNumber());
-            }
-        }
-
-        /* (non-Javadoc)
-         * @see org.xml.sax.helpers.DefaultHandler#fatalError(org.xml.sax.SAXParseException)
-         */
-        @Override
-        public void fatalError(SAXParseException e) {
-            if (mErrorHandler != null) {
-                mErrorHandler.handleError(e, e.getLineNumber());
-            }
-        }
-
-        /* (non-Javadoc)
-         * @see org.xml.sax.helpers.DefaultHandler#warning(org.xml.sax.SAXParseException)
-         */
-        @Override
-        public void warning(SAXParseException e) throws SAXException {
-            if (mErrorHandler != null) {
-                mErrorHandler.warning(e);
-            }
-        }
-
-        /**
-         * Processes the application node.
-         *
-         * @param attributes the attributes for the application node.
-         */
-        private void processApplicationNode(Attributes attributes) {
-            String value =
-                    getAttributeValue(
-                            attributes, AndroidManifest.ATTRIBUTE_PROCESS, true /* hasNamespace */);
-            if (value != null) {
-                mManifestData.addProcessName(value);
-                mManifestData.mDefaultProcess = value;
-            }
-
-            value =
-                    getAttributeValue(
-                            attributes,
-                            AndroidManifest.ATTRIBUTE_DEBUGGABLE,
-                            true /* hasNamespace*/);
-            if (value != null) {
-                mManifestData.mDebuggable = Boolean.parseBoolean(value);
-            }
-
-            value =
-                    getAttributeValue(
-                            attributes, AndroidManifest.ATTRIBUTE_NAME, true /* hasNamespace*/);
-
-            if (value != null) {
-                mManifestData.mKeepClasses.add(
-                        new ManifestData.KeepClass(
-                                combinePackageAndClassName(mManifestData.mPackage, value),
-                                null,
-                                AndroidManifest.NODE_APPLICATION));
-            }
-
-            value =
-                    getAttributeValue(
-                            attributes,
-                            AndroidManifest.ATTRIBUTE_BACKUP_AGENT,
-                            true /* hasNamespace*/);
-
-            if (value != null) {
-                mManifestData.mKeepClasses.add(
-                        new ManifestData.KeepClass(
-                                combinePackageAndClassName(mManifestData.mPackage, value),
-                                null,
-                                AndroidManifest.ATTRIBUTE_BACKUP_AGENT));
-            }
-        }
-
-        /**
-         * Processes the activity node.
-         *
-         * @param attributes the attributes for the activity node.
-         */
-        private void processActivityNode(Attributes attributes) {
-            // lets get the activity name, and add it to the list
-            String activityName = getAttributeValue(attributes, AndroidManifest.ATTRIBUTE_NAME,
-                    true /* hasNamespace */);
-            if (activityName != null) {
-                activityName = combinePackageAndClassName(mManifestData.mPackage, activityName);
-
-                // get the exported flag.
-                String exportedStr = getAttributeValue(attributes,
-                        AndroidManifest.ATTRIBUTE_EXPORTED, true);
-                boolean exported = exportedStr == null ||
-                        exportedStr.toLowerCase(Locale.US).equals("true"); //$NON-NLS-1$
-                mCurrentActivity = new Activity(activityName, exported);
-                mManifestData.mActivities.add(mCurrentActivity);
-
-                if (mErrorHandler != null) {
-                    mErrorHandler.checkClass(mLocator, activityName, SdkConstants.CLASS_ACTIVITY,
-                            true /* testVisibility */);
-                }
-            } else {
-                // no activity found! Aapt will output an error,
-                // so we don't have to do anything
-                mCurrentActivity = null;
-            }
-
-            String processName = getAttributeValue(attributes, AndroidManifest.ATTRIBUTE_PROCESS,
-                    true /* hasNamespace */);
-            if (processName != null) {
-                mManifestData.addProcessName(processName);
-            }
-
-            if (processName == null || processName.isEmpty()) {
-                processName = mManifestData.getDefaultProcess();
-            }
-
-            if (activityName != null) {
-                mManifestData.mKeepClasses.add(
-                        new ManifestData.KeepClass(
-                                activityName, processName, AndroidManifest.NODE_ACTIVITY));
-            }
-        }
-
-        /**
-         * Processes the service/receiver/provider nodes.
-         *
-         * @param attributes the attributes for the activity node.
-         * @param superClassName the fully qualified name of the super class that this
-         * @param localName the tag of the node node is representing
-         */
-        private void processNode(Attributes attributes, String superClassName, String localName) {
-            // lets get the class name, and check it if required.
-            String serviceName = getAttributeValue(attributes, AndroidManifest.ATTRIBUTE_NAME,
-                    true /* hasNamespace */);
-            if (serviceName != null) {
-                serviceName = combinePackageAndClassName(mManifestData.mPackage, serviceName);
-
-                if (mErrorHandler != null) {
-                    mErrorHandler.checkClass(mLocator, serviceName, superClassName,
-                            false /* testVisibility */);
-                }
-            }
-
-            String processName = getAttributeValue(attributes, AndroidManifest.ATTRIBUTE_PROCESS,
-                    true /* hasNamespace */);
-            if (processName != null) {
-                mManifestData.addProcessName(processName);
-            }
-
-            if (processName == null || processName.isEmpty()) {
-                processName = mManifestData.getDefaultProcess();
-            }
-
-            if (serviceName != null) {
-                mManifestData.mKeepClasses.add(
-                        new ManifestData.KeepClass(serviceName, processName, localName));
-            }
-        }
-
-        /**
-         * Processes the instrumentation node.
-         * @param attributes the attributes for the instrumentation node.
-         */
-        private void processInstrumentationNode(Attributes attributes) {
-            // lets get the class name, and check it if required.
-            String instrumentationName = getAttributeValue(attributes,
-                    AndroidManifest.ATTRIBUTE_NAME,
-                    true /* hasNamespace */);
-            if (instrumentationName != null) {
-                String instrClassName =
-                        combinePackageAndClassName(mManifestData.mPackage, instrumentationName);
-                String targetPackage = getAttributeValue(attributes,
-                        AndroidManifest.ATTRIBUTE_TARGET_PACKAGE,
-                        true /* hasNamespace */);
-                mManifestData.mInstrumentations.add(
-                        new Instrumentation(instrClassName, targetPackage));
-                mManifestData.mKeepClasses.add(
-                        new ManifestData.KeepClass(
-                                instrClassName, null, AndroidManifest.NODE_INSTRUMENTATION));
-                if (mErrorHandler != null) {
-                    mErrorHandler.checkClass(mLocator, instrClassName,
-                            SdkConstants.CLASS_INSTRUMENTATION, true /* testVisibility */);
-                }
-            }
-        }
-
-        /**
-         * Processes the supports-screens node.
-         * @param attributes the attributes for the supports-screens node.
-         */
-        private void processSupportsScreensNode(Attributes attributes) {
-            mManifestData.mSupportsScreensFromManifest = new SupportsScreens();
-
-            mManifestData.mSupportsScreensFromManifest.setResizeable(getAttributeBooleanValue(
-                    attributes, AndroidManifest.ATTRIBUTE_RESIZEABLE, true /*hasNamespace*/));
-
-            mManifestData.mSupportsScreensFromManifest.setAnyDensity(getAttributeBooleanValue(
-                    attributes, AndroidManifest.ATTRIBUTE_ANYDENSITY, true /*hasNamespace*/));
-
-            mManifestData.mSupportsScreensFromManifest.setSmallScreens(getAttributeBooleanValue(
-                    attributes, AndroidManifest.ATTRIBUTE_SMALLSCREENS, true /*hasNamespace*/));
-
-            mManifestData.mSupportsScreensFromManifest.setNormalScreens(getAttributeBooleanValue(
-                    attributes, AndroidManifest.ATTRIBUTE_NORMALSCREENS, true /*hasNamespace*/));
-
-            mManifestData.mSupportsScreensFromManifest.setLargeScreens(getAttributeBooleanValue(
-                    attributes, AndroidManifest.ATTRIBUTE_LARGESCREENS, true /*hasNamespace*/));
-        }
-
-        /**
-         * Processes the supports-screens node.
-         * @param attributes the attributes for the supports-screens node.
-         */
-        private void processUsesConfiguration(Attributes attributes) {
-            mManifestData.mUsesConfiguration = new UsesConfiguration();
-
-            mManifestData.mUsesConfiguration.mReqFiveWayNav = getAttributeBooleanValue(
-                    attributes,
-                    AndroidManifest.ATTRIBUTE_REQ_5WAYNAV, true /*hasNamespace*/);
-            mManifestData.mUsesConfiguration.mReqNavigation = Navigation.getEnum(
-                    getAttributeValue(attributes,
-                            AndroidManifest.ATTRIBUTE_REQ_NAVIGATION, true /*hasNamespace*/));
-            mManifestData.mUsesConfiguration.mReqHardKeyboard = getAttributeBooleanValue(
-                    attributes,
-                    AndroidManifest.ATTRIBUTE_REQ_HARDKEYBOARD, true /*hasNamespace*/);
-            mManifestData.mUsesConfiguration.mReqKeyboardType = Keyboard.getEnum(
-                    getAttributeValue(attributes,
-                            AndroidManifest.ATTRIBUTE_REQ_KEYBOARDTYPE, true /*hasNamespace*/));
-            mManifestData.mUsesConfiguration.mReqTouchScreen = TouchScreen.getEnum(
-                    getAttributeValue(attributes,
-                            AndroidManifest.ATTRIBUTE_REQ_TOUCHSCREEN, true /*hasNamespace*/));
-        }
-
-        private void processPermissionNode(Attributes attributes) {
-            mManifestData.mCustomPermissions.add(
-                    getAttributeValue(attributes, AndroidManifest.ATTRIBUTE_NAME, true));
-        }
-
-        /**
-         * Searches through the attributes list for a particular one and returns its value.
-         *
-         * @param attributes the attribute list to search through
-         * @param attributeName the name of the attribute to look for.
-         * @param hasNamespace indicates whether the attribute has an android namespace.
-         * @return a String with the value or null if the attribute was not found.
-         * @see SdkConstants#ANDROID_URI
-         */
-        private String getAttributeValue(
-                Attributes attributes, String attributeName, boolean hasNamespace) {
-            int count = attributes.getLength();
-            for (int i = 0 ; i < count ; i++) {
-                if (attributeName.equals(attributes.getLocalName(i))
-                        && ((hasNamespace && SdkConstants.ANDROID_URI.equals(attributes.getURI(i)))
-                        || (!hasNamespace && attributes.getURI(i).isEmpty()))) {
-                    return attributes.getValue(i);
-                }
-            }
-
-            return null;
-        }
-
-        /**
-         * Searches through the attributes list for a particular one and returns its value as a
-         * Boolean. If the attribute is not present, this will return null.
-         *
-         * @param attributes the attribute list to search through
-         * @param attributeName the name of the attribute to look for.
-         * @param hasNamespace indicates whether the attribute has an android namespace.
-         * @return a String with the value or null if the attribute was not found.
-         * @see SdkConstants#ANDROID_URI
-         */
-        private Boolean getAttributeBooleanValue(
-                Attributes attributes, String attributeName, boolean hasNamespace) {
-            int count = attributes.getLength();
-            for (int i = 0 ; i < count ; i++) {
-                if (attributeName.equals(attributes.getLocalName(i))
-                        && ((hasNamespace && SdkConstants.ANDROID_URI.equals(attributes.getURI(i)))
-                        || (!hasNamespace && attributes.getURI(i).isEmpty()))) {
-                    String attr = attributes.getValue(i);
-                    if (attr != null) {
-                        return Boolean.valueOf(attr);
-                    } else {
-                        return null;
-                    }
-                }
-            }
-
-            return null;
-        }
-
-        /**
-         * Combines a java package, with a class value from the manifest to make a fully qualified
-         * class name
-         *
-         * @param javaPackage the java package from the manifest.
-         * @param className the class name from the manifest.
-         * @return the fully qualified class name.
-         */
-        @Nullable
-        private static String combinePackageAndClassName(
-                @Nullable String javaPackage, @Nullable String className) {
-            if (className == null || className.isEmpty()) {
-                return javaPackage;
-            }
-            if (javaPackage == null || javaPackage.isEmpty()) {
-                return className;
-            }
-
-            // the class name can be a subpackage (starts with a '.'
-            // char), a simple class name (no dot), or a full java package
-            boolean startWithDot = (className.charAt(0) == '.');
-            boolean hasDot = (className.indexOf('.') != -1);
-            if (startWithDot || !hasDot) {
-
-                // add the concatenation of the package and class name
-                if (startWithDot) {
-                    return javaPackage + className;
-                } else {
-                    return javaPackage + '.' + className;
-                }
-            } else {
-                // just add the class as it should be a fully qualified java name.
-                return className;
-            }
-        }
-    }
-
-    private static final SAXParserFactory sParserFactory;
-
-    static {
-        sParserFactory = XmlUtils.getConfiguredSaxFactory(true, false);
-    }
-
-    /**
-     * Parses the Android Manifest, and returns a {@link ManifestData} object containing the result
-     * of the parsing.
-     *
-     * @param manifestFile the {@link IAbstractFile} representing the manifest file.
-     * @param gatherData indicates whether the parsing will extract data from the manifest. If false
-     *     the method will always return null.
-     * @param errorHandler an optional errorHandler.
-     * @return A class containing the manifest info obtained during the parsing, or null on error.
-     * @throws IOException If there was a problem parsing the file
-     * @throws SAXException If any SAX errors occurred during processing.
-     */
-    public static ManifestData parse(
-            IAbstractFile manifestFile, boolean gatherData, ManifestErrorHandler errorHandler)
-            throws IOException, SAXException {
-        if (manifestFile != null) {
-            SAXParser parser;
-            try {
-                parser = XmlUtils.createSaxParser(sParserFactory);
-            } catch (ParserConfigurationException | SAXException e) {
-                throw new RuntimeException(e);
-            }
-
-            ManifestData data = null;
-            if (gatherData) {
-                data = new ManifestData();
-            }
-
-            ManifestHandler manifestHandler = new ManifestHandler(data, errorHandler);
-
-            try (InputStream is = manifestFile.getContents()) {
-                parser.parse(new InputSource(is), manifestHandler);
-            } catch (StreamException e) {
-                throw new IOException(e);
-            }
-
-            return data;
-        }
-
-        return null;
-    }
-
-    /**
-     * Parses the Android Manifest, and returns an object containing the result of the parsing.
-     *
-     * <p>This is the equivalent of calling {@code parse(manifestFile, true, null)}.
-     *
-     * @param manifestFile the manifest file to parse.
-     */
-    public static ManifestData parse(IAbstractFile manifestFile) throws IOException, SAXException {
-        return parse(manifestFile, true, null);
-    }
-
-
-    /**
-     * Parses the Android Manifest from an {@link InputStream}, and returns a {@link ManifestData}
-     * object containing the result of the parsing.
-     *
-     * @param manifestFileStream the {@link InputStream} representing the manifest file.
-     * @return A class containing the manifest info obtained during the parsing or null on error.
-     */
-    public static ManifestData parse(InputStream manifestFileStream)
-            throws ParserConfigurationException, SAXException, IOException {
-        if (manifestFileStream != null) {
-            SAXParser parser = XmlUtils.createSaxParser(sParserFactory);
-
-            ManifestData data = new ManifestData();
-
-            ManifestHandler manifestHandler = new ManifestHandler(data, null);
-            parser.parse(new InputSource(manifestFileStream), manifestHandler);
-
-            return data;
-        }
-
-        return null;
-    }
-
-    @NonNull
-    public static ManifestData parse(@NonNull Path manifestFile) throws IOException {
-        try (InputStream is = new BufferedInputStream(Files.newInputStream(manifestFile))) {
-            return parse(is);
-        } catch (SAXException | ParserConfigurationException e) {
-            throw new IOException(e);
-        }
-    }
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlAttributeSortOrder.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlAttributeSortOrder.java b/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlAttributeSortOrder.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/xml/XmlAttributeSortOrder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,193 +0,0 @@
-package com.tyron.build.compiler.manifest.xml;
-
-import org.w3c.dom.Attr;
-
-import java.util.Comparator;
-
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_COLOR;
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_ID;
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_LAYOUT_HEIGHT;
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_LAYOUT_RESOURCE_PREFIX;
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_LAYOUT_WIDTH;
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_NAME;
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_STYLE;
-import static com.tyron.build.compiler.manifest.SdkConstants.XMLNS;
-import static com.google.common.base.Strings.nullToEmpty;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-/** Order to use when sorting attributes */
-public enum XmlAttributeSortOrder {
-    NO_SORTING("none"),     //$NON-NLS-1$
-    ALPHABETICAL("alpha"),  //$NON-NLS-1$
-    LOGICAL("logical");     //$NON-NLS-1$
-
-    XmlAttributeSortOrder(String key) {
-        this.key = key;
-    }
-
-    public final String key;
-
-    /**
-     * @return a comparator for use by this attribute sort order
-     */
-    @Nullable
-    public Comparator<Attr> getAttributeComparator() {
-        switch (this) {
-            case NO_SORTING:
-                return null;
-            case ALPHABETICAL:
-                return ALPHABETICAL_COMPARATOR;
-            case LOGICAL:
-            default:
-                return SORTED_ORDER_COMPARATOR;
-        }
-    }
-
-    /** Comparator which can be used to sort attributes in the coding style priority order */
-    private static final Comparator<Attr> SORTED_ORDER_COMPARATOR = new Comparator<Attr>() {
-        @Override
-        public int compare(Attr attr1, Attr attr2) {
-            // Namespace declarations should always go first
-            String prefix1 = attr1.getPrefix();
-            String prefix2 = attr2.getPrefix();
-            if (XMLNS.equals(prefix1)) {
-                if (XMLNS.equals(prefix2)) {
-                    return 0;
-                }
-                return -1;
-            } else if (XMLNS.equals(attr2.getPrefix())) {
-                return 1;
-            }
-
-            // Sort by preferred attribute order
-            String name1 = prefix1 != null ? attr1.getLocalName() : attr1.getName();
-            String name2 = prefix2 != null ? attr2.getLocalName() : attr2.getName();
-            return compareAttributes(prefix1, name1, prefix2, name2);
-        }
-    };
-
-    /**
-     * Comparator which can be used to sort attributes into alphabetical order (but xmlns
-     * is always first)
-     */
-    private static final Comparator<Attr> ALPHABETICAL_COMPARATOR = new Comparator<Attr>() {
-        @Override
-        public int compare(Attr attr1, Attr attr2) {
-            // Namespace declarations should always go first
-            if (XMLNS.equals(attr1.getPrefix())) {
-                if (XMLNS.equals(attr2.getPrefix())) {
-                    return 0;
-                }
-                return -1;
-            } else if (XMLNS.equals(attr2.getPrefix())) {
-                return 1;
-            }
-
-            // Sort by name rather than local name to ensure we sort by namespaces first,
-            // then by names.
-            return attr1.getName().compareTo(attr2.getName());
-        }
-    };
-
-    /**
-     * Returns {@link Comparator} values for ordering attributes in the following
-     * order:
-     * <ul>
-     *   <li> id
-     *   <li> style
-     *   <li> layout_width
-     *   <li> layout_height
-     *   <li> other layout params, sorted alphabetically
-     *   <li> other attributes, sorted alphabetically
-     * </ul>
-     *
-     * @param name1 the first attribute name to compare
-     * @param name2 the second attribute name to compare
-     * @return a negative number if name1 should be ordered before name2
-     */
-    public static int compareAttributes(String name1, String name2) {
-        int priority1 = getAttributePriority(name1);
-        int priority2 = getAttributePriority(name2);
-        if (priority1 != priority2) {
-            return priority1 - priority2;
-        }
-
-        // Sort remaining attributes alphabetically
-        return name1.compareTo(name2);
-    }
-
-    /**
-     * Returns {@link Comparator} values for ordering attributes in the following
-     * order:
-     * <ul>
-     *   <li> id
-     *   <li> style
-     *   <li> layout_width
-     *   <li> layout_height
-     *   <li> other layout params, sorted alphabetically
-     *   <li> other attributes, sorted alphabetically, first by namespace, then by name
-     * </ul>
-     * @param prefix1 the namespace prefix, if any, of {@code name1}
-     * @param name1 the first attribute name to compare
-     * @param prefix2  the namespace prefix, if any, of {@code name2}
-     * @param name2 the second attribute name to compare
-     * @return a negative number if name1 should be ordered before name2
-     */
-    public static int compareAttributes(
-            @Nullable String prefix1, @NonNull String name1,
-            @Nullable String prefix2, @NonNull String name2) {
-        int priority1 = getAttributePriority(name1);
-        int priority2 = getAttributePriority(name2);
-        if (priority1 != priority2) {
-            return priority1 - priority2;
-        }
-
-        int namespaceDelta = nullToEmpty(prefix1).compareTo(nullToEmpty(prefix2));
-        if (namespaceDelta != 0) {
-            return namespaceDelta;
-        }
-
-        // Sort remaining attributes alphabetically
-        return name1.compareTo(name2);
-    }
-
-
-    /** Returns a sorting priority for the given attribute name */
-    private static int getAttributePriority(String name) {
-        if (ATTR_ID.equals(name)) {
-            return 10;
-        }
-
-        if (ATTR_NAME.equals(name)) {
-            return 15;
-        }
-
-        if (ATTR_STYLE.equals(name)) {
-            return 20;
-        }
-
-        if (name.startsWith(ATTR_LAYOUT_RESOURCE_PREFIX)) {
-            // Width and height are special cased because we (a) want width and height
-            // before the other layout attributes, and (b) we want width to sort before height
-            // even though it comes after it alphabetically.
-            if (name.equals(ATTR_LAYOUT_WIDTH)) {
-                return 30;
-            }
-            if (name.equals(ATTR_LAYOUT_HEIGHT)) {
-                return 40;
-            }
-
-            return 50;
-        }
-
-        // "color" sorts to the end
-        if (ATTR_COLOR.equals(name)) {
-            return 100;
-        }
-
-        return 60;
-    }
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/Message.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/Message.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/Message.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/Message.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,84 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import com.google.common.collect.ImmutableList;
-
-import java.io.File;
-import java.util.List;
-
-public class Message {
-
-    private final Kind kind;
-    private final String text;
-    private final List<SourceFilePosition> sourceFilePositions;
-    private final String rawMessage;
-    private final String toolName;
-    
-    public Message(Kind kind, String text) {
-        this(kind, text, text, null, ImmutableList.of(SourceFilePosition.UNKNOWN));
-    }
-
-    public Message(Kind kind, String text, String rawMessage, String toolName, List<SourceFilePosition> sourceFilePositions) {
-        if (sourceFilePositions.isEmpty()) {
-            throw new IllegalArgumentException("SourceFilePositions cannot be empty");
-        }
-
-        this.kind = kind;
-        this.text = text;
-        this.sourceFilePositions = sourceFilePositions;
-        this.rawMessage = rawMessage;
-        this.toolName = toolName;
-    }
-
-    public Message(Kind kind, String text, String rawMessage, SourceFilePosition sourceFilePosition, SourceFilePosition... sourceFilePositions) {
-        this(kind, text, rawMessage, null, new ImmutableList.Builder<SourceFilePosition>()
-                .add(sourceFilePosition)
-                .add(sourceFilePositions)
-                .build());
-    }
-
-    public String getRawMessage() {
-        return rawMessage;
-    }
-
-    public String getToolName() {
-        return toolName;
-    }
-
-    public String getText() {
-        return text;
-    }
-
-    public List<SourceFilePosition> getSourceFilePositions() {
-        return sourceFilePositions;
-    }
-
-    public Kind getKind() {
-        return kind;
-    }
-
-    private String sourcePath;
-
-    public String getSourcePath() {
-        if (sourcePath == null) {
-            File file = sourceFilePositions.get(0).getFile().getSourceFile();
-            if (file == null) {
-                return null;
-            }
-            sourcePath = file.getAbsolutePath();
-        }
-        return sourcePath;
-    }
-
-    public enum Kind {
-        ERROR, WARNING, INFO, STATISTICS, UNKNOWN, SIMPLE;
-
-        public static Kind findIgnoringCase(String string, Kind defaultKind) {
-            for (Kind kind : values()) {
-                if (kind.toString().equalsIgnoreCase(string)) {
-                    return kind;
-                }
-            }
-            return defaultKind;
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFile.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFile.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFile.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFile.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,136 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Objects;
-import java.io.File;
-import java.io.Serializable;
-import java.nio.file.Paths;
-
-import com.google.errorprone.annotations.Immutable;
-
-/**
- * Represents a source file. Note: Since the same file may have different representations (eg a/b vs
- * a/../a/b), it is better to use absolute files, otherwise the equals/hash method of this class may
- * fail.
- */
-@Immutable
-public final class SourceFile implements Serializable {
-
-    @NonNull
-    public static final SourceFile UNKNOWN = new SourceFile();
-
-    /** The absolute file path to the file, used for accessing the file contents. */
-    @Nullable private final String mFilePath;
-
-    /**
-     * The path used as reference to the source file. If null, the mFilePath is used as the main
-     * source path. If mSourcePath is set, properties should only expose the mSourcePath, unless the
-     * file itself is being accessed.
-     */
-    @Nullable private String mSourcePath;
-
-    /**
-     * A human readable description
-     *
-     * <p>Usually the file name is OK for the short output, but for the manifest merger, where all
-     * of the files will be named AndroidManifest.xml the variant name is more useful.
-     */
-    @Nullable private final String mDescription;
-
-    @SuppressWarnings("NullableProblems")
-    public SourceFile(@NonNull File sourceFile, @Nullable String description) {
-        mFilePath = sourceFile.getAbsolutePath();
-        mDescription = description;
-    }
-
-    public SourceFile(@SuppressWarnings("NullableProblems") @NonNull File sourceFile) {
-        this(sourceFile, null);
-    }
-
-    public SourceFile(@SuppressWarnings("NullableProblems") @NonNull String description) {
-        mFilePath = null;
-        mDescription = description;
-    }
-
-    private SourceFile() {
-        mFilePath = null;
-        mDescription = null;
-    }
-
-    public void setOverrideSourcePath(@NonNull String value) {
-        mSourcePath = value;
-    }
-
-    @Nullable
-    public File getSourceFile() {
-        if (mFilePath != null) {
-            return new File(mFilePath);
-        }
-        return null;
-    }
-
-    @Nullable
-    public String getSourcePath() {
-        if (mSourcePath != null) {
-            return mSourcePath;
-        }
-        if (mFilePath != null) {
-            return Paths.get(mFilePath).toAbsolutePath().toString();
-        }
-        return null;
-    }
-
-    @Nullable
-    public String getDescription() {
-        return mDescription;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (!(obj instanceof SourceFile)) {
-            return false;
-        }
-        SourceFile other = (SourceFile) obj;
-
-        return Objects.equal(mDescription, other.mDescription)
-                && Objects.equal(getSourcePath(), other.getSourcePath());
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hashCode(getSourcePath(), mDescription);
-    }
-
-    @Override
-    @NonNull
-    public String toString() {
-        return print(false /* shortFormat */);
-    }
-
-    @NonNull
-    public String print(boolean shortFormat) {
-        String path;
-        if (mSourcePath != null) {
-            path = mSourcePath;
-        } else if (mFilePath != null) {
-            path = mFilePath;
-        } else {
-            if (mDescription == null) {
-                return "Unknown source file";
-            }
-            return mDescription;
-        }
-        String fileName = new File(path).getName();
-        String fileDisplayName = shortFormat ? fileName : path;
-        if (mDescription == null || mDescription.equals(fileName)) {
-            return fileDisplayName;
-        } else {
-            return String.format("[%1$s] %2$s", mDescription, fileDisplayName);
-        }
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePosition.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePosition.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePosition.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePosition.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,223 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import androidx.annotation.NonNull;
-
-import com.google.common.base.Objects;
-import java.io.Serializable;
-
-import com.google.errorprone.annotations.Immutable;
-
-/**
- * An immutable position in a text file, used in errors to point the user to an issue.
- *
- * <p>Positions that are unknown are represented by -1.
- */
-@Immutable
-public final class SourcePosition implements Serializable {
-
-    @NonNull
-    public static final SourcePosition UNKNOWN = new SourcePosition();
-
-    private final int mStartLine, mStartColumn, mStartOffset, mEndLine, mEndColumn, mEndOffset;
-
-    public SourcePosition(int startLine, int startColumn, int startOffset,
-                          int endLine, int endColumn, int endOffset) {
-        mStartLine = startLine;
-        mStartColumn = startColumn;
-        mStartOffset = startOffset;
-        mEndLine = endLine;
-        mEndColumn = endColumn;
-        mEndOffset = endOffset;
-    }
-
-    public SourcePosition(int lineNumber, int column, int offset) {
-        mStartLine = mEndLine = lineNumber;
-        mStartColumn = mEndColumn = column;
-        mStartOffset = mEndOffset = offset;
-    }
-
-    private SourcePosition() {
-        mStartLine = mStartColumn = mStartOffset = mEndLine = mEndColumn = mEndOffset = -1;
-    }
-
-    protected SourcePosition(SourcePosition copy) {
-        mStartLine = copy.getStartLine();
-        mStartColumn = copy.getStartColumn();
-        mStartOffset = copy.getStartOffset();
-        mEndLine = copy.getEndLine();
-        mEndColumn = copy.getEndColumn();
-        mEndOffset = copy.getEndOffset();
-    }
-
-    /**
-     * Outputs positions as human-readable formatted strings.
-     *
-     * e.g.
-     * <pre>84
-     * 84-86
-     * 84:5
-     * 84:5-28
-     * 85:5-86:47</pre>
-     *
-     * @return a human readable position.
-     */
-    @Override
-    public String toString() {
-        if (mStartLine == -1) {
-            return "?";
-        }
-        StringBuilder sB = new StringBuilder(15);
-        sB.append(mStartLine + 1); // Humans think that the first line is line 1.
-        if (mStartColumn != -1) {
-            sB.append(':');
-            sB.append(mStartColumn + 1);
-        }
-        if (mEndLine != -1) {
-
-            if (mEndLine == mStartLine) {
-                if (mEndColumn != -1 && mEndColumn != mStartColumn) {
-                    sB.append('-');
-                    sB.append(mEndColumn + 1);
-                }
-            } else {
-                sB.append('-');
-                sB.append(mEndLine + 1);
-                if (mEndColumn != -1) {
-                    sB.append(':');
-                    sB.append(mEndColumn + 1);
-                } else if (mStartColumn != -1) {
-                    // to distinguish between this case and the case when the start line is the same
-                    // as the end line.
-                    sB.append(":?");
-                }
-            }
-        }
-        return sB.toString();
-    }
-
-    private static int parseString(String string) {
-        if (string.equals("?")) {
-            return 0;
-        }
-        return Integer.parseInt(string);
-    }
-
-    /** Given the human-readable formatted string, returns a source position object. */
-    public static SourcePosition fromString(String string) {
-        if (string.equals("?")) {
-            return UNKNOWN;
-        }
-        int startLine, endLine = 0, startColumn = 0, endColumn = 0;
-        if (string.contains("-")) {
-            String[] startAndEndPositions = string.split("-");
-            if (startAndEndPositions[0].contains(":")) {
-                String[] startPosition = startAndEndPositions[0].split(":");
-                startLine = parseString(startPosition[0]);
-                startColumn = parseString(startPosition[1]);
-            } else {
-                startLine = parseString(startAndEndPositions[0]);
-            }
-
-            if (startAndEndPositions[1].contains(":")) {
-                String[] endPosition = startAndEndPositions[1].split(":");
-                endLine = parseString(endPosition[0]);
-                endColumn = parseString(endPosition[1]);
-            } else {
-                if (startColumn != 0) {
-                    endLine = startLine;
-                    endColumn = parseString(startAndEndPositions[1]);
-                } else {
-                    endLine = parseString(startAndEndPositions[1]);
-                }
-            }
-        } else {
-            if (string.contains(":")) {
-                String[] pos = string.split(":");
-                startLine = parseString(pos[0]);
-                startColumn = parseString(pos[1]);
-            } else {
-                startLine = parseString(string);
-            }
-        }
-
-        return new SourcePosition(
-                startLine - 1, startColumn - 1, -1, endLine - 1, endColumn - 1, -1);
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (!(obj instanceof SourcePosition)) {
-            return false;
-        }
-        SourcePosition other = (SourcePosition) obj;
-
-        return other.mStartLine == mStartLine &&
-                other.mStartColumn == mStartColumn &&
-                other.mStartOffset == mStartOffset &&
-                other.mEndLine == mEndLine &&
-                other.mEndColumn == mEndColumn &&
-                other.mEndOffset == mEndOffset;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects
-                .hashCode(mStartLine, mStartColumn, mStartOffset, mEndLine, mEndColumn, mEndOffset);
-    }
-
-    public int getStartLine() {
-        return mStartLine;
-    }
-
-    public int getStartColumn() {
-        return mStartColumn;
-    }
-
-    public int getStartOffset() {
-        return mStartOffset;
-    }
-
-
-    public int getEndLine() {
-        return mEndLine;
-    }
-
-    public int getEndColumn() {
-        return mEndColumn;
-    }
-
-    public int getEndOffset() {
-        return mEndOffset;
-    }
-
-    /**
-     * Compares the start of this SourcePosition with another.
-     * @return 0 if they are the same, &lt; 0 if this &lt; other and &gt; 0 if this &gt; other
-     */
-    public int compareStart(@NonNull SourcePosition other) {
-        if (mStartOffset != -1 && other.mStartOffset != -1) {
-            return mStartOffset - other.mStartOffset;
-        }
-        if (mStartLine == other.mStartLine && mStartColumn != -1 && other.mStartColumn != -1) {
-            return mStartColumn - other.mStartColumn;
-        }
-        return mStartLine - other.mStartLine;
-    }
-
-    /**
-     * Compares the end of this SourcePosition with another.
-     * @return 0 if they are the same, &lt; 0 if this &lt; other and &gt; 0 if this &gt; other
-     */
-    public int compareEnd(@NonNull SourcePosition other) {
-        if (mEndOffset != -1 && other.mEndOffset != -1) {
-            return mEndOffset - other.mEndOffset;
-        }
-        if (mEndLine == other.mEndLine && mEndColumn != -1 && other.mEndColumn != -1) {
-            return mEndColumn - other.mEndColumn;
-        }
-        return mEndLine - other.mEndLine;
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePosition.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePosition.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePosition.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePosition.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,76 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import androidx.annotation.NonNull;
-
-import com.google.common.base.Objects;
-import java.io.File;
-import java.io.Serializable;
-
-import com.google.errorprone.annotations.Immutable;
-
-@Immutable
-public final class SourceFilePosition implements Serializable {
-
-    public static final SourceFilePosition UNKNOWN =
-            new SourceFilePosition(SourceFile.UNKNOWN, SourcePosition.UNKNOWN);
-
-    @NonNull
-    private final SourceFile mSourceFile;
-
-    @NonNull
-    private final SourcePosition mSourcePosition;
-
-    public SourceFilePosition(@NonNull SourceFile sourceFile,
-                              @NonNull SourcePosition sourcePosition) {
-        mSourceFile = sourceFile;
-        mSourcePosition = sourcePosition;
-    }
-
-    public SourceFilePosition(@NonNull File file,
-                              @NonNull SourcePosition sourcePosition) {
-        this(new SourceFile(file), sourcePosition);
-    }
-
-    @NonNull
-    public SourcePosition getPosition() {
-        return mSourcePosition;
-    }
-
-    @NonNull
-    public SourceFile getFile() {
-        return mSourceFile;
-    }
-
-    @NonNull
-    @Override
-    public String toString() {
-        return print(false);
-    }
-
-    @NonNull
-    public String print(boolean shortFormat) {
-        if (mSourcePosition.equals(SourcePosition.UNKNOWN)) {
-            return mSourceFile.print(shortFormat);
-        } else {
-            return mSourceFile.print(shortFormat) + ':' + mSourcePosition.toString();
-        }
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hashCode(mSourceFile, mSourcePosition);
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (!(obj instanceof SourceFilePosition)) {
-            return false;
-        }
-        SourceFilePosition other = (SourceFilePosition) obj;
-        return Objects.equal(mSourceFile, other.mSourceFile) &&
-                Objects.equal(mSourcePosition, other.mSourcePosition);
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/MessageJsonSerializer.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/MessageJsonSerializer.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/MessageJsonSerializer.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/MessageJsonSerializer.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,209 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import com.google.common.collect.BiMap;
-import com.google.common.collect.EnumHashBiMap;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Maps;
-import com.google.gson.GsonBuilder;
-import com.google.gson.TypeAdapter;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.File;
-import java.io.IOException;
-
-/**
- * Class to handle json serialization and deserialization of messages.
- *
- * Reads json objects of the form:
- *
- * <pre>
- * {
- *     "kind":"ERROR",
- *     "text":"errorText",
- *     "original":"unparsed error text: Error in some intermediate file",
- *     "sources": [{
- *         "file":"/path/to/source.java",
- *         "position":{
- *             "startLine":1,
- *             "startColumn":2,
- *             "startOffset":3,
- *             "endLine":4,
- *             "endColumn":5,
- *             "endOffset":6
- *         }
- *     }]
- * }</pre>
- *
- * All fields, other than text, may be omitted. They have the following defaults:
- *
- * <table summary="Default values for the message fields.">
- *     <tr><th>Property</th>        <th>Default</th>             <th>Notes</th></tr>
- *     <tr><td>kind (ERROR, WARNING,
- *             INFO, UNKNOWN)</td>  <td>UNKNOWN</td>             <td></td></tr>
- *     <tr><td>text</td>            <td><i>Empty String</i></td> <td>Should not be omitted.</td></tr>
- *     <tr><td>file (Absolute)</td> <td>{} <i>[unknown]</i></td> <td>See {@link SourceFileJsonTypeAdapter}</td></tr>
- *     <tr><td>position</td>        <td>UNKNOWN</td>             <td></td></tr>
- *     <tr><td>startLine,
- *             startColumn,
- *             startOffset</td>     <td>-1 <i>[unknown]</i></td> <td rowspan="2">0-based</td></tr>
- *     <tr><td>endLine,
- *             endColumn,
- *             endOffset</td>       <td>startLine, startColumn,
- *                                      startOffset</td></tr>
- * </table>
- *
- * <b>Notes</b>
- * <ul>
- *     <li>Offset need not be included, if needed by the consumer of the message it can
- *         be derived from the file, line and column.</li>
- *     <li>If line is included and column is not the message will be considered to apply
- *         to the whole line.</li>
- *     <li>A message can have multiple sources.</li>
- * </ul>
- * It also can read legacy serialized objects of the form:
- *
- * <pre>{
- *     "kind":"ERROR",
- *     "text":"errorText",
- *     "sourcePath": "/path/to/source.java",
- *     "position":{
- *         "startLine":1,
- *         "startColumn":2,
- *         "startOffset":3,
- *         "endLine":4,
- *         "endColumn":5,
- *         "endOffset":6
- *     }
- * }</pre>
- *
- * These serializers are implemented using the lower-level TypeAdapter gson API which gives much
- * more control and allow changes to be made without breaking backward compatibility.
- */
-public class MessageJsonSerializer extends TypeAdapter<Message> {
-
-    private static final String KIND = "kind";
-
-    private static final String TEXT = "text";
-
-    private static final String SOURCE_FILE_POSITIONS = "sources";
-
-    private static final String RAW_MESSAGE = "original";
-
-    private static final String TOOL_NAME = "tool";
-
-    private static final String LEGACY_SOURCE_PATH = "sourcePath";
-
-    private static final String LEGACY_POSITION = "position";
-
-    private static final BiMap<Message.Kind, String> KIND_STRING_ENUM_MAP;
-
-    static {
-        EnumHashBiMap<Message.Kind, String> map = EnumHashBiMap.create(Message.Kind.class);
-        map.put(Message.Kind.ERROR, "error");
-        map.put(Message.Kind.WARNING, "warning");
-        map.put(Message.Kind.INFO, "info");
-        map.put(Message.Kind.STATISTICS, "statistics");
-        map.put(Message.Kind.UNKNOWN, "unknown");
-        map.put(Message.Kind.SIMPLE, "simple");
-        KIND_STRING_ENUM_MAP = Maps.unmodifiableBiMap(map);
-    }
-
-    private final SourceFilePositionJsonSerializer mSourceFilePositionTypeAdapter;
-    private final SourcePositionJsonTypeAdapter mSourcePositionTypeAdapter;
-
-    public MessageJsonSerializer() {
-        mSourceFilePositionTypeAdapter = new SourceFilePositionJsonSerializer();
-        mSourcePositionTypeAdapter = mSourceFilePositionTypeAdapter.getSourcePositionTypeAdapter();
-    }
-
-    @Override
-    public void write(JsonWriter out, Message message) throws IOException {
-        out.beginObject()
-                .name(KIND).value(KIND_STRING_ENUM_MAP.get(message.getKind()))
-                .name(TEXT).value(message.getText())
-                .name(SOURCE_FILE_POSITIONS).beginArray();
-        for (SourceFilePosition position : message.getSourceFilePositions()) {
-            mSourceFilePositionTypeAdapter.write(out, position);
-        }
-        out.endArray();
-        if (!message.getRawMessage().equals(message.getText())) {
-            out.name(RAW_MESSAGE).value(message.getRawMessage());
-        }
-        if (message.getToolName() != null) {
-            out.name(TOOL_NAME).value(message.getToolName());
-        }
-        out.endObject();
-    }
-
-    @Override
-    public Message read(JsonReader in) throws IOException {
-        in.beginObject();
-        Message.Kind kind = Message.Kind.UNKNOWN;
-        String text = "";
-        String rawMessage = null;
-        String toolName = null;
-        ImmutableList.Builder<SourceFilePosition> positions =
-                new ImmutableList.Builder<SourceFilePosition>();
-        SourceFile legacyFile = SourceFile.UNKNOWN;
-        SourcePosition legacyPosition = SourcePosition.UNKNOWN;
-        while (in.hasNext()) {
-            String name = in.nextName();
-            if (name.equals(KIND)) {
-                //noinspection StringToUpperCaseOrToLowerCaseWithoutLocale
-                Message.Kind theKind = KIND_STRING_ENUM_MAP.inverse()
-                        .get(in.nextString().toLowerCase());
-                kind = (theKind != null) ? theKind : Message.Kind.UNKNOWN;
-            } else if (name.equals(TEXT)) {
-                text = in.nextString();
-            } else if (name.equals(RAW_MESSAGE)) {
-                rawMessage = in.nextString();
-            } else if (name.equals(TOOL_NAME)) {
-                toolName = in.nextString();
-            } else if (name.equals(SOURCE_FILE_POSITIONS)) {
-                switch (in.peek()) {
-                    case BEGIN_ARRAY:
-                        in.beginArray();
-                        while(in.hasNext()) {
-                            positions.add(mSourceFilePositionTypeAdapter.read(in));
-                        }
-                        in.endArray();
-                        break;
-                    case BEGIN_OBJECT:
-                        positions.add(mSourceFilePositionTypeAdapter.read(in));
-                        break;
-                    default:
-                        in.skipValue();
-                        break;
-                }
-            } else if (name.equals(LEGACY_SOURCE_PATH)) {
-                legacyFile = new SourceFile(new File(in.nextString()));
-            } else if (name.equals(LEGACY_POSITION)) {
-                legacyPosition = mSourcePositionTypeAdapter.read(in);
-            } else {
-                in.skipValue();
-            }
-        }
-        in.endObject();
-
-        if (legacyFile != SourceFile.UNKNOWN || legacyPosition != SourcePosition.UNKNOWN) {
-            positions.add(new SourceFilePosition(legacyFile, legacyPosition));
-        }
-        if (rawMessage == null) {
-            rawMessage = text;
-        }
-        ImmutableList<SourceFilePosition> sourceFilePositions = positions.build();
-        if (!sourceFilePositions.isEmpty()) {
-            return new Message(kind, text, rawMessage, toolName, sourceFilePositions);
-        } else {
-            return new Message(kind, text, rawMessage, toolName, ImmutableList.of(SourceFilePosition.UNKNOWN));
-        }
-    }
-
-    public static void registerTypeAdapters(GsonBuilder builder) {
-        builder.registerTypeAdapter(SourceFile.class, new SourceFileJsonTypeAdapter());
-        builder.registerTypeAdapter(SourcePosition.class, new SourcePositionJsonTypeAdapter());
-        builder.registerTypeAdapter(SourceFilePosition.class,
-                new SourceFilePositionJsonSerializer());
-        builder.registerTypeAdapter(Message.class, new MessageJsonSerializer());
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFileJsonTypeAdapter.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFileJsonTypeAdapter.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFileJsonTypeAdapter.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFileJsonTypeAdapter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,99 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import com.google.common.base.Strings;
-import com.google.gson.TypeAdapter;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.File;
-import java.io.IOException;
-
-/**
- * JsonSerializer and Deserializer for {@link SourceFile}.
- *
- * <p>The JsonDeserialiser accepts either a string of the file path or a json object of the form
- *
- * <pre>{
- *     "path":"/path/to/file.java",
- *     "description": "short `human-readable description"
- * }</pre>
- *
- * where both properties are optionally present, so unknown is represented by the empty object.
- */
-public class SourceFileJsonTypeAdapter extends TypeAdapter<SourceFile> {
-
-    private static final String PATH = "path";
-
-    private static final String DESCRIPTION = "description";
-
-    @Override
-    public void write(JsonWriter out, SourceFile src) throws IOException {
-        String path = src.getSourcePath();
-        String description = src.getDescription();
-
-        if (description == null && path != null) {
-            out.value(path);
-            return;
-        }
-        out.beginObject();
-        if (description != null) {
-            out.name(DESCRIPTION).value(description);
-        }
-        if (path != null) {
-            out.name(PATH).value(path);
-        }
-        out.endObject();
-    }
-
-    @Override
-    public SourceFile read(JsonReader in) throws IOException {
-        switch (in.peek()) {
-            case BEGIN_OBJECT:
-                in.beginObject();
-                String filePath = null;
-                String description = null;
-                while (in.hasNext()) {
-                    String name = in.nextName();
-                    if (name.equals(PATH)) {
-                        filePath = in.nextString();
-                    } else if (DESCRIPTION.equals(name)) {
-                        description = in.nextString();
-                    } else {
-                        in.skipValue();
-                    }
-                }
-                in.endObject();
-                if (!Strings.isNullOrEmpty(filePath)) {
-                    File file = new File(filePath);
-                    SourceFile sf;
-                    if (!Strings.isNullOrEmpty(description)) {
-                        sf = new SourceFile(file, description);
-                    } else {
-                        sf = new SourceFile(file);
-                    }
-                    if (filePath.contains(":")) {
-                        sf.setOverrideSourcePath(filePath);
-                    }
-                    return sf;
-                } else {
-                    if (!Strings.isNullOrEmpty(description)) {
-                        return new SourceFile(description);
-                    } else {
-                        return SourceFile.UNKNOWN;
-                    }
-                }
-            case STRING:
-                String fileName = in.nextString();
-                if (Strings.isNullOrEmpty(fileName)) {
-                    return SourceFile.UNKNOWN;
-                }
-                SourceFile sf = new SourceFile(new File(fileName));
-                if (fileName.contains(":")) {
-                    sf.setOverrideSourcePath(fileName);
-                }
-                return sf;
-            default:
-                return SourceFile.UNKNOWN;
-        }
-
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePositionJsonTypeAdapter.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePositionJsonTypeAdapter.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePositionJsonTypeAdapter.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourcePositionJsonTypeAdapter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,84 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import com.google.gson.TypeAdapter;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-
-import java.io.IOException;
-
-public class SourcePositionJsonTypeAdapter extends TypeAdapter<SourcePosition> {
-
-    private static final String START_LINE = "startLine";
-
-    private static final String START_COLUMN = "startColumn";
-
-    private static final String START_OFFSET = "startOffset";
-
-    private static final String END_LINE = "endLine";
-
-    private static final String END_COLUMN = "endColumn";
-
-    private static final String END_OFFSET = "endOffset";
-
-    @Override
-    public void write(JsonWriter out, SourcePosition value) throws IOException {
-        int startLine = value.getStartLine();
-        int startColumn = value.getStartColumn();
-        int startOffset = value.getStartOffset();
-        int endLine = value.getEndLine();
-        int endColumn = value.getEndColumn();
-        int endOffset = value.getEndOffset();
-        out.beginObject();
-        if (startLine != -1) {
-            out.name(START_LINE).value(startLine);
-        }
-        if (startColumn != -1) {
-            out.name(START_COLUMN).value(startColumn);
-        }
-        if (startOffset != -1) {
-            out.name(START_OFFSET).value(startOffset);
-        }
-        if (endLine != -1 && endLine != startLine) {
-            out.name(END_LINE).value(endLine);
-        }
-        if (endColumn != -1 && endColumn != startColumn) {
-            out.name(END_COLUMN).value(endColumn);
-        }
-        if (endOffset != -1 && endOffset != startOffset) {
-            out.name(END_OFFSET).value(endOffset);
-        }
-        out.endObject();
-    }
-
-    @Override
-    public SourcePosition read(JsonReader in) throws IOException {
-        int startLine = -1, startColumn = -1, startOffset = -1;
-        int endLine = -1, endColumn = -1, endOffset = -1;
-        in.beginObject();
-        while (in.hasNext()) {
-            String name = in.nextName();
-            if (name.equals(START_LINE)) {
-                startLine = in.nextInt();
-            } else if (name.equals(START_COLUMN)) {
-                startColumn = in.nextInt();
-            } else if (name.equals(START_OFFSET)) {
-                startOffset = in.nextInt();
-            } else if (name.equals(END_LINE)) {
-                endLine = in.nextInt();
-            } else if (name.equals(END_COLUMN)) {
-                endColumn = in.nextInt();
-            } else if (name.equals(END_OFFSET)) {
-                endOffset = in.nextInt();
-            } else {
-                in.skipValue();
-            }
-        }
-        in.endObject();
-
-        endLine = (endLine != -1) ? endLine : startLine;
-        endColumn = (endColumn != -1) ? endColumn : startColumn;
-        endOffset = (endOffset != -1) ? endOffset : startOffset;
-        return new SourcePosition(startLine, startColumn, startOffset, endLine, endColumn,
-                endOffset);
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePositionJsonSerializer.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePositionJsonSerializer.java b/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePositionJsonSerializer.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/blame/SourceFilePositionJsonSerializer.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,67 +0,0 @@
-package com.tyron.build.compiler.manifest.blame;
-
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import com.google.gson.TypeAdapter;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-
-import java.io.IOException;
-
-public class SourceFilePositionJsonSerializer extends TypeAdapter<SourceFilePosition> {
-
-    private static final String POSITION = "position";
-
-    private static final String FILE = "file";
-
-    private final SourceFileJsonTypeAdapter mSourceFileJsonTypeAdapter;
-    private final SourcePositionJsonTypeAdapter mSourcePositionJsonTypeAdapter;
-
-    public SourceFilePositionJsonSerializer() {
-        mSourcePositionJsonTypeAdapter = new SourcePositionJsonTypeAdapter();
-        mSourceFileJsonTypeAdapter = new SourceFileJsonTypeAdapter();
-    }
-
-    @Override
-    public SourceFilePosition read(JsonReader in) throws IOException {
-        in.beginObject();
-        SourceFile file = SourceFile.UNKNOWN;
-        SourcePosition position = SourcePosition.UNKNOWN;
-        while(in.hasNext()) {
-            String name = in.nextName();
-            if (name.equals(FILE)) {
-                file = mSourceFileJsonTypeAdapter.read(in);
-            } else if (name.equals(POSITION)) {
-                position = mSourcePositionJsonTypeAdapter.read(in);
-            } else {
-                in.skipValue();
-            }
-        }
-        in.endObject();
-        return new SourceFilePosition(file, position);
-    }
-
-    @Override
-    public void write(JsonWriter out, SourceFilePosition src) throws IOException {
-        out.beginObject();
-        SourceFile sourceFile = src.getFile();
-        if (!sourceFile.equals(SourceFile.UNKNOWN)) {
-            out.name(FILE);
-            mSourceFileJsonTypeAdapter.write(out, sourceFile);
-        }
-        SourcePosition position = src.getPosition();
-        if (!position.equals(SourcePosition.UNKNOWN)) {
-            out.name(POSITION);
-            mSourcePositionJsonTypeAdapter.write(out, position);
-        }
-        out.endObject();
-    }
-
-    /* package */ SourcePositionJsonTypeAdapter getSourcePositionTypeAdapter() {
-        return mSourcePositionJsonTypeAdapter;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/resources/Keyboard.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/Keyboard.java b/Build/src/main/java/com/tyron/build/compiler/manifest/resources/Keyboard.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/Keyboard.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,76 +0,0 @@
-package com.tyron.build.compiler.manifest.resources;
-
-/**
- * Keyboard enum.
- * <p>This is used in the manifest in the uses-configuration node and in the resource folder names.
- */
-public enum Keyboard implements ResourceEnum {
-    NOKEY("nokeys", null, "No Keys", "No keyboard"), //$NON-NLS-1$
-    QWERTY("qwerty", null, "Qwerty", "Qwerty keyboard"), //$NON-NLS-1$
-    TWELVEKEY("12key", "twelvekey", "12 Key", "12 key keyboard"); //$NON-NLS-1$ //$NON-NLS-2$
-
-    private final String mValue, mValue2;
-    private final String mShortDisplayValue;
-    private final String mLongDisplayValue;
-
-    Keyboard(String value, String value2, String shortDisplayValue,
-             String longDisplayValue) {
-        mValue = value;
-        mValue2 = value2;
-        mShortDisplayValue = shortDisplayValue;
-        mLongDisplayValue = longDisplayValue;
-    }
-
-    /**
-     * Returns the enum for matching the provided qualifier value.
-     * @param value The qualifier value.
-     * @return the enum for the qualifier value or null if no matching was found.
-     */
-    public static Keyboard getEnum(String value) {
-        for (Keyboard kbrd : values()) {
-            if (kbrd.mValue.equals(value) ||
-                    (kbrd.mValue2 != null && kbrd.mValue2.equals(value))) {
-                return kbrd;
-            }
-        }
-
-        return null;
-    }
-
-    @Override
-    public String getResourceValue() {
-        return mValue;
-    }
-
-    @Override
-    public String getShortDisplayValue() {
-        return mShortDisplayValue;
-    }
-
-    @Override
-    public String getLongDisplayValue() {
-        return mLongDisplayValue;
-    }
-
-    public static int getIndex(Keyboard value) {
-        return value == null ? -1 : value.ordinal();
-    }
-
-    public static Keyboard getByIndex(int index) {
-        Keyboard[] values = values();
-        if (index >= 0 && index < values.length) {
-            return values[index];
-        }
-        return null;
-    }
-
-    @Override
-    public boolean isFakeValue() {
-        return false;
-    }
-
-    @Override
-    public boolean isValidValueForDevice() {
-        return true;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/resources/Navigation.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/Navigation.java b/Build/src/main/java/com/tyron/build/compiler/manifest/resources/Navigation.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/Navigation.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,76 +0,0 @@
-package com.tyron.build.compiler.manifest.resources;
-
-/**
- * Navigation enum.
- * <p>This is used in the manifest in the uses-configuration node and in the resource folder names.
- */
-public enum Navigation implements ResourceEnum {
-    NONAV("nonav", "None", "No navigation"), //$NON-NLS-1$
-    DPAD("dpad", "D-pad", "D-pad navigation"), //$NON-NLS-1$
-    TRACKBALL("trackball", "Trackball", "Trackball navigation"), //$NON-NLS-1$
-    WHEEL("wheel", "Wheel", "Wheel navigation"); //$NON-NLS-1$
-
-    private final String mValue;
-    private final String mShortDisplayValue;
-    private final String mLongDisplayValue;
-
-    Navigation(String value, String shortDisplayValue, String longDisplayValue) {
-        mValue = value;
-        mShortDisplayValue = shortDisplayValue;
-        mLongDisplayValue = longDisplayValue;
-    }
-
-    /**
-     * Returns the enum for matching the provided qualifier value.
-     * @param value The qualifier value.
-     * @return the enum for the qualifier value or null if no matching was found.
-     */
-    public static Navigation getEnum(String value) {
-        for (Navigation nav : values()) {
-            if (nav.mValue.equals(value)) {
-                return nav;
-            }
-        }
-
-        return null;
-    }
-
-    @Override
-    public String getResourceValue() {
-        return mValue;
-    }
-
-    @Override
-    public String getShortDisplayValue() {
-        return mShortDisplayValue;
-    }
-
-    @Override
-    public String getLongDisplayValue() {
-        return mLongDisplayValue;
-    }
-
-    public static int getIndex(Navigation value) {
-        return value == null ? -1 : value.ordinal();
-    }
-
-    public static Navigation getByIndex(int index) {
-        Navigation[] values = values();
-        if (index >= 0 && index < values.length) {
-            return values[index];
-        }
-        return null;
-    }
-
-    @Override
-    public boolean isFakeValue() {
-        return false;
-    }
-
-    @Override
-    public boolean isValidValueForDevice() {
-        return true;
-    }
-
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/resources/TouchScreen.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/TouchScreen.java b/Build/src/main/java/com/tyron/build/compiler/manifest/resources/TouchScreen.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/TouchScreen.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,74 +0,0 @@
-package com.tyron.build.compiler.manifest.resources;
-
-/**
- * Touch screen enum.
- * <p>This is used in the manifest in the uses-configuration node and in the resource folder names.
- */
-public enum TouchScreen implements ResourceEnum {
-    NOTOUCH("notouch", "No Touch", "No-touch screen"), //$NON-NLS-1$
-    STYLUS("stylus", "Stylus", "Stylus-based touchscreen"), //$NON-NLS-1$
-    FINGER("finger", "Finger", "Finger-based touchscreen"); //$NON-NLS-1$
-
-    private final String mValue;
-    private final String mShortDisplayValue;
-    private final String mLongDisplayValue;
-
-    TouchScreen(String value, String displayValue, String longDisplayValue) {
-        mValue = value;
-        mShortDisplayValue = displayValue;
-        mLongDisplayValue = longDisplayValue;
-    }
-
-    /**
-     * Returns the enum for matching the provided qualifier value.
-     * @param value The qualifier value.
-     * @return the enum for the qualifier value or null if no matching was found.
-     */
-    public static TouchScreen getEnum(String value) {
-        for (TouchScreen orient : values()) {
-            if (orient.mValue.equals(value)) {
-                return orient;
-            }
-        }
-
-        return null;
-    }
-
-    @Override
-    public String getResourceValue() {
-        return mValue;
-    }
-
-    @Override
-    public String getShortDisplayValue() {
-        return mShortDisplayValue;
-    }
-
-    @Override
-    public String getLongDisplayValue() {
-        return mLongDisplayValue;
-    }
-
-    public static int getIndex(TouchScreen touch) {
-        return touch == null ? -1 : touch.ordinal();
-    }
-
-    public static TouchScreen getByIndex(int index) {
-        TouchScreen[] values = values();
-        if (index >= 0 && index < values.length) {
-            return values[index];
-        }
-        return null;
-    }
-
-    @Override
-    public boolean isFakeValue() {
-        return false;
-    }
-
-    @Override
-    public boolean isValidValueForDevice() {
-        return true;
-    }
-
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceEnum.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceEnum.java b/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceEnum.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceEnum.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,45 +0,0 @@
-package com.tyron.build.compiler.manifest.resources;
-
-/**
- * An enum representing a resource qualifier value.
- */
-public interface ResourceEnum {
-
-    /**
-     * Returns the resource string. This is to be used in resource folder names.
-     */
-    String getResourceValue();
-
-    /**
-     * Whether the value actually used on device. This returns true only if a device can report
-     * this value, false if it's just used to qualify resources.
-     */
-    boolean isValidValueForDevice();
-
-    /**
-     * Whether the value is neither used for device nor resources. This returns false when
-     * the value is only used for internal usage in the custom editors.
-     */
-    boolean isFakeValue();
-
-    /**
-     * Returns a short string for display value. The string does not need to show the context.
-     * <p>For instance "exposed", which can be the value for the keyboard state or the navigation
-     * state, would be valid since something else in the UI is expected to show if this is about the
-     * keyboard or the navigation state.
-     *
-     * @see #getLongDisplayValue()
-     */
-    String getShortDisplayValue();
-
-    /**
-     * Returns a long string for display value. This must not only include the enum value but
-     * context (qualifier) about what the value represents.
-     * <p>For instance "Exposed keyboard", and "Export navigation", as "exposed" would not be
-     * enough to know what qualifier the value is about.
-     *
-     * @see #getShortDisplayValue()
-     */
-    String getLongDisplayValue();
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceConstants.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceConstants.java b/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceConstants.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceConstants.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,38 +0,0 @@
-package com.tyron.build.compiler.manifest.resources;
-
-/**
- * Resource constants.
- */
-public class ResourceConstants {
-    /** Default anim resource folder name, i.e. "anim". */
-    public static final String FD_RES_ANIM = "anim";
-    /** Default animator resource folder name, i.e. "animator". */
-    public static final String FD_RES_ANIMATOR = "animator";
-    /** Default color resource folder name, i.e. "color". */
-    public static final String FD_RES_COLOR = "color";
-    /** Default drawable resource folder name, i.e. "drawable". */
-    public static final String FD_RES_DRAWABLE = "drawable";
-    /** Default font resource folder name, i.e. "font". */
-    public static final String FD_RES_FONT = "font";
-    /** Default interpolator resource folder name, i.e. "interpolator". */
-    public static final String FD_RES_INTERPOLATOR = "interpolator";
-    /** Default layout resource folder name, i.e. "layout". */
-    public static final String FD_RES_LAYOUT = "layout";
-    /** Default menu resource folder name, i.e. "menu". */
-    public static final String FD_RES_MENU = "menu";
-    /** Default menu resource folder name, i.e. "mipmap". */
-    public static final String FD_RES_MIPMAP = "mipmap";
-    /** Default values resource folder name, i.e. "values". */
-    public static final String FD_RES_VALUES = "values";
-    /** Default xml resource folder name, i.e. "xml". */
-    public static final String FD_RES_XML = "xml";
-    /** Default raw resource folder name, i.e. "raw". */
-    public static final String FD_RES_RAW = "raw";
-    /** Default transition resource folder name, i.e. "transition". */
-    public static final String FD_RES_TRANSITION = "transition";
-    /** Default navigation resource folder name, i.e. "nav". */
-    public static final String FD_NAVIGATION = "navigation";
-
-    /** Separator between the resource folder qualifiers. */
-    public static final char RES_QUALIFIER_SEP = '-';
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceFolderType.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceFolderType.java b/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceFolderType.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/resources/ResourceFolderType.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,79 +0,0 @@
-package com.tyron.build.compiler.manifest.resources;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Enum representing a type of resource folder.
- */
-public enum ResourceFolderType {
-    ANIM(ResourceConstants.FD_RES_ANIM),
-    ANIMATOR(ResourceConstants.FD_RES_ANIMATOR),
-    COLOR(ResourceConstants.FD_RES_COLOR),
-    DRAWABLE(ResourceConstants.FD_RES_DRAWABLE),
-    FONT(ResourceConstants.FD_RES_FONT),
-    INTERPOLATOR(ResourceConstants.FD_RES_INTERPOLATOR),
-    LAYOUT(ResourceConstants.FD_RES_LAYOUT),
-    MENU(ResourceConstants.FD_RES_MENU),
-    MIPMAP(ResourceConstants.FD_RES_MIPMAP),
-    NAVIGATION(ResourceConstants.FD_NAVIGATION),
-    RAW(ResourceConstants.FD_RES_RAW),
-    TRANSITION(ResourceConstants.FD_RES_TRANSITION),
-    VALUES(ResourceConstants.FD_RES_VALUES),
-    XML(ResourceConstants.FD_RES_XML);
-
-    private final String name;
-
-    private static final Map<String, ResourceFolderType> nameToType;
-
-    static {
-        ResourceFolderType[] values = ResourceFolderType.values();
-        nameToType = new HashMap<>(2 * values.length);
-
-        for (ResourceFolderType type : values) {
-            nameToType.put(type.getName(), type);
-        }
-    }
-
-    ResourceFolderType(String name) {
-        this.name = name;
-    }
-
-    /**
-     * Returns the folder name for this resource folder type.
-     */
-    @NonNull
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Returns the enum by name.
-     * @param name The enum string value.
-     * @return the enum or null if not found.
-     */
-    @Nullable
-    public static ResourceFolderType getTypeByName(@NonNull String name) {
-        assert name.indexOf('-') == -1 : name; // use #getFolderType instead
-        return nameToType.get(name);
-    }
-
-    /**
-     * Returns the {@link ResourceFolderType} from the folder name
-     * @param folderName The name of the folder. This must be a valid folder name in the format
-     * <code>resType[-resqualifiers[-resqualifiers[...]]</code>
-     * @return the <code>ResourceFolderType</code> representing the type of the folder, or
-     * <code>null</code> if no matching type was found.
-     */
-    @Nullable
-    public static ResourceFolderType getFolderType(@NonNull String folderName) {
-        int index = folderName.indexOf(ResourceConstants.RES_QUALIFIER_SEP);
-        if (index != -1) {
-            folderName = folderName.substring(0, index);
-        }
-        return getTypeByName(folderName);
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/Actions.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/Actions.java b/Build/src/main/java/com/tyron/build/compiler/manifest/Actions.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/Actions.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,445 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.VisibleForTesting;
-
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
-import com.google.common.io.LineReader;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonParseException;
-import com.tyron.build.compiler.manifest.blame.MessageJsonSerializer;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.log.ILogger;
-
-import org.xml.sax.SAXException;
-
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.StringReader;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import com.google.errorprone.annotations.Immutable;
-import javax.xml.parsers.ParserConfigurationException;
-
-/**
- * Contains all actions taken during a merging invocation.
- */
-@Immutable
-public class Actions {
-
-    // TODO: i18n
-    @VisibleForTesting
-    static final String HEADER = "-- Merging decision tree log ---\n";
-
-    // defines all the records for the merging tool activity, indexed by element name+key.
-    // iterator should be ordered by the key insertion order.
-    private final Map<XmlNode.NodeKey, DecisionTreeRecord> mRecords;
-
-    public Actions(Map<XmlNode.NodeKey, DecisionTreeRecord> records) {
-        mRecords = records;
-    }
-
-    /**
-     * Returns a {@link com.google.common.collect.ImmutableSet} of all the element's keys that have
-     * at least one {@link NodeRecord}.
-     */
-    @NonNull
-    public Set<XmlNode.NodeKey> getNodeKeys() {
-        return mRecords.keySet();
-    }
-
-    /**
-     * Returns an {@link ImmutableList} of {@link NodeRecord} for the element identified with the
-     * passed key.
-     */
-    @NonNull
-    public ImmutableList<NodeRecord> getNodeRecords(XmlNode.NodeKey key) {
-        return mRecords.containsKey(key)
-                ? mRecords.get(key).getNodeRecords()
-                : ImmutableList.<NodeRecord>of();
-    }
-
-    /**
-     * Returns a {@link ImmutableList} of all attributes names that have at least one record for
-     * the element identified with the passed key.
-     */
-    @NonNull
-    public ImmutableList<XmlNode.NodeName> getRecordedAttributeNames(XmlNode.NodeKey nodeKey) {
-        DecisionTreeRecord decisionTreeRecord = mRecords.get(nodeKey);
-        if (decisionTreeRecord == null) {
-            return ImmutableList.of();
-        }
-        return decisionTreeRecord.getAttributesRecords().keySet().asList();
-    }
-
-    /**
-     * Returns the {@link com.google.common.collect.ImmutableList} of {@link AttributeRecord} for
-     * the attribute identified by attributeName of the element identified by elementKey.
-     */
-    @NonNull
-    public ImmutableList<AttributeRecord> getAttributeRecords(XmlNode.NodeKey elementKey,
-                                                              XmlNode.NodeName attributeName) {
-
-        DecisionTreeRecord decisionTreeRecord = mRecords.get(elementKey);
-        if (decisionTreeRecord == null) {
-            return ImmutableList.of();
-        }
-        return decisionTreeRecord.getAttributeRecords(attributeName);
-    }
-
-    /**
-     * Initial dump of the merging tool actions, need to be refined and spec'ed out properly.
-     * @param logger logger to log to at INFO level.
-     */
-    void log(ILogger logger) {
-        logger.verbose(getLogs());
-    }
-
-    /**
-     * Dump merging tool actions to a text file.
-     * @param fileWriter the file to write all actions into.
-     * @throws IOException
-     */
-    void log(FileWriter fileWriter) throws IOException {
-        fileWriter.append(getLogs());
-    }
-
-    private String getLogs() {
-        StringBuilder stringBuilder = new StringBuilder();
-        stringBuilder.append(HEADER);
-        for (Map.Entry<XmlNode.NodeKey, Actions.DecisionTreeRecord> record : mRecords.entrySet()) {
-            stringBuilder.append(record.getKey()).append("\n");
-            for (Actions.NodeRecord nodeRecord : record.getValue().getNodeRecords()) {
-                nodeRecord.print(stringBuilder);
-                stringBuilder.append('\n');
-            }
-            for (Map.Entry<XmlNode.NodeName, List<Actions.AttributeRecord>> attributeRecords :
-                    record.getValue().mAttributeRecords.entrySet()) {
-                stringBuilder.append('\t').append(attributeRecords.getKey()).append('\n');
-                for (Actions.AttributeRecord attributeRecord : attributeRecords.getValue()) {
-                    stringBuilder.append("\t\t");
-                    attributeRecord.print(stringBuilder);
-                    stringBuilder.append('\n');
-                }
-            }
-        }
-        return stringBuilder.toString();
-    }
-
-    /**
-     * Defines all possible actions taken from the merging tool for an xml element or attribute.
-     */
-    enum ActionType {
-        /**
-         * The element was added into the resulting merged manifest.
-         */
-        ADDED,
-        /**
-         * The element was injected from the merger invocation parameters.
-         */
-        INJECTED,
-        /**
-         * The element was merged with another element into the resulting merged manifest.
-         */
-        MERGED,
-        /**
-         * The element was rejected.
-         */
-        REJECTED,
-        /**
-         * The implied element was added was added when importing a library that expected the
-         * element to be present by default while targeted SDK requires its declaration.
-         */
-        IMPLIED,
-    }
-
-    /**
-     * Defines an abstract record contain common metadata for elements and attributes actions.
-     */
-    public abstract static class Record {
-
-        @NonNull protected final ActionType mActionType;
-        @NonNull protected final SourceFilePosition mActionLocation;
-        @NonNull protected final XmlNode.NodeKey mTargetId;
-        @Nullable
-        protected final String mReason;
-
-        private Record(@NonNull ActionType actionType,
-                       @NonNull SourceFilePosition actionLocation,
-                       @NonNull XmlNode.NodeKey targetId,
-                       @Nullable String reason) {
-            mActionType = Preconditions.checkNotNull(actionType);
-            mActionLocation = Preconditions.checkNotNull(actionLocation);
-            mTargetId = Preconditions.checkNotNull(targetId);
-            mReason = reason;
-        }
-
-        public ActionType getActionType() {
-            return mActionType;
-        }
-
-        public SourceFilePosition getActionLocation() {
-            return mActionLocation;
-        }
-
-        public XmlNode.NodeKey getTargetId() {
-            return mTargetId;
-        }
-
-        public void print(StringBuilder stringBuilder) {
-            stringBuilder.append(mActionType)
-                    .append(" from ")
-                    .append(mActionLocation);
-            if (mReason != null) {
-                stringBuilder.append(" reason: ")
-                        .append(mReason);
-            }
-        }
-    }
-
-    /**
-     * Defines a merging tool action for an xml element.
-     */
-    public static class NodeRecord extends Record {
-
-        private final NodeOperationType mNodeOperationType;
-
-        NodeRecord(@NonNull ActionType actionType,
-                   @NonNull SourceFilePosition actionLocation,
-                   @NonNull XmlNode.NodeKey targetId,
-                   @Nullable String reason,
-                   @NonNull NodeOperationType nodeOperationType) {
-            super(actionType, actionLocation, targetId, reason);
-            this.mNodeOperationType = Preconditions.checkNotNull(nodeOperationType);
-        }
-
-        @Override
-        public String toString() {
-            return "Id=" + mTargetId.toString() + " actionType=" + getActionType()
-                    + " location=" + getActionLocation()
-                    + " opType=" + mNodeOperationType;
-        }
-    }
-
-    /**
-     * Defines a merging tool action for an xml attribute
-     */
-    public static class AttributeRecord extends Record {
-
-        // first in wins which should be fine, the first
-        // operation type will be the highest priority one
-        private final AttributeOperationType mOperationType;
-
-        AttributeRecord(
-                @NonNull ActionType actionType,
-                @NonNull SourceFilePosition actionLocation,
-                @NonNull XmlNode.NodeKey targetId,
-                @Nullable String reason,
-                @Nullable AttributeOperationType operationType) {
-            super(actionType, actionLocation, targetId, reason);
-            this.mOperationType = operationType;
-        }
-
-        @Nullable
-        public AttributeOperationType getOperationType() {
-            return mOperationType;
-        }
-
-        @Override
-        public String toString() {
-            return "Id=" + mTargetId + " actionType=" + getActionType()
-                    + " location=" + getActionLocation()
-                    + " opType=" + getOperationType();
-        }
-    }
-
-    public String persist() throws IOException  {
-        GsonBuilder gson = new GsonBuilder().setPrettyPrinting();
-        gson.enableComplexMapKeySerialization();
-        MessageJsonSerializer.registerTypeAdapters(gson);
-        return gson.create().toJson(this);
-    }
-
-    @Nullable
-    public static Actions load(InputStream inputStream) throws IOException {
-
-        return getGsonParser().fromJson(new InputStreamReader(inputStream), Actions.class);
-    }
-
-    private static class NodeNameDeserializer implements JsonDeserializer<XmlNode.NodeName> {
-
-        @Override
-        public XmlNode.NodeName deserialize(JsonElement json, Type typeOfT,
-                                            JsonDeserializationContext context) throws JsonParseException {
-            if (json.getAsJsonObject().get("mNamespaceURI") != null) {
-                return context.deserialize(json, XmlNode.NamespaceAwareName.class);
-            } else {
-                return context.deserialize(json, XmlNode.Name.class);
-            }
-        }
-    }
-
-    @Nullable
-    @SuppressWarnings("unchecked")
-    public static Actions load(String xml) {
-
-        return getGsonParser().fromJson(xml, Actions.class);
-    }
-
-    private static Gson getGsonParser() {
-        GsonBuilder gsonBuilder = new GsonBuilder();
-        gsonBuilder.enableComplexMapKeySerialization();
-        gsonBuilder.registerTypeAdapter(XmlNode.NodeName.class, new NodeNameDeserializer());
-        MessageJsonSerializer.registerTypeAdapters(gsonBuilder);
-        return gsonBuilder.create();
-    }
-
-    public ImmutableMultimap<Integer, Record> getResultingSourceMapping(XmlDocument xmlDocument)
-            throws ParserConfigurationException, SAXException, IOException {
-
-        SourceFile inMemory = SourceFile.UNKNOWN;
-
-        XmlDocument loadedWithLineNumbers = XmlLoader.load(
-                xmlDocument.getSelectors(),
-                xmlDocument.getSystemPropertyResolver(),
-                inMemory,
-                xmlDocument.prettyPrint(),
-                XmlDocument.Type.MAIN,
-                Optional.<String>absent() /* mainManifestPackageName */);
-
-        ImmutableMultimap.Builder<Integer, Record> mappingBuilder = ImmutableMultimap.builder();
-        for (XmlElement xmlElement : loadedWithLineNumbers.getRootNode().getMergeableElements()) {
-            parse(xmlElement, mappingBuilder);
-        }
-        return mappingBuilder.build();
-    }
-
-    private void parse(XmlElement element,
-                       ImmutableMultimap.Builder<Integer, Record> mappings) {
-        DecisionTreeRecord decisionTreeRecord = mRecords.get(element.getId());
-        if (decisionTreeRecord != null) {
-            Actions.NodeRecord nodeRecord = findNodeRecord(decisionTreeRecord);
-            if (nodeRecord != null) {
-                mappings.put(element.getPosition().getStartLine(), nodeRecord);
-            }
-            for (XmlAttribute xmlAttribute : element.getAttributes()) {
-                Actions.AttributeRecord attributeRecord = findAttributeRecord(decisionTreeRecord,
-                        xmlAttribute);
-                if (attributeRecord != null) {
-                    mappings.put(xmlAttribute.getPosition().getStartLine(), attributeRecord);
-                }
-            }
-        }
-        for (XmlElement xmlElement : element.getMergeableElements()) {
-            parse(xmlElement, mappings);
-        }
-    }
-
-    public String blame(XmlDocument xmlDocument)
-            throws IOException, SAXException, ParserConfigurationException {
-
-        ImmutableMultimap<Integer, Record> resultingSourceMapping =
-                getResultingSourceMapping(xmlDocument);
-        LineReader lineReader = new LineReader(
-                new StringReader(xmlDocument.prettyPrint()));
-
-        StringBuilder actualMappings = new StringBuilder();
-        String line;
-        int count = 0;
-        while ((line = lineReader.readLine()) != null) {
-            actualMappings.append(count + 1).append(line).append("\n");
-            if (resultingSourceMapping.containsKey(count)) {
-                for (Record record : resultingSourceMapping.get(count)) {
-                    actualMappings.append(count + 1).append("-->")
-                            .append(record.getActionLocation().toString())
-                            .append("\n");
-                }
-            }
-            count++;
-        }
-        return actualMappings.toString();
-    }
-
-    @Nullable
-    private static Actions.NodeRecord findNodeRecord(DecisionTreeRecord decisionTreeRecord) {
-        for (Actions.NodeRecord nodeRecord : decisionTreeRecord.getNodeRecords()) {
-            if (nodeRecord.getActionType() == Actions.ActionType.ADDED) {
-                return nodeRecord;
-            }
-        }
-        return null;
-    }
-
-    @Nullable
-    private static Actions.AttributeRecord findAttributeRecord(
-            DecisionTreeRecord decisionTreeRecord,
-            XmlAttribute xmlAttribute) {
-        for (Actions.AttributeRecord attributeRecord : decisionTreeRecord
-                .getAttributeRecords(xmlAttribute.getName())) {
-            if (attributeRecord.getActionType() == Actions.ActionType.ADDED) {
-                return attributeRecord;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Internal structure on how {@link Actions.Record}s are kept for an
-     * xml element.
-     *
-     * Each xml element should have an associated DecisionTreeRecord which keeps a list of
-     * {@link Actions.NodeRecord} for all the node actions related
-     * to this xml element.
-     *
-     * It will also contain a map indexed by attribute name on all the attribute actions related
-     * to that particular attribute within the xml element.
-     *
-     */
-    static class DecisionTreeRecord {
-        // all other occurrences of the nodes decisions, in order of decisions.
-        private final List<NodeRecord> mNodeRecords = new ArrayList<NodeRecord>();
-
-        // all attributes decisions indexed by attribute name.
-        final Map<XmlNode.NodeName, List<AttributeRecord>> mAttributeRecords =
-                new HashMap<XmlNode.NodeName, List<AttributeRecord>>();
-
-        ImmutableList<NodeRecord> getNodeRecords() {
-            return ImmutableList.copyOf(mNodeRecords);
-        }
-
-        ImmutableMap<XmlNode.NodeName, List<AttributeRecord>> getAttributesRecords() {
-            return ImmutableMap.copyOf(mAttributeRecords);
-        }
-
-        DecisionTreeRecord() {
-        }
-
-        void addNodeRecord(NodeRecord nodeRecord) {
-            mNodeRecords.add(nodeRecord);
-        }
-
-        ImmutableList<AttributeRecord> getAttributeRecords(XmlNode.NodeName attributeName) {
-            List<AttributeRecord> attributeRecords = mAttributeRecords.get(attributeName);
-            return attributeRecords == null
-                    ? ImmutableList.<AttributeRecord>of()
-                    : ImmutableList.copyOf(attributeRecords);
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/XmlNode.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlNode.java b/Build/src/main/java/com/tyron/build/compiler/manifest/XmlNode.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlNode.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,272 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-
-import com.google.common.base.Function;
-import com.google.common.base.Objects;
-import com.google.common.base.Preconditions;
-import com.google.errorprone.annotations.Immutable;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-
-/**
- * Common behavior of any xml declaration.
- */
-public abstract class XmlNode {
-
-    protected static final Function<Node, String> NODE_TO_NAME =
-            new Function<Node, String>() {
-                @Override
-                public String apply(Node input) {
-                    return input.getNodeName();
-                }
-            };
-
-    private NodeKey mOriginalId = null;
-
-    /**
-     * Returns a constant Nodekey that can be used throughout the lifecycle of the xml element.
-     * The {@link #getId} can return different values over time as the key of the element can be
-     * for instance, changed through placeholder replacement.
-     */
-    public synchronized NodeKey getOriginalId() {
-        if (mOriginalId == null) {
-            mOriginalId = getId();
-        }
-        return mOriginalId;
-    }
-
-    /**
-     * Returns an unique id within the manifest file for the element.
-     */
-    public abstract NodeKey getId();
-
-    /**
-     * Returns the element's position
-     */
-    @NonNull
-    public abstract SourcePosition getPosition();
-
-    /**
-     * Returns the element's document xml source file location.
-     */
-    @NonNull
-    public abstract SourceFile getSourceFile();
-
-    /**
-     * Returns the element's document xml source file location.
-     */
-    public SourceFilePosition getSourceFilePosition() {
-        return new SourceFilePosition(getSourceFile(), getPosition());
-    }
-
-    /**
-     * Returns the element's xml
-     */
-    @NonNull
-    public abstract Node getXml();
-
-    /**
-     * Returns the name of this xml element or attribute.
-     */
-    public abstract NodeName getName();
-
-    /**
-     * Abstraction to an xml name to isolate whether the name has a namespace or not.
-     */
-    public interface NodeName {
-
-        /**
-         * Returns true if this attribute name has a namespace declaration and that namespapce is
-         * the same as provided, false otherwise.
-         */
-        boolean isInNamespace(String namespaceURI);
-
-        /**
-         * Adds a new attribute of this name to a xml element with a value.
-         * @param to the xml element to add the attribute to.
-         * @param withValue the new attribute's value.
-         */
-        void addToNode(Element to, String withValue);
-
-        /**
-         * The local name.
-         */
-        String getLocalName();
-    }
-
-    /**
-     * Factory method to create an instance of {@link com.android.manifmerger.XmlNode.NodeName}
-     * for an existing xml node.
-     * @param node the xml definition.
-     * @return an instance of {@link com.android.manifmerger.XmlNode.NodeName} providing
-     * namespace handling.
-     */
-    public static NodeName unwrapName(Node node) {
-        return node.getNamespaceURI() == null
-                ? new Name(node.getNodeName())
-                : new NamespaceAwareName(node);
-    }
-
-    public static NodeName fromXmlName(String name) {
-        return (name.contains(":"))
-                ? new NamespaceAwareName(SdkConstants.ANDROID_URI,
-                name.substring(0, name.indexOf(':')),
-                name.substring(name.indexOf(':') + 1))
-                : new Name(name);
-    }
-
-    public static NodeName fromNSName(String namespaceUri, String prefix, String localName) {
-        return new NamespaceAwareName(namespaceUri, prefix, localName);
-    }
-
-    /**
-     * Returns the position of this attribute in the original xml file. This may return an invalid
-     * location as this xml fragment does not exist in any xml file but is the temporary result
-     * of the merging process.
-     * @return a human readable position.
-     */
-    public String printPosition() {
-        return getSourceFilePosition().print(true /*shortFormat*/);
-    }
-
-    /**
-     * Implementation of {@link com.android.manifmerger.XmlNode.NodeName} for an
-     * node's declaration not using a namespace.
-     */
-    public static final class Name implements NodeName {
-        private final String mName;
-
-        private Name(@NonNull String name) {
-            this.mName = Preconditions.checkNotNull(name);
-        }
-
-        @Override
-        public boolean isInNamespace(String namespaceURI) {
-            return false;
-        }
-
-        @Override
-        public void addToNode(Element to, String withValue) {
-            to.setAttribute(mName, withValue);
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            return (o != null && o instanceof Name && ((Name) o).mName.equals(this.mName));
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hashCode(mName);
-        }
-
-        @Override
-        public String toString() {
-            return mName;
-        }
-
-        @Override
-        public String getLocalName() {
-            return mName;
-        }
-    }
-
-    /**
-     * Implementation of the {@link com.android.manifmerger.XmlNode.NodeName} for a namespace aware attribute.
-     */
-    public static final class NamespaceAwareName implements NodeName {
-
-        private final String mNamespaceURI;
-
-        // ignore for comparison and hashcoding since different documents can use different
-        // prefixes for the same namespace URI.
-        private final String mPrefix;
-        private final String mLocalName;
-
-        private NamespaceAwareName(@NonNull Node node) {
-            this.mNamespaceURI = Preconditions.checkNotNull(node.getNamespaceURI());
-            this.mPrefix = Preconditions.checkNotNull(node.getPrefix());
-            this.mLocalName = Preconditions.checkNotNull(node.getLocalName());
-        }
-
-        private NamespaceAwareName(@NonNull String namespaceURI,
-                                   @NonNull String prefix,
-                                   @NonNull String localName) {
-            mNamespaceURI = Preconditions.checkNotNull(namespaceURI);
-            mPrefix = Preconditions.checkNotNull(prefix);
-            mLocalName = Preconditions.checkNotNull(localName);
-        }
-
-        @Override
-        public boolean isInNamespace(String namespaceURI) {
-            return mNamespaceURI.equals(namespaceURI);
-        }
-
-        @Override
-        public void addToNode(Element to, String withValue) {
-            // TODO: consider standardizing everything on "android:"
-            to.setAttributeNS(mNamespaceURI, mPrefix + ":" + mLocalName, withValue);
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hashCode(mNamespaceURI, mLocalName);
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            return (o != null && o instanceof NamespaceAwareName
-                    && ((NamespaceAwareName) o).mLocalName.equals(this.mLocalName)
-                    && ((NamespaceAwareName) o).mNamespaceURI.equals(this.mNamespaceURI));
-        }
-
-        @Override
-        public String toString() {
-            return mPrefix + ":" + mLocalName;
-        }
-
-        @Override
-        public String getLocalName() {
-            return mLocalName;
-        }
-    }
-
-    /**
-     * A xml element or attribute key.
-     */
-    @Immutable
-    public static class NodeKey {
-
-        @NonNull
-        private final String mKey;
-
-        NodeKey(@NonNull String key) {
-            mKey = key;
-        }
-
-        public static NodeKey fromXml(Element element) {
-            return new OrphanXmlElement(element).getId();
-        }
-
-        @Override
-        public String toString() {
-            return mKey;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            return (o != null && o instanceof NodeKey && ((NodeKey) o).mKey.equals(this.mKey));
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hashCode(mKey);
-        }
-    }
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/Selector.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/Selector.java b/Build/src/main/java/com/tyron/build/compiler/manifest/Selector.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/Selector.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,48 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
-
-
-import com.google.errorprone.annotations.Immutable;
-
-/**
- * Represents a selector to be able to identify manifest file xml elements.
- */
-@Immutable
-public class Selector {
-
-    /**
-     * local name for tools:selector attributes.
-     */
-    public static final String SELECTOR_LOCAL_NAME = "selector";
-
-    @NonNull private final String mPackageName;
-
-    public Selector(@NonNull String packageName) {
-        mPackageName = Preconditions.checkNotNull(packageName);
-    }
-
-    /**
-     * Returns true if the passed element is "selected" by this selector. If so, any action this
-     * selector decorated will be applied to the element.
-     */
-    boolean appliesTo(XmlElement element) {
-        Optional<XmlAttribute> packageName = element.getDocument().getPackage();
-        return packageName.isPresent() && mPackageName.equals(packageName.get().getValue());
-    }
-
-    /**
-     * Returns true if the passed resolver can resolve this selector, false otherwise.
-     */
-    boolean isResolvable(KeyResolver<String> resolver) {
-        return resolver.resolve(mPackageName) != null;
-    }
-
-    @Override
-    public String toString() {
-        return mPackageName;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ICallback.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ICallback.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ICallback.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ICallback.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,13 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-
-/**
- * Callback used by the merger to query the caller
- */
-public interface ICallback {
-
-    public static final int UNKNOWN_CODENAME = 0;
-
-    public int queryCodenameApiLevel(@NonNull String codeName);
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/MergerLog.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/MergerLog.java b/Build/src/main/java/com/tyron/build/compiler/manifest/MergerLog.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/MergerLog.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,44 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-
-import com.tyron.build.model.FileAndLine;
-import com.tyron.build.log.ILogger;
-
-/**
- * Helper to create {@link IMergerLog} instances with specific purposes
- */
-public abstract class MergerLog {
-
-    /**
-     * Create a new instance of a {@link MergerLog} that prints to an {@link com.tyron.code.service.ILogger}
-     *
-     * @param sdkLog a non-null {@link ILogger}
-     * @return A new IMergeLog
-     */
-    public static IMergerLog wrapSdkLog(@NonNull final ILogger sdkLog) {
-        return new IMergerLog() {
-            @Override
-            public void error(@NonNull Severity severity, @NonNull FileAndLine location, @NonNull String message, Object... msgParams) {
-                switch (severity) {
-                    case INFO:
-                        sdkLog.debug(message);
-                        break;
-                    case WARNING:
-                        sdkLog.warning("Warning: " + message + ' ' + location);
-                        break;
-                    case ERROR:
-                        sdkLog.error("Error: " + message + ' ' + location);
-                }
-            }
-
-            @Override
-            public void conflict(@NonNull Severity severity, @NonNull FileAndLine location1, @NonNull FileAndLine location2, @NonNull String message, Object... msgParams) {
-              //  switch (severity) {
-                //    case ERROR:
-                        sdkLog.error(String.format(message, msgParams) + "\nlocation 1: " + location1 + "\n location 2: " + location2);
-                //}
-            }
-        };
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/MergeType.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/MergeType.java b/Build/src/main/java/com/tyron/build/compiler/manifest/MergeType.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/MergeType.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,36 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-/**
- * Defines the default merging activity for same type.
- *
- * WIP more work needed.
- */
-public enum MergeType {
-
-    /**
-     * Merge this element's children with lower priority element's children. Do not merge
-     * element's attributes.
-     */
-    MERGE_CHILDREN_ONLY,
-
-    /**
-     * Merge this element with lower priority elements.
-     */
-    MERGE,
-
-    /**
-     * Always generate a merging failure when encountering lower priority elements.
-     */
-    CONFLICT,
-
-    /**
-     * Do not attempt to merge with lower priority elements.
-     */
-    IGNORE,
-
-    /**
-     * Always consume lower priority elements unless it is strictly equals to the higher priority
-     * element.
-     */
-    ALWAYS,
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/XmlLoader.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlLoader.java b/Build/src/main/java/com/tyron/build/compiler/manifest/XmlLoader.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlLoader.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,86 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.ManifestMerger2.SystemProperty;
-import static com.tyron.build.compiler.manifest.PlaceholderHandler.KeyBasedValueResolver;
-
-import com.google.common.base.Optional;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.util.PositionXmlParser;
-
-import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
-
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-import javax.xml.parsers.ParserConfigurationException;
-
-/**
- * Responsible for loading XML files.
- */
-public final class XmlLoader {
-
-    private XmlLoader() {}
-
-    /**
-     * Loads an xml file without doing xml validation and return a {@link XmlDocument}
-     *
-     * @param displayName the xml file display name.
-     * @param xmlFile the xml file.
-     * @return the initialized {@link com.tyron.build.compiler.manifest.XmlDocument}
-     */
-    public static XmlDocument load(
-            KeyResolver<String> selectors,
-            KeyBasedValueResolver<SystemProperty> systemPropertyResolver,
-            String displayName,
-            File xmlFile,
-            XmlDocument.Type type,
-            Optional<String> mainManifestPackageName)
-            throws IOException, SAXException, ParserConfigurationException {
-        InputStream inputStream = new BufferedInputStream(new FileInputStream(xmlFile));
-
-        Document domDocument = PositionXmlParser.parse(inputStream);
-        return domDocument != null ? new XmlDocument(
-                new SourceFile(xmlFile, displayName),
-                selectors,
-                systemPropertyResolver,
-                domDocument.getDocumentElement(),
-                type,
-                mainManifestPackageName)
-                : null;
-    }
-
-
-    /**
-     * Loads a xml document from its {@link String} representation without doing xml validation and
-     * return a {@link com.tyron.build.compiler.manifest.XmlDocument}
-     * @param sourceFile the source location to use for logging and record collection.
-     * @param xml the persisted xml.
-     * @return the initialized {@link com.tyron.build.compiler.manifest.XmlDocument}
-     * @throws IOException this should never be thrown.
-     * @throws SAXException if the xml is incorrect
-     * @throws ParserConfigurationException if the xml engine cannot be configured.
-     */
-    public static XmlDocument load(
-            KeyResolver<String> selectors,
-            KeyBasedValueResolver<SystemProperty> systemPropertyResolver,
-            SourceFile sourceFile,
-            String xml,
-            XmlDocument.Type type,
-            Optional<String> mainManifestPackageName)
-            throws IOException, SAXException, ParserConfigurationException {
-        Document domDocument = PositionXmlParser.parse(xml);
-        return domDocument != null
-                ? new XmlDocument(
-                sourceFile,
-                selectors,
-                systemPropertyResolver,
-                domDocument.getDocumentElement(),
-                type,
-                mainManifestPackageName)
-                : null;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/IMergerLog.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/IMergerLog.java b/Build/src/main/java/com/tyron/build/compiler/manifest/IMergerLog.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/IMergerLog.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,48 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-
-import com.tyron.build.model.FileAndLine;
-
-/**
- * Logger interface for the {@link ManifestMerger}
- */
-public interface IMergerLog {
-
-    /** Severity of the error message */
-    public enum Severity {
-        /**
-         * A very low severity information, This does not stop processing
-         * Clients might want to have a "not verbose" flag to not display this
-         */
-        INFO,
-        /**
-         * Warning, this does not stop processing
-         */
-        WARNING,
-        /**
-         * A fatal error.
-         * The merger does not stop on errors, in an attempt to accumulate as much
-         * info as possible to return to the user. However in case even on error
-         * is generated the output should not be used, if any.
-         */
-        ERROR
-    }
-
-    public abstract void error (
-            @NonNull Severity severity,
-            @NonNull FileAndLine location,
-            @NonNull String message,
-            Object... msgParams);
-
-    public abstract void conflict(
-            @NonNull Severity severity,
-            @NonNull FileAndLine location1,
-            @NonNull FileAndLine location2,
-            @NonNull String message,
-            Object... msgParams);
-
-    public static final String MAIN_MANIFEST = "@main";
-
-    public static final String LIBRARY = "@library";
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/XmlElement.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlElement.java b/Build/src/main/java/com/tyron/build/compiler/manifest/XmlElement.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlElement.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,863 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
-import com.google.common.base.Splitter;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.util.SdkUtils;
-import com.tyron.build.util.XmlUtils;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.w3c.dom.Text;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Xml {@link org.w3c.dom.Element} which is mergeable.
- *
- * A mergeable element can contains 3 types of children :
- * <ul>
- *     <li>a child element, which itself may or may not be mergeable.</li>
- *     <li>xml attributes which are related to the element.</li>
- *     <li>tools oriented attributes to trigger specific behaviors from the merging tool</li>
- * </ul>
- *
- * The two main responsibilities of this class is to be capable of comparing itself against
- * another instance of the same type as well as providing XML element merging capabilities.
- */
-public class XmlElement extends OrphanXmlElement {
-
-    @NonNull private final XmlDocument mDocument;
-
-    private final NodeOperationType mNodeOperationType;
-    // list of non tools related attributes.
-    private final ImmutableList<XmlAttribute> mAttributes;
-    // map of all tools related attributes keyed by target attribute name
-    private final Map<NodeName, AttributeOperationType> mAttributesOperationTypes;
-    // list of mergeable children elements.
-    private final ImmutableList<XmlElement> mMergeableChildren;
-    // optional selector declared on this xml element.
-    @Nullable private final Selector mSelector;
-    // optional list of libraries that we should ignore the minSdk version
-    @NonNull private final List<Selector> mOverrideUsesSdkLibrarySelectors;
-
-
-    public XmlElement(@NonNull Element xml, @NonNull XmlDocument document) {
-        super(xml);
-
-        mDocument = Preconditions.checkNotNull(document);
-        Selector selector = null;
-        List<Selector> overrideUsesSdkLibrarySelectors = ImmutableList.of();
-
-        ImmutableMap.Builder<NodeName, AttributeOperationType> attributeOperationTypeBuilder =
-                ImmutableMap.builder();
-        ImmutableList.Builder<XmlAttribute> attributesListBuilder = ImmutableList.builder();
-        NamedNodeMap namedNodeMap = getXml().getAttributes();
-        NodeOperationType lastNodeOperationType = null;
-        for (int i = 0; i < namedNodeMap.getLength(); i++) {
-            Node attribute = namedNodeMap.item(i);
-            if (SdkConstants.TOOLS_URI.equals(attribute.getNamespaceURI())) {
-                String instruction = attribute.getLocalName();
-                if (instruction.equals(NodeOperationType.NODE_LOCAL_NAME)) {
-                    // should we flag an error when there are more than one operation type on a node ?
-                    lastNodeOperationType = NodeOperationType.valueOf(
-                            SdkUtils.camelCaseToConstantName(
-                                    attribute.getNodeValue()));
-                } else if (instruction.equals(Selector.SELECTOR_LOCAL_NAME)) {
-                    selector = new Selector(attribute.getNodeValue());
-                } else if (instruction.equals(NodeOperationType.OVERRIDE_USES_SDK)) {
-                    String nodeValue = attribute.getNodeValue();
-                    ImmutableList.Builder<Selector> builder = ImmutableList.builder();
-                    for (String selectorValue : Splitter.on(',').split(nodeValue)) {
-                        builder.add(new Selector(selectorValue.trim()));
-                    }
-                    overrideUsesSdkLibrarySelectors = builder.build();
-                } else {
-                    AttributeOperationType attributeOperationType;
-                    try {
-                        attributeOperationType =
-                                AttributeOperationType.valueOf(
-                                        SdkUtils.xmlNameToConstantName(instruction));
-                    } catch (IllegalArgumentException e) {
-                        try {
-                            // is this another tool's operation type that we do not care about.
-                            OtherOperationType.valueOf(instruction);
-                            break;
-                        } catch (IllegalArgumentException e1) {
-
-                            String errorMessage =
-                                    String.format("Invalid instruction '%1$s', "
-                                                    + "valid instructions are : %2$s",
-                                            instruction,
-                                            Joiner.on(',').join(AttributeOperationType.values())
-                                    );
-                            throw new RuntimeException(MergingException.wrapException(e1)
-                                    .withMessage(errorMessage)
-                                    .withFile(mDocument.getSourceFile())
-                                    .withPosition(mDocument.getNodePosition(xml)).build());
-                        }
-                    }
-                    for (String attributeName : Splitter.on(',').trimResults()
-                            .split(attribute.getNodeValue())) {
-                        if (attributeName.indexOf(XmlUtils.NS_SEPARATOR) == -1) {
-                            String toolsPrefix = XmlUtils
-                                    .lookupNamespacePrefix(getXml(), SdkConstants.TOOLS_URI,
-                                            SdkConstants.ANDROID_NS_NAME, false);
-                            // automatically provide the prefix.
-                            attributeName = toolsPrefix + XmlUtils.NS_SEPARATOR + attributeName;
-                        }
-                        NodeName nodeName = XmlNode.fromXmlName(attributeName);
-                        attributeOperationTypeBuilder.put(nodeName, attributeOperationType);
-                    }
-                }
-            }
-        }
-        mAttributesOperationTypes = attributeOperationTypeBuilder.build();
-        for (int i = 0; i < namedNodeMap.getLength(); i++) {
-            Node attribute = namedNodeMap.item(i);
-            XmlAttribute xmlAttribute = new XmlAttribute(
-                    this, (Attr) attribute, getType().getAttributeModel(XmlNode.fromXmlName(
-                    ((Attr) attribute).getName())));
-            attributesListBuilder.add(xmlAttribute);
-        }
-        mNodeOperationType = lastNodeOperationType;
-        mAttributes = attributesListBuilder.build();
-        mMergeableChildren = initMergeableChildren();
-        mSelector = selector;
-        mOverrideUsesSdkLibrarySelectors = overrideUsesSdkLibrarySelectors;
-    }
-
-    /**
-     * Returns the owning {@link com.tyron.build.compiler.manifest.XmlDocument}
-     */
-    @NonNull
-    public XmlDocument getDocument() {
-        return mDocument;
-    }
-
-    /**
-     * Returns the list of attributes for this xml element.
-     */
-    public List<XmlAttribute> getAttributes() {
-        return mAttributes;
-    }
-
-    /**
-     * Returns the {@link com.tyron.build.compiler.manifest.XmlAttribute} for an attribute present on this
-     * xml element, or {@link com.google.common.base.Optional#absent} if not present.
-     * @param attributeName the attribute name.
-     */
-    public Optional<XmlAttribute> getAttribute(NodeName attributeName) {
-        for (XmlAttribute xmlAttribute : mAttributes) {
-            if (xmlAttribute.getName().equals(attributeName)) {
-                return Optional.of(xmlAttribute);
-            }
-        }
-        return Optional.absent();
-    }
-
-    /**
-     * Get the node operation type as optionally specified by the user. If the user did not
-     * explicitly specify how conflicting elements should be handled, a
-     * {@link com.tyron.build.compiler.manifest.NodeOperationType#MERGE} will be returned.
-     */
-    public NodeOperationType getOperationType() {
-        return mNodeOperationType != null
-                ? mNodeOperationType
-                : NodeOperationType.MERGE;
-    }
-
-    /**
-     * Get the attribute operation type as optionally specified by the user. If the user did not
-     * explicitly specify how conflicting attributes should be handled, a
-     * {@link AttributeOperationType#STRICT} will be returned.
-     */
-    public AttributeOperationType getAttributeOperationType(NodeName attributeName) {
-        return mAttributesOperationTypes.containsKey(attributeName)
-                ? mAttributesOperationTypes.get(attributeName)
-                : AttributeOperationType.STRICT;
-    }
-
-    public Collection<Map.Entry<NodeName, AttributeOperationType>> getAttributeOperations() {
-        return mAttributesOperationTypes.entrySet();
-    }
-
-    @NonNull
-    public List<Selector> getOverrideUsesSdkLibrarySelectors() {
-        return mOverrideUsesSdkLibrarySelectors;
-    }
-
-
-    @NonNull
-    @Override
-    public SourcePosition getPosition() {
-        return mDocument.getNodePosition(this);
-    }
-
-    @NonNull
-    @Override
-    public SourceFile getSourceFile() {
-        return mDocument.getSourceFile();
-    }
-
-
-    /**
-     * Merge this xml element with a lower priority node.
-     *
-     * For now, attributes will be merged. If present on both xml elements, a warning will be
-     * issued and the attribute merge will be rejected.
-     *
-     * @param lowerPriorityNode lower priority Xml element to merge with.
-     * @param mergingReport the merging report to log errors and actions.
-     */
-    public void mergeWithLowerPriorityNode(
-            XmlElement lowerPriorityNode,
-            MergingReport.Builder mergingReport) {
-
-
-        if (mSelector != null && !mSelector.isResolvable(getDocument().getSelectors())) {
-            mergingReport.addMessage(getSourceFilePosition(),
-                    MergingReport.Record.Severity.ERROR,
-                    String.format("'tools:selector=\"%1$s\"' is not a valid library identifier, "
-                                    + "valid identifiers are : %2$s",
-                            mSelector.toString(),
-                            Joiner.on(',').join(mDocument.getSelectors().getKeys())));
-            return;
-
-        }
-        mergingReport.getLogger().info("Merging " + getId()
-                + " with lower " + lowerPriorityNode.printPosition());
-
-        // workaround for 0.12 release and overlay treatment of manifest entries. This will
-        // need to be expressed in the model instead.
-        MergeType mergeType = getType().getMergeType();
-        // if element we are merging in is not a library (an overlay or an application),  we should
-        // always merge the <manifest> attributes otherwise, we do not merge the libraries
-        // <manifest> attributes.
-        if (isA(ManifestModel.NodeTypes.MANIFEST)
-                && lowerPriorityNode.getDocument().getFileType() != XmlDocument.Type.LIBRARY) {
-            mergeType = MergeType.MERGE;
-        }
-
-        if (mergeType != MergeType.MERGE_CHILDREN_ONLY) {
-            // make a copy of all the attributes metadata, it will eliminate elements from this
-            // list as it finds them explicitly defined in the lower priority node.
-            // At the end of the explicit attributes processing, the remaining elements of this
-            // list will need to be checked for default value that may clash with a locally
-            // defined attribute.
-            List<AttributeModel> attributeModels =
-                    new ArrayList<AttributeModel>(lowerPriorityNode.getType().getAttributeModels());
-
-            // merge explicit attributes from lower priority node.
-            for (XmlAttribute lowerPriorityAttribute : lowerPriorityNode.getAttributes()) {
-                lowerPriorityAttribute.mergeInHigherPriorityElement(this, mergingReport);
-                if (lowerPriorityAttribute.getModel() != null) {
-                    attributeModels.remove(lowerPriorityAttribute.getModel());
-                }
-            }
-            // merge implicit default values from lower priority node when we have an explicit
-            // attribute declared on this node.
-            for (AttributeModel attributeModel : attributeModels) {
-                if (attributeModel.getDefaultValue() != null) {
-                    Optional<XmlAttribute> myAttribute = getAttribute(attributeModel.getName());
-                    if (myAttribute.isPresent()) {
-                        myAttribute.get().mergeWithLowerPriorityDefaultValue(
-                                mergingReport, lowerPriorityNode);
-                    }
-                }
-            }
-        }
-        // are we supposed to merge children ?
-        if (mNodeOperationType != NodeOperationType.MERGE_ONLY_ATTRIBUTES) {
-            mergeChildren(lowerPriorityNode, mergingReport);
-        } else {
-            // record rejection of the lower priority node's children .
-            for (XmlElement lowerPriorityChild : lowerPriorityNode.getMergeableElements()) {
-                mergingReport.getActionRecorder().recordNodeAction(this,
-                        Actions.ActionType.REJECTED,
-                        lowerPriorityChild);
-            }
-        }
-    }
-
-    public ImmutableList<XmlElement> getMergeableElements() {
-        return mMergeableChildren;
-    }
-
-    /**
-     * Returns a child of a particular type and a particular key.
-     * @param type the requested child type.
-     * @param keyValue the requested child key.
-     * @return the child of {@link com.google.common.base.Optional#absent()} if no child of this
-     * type and key exist.
-     */
-    public Optional<XmlElement> getNodeByTypeAndKey(
-            ManifestModel.NodeTypes type,
-            @Nullable String keyValue) {
-
-        for (XmlElement xmlElement : mMergeableChildren) {
-            if (xmlElement.isA(type) &&
-                    (keyValue == null || keyValue.equals(xmlElement.getKey()))) {
-                return Optional.of(xmlElement);
-            }
-        }
-        return Optional.absent();
-    }
-
-    /**
-     * Returns all immediate children of this node for a particular type, irrespective of their
-     * key.
-     * @param type the type of children element requested.
-     * @return the list (potentially empty) of children.
-     */
-    public ImmutableList<XmlElement> getAllNodesByType(ManifestModel.NodeTypes type) {
-        ImmutableList.Builder<XmlElement> listBuilder = ImmutableList.builder();
-        for (XmlElement mergeableChild : initMergeableChildren()) {
-            if (mergeableChild.isA(type)) {
-                listBuilder.add(mergeableChild);
-            }
-        }
-        return listBuilder.build();
-    }
-
-    // merge this higher priority node with a lower priority node.
-    public void mergeChildren(XmlElement lowerPriorityNode,
-                              MergingReport.Builder mergingReport) {
-
-        // read all lower priority mergeable nodes.
-        // if the same node is not defined in this document merge it in.
-        // if the same is defined, so far, give an error message.
-        for (XmlElement lowerPriorityChild : lowerPriorityNode.getMergeableElements()) {
-
-            if (shouldIgnore(lowerPriorityChild, mergingReport)) {
-                continue;
-            }
-            mergeChild(lowerPriorityChild, mergingReport);
-        }
-    }
-
-    /**
-     * Returns true if this element supports having a tools:selector decoration, false otherwise.
-     */
-    public boolean supportsSelector() {
-        return getOperationType().isSelectable();
-    }
-
-    // merge a child of a lower priority node into this higher priority node.
-    private void mergeChild(XmlElement lowerPriorityChild, MergingReport.Builder mergingReport) {
-
-        ILogger logger = mergingReport.getLogger();
-
-        // If this a custom element, we just blindly merge it in.
-        if (lowerPriorityChild.getType() == ManifestModel.NodeTypes.CUSTOM) {
-            handleCustomElement(lowerPriorityChild, mergingReport);
-            return;
-        }
-
-        Optional<XmlElement> thisChildOptional =
-                getNodeByTypeAndKey(lowerPriorityChild.getType(),lowerPriorityChild.getKey());
-
-        // only in the lower priority document ?
-        if (!thisChildOptional.isPresent()) {
-            addElement(lowerPriorityChild, mergingReport);
-            return;
-        }
-        // it's defined in both files.
-        logger.verbose(String.format(lowerPriorityChild.getId() + " defined in both files..."));
-
-        XmlElement thisChild = thisChildOptional.get();
-        switch (thisChild.getType().getMergeType()) {
-            case CONFLICT:
-                addMessage(mergingReport, MergingReport.Record.Severity.ERROR, String.format(
-                        "Node %1$s cannot be present in more than one input file and it's "
-                                + "present at %2$s and %3$s",
-                        thisChild.getType(),
-                        thisChild.printPosition(),
-                        lowerPriorityChild.printPosition()
-                ));
-                break;
-            case ALWAYS:
-
-                // no merging, we consume the lower priority node unmodified.
-                // if the two elements are equal, just skip it.
-
-                // but check first that we are not supposed to replace or remove it.
-                NodeOperationType operationType =
-                        calculateNodeOperationType(thisChild, lowerPriorityChild);
-                if (operationType == NodeOperationType.REMOVE ||
-                        operationType == NodeOperationType.REPLACE) {
-                    mergingReport.getActionRecorder().recordNodeAction(thisChild,
-                            Actions.ActionType.REJECTED, lowerPriorityChild);
-                    break;
-                }
-
-                if (thisChild.getType().areMultipleDeclarationAllowed()) {
-                    mergeChildrenWithMultipleDeclarations(lowerPriorityChild, mergingReport);
-                } else {
-                    if (!thisChild.isEquals(lowerPriorityChild)) {
-                        addElement(lowerPriorityChild, mergingReport);
-                    }
-                }
-                break;
-            default:
-                // 2 nodes exist, some merging need to happen
-                handleTwoElementsExistence(thisChild, lowerPriorityChild, mergingReport);
-                break;
-        }
-    }
-
-    /**
-     * Handles presence of custom elements (elements not part of the android or tools
-     * namespaces). Such elements are merged unchanged into the resulting document, and
-     * optionally, the namespace definition is added to the merged document root element.
-     * @param customElement the custom element present in the lower priority document.
-     * @param mergingReport the merging report to log errors and actions.
-     */
-    private void handleCustomElement(XmlElement customElement,
-                                     MergingReport.Builder mergingReport) {
-        addElement(customElement, mergingReport);
-
-        // add the custom namespace to the document generation.
-        String nodeName = customElement.getXml().getNodeName();
-        if (!nodeName.contains(":")) {
-            return;
-        }
-        String prefix = nodeName.substring(0, nodeName.indexOf(':'));
-        String namespace = customElement.getDocument().getRootNode()
-                .getXml().getAttribute(SdkConstants.XMLNS_PREFIX + prefix);
-
-        if (namespace != null) {
-            getDocument().getRootNode().getXml().setAttributeNS(
-                    SdkConstants.XMLNS_URI, SdkConstants.XMLNS_PREFIX + prefix, namespace);
-        }
-    }
-
-    /**
-     * Merges two children when this children's type allow multiple elements declaration with the
-     * same key value. In that case, we only merge the lower priority child if there is not already
-     * an element with the same key value that is equal to the lower priority child. Two children
-     * are equals if they have the same attributes and children declared irrespective of the
-     * declaration order.
-     *
-     * @param lowerPriorityChild the lower priority element's child.
-     * @param mergingReport the merging report to log errors and actions.
-     */
-    private void mergeChildrenWithMultipleDeclarations(
-            XmlElement lowerPriorityChild,
-            MergingReport.Builder mergingReport) {
-
-        Preconditions.checkArgument(lowerPriorityChild.getType().areMultipleDeclarationAllowed());
-        if (lowerPriorityChild.getType().areMultipleDeclarationAllowed()) {
-            for (XmlElement sameTypeChild : getAllNodesByType(lowerPriorityChild.getType())) {
-                if (sameTypeChild.getId().equals(lowerPriorityChild.getId()) &&
-                        sameTypeChild.isEquals(lowerPriorityChild)) {
-                    return;
-                }
-            }
-        }
-        // if we end up here, we never found a child of this element with the same key and strictly
-        // equals to the lowerPriorityChild so we should merge it in.
-        addElement(lowerPriorityChild, mergingReport);
-    }
-
-    /**
-     * Determine if we should completely ignore a child from any merging activity.
-     * There are 2 situations where we should ignore a lower priority child :
-     * <p>
-     * <ul>
-     *     <li>The associate {@link com.tyron.build.compiler.manifest.ManifestModel.NodeTypes} is
-     *     annotated with {@link com.tyron.build.compiler.manifest.MergeType#IGNORE}</li>
-     *     <li>This element has a child of the same type with no key that has a '
-     *     tools:node="removeAll' attribute.</li>
-     * </ul>
-     * @param lowerPriorityChild the lower priority child we should determine eligibility for
-     *                           merging.
-     * @return true if the element should be ignored, false otherwise.
-     */
-    private boolean shouldIgnore(
-            XmlElement lowerPriorityChild,
-            MergingReport.Builder mergingReport) {
-
-        if (lowerPriorityChild.getType().getMergeType() == MergeType.IGNORE) {
-            return true;
-        }
-
-        // do we have an element of the same type of that child with no key ?
-        Optional<XmlElement> thisChildElementOptional =
-                getNodeByTypeAndKey(lowerPriorityChild.getType(), null /* keyValue */);
-        if (!thisChildElementOptional.isPresent()) {
-            return false;
-        }
-        XmlElement thisChild = thisChildElementOptional.get();
-
-        // are we supposed to delete all occurrences and if yes, is there a selector defined to
-        // filter which elements should be deleted.
-        boolean shouldDelete = thisChild.mNodeOperationType == NodeOperationType.REMOVE_ALL
-                && (thisChild.mSelector == null
-                || thisChild.mSelector.appliesTo(lowerPriorityChild));
-        // if we should discard this child element, record the action.
-        if (shouldDelete) {
-            mergingReport.getActionRecorder().recordNodeAction(thisChildElementOptional.get(),
-                    Actions.ActionType.REJECTED,
-                    lowerPriorityChild);
-        }
-        return shouldDelete;
-    }
-
-    /**
-     * Handle 2 elements (of same identity) merging.
-     * higher priority one has a tools:node="remove", remove the low priority one
-     * higher priority one has a tools:node="replace", replace the low priority one
-     * higher priority one has a tools:node="strict", flag the error if not equals.
-     * default or tools:node="merge", merge the two elements.
-     * @param higherPriority the higher priority node.
-     * @param lowerPriority the lower priority element.
-     * @param mergingReport the merging report to log errors and actions.
-     */
-    private void handleTwoElementsExistence(
-            XmlElement higherPriority,
-            XmlElement lowerPriority,
-            MergingReport.Builder mergingReport) {
-
-        NodeOperationType operationType = calculateNodeOperationType(higherPriority, lowerPriority);
-        // 2 nodes exist, 3 possibilities :
-        //  higher priority one has a tools:node="remove", remove the low priority one
-        //  higher priority one has a tools:node="replace", replace the low priority one
-        //  higher priority one has a tools:node="strict", flag the error if not equals.
-        switch(operationType) {
-            case MERGE:
-            case MERGE_ONLY_ATTRIBUTES:
-                // record the action
-                mergingReport.getActionRecorder().recordNodeAction(higherPriority,
-                        Actions.ActionType.MERGED, lowerPriority);
-                // and perform the merge
-                higherPriority.mergeWithLowerPriorityNode(lowerPriority, mergingReport);
-                break;
-            case REMOVE:
-            case REPLACE:
-                // so far remove and replace and similar, the post validation will take
-                // care of removing this node in the case of REMOVE.
-
-                // just don't import the lower priority node and record the action.
-                mergingReport.getActionRecorder().recordNodeAction(higherPriority,
-                        Actions.ActionType.REJECTED, lowerPriority);
-                break;
-            case STRICT:
-                Optional<String> compareMessage = higherPriority.compareTo(lowerPriority);
-                if (compareMessage.isPresent()) {
-                    // flag error.
-                    addMessage(mergingReport, MergingReport.Record.Severity.ERROR, String.format(
-                            "Node %1$s at %2$s is tagged with tools:node=\"strict\", yet "
-                                    + "%3$s at %4$s is different : %5$s",
-                            higherPriority.getId(),
-                            higherPriority.printPosition(),
-                            lowerPriority.getId(),
-                            lowerPriority.printPosition(),
-                            compareMessage.get()
-                    ));
-                }
-                break;
-            default:
-                mergingReport.getLogger().error(String.format(
-                        "Unhandled node operation type %s", higherPriority.getOperationType()));
-                break;
-        }
-    }
-
-    /**
-     * Calculate the effective node operation type for a higher priority node when a lower priority
-     * node is queried for merge.
-     * @param higherPriority the higher priority node which may have a {@link NodeOperationType}
-     *                       declaration and may also have a {@link Selector} declaration.
-     * @param lowerPriority the lower priority node that is elected for merging with the higher
-     *                      priority node.
-     * @return the effective {@link NodeOperationType} that should be used to affect higher and
-     * lower priority nodes merging.
-     */
-    private static NodeOperationType calculateNodeOperationType(
-            @NonNull XmlElement higherPriority,
-            @NonNull XmlElement lowerPriority) {
-
-        NodeOperationType operationType = higherPriority.getOperationType();
-        // if the operation's selector exists and the lower priority node is not selected,
-        // we revert to default operation type which is merge.
-        if (higherPriority.supportsSelector()
-                && higherPriority.mSelector != null
-                && !higherPriority.mSelector.appliesTo(lowerPriority)) {
-            operationType = NodeOperationType.MERGE;
-        }
-        return operationType;
-    }
-
-    /**
-     * Add an element and its leading comments as the last sub-element of the current element.
-     * @param elementToBeAdded xml element to be added to the current element.
-     * @param mergingReport the merging report to log errors and actions.
-     */
-    private void addElement(XmlElement elementToBeAdded, MergingReport.Builder mergingReport) {
-
-        List<Node> comments = getLeadingComments(elementToBeAdded.getXml());
-        // record all the actions before the node is moved from the library document to the main
-        // merged document.
-        mergingReport.getActionRecorder().recordDefaultNodeAction(elementToBeAdded);
-
-        // only in the new file, just import it.
-        Node node = getXml().getOwnerDocument().adoptNode(elementToBeAdded.getXml());
-        getXml().appendChild(node);
-
-        // also adopt the child's comments if any.
-        for (Node comment : comments) {
-            Node newComment = getXml().getOwnerDocument().adoptNode(comment);
-            getXml().insertBefore(newComment, node);
-        }
-
-        mergingReport.getLogger().verbose("Adopted " + node);
-    }
-
-    public boolean isEquals(XmlElement otherNode) {
-        return !compareTo(otherNode).isPresent();
-    }
-
-    /**
-     * Returns a potentially null (if not present) selector decoration on this element.
-     */
-    @Nullable
-    public Selector getSelector() {
-        return mSelector;
-    }
-
-    /**
-     * Compares this element with another {@link XmlElement} ignoring all attributes belonging to
-     * the {@link com.tyron.build.compiler.manifest.SdkConstants#TOOLS_URI} namespace.
-     *
-     * @param other the other element to compare against.
-     * @return a {@link String} describing the differences between the two XML elements or
-     * {@link Optional#absent()} if they are equals.
-     */
-    public Optional<String> compareTo(Object other) {
-
-        if (!(other instanceof XmlElement)) {
-            return Optional.of("Wrong type");
-        }
-        XmlElement otherNode = (XmlElement) other;
-
-        // compare element names
-        if (getXml().getNamespaceURI() != null) {
-            if (!getXml().getLocalName().equals(otherNode.getXml().getLocalName())) {
-                return Optional.of(
-                        String.format("Element names do not match: %1$s versus %2$s",
-                                getXml().getLocalName(),
-                                otherNode.getXml().getLocalName()));
-            }
-            // compare element ns
-            String thisNS = getXml().getNamespaceURI();
-            String otherNS = otherNode.getXml().getNamespaceURI();
-            if ((thisNS == null && otherNS != null)
-                    || (thisNS != null && !thisNS.equals(otherNS))) {
-                return Optional.of(
-                        String.format("Element namespaces names do not match: %1$s versus %2$s",
-                                thisNS, otherNS));
-            }
-        } else {
-            if (!getXml().getNodeName().equals(otherNode.getXml().getNodeName())) {
-                return Optional.of(String.format("Element names do not match: %1$s versus %2$s",
-                        getXml().getNodeName(),
-                        otherNode.getXml().getNodeName()));
-            }
-        }
-
-        // compare attributes, we do it twice to identify added/missing elements in both lists.
-        Optional<String> message = checkAttributes(this, otherNode);
-        if (message.isPresent()) {
-            return message;
-        }
-        message = checkAttributes(otherNode, this);
-        if (message.isPresent()) {
-            return message;
-        }
-
-        // compare children
-        List<Node> expectedChildren = filterUninterestingNodes(getXml().getChildNodes());
-        List<Node> actualChildren = filterUninterestingNodes(otherNode.getXml().getChildNodes());
-        if (expectedChildren.size() != actualChildren.size()) {
-
-            if (expectedChildren.size() > actualChildren.size()) {
-                // missing some.
-                List<String> missingChildrenNames =
-                        Lists.transform(expectedChildren, NODE_TO_NAME);
-                missingChildrenNames.removeAll(Lists.transform(actualChildren, NODE_TO_NAME));
-                return Optional.of(String.format(
-                        "%1$s: Number of children do not match up: "
-                                + "expected %2$d versus %3$d at %4$s, missing %5$s",
-                        getId(),
-                        expectedChildren.size(),
-                        actualChildren.size(),
-                        otherNode.printPosition(),
-                        Joiner.on(",").join(missingChildrenNames)));
-            } else {
-                // extra ones.
-                List<String> extraChildrenNames = Lists.transform(actualChildren, NODE_TO_NAME);
-                extraChildrenNames.removeAll(Lists.transform(expectedChildren, NODE_TO_NAME));
-                return Optional.of(String.format(
-                        "%1$s: Number of children do not match up: "
-                                + "expected %2$d versus %3$d at %4$s, extra elements found : %5$s",
-                        getId(),
-                        expectedChildren.size(),
-                        actualChildren.size(),
-                        otherNode.printPosition(),
-                        Joiner.on(",").join(expectedChildren)));
-            }
-        }
-        for (Node expectedChild : expectedChildren) {
-            if (expectedChild.getNodeType() == Node.ELEMENT_NODE) {
-                XmlElement expectedChildNode = new XmlElement((Element) expectedChild, mDocument);
-                message = findAndCompareNode(otherNode, actualChildren, expectedChildNode);
-                if (message.isPresent()) {
-                    return message;
-                }
-            }
-        }
-        return Optional.absent();
-    }
-
-    private Optional<String> findAndCompareNode(
-            XmlElement otherElement,
-            List<Node> otherElementChildren,
-            XmlElement childNode) {
-
-        Optional<String> message = Optional.absent();
-        for (Node potentialNode : otherElementChildren) {
-            if (potentialNode.getNodeType() == Node.ELEMENT_NODE) {
-                XmlElement otherChildNode = new XmlElement((Element) potentialNode, mDocument);
-                if (childNode.getType() == otherChildNode.getType()) {
-                    // check if this element uses a key.
-                    if (childNode.getType().getNodeKeyResolver().getKeyAttributesNames()
-                            .isEmpty()) {
-                        // no key... try all the other elements, if we find one equal, we are done.
-                        message = childNode.compareTo(otherChildNode);
-                        if (!message.isPresent()) {
-                            return Optional.absent();
-                        }
-                    } else {
-                        // key...
-                        if (childNode.getKey() == null) {
-                            // other key MUST also be null.
-                            if (otherChildNode.getKey() == null) {
-                                return childNode.compareTo(otherChildNode);
-                            }
-                        } else {
-                            if (childNode.getKey().equals(otherChildNode.getKey())) {
-                                return childNode.compareTo(otherChildNode);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        return message.isPresent()
-                ? message
-                : Optional.of(String.format("Child %1$s not found in document %2$s",
-                childNode.getId(),
-                otherElement.printPosition()));
-    }
-
-    private static List<Node> filterUninterestingNodes(NodeList nodeList) {
-        List<Node> interestingNodes = new ArrayList<Node>();
-        for (int i = 0; i < nodeList.getLength(); i++) {
-            Node node = nodeList.item(i);
-            if (node.getNodeType() == Node.TEXT_NODE) {
-                Text t = (Text) node;
-                if (!t.getData().trim().isEmpty()) {
-                    interestingNodes.add(node);
-                }
-            } else if (node.getNodeType() != Node.COMMENT_NODE) {
-                interestingNodes.add(node);
-            }
-
-        }
-        return interestingNodes;
-    }
-
-    private static Optional<String> checkAttributes(
-            XmlElement expected,
-            XmlElement actual) {
-
-        for (XmlAttribute expectedAttr : expected.getAttributes()) {
-            XmlAttribute.NodeName attributeName = expectedAttr.getName();
-            if (attributeName.isInNamespace(SdkConstants.TOOLS_URI)) {
-                continue;
-            }
-            Optional<XmlAttribute> actualAttr = actual.getAttribute(attributeName);
-            if (actualAttr.isPresent()) {
-                if (!expectedAttr.getValue().equals(actualAttr.get().getValue())) {
-                    return Optional.of(
-                            String.format("Attribute %1$s do not match: %2$s versus %3$s at %4$s",
-                                    expectedAttr.getId(),
-                                    expectedAttr.getValue(),
-                                    actualAttr.get().getValue(),
-                                    actual.printPosition()));
-                }
-            } else {
-                return Optional.of(String.format("Attribute %1$s not found at %2$s",
-                        expectedAttr.getId(), actual.printPosition()));
-            }
-        }
-        return Optional.absent();
-    }
-
-    private ImmutableList<XmlElement> initMergeableChildren() {
-        ImmutableList.Builder<XmlElement> mergeableNodes = new ImmutableList.Builder<XmlElement>();
-        NodeList nodeList = getXml().getChildNodes();
-        for (int i = 0; i < nodeList.getLength(); i++) {
-            Node node = nodeList.item(i);
-            if (node instanceof Element) {
-                XmlElement xmlElement = new XmlElement((Element) node, mDocument);
-                mergeableNodes.add(xmlElement);
-            }
-        }
-        return mergeableNodes.build();
-    }
-
-    /**
-     * Returns all leading comments in the source xml before the node to be adopted.
-     * @param nodeToBeAdopted node that will be added as a child to this node.
-     */
-    static List<Node> getLeadingComments(Node nodeToBeAdopted) {
-        ImmutableList.Builder<Node> nodesToAdopt = new ImmutableList.Builder<Node>();
-        Node previousSibling = nodeToBeAdopted.getPreviousSibling();
-        while (previousSibling != null
-                && (previousSibling.getNodeType() == Node.COMMENT_NODE
-                || previousSibling.getNodeType() == Node.TEXT_NODE)) {
-            // we really only care about comments.
-            if (previousSibling.getNodeType() == Node.COMMENT_NODE) {
-                nodesToAdopt.add(previousSibling);
-            }
-            previousSibling = previousSibling.getPreviousSibling();
-        }
-        return nodesToAdopt.build().reverse();
-    }
-
-    void addMessage(MergingReport.Builder mergingReport,
-                    MergingReport.Record.Severity severity,
-                    String message) {
-        mergingReport.addMessage(getSourceFilePosition(),
-                severity,
-                message);
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/KeyResolver.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/KeyResolver.java b/Build/src/main/java/com/tyron/build/compiler/manifest/KeyResolver.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/KeyResolver.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,20 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.Nullable;
-
-/**
- * Facility to identify an element from its key.
- */
-public interface KeyResolver<T> {
-
-    /**
-     * Returns an element identified with the passed key.
-     * @param key key to resolve.
-     * @return the element identified by the passed key or null if there is no key of that name.
-     */
-    @Nullable
-    T resolve(String key);
-
-    Iterable<String> getKeys();
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/XmlDocument.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlDocument.java b/Build/src/main/java/com/tyron/build/compiler/manifest/XmlDocument.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlDocument.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,562 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.ManifestModel.NodeTypes.USES_PERMISSION;
-import static com.tyron.build.compiler.manifest.ManifestModel.NodeTypes.USES_SDK;
-
-import com.android.sdklib.SdkVersionInfo;
-import com.tyron.build.compiler.manifest.ManifestMerger2.SystemProperty;
-import com.tyron.build.compiler.manifest.PlaceholderHandler.KeyBasedValueResolver;
-
-import android.util.Pair;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
-import com.google.common.base.Strings;
-import com.google.common.collect.ImmutableList;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-import com.tyron.build.compiler.manifest.xml.XmlFormatPreferences;
-import com.tyron.build.compiler.manifest.xml.XmlFormatStyle;
-import com.tyron.build.compiler.manifest.xml.XmlPrettyPrinter;
-import com.tyron.build.util.PositionXmlParser;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * Represents a loaded xml document.
- *
- * Has pointers to the root {@link XmlElement} element and provides services to persist the document
- * to an external format. Also provides abilities to be merged with other
- * {@link XmlDocument} as well as access to the line numbers for all
- * document's xml elements and attributes.
- *
- */
-public class XmlDocument {
-
-    private static final String DEFAULT_SDK_VERSION = "1";
-
-    /**
-     * The document type.
-     */
-    enum Type {
-        /**
-         * A manifest overlay as found in the build types and variants.
-         */
-        OVERLAY,
-        /**
-         * The main android manifest file.
-         */
-        MAIN,
-        /**
-         * A library manifest that is imported in the application.
-         */
-        LIBRARY
-    }
-
-    private final Element mRootElement;
-    // this is initialized lazily to avoid un-necessary early parsing.
-    private final AtomicReference<XmlElement> mRootNode = new AtomicReference<XmlElement>(null);
-    private final SourceFile mSourceFile;
-    private final KeyResolver<String> mSelectors;
-    private final KeyBasedValueResolver<SystemProperty> mSystemPropertyResolver;
-    private final Type mType;
-    private final Optional<String> mMainManifestPackageName;
-
-    public XmlDocument(
-            @NonNull SourceFile sourceLocation,
-            @NonNull KeyResolver<String> selectors,
-            @NonNull KeyBasedValueResolver<SystemProperty> systemPropertyResolver,
-            @NonNull Element element,
-            @NonNull Type type,
-            @NonNull Optional<String> mainManifestPackageName) {
-        this.mSourceFile = Preconditions.checkNotNull(sourceLocation);
-        this.mRootElement = Preconditions.checkNotNull(element);
-        this.mSelectors = Preconditions.checkNotNull(selectors);
-        this.mSystemPropertyResolver = Preconditions.checkNotNull(systemPropertyResolver);
-        this.mType = type;
-        this.mMainManifestPackageName = mainManifestPackageName;
-    }
-
-    public Type getFileType() {
-        return mType;
-    }
-
-    /**
-     * Returns a pretty string representation of this document.
-     */
-    public String prettyPrint() {
-        return XmlPrettyPrinter.prettyPrint(
-                getXml(),
-                XmlFormatPreferences.defaults(),
-                XmlFormatStyle.get(getRootNode().getXml()),
-                null, /* endOfLineSeparator */
-                false /* endWithNewLine */);
-    }
-
-    /**
-     * merge this higher priority document with a higher priority document.
-     * @param lowerPriorityDocument the lower priority document to merge in.
-     * @param mergingReportBuilder the merging report to record errors and actions.
-     * @return a new merged {@link XmlDocument} or
-     * {@link Optional#absent()} if there were errors during the merging activities.
-     */
-    public Optional<XmlDocument> merge(
-            XmlDocument lowerPriorityDocument,
-            MergingReport.Builder mergingReportBuilder) {
-
-        if (getFileType() == Type.MAIN) {
-            mergingReportBuilder.getActionRecorder().recordDefaultNodeAction(getRootNode());
-        }
-
-        getRootNode().mergeWithLowerPriorityNode(
-                lowerPriorityDocument.getRootNode(), mergingReportBuilder);
-
-        addImplicitElements(lowerPriorityDocument, mergingReportBuilder);
-
-        // force re-parsing as new nodes may have appeared.
-        return mergingReportBuilder.hasErrors()
-                ? Optional.<XmlDocument>absent()
-                : Optional.of(reparse());
-    }
-
-    /**
-     * Forces a re-parsing of the document
-     * @return a new {@link XmlDocument} with up to date information.
-     */
-    public XmlDocument reparse() {
-        return new XmlDocument(
-                mSourceFile,
-                mSelectors,
-                mSystemPropertyResolver,
-                mRootElement,
-                mType,
-                mMainManifestPackageName);
-    }
-
-    /**
-     * Returns a {@link KeyResolver} capable of resolving all selectors
-     * types
-     */
-    public KeyResolver<String> getSelectors() {
-        return mSelectors;
-    }
-
-    /**
-     * Returns the {@link PlaceholderHandler.KeyBasedValueResolver} capable
-     * of resolving all injected {@link ManifestMerger2.SystemProperty}
-     */
-    public KeyBasedValueResolver<SystemProperty> getSystemPropertyResolver() {
-        return mSystemPropertyResolver;
-    }
-
-    /**
-     * Compares this document to another {@link XmlDocument} ignoring all
-     * attributes belonging to the {@link SdkConstants#TOOLS_URI} namespace.
-     *
-     * @param other the other document to compare against.
-     * @return  a {@link String} describing the differences between the two XML elements or
-     * {@link Optional#absent()} if they are equals.
-     */
-    public Optional<String> compareTo(XmlDocument other) {
-        return getRootNode().compareTo(other.getRootNode());
-    }
-
-    /**
-     * Returns the position of the specified {@link XmlNode}.
-     */
-    @NonNull
-    static SourcePosition getNodePosition(XmlNode node) {
-        return getNodePosition(node.getXml());
-    }
-
-    /**
-     * Returns the position of the specified {@link org.w3c.dom.Node}.
-     */
-    @NonNull
-    static SourcePosition getNodePosition(Node xml) {
-        return PositionXmlParser.getPosition(xml);
-    }
-
-    @NonNull
-    public SourceFile getSourceFile() {
-        return mSourceFile;
-    }
-
-    public synchronized XmlElement getRootNode() {
-        if (mRootNode.get() == null) {
-            this.mRootNode.set(new XmlElement(mRootElement, this));
-        }
-        return mRootNode.get();
-    }
-
-    public Optional<XmlElement> getByTypeAndKey(
-            ManifestModel.NodeTypes type,
-            @Nullable String keyValue) {
-
-        return getRootNode().getNodeByTypeAndKey(type, keyValue);
-    }
-
-    /**
-     * Package name for this android manifest which will be used to resolve
-     * partial path. In the case of Overlays, this is absent and the main
-     * manifest packageName must be used.
-     * @return the package name to do partial class names resolution.
-     */
-    public String getPackageName() {
-        return mMainManifestPackageName.or(mRootElement.getAttribute("package"));
-    }
-
-    /**
-     * Returns the package name to use to expand the attributes values with the
-     * document's package name
-     * @return the package name to use for attribute expansion.
-     */
-    public String getPackageNameForAttributeExpansion() {
-        String aPackage = mRootElement.getAttribute("package");
-        if (aPackage != null) {
-            return aPackage;
-        }
-        if (mMainManifestPackageName.isPresent()) {
-            return mMainManifestPackageName.get();
-        }
-        throw new RuntimeException("No package present in overlay or main manifest file");
-    }
-
-    public Optional<XmlAttribute> getPackage() {
-        Optional<XmlAttribute> packageAttribute =
-                getRootNode().getAttribute(XmlNode.fromXmlName("package"));
-        return packageAttribute.isPresent()
-                ? packageAttribute
-                : getRootNode().getAttribute(XmlNode.fromNSName(
-                SdkConstants.ANDROID_URI, "android", "package"));
-    }
-
-    public Document getXml() {
-        return mRootElement.getOwnerDocument();
-    }
-
-    /**
-     * Returns the minSdk version specified in the uses_sdk element if present or the
-     * default value.
-     */
-    private String getRawMinSdkVersion() {
-        Optional<XmlElement> usesSdk = getByTypeAndKey(
-                USES_SDK, null);
-        if (usesSdk.isPresent()) {
-            Optional<XmlAttribute> minSdkVersion = usesSdk.get()
-                    .getAttribute(XmlNode.fromXmlName("android:minSdkVersion"));
-            if (minSdkVersion.isPresent()) {
-                return minSdkVersion.get().getValue();
-            }
-        }
-        return DEFAULT_SDK_VERSION;
-    }
-
-    /**
-     * Returns the minSdk version for this manifest file. It can be injected from the outer
-     * build.gradle or can be expressed in the uses_sdk element.
-     */
-    private String getMinSdkVersion() {
-        // check for system properties.
-        String injectedMinSdk = mSystemPropertyResolver.getValue(SystemProperty.MIN_SDK_VERSION);
-        if (injectedMinSdk != null) {
-            return injectedMinSdk;
-        }
-        return getRawMinSdkVersion();
-    }
-
-    /**
-     * Returns the targetSdk version specified in the uses_sdk element if present or the
-     * default value.
-     */
-    private String getRawTargetSdkVersion() {
-
-        Optional<XmlElement> usesSdk = getByTypeAndKey(
-                USES_SDK, null);
-        if (usesSdk.isPresent()) {
-            Optional<XmlAttribute> targetSdkVersion = usesSdk.get()
-                    .getAttribute(XmlNode.fromXmlName("android:targetSdkVersion"));
-            if (targetSdkVersion.isPresent()) {
-                return targetSdkVersion.get().getValue();
-            }
-        }
-        return getRawMinSdkVersion();
-    }
-
-    /**
-     * Returns the targetSdk version for this manifest file. It can be injected from the outer
-     * build.gradle or can be expressed in the uses_sdk element.
-     */
-    private String getTargetSdkVersion() {
-
-        // check for system properties.
-        String injectedTargetVersion = mSystemPropertyResolver
-                .getValue(SystemProperty.TARGET_SDK_VERSION);
-        if (injectedTargetVersion != null) {
-            return injectedTargetVersion;
-        }
-        return getRawTargetSdkVersion();
-    }
-
-    /**
-     * Decodes a sdk version from either its decimal representation or from a platform code name.
-     * @param attributeVersion the sdk version attribute as specified by users.
-     * @return the integer representation of the platform level.
-     */
-    private static int getApiLevelFromAttribute(String attributeVersion) {
-        Preconditions.checkArgument(!Strings.isNullOrEmpty(attributeVersion));
-        if (Character.isDigit(attributeVersion.charAt(0))) {
-            return Integer.parseInt(attributeVersion);
-        }
-        return SdkVersionInfo.getApiByPreviewName(attributeVersion, true);
-    }
-
-    /**
-     * Add all implicit elements from the passed lower priority document that are
-     * required in the target SDK.
-     */
-    @SuppressWarnings("unchecked") // compiler confused about varargs and generics.
-    private void addImplicitElements(XmlDocument lowerPriorityDocument,
-                                     MergingReport.Builder mergingReport) {
-
-        // if this document is an overlay, tolerate the absence of uses-sdk and do not
-        // assume implicit minimum versions.
-        Optional<XmlElement> usesSdk = getByTypeAndKey(
-                USES_SDK, null);
-        if (mType == Type.OVERLAY && !usesSdk.isPresent()) {
-            return;
-        }
-
-        // check that the uses-sdk element does not have any tools:node instruction.
-        if (usesSdk.isPresent()) {
-            XmlElement usesSdkElement = usesSdk.get();
-            if (usesSdkElement.getOperationType() != NodeOperationType.MERGE) {
-                mergingReport
-                        .addMessage(
-                                new SourceFilePosition(
-                                        getSourceFile(),
-                                        usesSdkElement.getPosition()),
-                                MergingReport.Record.Severity.ERROR,
-                                "uses-sdk element cannot have a \"tools:node\" attribute");
-                return;
-            }
-        }
-        int thisTargetSdk = getApiLevelFromAttribute(getTargetSdkVersion());
-
-        // when we are importing a library, we should never use the build.gradle injected
-        // values (only valid for overlay, main manifest) so use the raw versions coming from
-        // the AndroidManifest.xml
-        int libraryTargetSdk = getApiLevelFromAttribute(
-                lowerPriorityDocument.getFileType() == Type.LIBRARY
-                        ? lowerPriorityDocument.getRawTargetSdkVersion()
-                        : lowerPriorityDocument.getTargetSdkVersion());
-
-        // if library is using a code name rather than an API level, make sure this document target
-        // sdk version is using the same code name.
-        String libraryTargetSdkVersion = lowerPriorityDocument.getTargetSdkVersion();
-        if (!Character.isDigit(libraryTargetSdkVersion.charAt(0))) {
-            // this is a code name, ensure this document uses the same code name.
-            if (!libraryTargetSdkVersion.equals(getTargetSdkVersion())) {
-                mergingReport.addMessage(getSourceFile(), MergingReport.Record.Severity.ERROR,
-                        String.format(
-                                "uses-sdk:targetSdkVersion %1$s cannot be different than version "
-                                        + "%2$s declared in library %3$s",
-                                getTargetSdkVersion(),
-                                libraryTargetSdkVersion,
-                                lowerPriorityDocument.getSourceFile().print(false)
-                        )
-                );
-                return;
-            }
-        }
-        // same for minSdkVersion, if the library is using a code name, the application must
-        // also be using the same code name.
-        String libraryMinSdkVersion = lowerPriorityDocument.getRawMinSdkVersion();
-        if (!Character.isDigit(libraryMinSdkVersion.charAt(0))) {
-            // this is a code name, ensure this document uses the same code name.
-            if (!libraryMinSdkVersion.equals(getMinSdkVersion())) {
-                mergingReport.addMessage(getSourceFile(), MergingReport.Record.Severity.ERROR,
-                        String.format(
-                                "uses-sdk:minSdkVersion %1$s cannot be different than version "
-                                        + "%2$s declared in library %3$s",
-                                getMinSdkVersion(),
-                                libraryMinSdkVersion,
-                                lowerPriorityDocument.getSourceFile().print(false)
-                        )
-                );
-                return;
-            }
-        }
-
-        if (!checkUsesSdkMinVersion(lowerPriorityDocument, mergingReport)) {
-            String error = String.format(
-                    "uses-sdk:minSdkVersion %1$s cannot be smaller than version "
-                            + "%2$s declared in library %3$s\n"
-                            + "\tSuggestion: use tools:overrideLibrary=\"%4$s\" to force usage",
-                    getMinSdkVersion(),
-                    lowerPriorityDocument.getRawMinSdkVersion(),
-                    lowerPriorityDocument.getSourceFile().print(false),
-                    lowerPriorityDocument.getPackageName());
-            if (usesSdk.isPresent()) {
-                mergingReport.addMessage(
-                        new SourceFilePosition(getSourceFile(), usesSdk.get().getPosition()),
-                        MergingReport.Record.Severity.ERROR,
-                        error);
-            } else {
-                mergingReport.addMessage(
-                        getSourceFile(), MergingReport.Record.Severity.ERROR, error);
-            }
-            return;
-        }
-
-        // if the merged document target SDK is equal or smaller than the library's, nothing to do.
-        if (thisTargetSdk <= libraryTargetSdk) {
-            return;
-        }
-
-        // There is no need to add any implied permissions when targeting an old runtime.
-        if (thisTargetSdk < 4) {
-            return;
-        }
-
-        boolean hasWriteToExternalStoragePermission =
-                lowerPriorityDocument.getByTypeAndKey(
-                         USES_PERMISSION, permission("WRITE_EXTERNAL_STORAGE")).isPresent();
-
-        if (libraryTargetSdk < 4) {
-            addIfAbsent(mergingReport.getActionRecorder(),
-                    USES_PERMISSION,
-                    permission("WRITE_EXTERNAL_STORAGE"),
-                    lowerPriorityDocument.getPackageName() + " has a targetSdkVersion < 4");
-            hasWriteToExternalStoragePermission = true;
-
-            addIfAbsent(mergingReport.getActionRecorder(),
-                    USES_PERMISSION,
-                    permission("READ_PHONE_STATE"),
-                    lowerPriorityDocument.getPackageName() + " has a targetSdkVersion < 4");
-        }
-
-        // If the application has requested WRITE_EXTERNAL_STORAGE, we will
-        // force them to always take READ_EXTERNAL_STORAGE as well.  We always
-        // do this (regardless of target API version) because we can't have
-        // an app with write permission but not read permission.
-        if (hasWriteToExternalStoragePermission) {
-
-            addIfAbsent(mergingReport.getActionRecorder(),
-                    USES_PERMISSION,
-                    permission("READ_EXTERNAL_STORAGE"),
-                    lowerPriorityDocument.getPackageName() + " requested WRITE_EXTERNAL_STORAGE");
-        }
-
-        // Pre-JellyBean call log permission compatibility.
-        if (thisTargetSdk >= 16 && libraryTargetSdk < 16) {
-            if (lowerPriorityDocument.getByTypeAndKey(
-                    USES_PERMISSION, permission("READ_CONTACTS")).isPresent()) {
-                addIfAbsent(mergingReport.getActionRecorder(),
-                        USES_PERMISSION, permission("READ_CALL_LOG"),
-                        lowerPriorityDocument.getPackageName()
-                                + " has targetSdkVersion < 16 and requested READ_CONTACTS");
-            }
-            if (lowerPriorityDocument.getByTypeAndKey(
-                    USES_PERMISSION, permission("WRITE_CONTACTS")).isPresent()) {
-                addIfAbsent(mergingReport.getActionRecorder(),
-                        USES_PERMISSION, permission("WRITE_CALL_LOG"),
-                        lowerPriorityDocument.getPackageName()
-                                + " has targetSdkVersion < 16 and requested WRITE_CONTACTS");
-            }
-        }
-    }
-
-    /**
-     * Returns true if the minSdkVersion of the application and the library are compatible, false
-     * otherwise.
-     */
-    private boolean checkUsesSdkMinVersion(XmlDocument lowerPriorityDocument,
-                                           MergingReport.Builder mergingReport) {
-
-        int thisMinSdk = getApiLevelFromAttribute(getMinSdkVersion());
-        int libraryMinSdk = getApiLevelFromAttribute(
-                lowerPriorityDocument.getRawMinSdkVersion());
-
-        // the merged document minSdk cannot be lower than a library
-        if (thisMinSdk < libraryMinSdk) {
-
-            // check if this higher priority document has any tools instructions for the node
-            Optional<XmlElement> xmlElementOptional = getByTypeAndKey(USES_SDK, null);
-            if (!xmlElementOptional.isPresent()) {
-                return false;
-            }
-            XmlElement xmlElement = xmlElementOptional.get();
-
-            // if we find a selector that applies to this library. the users wants to explicitly
-            // allow this higher version library to be allowed.
-            for (Selector selector : xmlElement.getOverrideUsesSdkLibrarySelectors()) {
-                if (selector.appliesTo(lowerPriorityDocument.getRootNode())) {
-                    return true;
-                }
-            }
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Adds a new element of type nodeType with a specific keyValue if the element is absent in this
-     * document. Will also add attributes expressed through key value pairs.
-     *
-     * @param actionRecorder to records creation actions.
-     * @param nodeType the node type to crete
-     * @param keyValue the optional key for the element.
-     * @param attributes the optional array of key value pairs for extra element attribute.
-     * @return the Xml element whether it was created or existed or {@link Optional#absent()} if
-     * it does not exist in this document.
-     */
-    private Optional<Element> addIfAbsent(
-            @NonNull ActionRecorder actionRecorder,
-            @NonNull ManifestModel.NodeTypes nodeType,
-            @Nullable String keyValue,
-            @Nullable String reason,
-            @Nullable Pair<String, String>... attributes) {
-
-        Optional<XmlElement> xmlElementOptional = getByTypeAndKey(nodeType, keyValue);
-        if (xmlElementOptional.isPresent()) {
-            return Optional.absent();
-        }
-        Element elementNS = getXml()
-                .createElementNS(SdkConstants.ANDROID_URI, "android:" + nodeType.toXmlName());
-
-
-        ImmutableList<String> keyAttributesNames = nodeType.getNodeKeyResolver()
-                .getKeyAttributesNames();
-        if (keyAttributesNames.size() == 1) {
-            elementNS.setAttributeNS(
-                    SdkConstants.ANDROID_URI, "android:" + keyAttributesNames.get(0), keyValue);
-        }
-        if (attributes != null) {
-            for (Pair<String, String> attribute : attributes) {
-                elementNS.setAttributeNS(
-                        SdkConstants.ANDROID_URI, "android:" + attribute.first,
-                        attribute.second);
-            }
-        }
-
-        // record creation.
-        XmlElement xmlElement = new XmlElement(elementNS, this);
-        actionRecorder.recordImpliedNodeAction(xmlElement, reason);
-
-        getRootNode().getXml().appendChild(elementNS);
-        return Optional.of(elementNS);
-    }
-
-    private static String permission(String permissionName) {
-        return "android.permission." + permissionName;
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/PreValidator.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/PreValidator.java b/Build/src/main/java/com/tyron/build/compiler/manifest/PreValidator.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/PreValidator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,268 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.MergingReport.Record.Severity.ERROR;
-import static com.tyron.build.compiler.manifest.MergingReport.Record.Severity.WARNING;
-import static com.tyron.build.compiler.manifest.XmlNode.NodeKey;
-
-import androidx.annotation.NonNull;
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.base.Strings;
-import com.google.common.collect.ImmutableList;
-import com.tyron.build.compiler.manifest.xml.AndroidManifest;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Validates a loaded {@link XmlDocument} and check for potential inconsistencies in the model due
- * to user error or omission.
- *
- * This is implemented as a separate class so it can be invoked by tools independently from the
- * merging process.
- *
- * This validator will check the state of the loaded xml document before any merging activity is
- * attempted. It verifies things like a "tools:replace="foo" attribute has a "android:foo"
- * attribute also declared on the same element (since we want to replace its value).
- */
-public class PreValidator {
-
-    private PreValidator(){
-    }
-
-    /**
-     * Validates a loaded {@link com.tyron.build.compiler.manifest.XmlDocument} and return a status of the
-     * merging model.
-     *
-     * Will return one the following status :
-     * <ul>
-     *     <li>{@link com.tyron.build.compiler.manifest.MergingReport.Result#SUCCESS} : the merging model is
-     *     correct, merging should be attempted</li>
-     *     <li>{@link com.tyron.build.compiler.manifest.MergingReport.Result#WARNING} : the merging model
-     *     contains non fatal error, user should be notified, merging can be attempted</li>
-     *     <li>{@link com.tyron.build.compiler.manifest.MergingReport.Result#ERROR} : the merging model
-     *     contains errors, user must be notified, merging should not be attempted</li>
-     * </ul>
-     *
-     * A successful validation does not mean that the merging will be successful, it only means
-     * that the {@link SdkConstants#TOOLS_URI} instructions are correct and consistent.
-     *
-     * @param mergingReport report to log warnings and errors.
-     * @param xmlDocument the loaded xml part.
-     * @return one the {@link com.tyron.build.compiler.manifest.MergingReport.Result} value.
-     */
-    @NonNull
-    public static MergingReport.Result validate(
-            @NonNull MergingReport.Builder mergingReport,
-            @NonNull XmlDocument xmlDocument) {
-
-        validateManifestAttribute(
-                mergingReport, xmlDocument.getRootNode(), xmlDocument.getFileType());
-        return validate(mergingReport, xmlDocument.getRootNode());
-    }
-
-    private static MergingReport.Result validate(MergingReport.Builder mergingReport,
-                                                 XmlElement xmlElement) {
-
-        validateAttributeInstructions(mergingReport, xmlElement);
-
-        validateAndroidAttributes(mergingReport, xmlElement);
-
-        checkSelectorPresence(mergingReport, xmlElement);
-
-        // create a temporary hash map of children indexed by key to ensure key uniqueness.
-        Map<NodeKey, XmlElement> childrenKeys = new HashMap<NodeKey, XmlElement>();
-        for (XmlElement childElement : xmlElement.getMergeableElements()) {
-
-            // if this element is tagged with 'tools:node=removeAll', ensure it has no other
-            // attributes.
-            if (childElement.getOperationType() == NodeOperationType.REMOVE_ALL) {
-                validateRemoveAllOperation(mergingReport, childElement);
-            } else {
-                if (checkKeyPresence(mergingReport, childElement)) {
-                    XmlElement twin = childrenKeys.get(childElement.getId());
-                    if (twin != null && !childElement.getType().areMultipleDeclarationAllowed()) {
-                        // we have 2 elements with the same identity, if they are equals,
-                        // issue a warning, if not, issue an error.
-                        String message = String.format(
-                                "Element %1$s at %2$s duplicated with element declared at %3$s",
-                                childElement.getId(),
-                                childElement.printPosition(),
-                                childrenKeys.get(childElement.getId()).printPosition());
-                        if (twin.compareTo(childElement).isPresent()) {
-                            childElement.addMessage(mergingReport, ERROR, message);
-                        } else {
-                            childElement.addMessage(mergingReport, WARNING, message);
-                        }
-                    }
-                    childrenKeys.put(childElement.getId(), childElement);
-                }
-                validate(mergingReport, childElement);
-            }
-        }
-        return mergingReport.hasErrors()
-                ? MergingReport.Result.ERROR : MergingReport.Result.SUCCESS;
-    }
-
-    /**
-     * Validate an xml declaration with 'tools:node="removeAll" annotation. There should not
-     * be any other attribute declaration on this element.
-     */
-    private static void validateRemoveAllOperation(MergingReport.Builder mergingReport,
-                                                   XmlElement element) {
-
-        NamedNodeMap attributes = element.getXml().getAttributes();
-        if (attributes.getLength() > 1) {
-            List<String> extraAttributeNames = new ArrayList<String>();
-            for (int i = 0; i < attributes.getLength(); i++) {
-                Node item = attributes.item(i);
-                if (!(SdkConstants.TOOLS_URI.equals(item.getNamespaceURI()) &&
-                        NodeOperationType.NODE_LOCAL_NAME.equals(item.getLocalName()))) {
-                    extraAttributeNames.add(item.getNodeName());
-                }
-            }
-            String message = String.format(
-                    "Element %1$s at %2$s annotated with 'tools:node=\"removeAll\"' cannot "
-                            + "have other attributes : %3$s",
-                    element.getId(),
-                    element.printPosition(),
-                    Joiner.on(',').join(extraAttributeNames)
-            );
-            element.addMessage(mergingReport, ERROR, message);
-        }
-    }
-
-    private static void checkSelectorPresence(MergingReport.Builder mergingReport,
-                                              XmlElement element) {
-
-        Attr selectorAttribute =
-                element.getXml().getAttributeNodeNS(SdkConstants.TOOLS_URI, Selector.SELECTOR_LOCAL_NAME);
-        if (selectorAttribute!=null && !element.supportsSelector()) {
-            String message = String.format(
-                    "Unsupported tools:selector=\"%1$s\" found on node %2$s at %3$s",
-                    selectorAttribute.getValue(),
-                    element.getId(),
-                    element.printPosition());
-            element.addMessage(mergingReport, ERROR, message);
-        }
-    }
-
-    private static void validateManifestAttribute(
-            MergingReport.Builder mergingReport, XmlElement manifest, XmlDocument.Type fileType) {
-        Attr attributeNode = manifest.getXml().getAttributeNode(AndroidManifest.ATTRIBUTE_PACKAGE);
-        // it's ok for an overlay to not have a package name, it's not ok for a main manifest
-        // and it's a warning for a library.
-        if (attributeNode == null && fileType != XmlDocument.Type.OVERLAY) {
-            manifest.addMessage(mergingReport,
-                    fileType == XmlDocument.Type.MAIN ? ERROR : WARNING,
-                    String.format(
-                            "Missing 'package' declaration in manifest at %1$s",
-                            manifest.printPosition()));
-        }
-    }
-
-    /**
-     * Checks that an element which is supposed to have a key does have one.
-     * @param mergingReport report to log warnings and errors.
-     * @param xmlElement xml element to check for key presence.
-     * @return true if the element has a valid key or false it does not need one or it is invalid.
-     */
-    private static boolean checkKeyPresence(
-            MergingReport.Builder mergingReport,
-            XmlElement xmlElement) {
-        ManifestModel.NodeKeyResolver nodeKeyResolver = xmlElement.getType().getNodeKeyResolver();
-        ImmutableList<String> keyAttributesNames = nodeKeyResolver.getKeyAttributesNames();
-        if (keyAttributesNames.isEmpty()) {
-            return false;
-        }
-        if (Strings.isNullOrEmpty(xmlElement.getKey())) {
-            // we should have a key but we don't.
-            String message = keyAttributesNames.size() > 1
-                    ? String.format(
-                    "Missing one of the key attributes '%1$s' on element %2$s at %3$s",
-                    Joiner.on(',').join(keyAttributesNames),
-                    xmlElement.getId(),
-                    xmlElement.printPosition())
-                    : String.format(
-                    "Missing '%1$s' key attribute on element %2$s at %3$s",
-                    keyAttributesNames.get(0),
-                    xmlElement.getId(),
-                    xmlElement.printPosition());
-            xmlElement.addMessage(mergingReport, ERROR, message);
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Validate attributes part of the {@link SdkConstants#ANDROID_URI}
-     * @param mergingReport report to log warnings and errors.
-     * @param xmlElement xml element to check its attributes.
-     */
-    private static void validateAndroidAttributes(MergingReport.Builder mergingReport,
-                                                  XmlElement xmlElement) {
-        for (XmlAttribute xmlAttribute : xmlElement.getAttributes()) {
-            AttributeModel model = xmlAttribute.getModel();
-            if (model != null && model.getOnReadValidator() != null) {
-                model.getOnReadValidator().validates(
-                        mergingReport, xmlAttribute, xmlAttribute.getValue());
-            }
-        }
-    }
-
-    /**
-     * Validates attributes part of the {@link SdkConstants#TOOLS_URI}
-     * @param mergingReport report to log warnings and errors.
-     * @param xmlElement xml element to check its attributes.
-     */
-    private static void validateAttributeInstructions(
-            MergingReport.Builder mergingReport,
-            XmlElement xmlElement) {
-
-        for (Map.Entry<XmlNode.NodeName, AttributeOperationType> attributeOperationTypeEntry :
-                xmlElement.getAttributeOperations()) {
-
-            Optional<XmlAttribute> attribute = xmlElement
-                    .getAttribute(attributeOperationTypeEntry.getKey());
-            switch(attributeOperationTypeEntry.getValue()) {
-                case STRICT:
-                    break;
-                case REMOVE:
-                    // check we are not provided a new value.
-                    if (attribute.isPresent()) {
-                        // Add one to startLine so the first line is displayed as 1.
-                        xmlElement.addMessage(mergingReport, ERROR, String.format(
-                                "tools:remove specified at line:%d for attribute %s, but "
-                                        + "attribute also declared at line:%d, "
-                                        + "do you want to use tools:replace instead ?",
-                                xmlElement.getPosition().getStartLine() + 1,
-                                attributeOperationTypeEntry.getKey(),
-                                attribute.get().getPosition().getStartLine() + 1
-                        ));
-                    }
-                    break;
-                case REPLACE:
-                    // check we are provided a new value
-                    if (!attribute.isPresent()) {
-                        // Add one to startLine so the first line is displayed as 1.
-                        xmlElement.addMessage(mergingReport, ERROR, String.format(
-                                "tools:replace specified at line:%d for attribute %s, but "
-                                        + "no new value specified",
-                                xmlElement.getPosition().getStartLine() + 1,
-                                attributeOperationTypeEntry.getKey()
-                        ));
-                    }
-                    break;
-                default:
-                    throw new IllegalStateException("Unhandled AttributeOperationType " +
-                            attributeOperationTypeEntry.getValue());
-            }
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/SdkConstants.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/SdkConstants.java b/Build/src/main/java/com/tyron/build/compiler/manifest/SdkConstants.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/SdkConstants.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1244 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import java.io.File;
-/**
- * Constant definition class.<br>
- * <br>
- * Most constants have a prefix defining the content.
- * <ul>
- * <li><code>OS_</code> OS path constant. These paths are different depending on the platform.</li>
- * <li><code>FN_</code> File name constant.</li>
- * <li><code>FD_</code> Folder name constant.</li>
- * <li><code>TAG_</code> XML element tag name</li>
- * <li><code>ATTR_</code> XML attribute name</li>
- * <li><code>VALUE_</code> XML attribute value</li>
- * <li><code>CLASS_</code> Class name</li>
- * <li><code>DOT_</code> File name extension, including the dot </li>
- * <li><code>EXT_</code> File name extension, without the dot </li>
- * </ul>
- */
-@SuppressWarnings({"javadoc", "unused"}) // Not documenting all the fields here
-public final class SdkConstants {
-    public static final int PLATFORM_UNKNOWN = 0;
-    public static final int PLATFORM_LINUX = 1;
-    public static final int PLATFORM_WINDOWS = 2;
-    public static final int PLATFORM_DARWIN = 3;
-    /**
-     * Returns current platform, one of {@link #PLATFORM_WINDOWS}, {@link #PLATFORM_DARWIN},
-     * {@link #PLATFORM_LINUX} or {@link #PLATFORM_UNKNOWN}.
-     */
-    public static final int CURRENT_PLATFORM = currentPlatform();
-    /** Environment variable that specifies the path of an Android SDK. */
-    public static final String ANDROID_HOME_ENV = "ANDROID_HOME";
-    /** Property in local.properties file that specifies the path of the Android SDK.  */
-    public static final String SDK_DIR_PROPERTY = "sdk.dir";
-    /** Property in local.properties file that specifies the path of the Android NDK.  */
-    public static final String NDK_DIR_PROPERTY = "ndk.dir";
-    /** Property in gradle-wrapper.properties file that specifies the URL to the correct Gradle distribution. */
-    public static final String GRADLE_DISTRIBUTION_URL_PROPERTY = "distributionUrl";  //$NON-NLS-1$
-    /**
-     * The encoding we strive to use for all files we write.
-     * <p>
-     * When possible, use the APIs which take a {@link java.nio.charset.Charset} and pass in
-     * {@link com.google.common.base.Charsets#UTF_8} instead of using the String encoding
-     * method.
-     */
-    public static final String UTF_8 = "UTF-8";                                       //$NON-NLS-1$
-    /**
-     * Charset for the ini file handled by the SDK.
-     */
-    public static final String INI_CHARSET = UTF_8;
-    /** Path separator used by Gradle */
-    public static final String GRADLE_PATH_SEPARATOR = ":";                           //$NON-NLS-1$
-    /** An SDK Project's AndroidManifest.xml file */
-    public static final String FN_ANDROID_MANIFEST_XML= "AndroidManifest.xml";        //$NON-NLS-1$
-    /** pre-dex jar filename. i.e. "classes.jar" */
-    public static final String TOOLS_NS_NAME = "tools";
-    public static final String FN_CLASSES_JAR = "classes.jar";
-    //$NON-NLS-1$
-    /** Dex filename inside the APK. i.e. "classes.dex" */
-    public static final String FN_APK_CLASSES_DEX = "classes.dex";                    //$NON-NLS-1$
-    /** Dex filename inside the APK. i.e. "classes.dex" */
-    public static final String FN_APK_CLASSES_N_DEX = "classes%d.dex";                //$NON-NLS-1$
-    /** An SDK Project's build.xml file */
-    public static final String FN_BUILD_XML = "build.xml";                            //$NON-NLS-1$
-    /** An SDK Project's build.gradle file */
-    public static final String FN_BUILD_GRADLE = "build.gradle";                      //$NON-NLS-1$
-    /** An SDK Project's settings.gradle file */
-    public static final String FN_SETTINGS_GRADLE = "settings.gradle";                //$NON-NLS-1$
-    /** An SDK Project's gradle.properties file */
-    public static final String FN_GRADLE_PROPERTIES = "gradle.properties";            //$NON-NLS-1$
-    /** An SDK Project's gradle daemon executable */
-    public static final String FN_GRADLE_UNIX = "gradle";                             //$NON-NLS-1$
-    /** An SDK Project's gradle.bat daemon executable (gradle for windows) */
-    public static final String FN_GRADLE_WIN = FN_GRADLE_UNIX + ".bat";               //$NON-NLS-1$
-    /** An SDK Project's gradlew file */
-    public static final String FN_GRADLE_WRAPPER_UNIX = "gradlew";                    //$NON-NLS-1$
-    /** An SDK Project's gradlew.bat file (gradlew for windows) */
-    public static final String FN_GRADLE_WRAPPER_WIN = FN_GRADLE_WRAPPER_UNIX + ".bat"; //$NON-NLS-1$
-    /** An SDK Project's gradle wrapper library */
-    public static final String FN_GRADLE_WRAPPER_JAR = "gradle-wrapper.jar";          //$NON-NLS-1$
-    /** Name of the framework library, i.e. "android.jar" */
-    public static final String FN_FRAMEWORK_LIBRARY = "android.jar";                  //$NON-NLS-1$
-    /** Name of the framework library, i.e. "uiautomator.jar" */
-    public static final String FN_UI_AUTOMATOR_LIBRARY = "uiautomator.jar";           //$NON-NLS-1$
-    /** Name of the layout attributes, i.e. "attrs.xml" */
-    public static final String FN_ATTRS_XML = "attrs.xml";                            //$NON-NLS-1$
-    /** Name of the layout attributes, i.e. "attrs_manifest.xml" */
-    public static final String FN_ATTRS_MANIFEST_XML = "attrs_manifest.xml";          //$NON-NLS-1$
-    /** framework aidl import file */
-    public static final String FN_FRAMEWORK_AIDL = "framework.aidl";                  //$NON-NLS-1$
-    /** framework renderscript folder */
-    public static final String FN_FRAMEWORK_RENDERSCRIPT = "renderscript";            //$NON-NLS-1$
-    /** framework include folder */
-    public static final String FN_FRAMEWORK_INCLUDE = "include";                      //$NON-NLS-1$
-    /** framework include (clang) folder */
-    public static final String FN_FRAMEWORK_INCLUDE_CLANG = "clang-include";          //$NON-NLS-1$
-    /** layoutlib.jar file */
-    public static final String FN_LAYOUTLIB_JAR = "layoutlib.jar";                    //$NON-NLS-1$
-    /** widget list file */
-    public static final String FN_WIDGETS = "widgets.txt";                            //$NON-NLS-1$
-    /** Intent activity actions list file */
-    public static final String FN_INTENT_ACTIONS_ACTIVITY = "activity_actions.txt";   //$NON-NLS-1$
-    /** Intent broadcast actions list file */
-    public static final String FN_INTENT_ACTIONS_BROADCAST = "broadcast_actions.txt"; //$NON-NLS-1$
-    /** Intent service actions list file */
-    public static final String FN_INTENT_ACTIONS_SERVICE = "service_actions.txt";     //$NON-NLS-1$
-    /** Intent category list file */
-    public static final String FN_INTENT_CATEGORIES = "categories.txt";               //$NON-NLS-1$
-    /** annotations support jar */
-    public static final String FN_ANNOTATIONS_JAR = "annotations.jar";                //$NON-NLS-1$
-    /** platform build property file */
-    public static final String FN_BUILD_PROP = "build.prop";                          //$NON-NLS-1$
-    /** plugin properties file */
-    public static final String FN_PLUGIN_PROP = "plugin.prop";                        //$NON-NLS-1$
-    /** add-on manifest file */
-    public static final String FN_MANIFEST_INI = "manifest.ini";                      //$NON-NLS-1$
-    /** add-on layout device XML file. */
-    public static final String FN_DEVICES_XML = "devices.xml";                        //$NON-NLS-1$
-    /** hardware properties definition file */
-    public static final String FN_HARDWARE_INI = "hardware-properties.ini";           //$NON-NLS-1$
-    /** project property file */
-    public static final String FN_PROJECT_PROPERTIES = "project.properties";          //$NON-NLS-1$
-    /** project local property file */
-    public static final String FN_LOCAL_PROPERTIES = "local.properties";              //$NON-NLS-1$
-    /** project ant property file */
-    public static final String FN_ANT_PROPERTIES = "ant.properties";                  //$NON-NLS-1$
-    /** project local property file */
-    public static final String FN_GRADLE_WRAPPER_PROPERTIES = "gradle-wrapper.properties"; //$NON-NLS-1$
-    /** Skin layout file */
-    public static final String FN_SKIN_LAYOUT = "layout";                             //$NON-NLS-1$
-    /** dx.jar file */
-    public static final String FN_DX_JAR = "dx.jar";                                  //$NON-NLS-1$
-    /** dx executable (with extension for the current OS) */
-    public static final String FN_DX =
-            "dx" + ext(".bat", "");                           //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** aapt executable (with extension for the current OS) */
-    public static final String FN_AAPT =
-            "aapt" + ext(".exe", "");                         //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** aidl executable (with extension for the current OS) */
-    public static final String FN_AIDL =
-            "aidl" + ext(".exe", "");                         //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** renderscript executable (with extension for the current OS) */
-    public static final String FN_RENDERSCRIPT =
-            "llvm-rs-cc" + ext(".exe", "");                   //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** renderscript support exe (with extension for the current OS) */
-    public static final String FN_BCC_COMPAT =
-            "bcc_compat" + ext(".exe", "");               //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** renderscript support linker for ARM (with extension for the current OS) */
-    public static final String FN_LD_ARM =
-            "arm-linux-androideabi-ld" + ext(".exe", ""); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** renderscript support linker for X86 (with extension for the current OS) */
-    public static final String FN_LD_X86 =
-            "i686-linux-android-ld" + ext(".exe", "");   //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** renderscript support linker for MIPS (with extension for the current OS) */
-    public static final String FN_LD_MIPS =
-            "mipsel-linux-android-ld" + ext(".exe", ""); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** adb executable (with extension for the current OS) */
-    public static final String FN_ADB =
-            "adb" + ext(".exe", "");                          //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** emulator executable for the current OS */
-    public static final String FN_EMULATOR =
-            "emulator" + ext(".exe", "");                     //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** zipalign executable (with extension for the current OS) */
-    public static final String FN_ZIPALIGN =
-            "zipalign" + ext(".exe", "");                     //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** dexdump executable (with extension for the current OS) */
-    public static final String FN_DEXDUMP =
-            "dexdump" + ext(".exe", "");                      //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** proguard executable (with extension for the current OS) */
-    public static final String FN_PROGUARD =
-            "proguard" + ext(".bat", ".sh");                  //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** find_lock for Windows (with extension for the current OS) */
-    public static final String FN_FIND_LOCK =
-            "find_lock" + ext(".exe", "");                    //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** hprof-conv executable (with extension for the current OS) */
-    public static final String FN_HPROF_CONV =
-            "hprof-conv" + ext(".exe", "");                   //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-    /** jack.jar */
-    public static final String FN_JACK = "jack.jar";                                  //$NON-NLS-1$
-    /** jill.jar */
-    public static final String FN_JILL = "jill.jar";                                  //$NON-NLS-1$
-    /** split-select */
-    public static final String FN_SPLIT_SELECT = "split-select" + ext(".exe", "");
-    /** properties file for SDK Updater packages */
-    public static final String FN_SOURCE_PROP = "source.properties";                  //$NON-NLS-1$
-    /** properties file for content hash of installed packages */
-    public static final String FN_CONTENT_HASH_PROP = "content_hash.properties";      //$NON-NLS-1$
-    /** properties file for the SDK */
-    public static final String FN_SDK_PROP = "sdk.properties";                        //$NON-NLS-1$
-    public static final String FN_RENDERSCRIPT_V8_JAR = "renderscript-v8.jar"; //$NON-NLS-1$
-    /**
-     * filename for gdbserver.
-     */
-    public static final String FN_GDBSERVER = "gdbserver";              //$NON-NLS-1$
-    public static final String FN_GDB_SETUP = "gdb.setup";              //$NON-NLS-1$
-    /** global Android proguard config file */
-    public static final String FN_ANDROID_PROGUARD_FILE = "proguard-android.txt";   //$NON-NLS-1$
-    /** global Android proguard config file with optimization enabled */
-    public static final String FN_ANDROID_OPT_PROGUARD_FILE = "proguard-android-optimize.txt";  //$NON-NLS-1$
-    /** default proguard config file with new file extension (for project specific stuff) */
-    public static final String FN_PROJECT_PROGUARD_FILE = "proguard-project.txt";   //$NON-NLS-1$
-    /* Folder Names for Android Projects . */
-    /** Resources folder name, i.e. "res". */
-    public static final String FD_RESOURCES = "res";                    //$NON-NLS-1$
-    /** Assets folder name, i.e. "assets" */
-    public static final String FD_ASSETS = "assets";                    //$NON-NLS-1$
-    /** Default source folder name in an SDK project, i.e. "src".
-     * <p/>
-     * Note: this is not the same as {@link #FD_PKG_SOURCES}
-     * which is an SDK sources folder for packages. */
-    public static final String FD_SOURCES = "src";                      //$NON-NLS-1$
-    /** Default main source set folder name, i.e. "main" */
-    public static final String FD_MAIN = "main";                        //$NON-NLS-1$
-    /** Default test source set folder name, i.e. "androidTest" */
-    public static final String FD_TEST = "androidTest";                 //$NON-NLS-1$
-    /** Default java code folder name, i.e. "java" */
-    public static final String FD_JAVA = "java";                        //$NON-NLS-1$
-    /** Default native code folder name, i.e. "jni" */
-    public static final String FD_JNI = "jni";                          //$NON-NLS-1$
-    /** Default gradle folder name, i.e. "gradle" */
-    public static final String FD_GRADLE = "gradle";                    //$NON-NLS-1$
-    /** Default gradle wrapper folder name, i.e. "gradle/wrapper" */
-    public static final String FD_GRADLE_WRAPPER = FD_GRADLE + File.separator + "wrapper"; //$NON-NLS-1$
-    /** Default generated source folder name, i.e. "gen" */
-    public static final String FD_GEN_SOURCES = "gen";                  //$NON-NLS-1$
-    /** Default native library folder name inside the project, i.e. "libs"
-     * While the folder inside the .apk is "lib", we call that one libs because
-     * that's what we use in ant for both .jar and .so and we need to make the 2 development ways
-     * compatible. */
-    public static final String FD_NATIVE_LIBS = "libs";                 //$NON-NLS-1$
-    /** Native lib folder inside the APK: "lib" */
-    public static final String FD_APK_NATIVE_LIBS = "lib";              //$NON-NLS-1$
-    /** Default output folder name, i.e. "bin" */
-    public static final String FD_OUTPUT = "bin";                       //$NON-NLS-1$
-    /** Classes output folder name, i.e. "classes" */
-    public static final String FD_CLASSES_OUTPUT = "classes";           //$NON-NLS-1$
-    /** proguard output folder for mapping, etc.. files */
-    public static final String FD_PROGUARD = "proguard";                //$NON-NLS-1$
-    /** aidl output folder for copied aidl files */
-    public static final String FD_AIDL = "aidl";                        //$NON-NLS-1$
-    /** rs Libs output folder for support mode */
-    public static final String FD_RS_LIBS = "rsLibs";                   //$NON-NLS-1$
-    /** rs Libs output folder for support mode */
-    public static final String FD_RS_OBJ = "rsObj";                     //$NON-NLS-1$
-    /** jars folder */
-    public static final String FD_JARS = "jars";                        //$NON-NLS-1$
-    /* Folder Names for the Android SDK */
-    /** Name of the SDK platforms folder. */
-    public static final String FD_PLATFORMS = "platforms";              //$NON-NLS-1$
-    /** Name of the SDK addons folder. */
-    public static final String FD_ADDONS = "add-ons";                   //$NON-NLS-1$
-    /** Name of the SDK system-images folder. */
-    public static final String FD_SYSTEM_IMAGES = "system-images";      //$NON-NLS-1$
-    /** Name of the SDK sources folder where source packages are installed.
-     * <p/>
-     * Note this is not the same as {@link #FD_SOURCES} which is the folder name where sources
-     * are installed inside a project. */
-    public static final String FD_PKG_SOURCES = "sources";              //$NON-NLS-1$
-    /** Name of the SDK tools folder. */
-    public static final String FD_TOOLS = "tools";                      //$NON-NLS-1$
-    /** Name of the SDK tools/support folder. */
-    public static final String FD_SUPPORT = "support";                  //$NON-NLS-1$
-    /** Name of the SDK platform tools folder. */
-    public static final String FD_PLATFORM_TOOLS = "platform-tools";    //$NON-NLS-1$
-    /** Name of the SDK build tools folder. */
-    public static final String FD_BUILD_TOOLS = "build-tools";          //$NON-NLS-1$
-    /** Name of the SDK tools/lib folder. */
-    public static final String FD_LIB = "lib";                          //$NON-NLS-1$
-    /** Name of the SDK docs folder. */
-    public static final String FD_DOCS = "docs";                        //$NON-NLS-1$
-    /** Name of the doc folder containing API reference doc (javadoc) */
-    public static final String FD_DOCS_REFERENCE = "reference";         //$NON-NLS-1$
-    /** Name of the SDK images folder. */
-    public static final String FD_IMAGES = "images";                    //$NON-NLS-1$
-    /** Name of the ABI to support. */
-    public static final String ABI_ARMEABI      = "armeabi";            //$NON-NLS-1$
-    public static final String ABI_ARMEABI_V7A  = "armeabi-v7a";        //$NON-NLS-1$
-    public static final String ABI_ARM64_V8A    = "arm64-v8a";          //$NON-NLS-1$
-    public static final String ABI_INTEL_ATOM   = "x86";                //$NON-NLS-1$
-    public static final String ABI_INTEL_ATOM64 = "x86_64";             //$NON-NLS-1$
-    public static final String ABI_MIPS         = "mips";               //$NON-NLS-1$
-    public static final String ABI_MIPS64       = "mips64";             //$NON-NLS-1$
-    /** Name of the CPU arch to support. */
-    public static final String CPU_ARCH_ARM          = "arm";           //$NON-NLS-1$
-    public static final String CPU_ARCH_ARM64        = "arm64";         //$NON-NLS-1$
-    public static final String CPU_ARCH_INTEL_ATOM   = "x86";           //$NON-NLS-1$
-    public static final String CPU_ARCH_INTEL_ATOM64 = "x86_64";        //$NON-NLS-1$
-    public static final String CPU_ARCH_MIPS         = "mips";          //$NON-NLS-1$
-    /** TODO double-check this is appropriate value for mips64 */
-    public static final String CPU_ARCH_MIPS64       = "mips64";        //$NON-NLS-1$
-    /** Name of the CPU model to support. */
-    public static final String CPU_MODEL_CORTEX_A8 = "cortex-a8";       //$NON-NLS-1$
-    /** Name of the SDK skins folder. */
-    public static final String FD_SKINS = "skins";                      //$NON-NLS-1$
-    /** Name of the SDK samples folder. */
-    public static final String FD_SAMPLES = "samples";                  //$NON-NLS-1$
-    /** Name of the SDK extras folder. */
-    public static final String FD_EXTRAS = "extras";                    //$NON-NLS-1$
-    public static final String FD_M2_REPOSITORY = "m2repository";       //$NON-NLS-1$
-    public static final String FD_NDK = "ndk-bundle";                   //$NON-NLS-1$
-    /**
-     * Name of an extra's sample folder.
-     * Ideally extras should have one {@link #FD_SAMPLES} folder containing
-     * one or more sub-folders (one per sample). However some older extras
-     * might contain a single "sample" folder with directly the samples files
-     * in it. When possible we should encourage extras' owners to move to the
-     * multi-samples format.
-     */
-    public static final String FD_SAMPLE = "sample";                    //$NON-NLS-1$
-    /** Name of the SDK templates folder, i.e. "templates" */
-    public static final String FD_TEMPLATES = "templates";              //$NON-NLS-1$
-    /** Name of the SDK Ant folder, i.e. "ant" */
-    public static final String FD_ANT = "ant";                          //$NON-NLS-1$
-    /** Name of the SDK data folder, i.e. "data" */
-    public static final String FD_DATA = "data";                        //$NON-NLS-1$
-    /** Name of the SDK renderscript folder, i.e. "rs" */
-    public static final String FD_RENDERSCRIPT = "rs";                  //$NON-NLS-1$
-    /** Name of the Java resources folder, i.e. "resources" */
-    public static final String FD_JAVA_RES = "resources";               //$NON-NLS-1$
-    /** Name of the SDK resources folder, i.e. "res" */
-    public static final String FD_RES = "res";                          //$NON-NLS-1$
-    /** Name of the SDK font folder, i.e. "fonts" */
-    public static final String FD_FONTS = "fonts";                      //$NON-NLS-1$
-    /** Name of the android sources directory and the root of the SDK sources package folder. */
-    public static final String FD_ANDROID_SOURCES = "sources";          //$NON-NLS-1$
-    /** Name of the addon libs folder. */
-    public static final String FD_ADDON_LIBS = "libs";                  //$NON-NLS-1$
-    /** Name of the cache folder in the $HOME/.android. */
-    public static final String FD_CACHE = "cache";                      //$NON-NLS-1$
-    /** API codename of a release (non preview) system image or platform. **/
-    public static final String CODENAME_RELEASE = "REL";                //$NON-NLS-1$
-    /** Namespace for the resource XML, i.e. "http://schemas.android.com/apk/res/android" */
-    public static final String NS_RESOURCES =
-            "http://schemas.android.com/apk/res/android";                   //$NON-NLS-1$
-    /**
-     * Namespace pattern for the custom resource XML, i.e. "http://schemas.android.com/apk/res/%s"
-     * <p/>
-     * This string contains a %s. It must be combined with the desired Java package, e.g.:
-     * <pre>
-     *    String.format(SdkConstants.NS_CUSTOM_RESOURCES_S, "android");
-     *    String.format(SdkConstants.NS_CUSTOM_RESOURCES_S, "com.test.mycustomapp");
-     * </pre>
-     *
-     * Note: if you need an URI specifically for the "android" namespace, consider using
-     * {@link SdkConstants#NS_RESOURCES} instead.
-     */
-    public static final String NS_CUSTOM_RESOURCES_S = "http://schemas.android.com/apk/res/%1$s"; //$NON-NLS-1$
-    /** The name of the uses-library that provides "android.test.runner" */
-    public static final String ANDROID_TEST_RUNNER_LIB =
-            "android.test.runner";                                          //$NON-NLS-1$
-    /* Folder path relative to the SDK root */
-    /** Path of the documentation directory relative to the sdk folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_DOCS_FOLDER = FD_DOCS + File.separator;
-    /** Path of the tools directory relative to the sdk folder, or to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_TOOLS_FOLDER = FD_TOOLS + File.separator;
-    /** Path of the lib directory relative to the sdk folder, or to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_TOOLS_LIB_FOLDER =
-            OS_SDK_TOOLS_FOLDER + FD_LIB + File.separator;
-    /**
-     * Path of the lib directory relative to the sdk folder, or to a platform
-     * folder. This is an OS path, ending with a separator.
-     */
-    public static final String OS_SDK_TOOLS_LIB_EMULATOR_FOLDER = OS_SDK_TOOLS_LIB_FOLDER
-            + "emulator" + File.separator;                              //$NON-NLS-1$
-    /** Path of the platform tools directory relative to the sdk folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_PLATFORM_TOOLS_FOLDER = FD_PLATFORM_TOOLS + File.separator;
-    /** Path of the build tools directory relative to the sdk folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_BUILD_TOOLS_FOLDER = FD_BUILD_TOOLS + File.separator;
-    /** Path of the Platform tools Lib directory relative to the sdk folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_PLATFORM_TOOLS_LIB_FOLDER =
-            OS_SDK_PLATFORM_TOOLS_FOLDER + FD_LIB + File.separator;
-    /** Path of the bin folder of proguard folder relative to the sdk folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_TOOLS_PROGUARD_BIN_FOLDER =
-            OS_SDK_TOOLS_FOLDER +
-                    "proguard" + File.separator +                                   //$NON-NLS-1$
-                    "bin" + File.separator;                                         //$NON-NLS-1$
-    /** Path of the template gradle wrapper folder relative to the sdk folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SDK_TOOLS_TEMPLATES_GRADLE_WRAPPER_FOLDER =
-            OS_SDK_TOOLS_FOLDER + FD_TEMPLATES + File.separator + FD_GRADLE_WRAPPER + File.separator;
-    /* Folder paths relative to a platform or add-on folder */
-    /** Path of the images directory relative to a platform or addon folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_IMAGES_FOLDER = FD_IMAGES + File.separator;
-    /** Path of the skin directory relative to a platform or addon folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_SKINS_FOLDER = FD_SKINS + File.separator;
-    /* Folder paths relative to a Platform folder */
-    /** Path of the data directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_DATA_FOLDER = FD_DATA + File.separator;
-    /** Path of the renderscript directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_RENDERSCRIPT_FOLDER = FD_RENDERSCRIPT + File.separator;
-    /** Path of the samples directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_SAMPLES_FOLDER = FD_SAMPLES + File.separator;
-    /** Path of the resources directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_RESOURCES_FOLDER =
-            OS_PLATFORM_DATA_FOLDER + FD_RES + File.separator;
-    /** Path of the fonts directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_FONTS_FOLDER =
-            OS_PLATFORM_DATA_FOLDER + FD_FONTS + File.separator;
-    /** Path of the android source directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_SOURCES_FOLDER = FD_ANDROID_SOURCES + File.separator;
-    /** Path of the android templates directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_TEMPLATES_FOLDER = FD_TEMPLATES + File.separator;
-    /** Path of the Ant build rules directory relative to a platform folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_PLATFORM_ANT_FOLDER = FD_ANT + File.separator;
-    /** Path of the attrs.xml file relative to a platform folder. */
-    public static final String OS_PLATFORM_ATTRS_XML =
-            OS_PLATFORM_RESOURCES_FOLDER + SdkConstants.FD_RES_VALUES + File.separator +
-                    FN_ATTRS_XML;
-    /** Path of the attrs_manifest.xml file relative to a platform folder. */
-    public static final String OS_PLATFORM_ATTRS_MANIFEST_XML =
-            OS_PLATFORM_RESOURCES_FOLDER + SdkConstants.FD_RES_VALUES + File.separator +
-                    FN_ATTRS_MANIFEST_XML;
-    /** Path of the layoutlib.jar file relative to a platform folder. */
-    public static final String OS_PLATFORM_LAYOUTLIB_JAR =
-            OS_PLATFORM_DATA_FOLDER + FN_LAYOUTLIB_JAR;
-    /** Path of the renderscript include folder relative to a platform folder. */
-    public static final String OS_FRAMEWORK_RS =
-            FN_FRAMEWORK_RENDERSCRIPT + File.separator + FN_FRAMEWORK_INCLUDE;
-    /** Path of the renderscript (clang) include folder relative to a platform folder. */
-    public static final String OS_FRAMEWORK_RS_CLANG =
-            FN_FRAMEWORK_RENDERSCRIPT + File.separator + FN_FRAMEWORK_INCLUDE_CLANG;
-    /* Folder paths relative to a addon folder */
-    /** Path of the images directory relative to a folder folder.
-     *  This is an OS path, ending with a separator. */
-    public static final String OS_ADDON_LIBS_FOLDER = FD_ADDON_LIBS + File.separator;
-    /** Skin default **/
-    public static final String SKIN_DEFAULT = "default";                    //$NON-NLS-1$
-    /** SDK property: ant templates revision */
-    public static final String PROP_SDK_ANT_TEMPLATES_REVISION =
-            "sdk.ant.templates.revision";                                       //$NON-NLS-1$
-    /** SDK property: default skin */
-    public static final String PROP_SDK_DEFAULT_SKIN = "sdk.skin.default"; //$NON-NLS-1$
-    /* Android Class Constants */
-    public static final String CLASS_ACTIVITY = "android.app.Activity"; //$NON-NLS-1$
-    public static final String CLASS_APPLICATION = "android.app.Application"; //$NON-NLS-1$
-    public static final String CLASS_SERVICE = "android.app.Service"; //$NON-NLS-1$
-    public static final String CLASS_BROADCASTRECEIVER = "android.content.BroadcastReceiver"; //$NON-NLS-1$
-    public static final String CLASS_CONTENTPROVIDER = "android.content.ContentProvider"; //$NON-NLS-1$
-    public static final String CLASS_ATTRIBUTE_SET = "android.util.AttributeSet"; //$NON-NLS-1$
-    public static final String CLASS_INSTRUMENTATION = "android.app.Instrumentation"; //$NON-NLS-1$
-    public static final String CLASS_INSTRUMENTATION_RUNNER =
-            "android.test.InstrumentationTestRunner"; //$NON-NLS-1$
-    public static final String CLASS_BUNDLE = "android.os.Bundle"; //$NON-NLS-1$
-    public static final String CLASS_R = "android.R"; //$NON-NLS-1$
-    public static final String CLASS_R_PREFIX = CLASS_R + "."; //$NON-NLS-1$
-    public static final String CLASS_MANIFEST_PERMISSION = "android.Manifest$permission"; //$NON-NLS-1$
-    public static final String CLASS_INTENT = "android.content.Intent"; //$NON-NLS-1$
-    public static final String CLASS_CONTEXT = "android.content.Context"; //$NON-NLS-1$
-    public static final String CLASS_VIEW = "android.view.View"; //$NON-NLS-1$
-    public static final String CLASS_VIEWGROUP = "android.view.ViewGroup"; //$NON-NLS-1$
-    public static final String CLASS_NAME_LAYOUTPARAMS = "LayoutParams"; //$NON-NLS-1$
-    public static final String CLASS_VIEWGROUP_LAYOUTPARAMS =
-            CLASS_VIEWGROUP + "$" + CLASS_NAME_LAYOUTPARAMS; //$NON-NLS-1$
-    public static final String CLASS_NAME_FRAMELAYOUT = "FrameLayout"; //$NON-NLS-1$
-    public static final String CLASS_FRAMELAYOUT =
-            "android.widget." + CLASS_NAME_FRAMELAYOUT; //$NON-NLS-1$
-    public static final String CLASS_PREFERENCE = "android.preference.Preference"; //$NON-NLS-1$
-    public static final String CLASS_NAME_PREFERENCE_SCREEN = "PreferenceScreen"; //$NON-NLS-1$
-    public static final String CLASS_PREFERENCES =
-            "android.preference." + CLASS_NAME_PREFERENCE_SCREEN; //$NON-NLS-1$
-    public static final String CLASS_PREFERENCEGROUP = "android.preference.PreferenceGroup"; //$NON-NLS-1$
-    public static final String CLASS_PARCELABLE = "android.os.Parcelable"; //$NON-NLS-1$
-    public static final String CLASS_PARCEL = "android.os.Parcel"; //$NON-NLS-1$
-    public static final String CLASS_FRAGMENT = "android.app.Fragment"; //$NON-NLS-1$
-    public static final String CLASS_V4_FRAGMENT = "android.support.v4.app.Fragment"; //$NON-NLS-1$
-    public static final String CLASS_ACTION_PROVIDER = "android.view.ActionProvider"; //$NON-NLS-1$
-    public static final String CLASS_BACKUP_AGENT = "android.app.backup.BackupAgent"; //$NON-NLS-1$
-    /** MockView is part of the layoutlib bridge and used to display classes that have
-     * no rendering in the graphical layout editor. */
-    public static final String CLASS_MOCK_VIEW = "com.android.layoutlib.bridge.MockView"; //$NON-NLS-1$
-    public static final String CLASS_LAYOUT_INFLATER = "android.view.LayoutInflater"; //$NON-NLS-1$
-    /* Android Design Support Class Constants */
-    public static final String CLASS_COORDINATOR_LAYOUT = "android.support.design.widget.CoordinatorLayout"; //$NON-NLS-1$
-    public static final String CLASS_APP_BAR_LAYOUT = "android.support.design.widget.AppBarLayout"; //$NON-NLS-1$
-    public static final String CLASS_FLOATING_ACTION_BUTTON = "android.support.design.widget.FloatingActionButton"; //$NON-NLS-1$
-    public static final String CLASS_COLLAPSING_TOOLBAR_LAYOUT = "android.support.design.widget.CollapsingToolbarLayout"; //$NON-NLS-1$
-    public static final String CLASS_NAVIGATION_VIEW = "android.support.design.widget.NavigationView"; //$NON-NLS-1$
-    public static final String CLASS_SNACKBAR = "android.support.design.widget.Snackbar"; //$NON-NLS-1$
-    public static final String CLASS_TAB_LAYOUT = "android.support.design.widget.TabLayout"; //$NON-NLS-1$
-    public static final String CLASS_TEXT_INPUT_LAYOUT = "android.support.design.widget.TextInputLayout"; //$NON-NLS-1$
-    public static final String CLASS_NESTED_SCROLL_VIEW = "android.support.v4.widget.NestedScrollView";  //$NON-NLS-1$
-    /** Returns the appropriate name for the 'android' command, which is 'android.exe' for
-     * Windows and 'android' for all other platforms. */
-    public static String androidCmdName() {
-        String os = System.getProperty("os.name");          //$NON-NLS-1$
-        String cmd = "android";                             //$NON-NLS-1$
-        if (os.startsWith("Windows")) {                     //$NON-NLS-1$
-            cmd += ".bat";                                  //$NON-NLS-1$
-        }
-        return cmd;
-    }
-    /** Returns the appropriate name for the 'mksdcard' command, which is 'mksdcard.exe' for
-     * Windows and 'mkdsdcard' for all other platforms. */
-    public static String mkSdCardCmdName() {
-        String os = System.getProperty("os.name");          //$NON-NLS-1$
-        String cmd = "mksdcard";                            //$NON-NLS-1$
-        if (os.startsWith("Windows")) {                     //$NON-NLS-1$
-            cmd += ".exe";                                  //$NON-NLS-1$
-        }
-        return cmd;
-    }
-    /**
-     * Returns current platform
-     *
-     * @return one of {@link #PLATFORM_WINDOWS}, {@link #PLATFORM_DARWIN},
-     * {@link #PLATFORM_LINUX} or {@link #PLATFORM_UNKNOWN}.
-     */
-    public static int currentPlatform() {
-        String os = System.getProperty("os.name");          //$NON-NLS-1$
-        if (os.startsWith("Mac OS")) {                      //$NON-NLS-1$
-            return PLATFORM_DARWIN;
-        } else if (os.startsWith("Windows")) {              //$NON-NLS-1$
-            return PLATFORM_WINDOWS;
-        } else if (os.startsWith("Linux")) {                //$NON-NLS-1$
-            return PLATFORM_LINUX;
-        }
-        return PLATFORM_UNKNOWN;
-    }
-    /**
-     * Returns current platform's UI name
-     *
-     * @return one of "Windows", "Mac OS X", "Linux" or "other".
-     */
-    public static String currentPlatformName() {
-        String os = System.getProperty("os.name");          //$NON-NLS-1$
-        if (os.startsWith("Mac OS")) {                      //$NON-NLS-1$
-            return "Mac OS X";                              //$NON-NLS-1$
-        } else if (os.startsWith("Windows")) {              //$NON-NLS-1$
-            return "Windows";                               //$NON-NLS-1$
-        } else if (os.startsWith("Linux")) {                //$NON-NLS-1$
-            return "Linux";                                 //$NON-NLS-1$
-        }
-        return "Other";
-    }
-    private static String ext(String windowsExtension, String nonWindowsExtension) {
-        if (CURRENT_PLATFORM == PLATFORM_WINDOWS) {
-            return windowsExtension;
-        } else {
-            return nonWindowsExtension;
-        }
-    }
-    /** Default anim resource folder name, i.e. "anim" */
-    public static final String FD_RES_ANIM = "anim"; //$NON-NLS-1$
-    /** Default animator resource folder name, i.e. "animator" */
-    public static final String FD_RES_ANIMATOR = "animator"; //$NON-NLS-1$
-    /** Default color resource folder name, i.e. "color" */
-    public static final String FD_RES_COLOR = "color"; //$NON-NLS-1$
-    /** Default drawable resource folder name, i.e. "drawable" */
-    public static final String FD_RES_DRAWABLE = "drawable"; //$NON-NLS-1$
-    /** Default interpolator resource folder name, i.e. "interpolator" */
-    public static final String FD_RES_INTERPOLATOR = "interpolator"; //$NON-NLS-1$
-    /** Default layout resource folder name, i.e. "layout" */
-    public static final String FD_RES_LAYOUT = "layout"; //$NON-NLS-1$
-    /** Default menu resource folder name, i.e. "menu" */
-    public static final String FD_RES_MENU = "menu"; //$NON-NLS-1$
-    /** Default menu resource folder name, i.e. "mipmap" */
-    public static final String FD_RES_MIPMAP = "mipmap"; //$NON-NLS-1$
-    /** Default values resource folder name, i.e. "values" */
-    public static final String FD_RES_VALUES = "values"; //$NON-NLS-1$
-    /** Default xml resource folder name, i.e. "xml" */
-    public static final String FD_RES_XML = "xml"; //$NON-NLS-1$
-    /** Default raw resource folder name, i.e. "raw" */
-    public static final String FD_RES_RAW = "raw"; //$NON-NLS-1$
-    /** Separator between the resource folder qualifier. */
-    public static final String RES_QUALIFIER_SEP = "-"; //$NON-NLS-1$
-    /** Namespace used in XML files for Android attributes */
-    // ---- XML ----
-    /** URI of the reserved "xmlns"  prefix */
-    public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/";  //$NON-NLS-1$
-    /** The "xmlns" attribute name */
-    public static final String XMLNS = "xmlns";                              //$NON-NLS-1$
-    /** The default prefix used for the {@link #XMLNS_URI} */
-    public static final String XMLNS_PREFIX = "xmlns:";                      //$NON-NLS-1$
-    /** Qualified name of the xmlns android declaration element */
-    public static final String XMLNS_ANDROID = "xmlns:android";              //$NON-NLS-1$
-    /** The default prefix used for the {@link #ANDROID_URI} name space */
-    public static final String ANDROID_NS_NAME = "android";                  //$NON-NLS-1$
-    /** The default prefix used for the {@link #ANDROID_URI} name space including the colon  */
-    public static final String ANDROID_NS_NAME_PREFIX = "android:";          //$NON-NLS-1$
-    public static final int ANDROID_NS_NAME_PREFIX_LEN = ANDROID_NS_NAME_PREFIX.length();
-    /** The default prefix used for the app */
-    public static final String APP_PREFIX = "app";                          //$NON-NLS-1$
-    /** The entity for the ampersand character */
-    public static final String AMP_ENTITY = "&amp;";                         //$NON-NLS-1$
-    /** The entity for the quote character */
-    public static final String QUOT_ENTITY = "&quot;";                       //$NON-NLS-1$
-    /** The entity for the apostrophe character */
-    public static final String APOS_ENTITY = "&apos;";                       //$NON-NLS-1$
-    /** The entity for the less than character */
-    public static final String LT_ENTITY = "&lt;";                           //$NON-NLS-1$
-    /** The entity for the greater than character */
-    public static final String GT_ENTITY = "&gt;";                           //$NON-NLS-1$
-    public static final String NEWLINE_ENTITY = "&#xA;";
-    // ---- Elements and Attributes ----
-    /** Namespace prefix used for all resources */
-    public static final String URI_PREFIX =
-            "http://schemas.android.com/apk/res/";                     //$NON-NLS-1$
-    /** Namespace used in XML files for Android attributes */
-    public static final String ANDROID_URI =
-            "http://schemas.android.com/apk/res/android";              //$NON-NLS-1$
-    /** Namespace used in XML files for Android Tooling attributes */
-    public static final String TOOLS_URI =
-            "http://schemas.android.com/tools";                        //$NON-NLS-1$
-    /** Namespace used for auto-adjusting namespaces */
-    public static final String AUTO_URI =
-            "http://schemas.android.com/apk/res-auto";                 //$NON-NLS-1$
-    /** Default prefix used for tools attributes */
-    public static final String TOOLS_PREFIX = "tools";                 //$NON-NLS-1$
-    public static final String R_CLASS = "R";                          //$NON-NLS-1$
-    public static final String ANDROID_PKG = "android";                //$NON-NLS-1$
-    // Tags: Manifest
-    public static final String TAG_SERVICE = "service";                //$NON-NLS-1$
-    public static final String TAG_PERMISSION = "permission";          //$NON-NLS-1$
-    public static final String TAG_USES_FEATURE = "uses-feature";      //$NON-NLS-1$
-    public static final String TAG_USES_PERMISSION = "uses-permission";//$NON-NLS-1$
-    public static final String TAG_USES_LIBRARY = "uses-library";      //$NON-NLS-1$
-    public static final String TAG_APPLICATION = "application";        //$NON-NLS-1$
-    public static final String TAG_INTENT_FILTER = "intent-filter";    //$NON-NLS-1$
-    public static final String TAG_USES_SDK = "uses-sdk";              //$NON-NLS-1$
-    public static final String TAG_ACTIVITY = "activity";              //$NON-NLS-1$
-    public static final String TAG_RECEIVER = "receiver";              //$NON-NLS-1$
-    public static final String TAG_PROVIDER = "provider";              //$NON-NLS-1$
-    public static final String TAG_GRANT_PERMISSION = "grant-uri-permission"; //$NON-NLS-1$
-    public static final String TAG_PATH_PERMISSION = "path-permission"; //$NON-NLS-1$
-    // Tags: Resources
-    public static final String TAG_RESOURCES = "resources";            //$NON-NLS-1$
-    public static final String TAG_STRING = "string";                  //$NON-NLS-1$
-    public static final String TAG_ARRAY = "array";                    //$NON-NLS-1$
-    public static final String TAG_STYLE = "style";                    //$NON-NLS-1$
-    public static final String TAG_ITEM = "item";                      //$NON-NLS-1$
-    public static final String TAG_GROUP = "group";                    //$NON-NLS-1$
-    public static final String TAG_STRING_ARRAY = "string-array";      //$NON-NLS-1$
-    public static final String TAG_PLURALS = "plurals";                //$NON-NLS-1$
-    public static final String TAG_INTEGER_ARRAY = "integer-array";    //$NON-NLS-1$
-    public static final String TAG_COLOR = "color";                    //$NON-NLS-1$
-    public static final String TAG_DIMEN = "dimen";                    //$NON-NLS-1$
-    public static final String TAG_DRAWABLE = "drawable";              //$NON-NLS-1$
-    public static final String TAG_MENU = "menu";                      //$NON-NLS-1$
-    public static final String TAG_ENUM = "enum";                      //$NON-NLS-1$
-    public static final String TAG_FLAG = "flag";                      //$NON-NLS-1$
-    public static final String TAG_ATTR = "attr";                      //$NON-NLS-1$
-    public static final String TAG_DECLARE_STYLEABLE = "declare-styleable"; //$NON-NLS-1$
-    public static final String TAG_EAT_COMMENT = "eat-comment";        //$NON-NLS-1$
-    public static final String TAG_SKIP = "skip";                      //$NON-NLS-1$
-    public static final String TAG_SELECTOR = "selector";              //$NON-NLS-1$
-    // Tags: XML
-    public static final String TAG_HEADER = "header";                  //$NON-NLS-1$
-    public static final String TAG_APPWIDGET_PROVIDER = "appwidget-provider"; //$NON-NLS-1$
-    public static final String TAG_PREFERENCE_SCREEN = "PreferenceScreen"; //$NON-NLS-1$
-    // Tags: Layouts
-    public static final String VIEW_TAG = "view";                      //$NON-NLS-1$
-    public static final String VIEW_INCLUDE = "include";               //$NON-NLS-1$
-    public static final String VIEW_MERGE = "merge";                   //$NON-NLS-1$
-    public static final String VIEW_FRAGMENT = "fragment";             //$NON-NLS-1$
-    public static final String REQUEST_FOCUS = "requestFocus";         //$NON-NLS-1$
-    public static final String TAG = "tag";                            //$NON-NLS-1$
-    public static final String VIEW = "View";                          //$NON-NLS-1$
-    public static final String VIEW_GROUP = "ViewGroup";               //$NON-NLS-1$
-    public static final String FRAME_LAYOUT = "FrameLayout";           //$NON-NLS-1$
-    public static final String LINEAR_LAYOUT = "LinearLayout";         //$NON-NLS-1$
-    public static final String RELATIVE_LAYOUT = "RelativeLayout";     //$NON-NLS-1$
-    public static final String GRID_LAYOUT = "GridLayout";             //$NON-NLS-1$
-    public static final String SCROLL_VIEW = "ScrollView";             //$NON-NLS-1$
-    public static final String BUTTON = "Button";                      //$NON-NLS-1$
-    public static final String COMPOUND_BUTTON = "CompoundButton";     //$NON-NLS-1$
-    public static final String ADAPTER_VIEW = "AdapterView";           //$NON-NLS-1$
-    public static final String GALLERY = "Gallery";                    //$NON-NLS-1$
-    public static final String GRID_VIEW = "GridView";                 //$NON-NLS-1$
-    public static final String TAB_HOST = "TabHost";                   //$NON-NLS-1$
-    public static final String RADIO_GROUP = "RadioGroup";             //$NON-NLS-1$
-    public static final String RADIO_BUTTON = "RadioButton";           //$NON-NLS-1$
-    public static final String SWITCH = "Switch";                      //$NON-NLS-1$
-    public static final String EDIT_TEXT = "EditText";                 //$NON-NLS-1$
-    public static final String LIST_VIEW = "ListView";                 //$NON-NLS-1$
-    public static final String TEXT_VIEW = "TextView";                 //$NON-NLS-1$
-    public static final String CHECKED_TEXT_VIEW = "CheckedTextView";  //$NON-NLS-1$
-    public static final String IMAGE_VIEW = "ImageView";               //$NON-NLS-1$
-    public static final String SURFACE_VIEW = "SurfaceView";           //$NON-NLS-1$
-    public static final String ABSOLUTE_LAYOUT = "AbsoluteLayout";     //$NON-NLS-1$
-    public static final String TABLE_LAYOUT = "TableLayout";           //$NON-NLS-1$
-    public static final String TABLE_ROW = "TableRow";                 //$NON-NLS-1$
-    public static final String TAB_WIDGET = "TabWidget";               //$NON-NLS-1$
-    public static final String IMAGE_BUTTON = "ImageButton";           //$NON-NLS-1$
-    public static final String SEEK_BAR = "SeekBar";                   //$NON-NLS-1$
-    public static final String VIEW_STUB = "ViewStub";                 //$NON-NLS-1$
-    public static final String SPINNER = "Spinner";                    //$NON-NLS-1$
-    public static final String WEB_VIEW = "WebView";                   //$NON-NLS-1$
-    public static final String TOGGLE_BUTTON = "ToggleButton";         //$NON-NLS-1$
-    public static final String CHECK_BOX = "CheckBox";                 //$NON-NLS-1$
-    public static final String ABS_LIST_VIEW = "AbsListView";          //$NON-NLS-1$
-    public static final String PROGRESS_BAR = "ProgressBar";           //$NON-NLS-1$
-    public static final String ABS_SPINNER = "AbsSpinner";             //$NON-NLS-1$
-    public static final String ABS_SEEK_BAR = "AbsSeekBar";            //$NON-NLS-1$
-    public static final String VIEW_ANIMATOR = "ViewAnimator";         //$NON-NLS-1$
-    public static final String VIEW_SWITCHER = "ViewSwitcher";         //$NON-NLS-1$
-    public static final String EXPANDABLE_LIST_VIEW = "ExpandableListView";    //$NON-NLS-1$
-    public static final String HORIZONTAL_SCROLL_VIEW = "HorizontalScrollView"; //$NON-NLS-1$
-    public static final String MULTI_AUTO_COMPLETE_TEXT_VIEW = "MultiAutoCompleteTextView"; //$NON-NLS-1$
-    public static final String AUTO_COMPLETE_TEXT_VIEW = "AutoCompleteTextView"; //$NON-NLS-1$
-    public static final String CHECKABLE = "Checkable";                //$NON-NLS-1$
-    public static final String TEXTURE_VIEW = "TextureView";           //$NON-NLS-1$
-    /* Android Design Support Tag Constants */
-    public static final String COORDINATOR_LAYOUT = CLASS_COORDINATOR_LAYOUT;
-    public static final String APP_BAR_LAYOUT = CLASS_APP_BAR_LAYOUT;
-    public static final String FLOATING_ACTION_BUTTON = CLASS_FLOATING_ACTION_BUTTON;
-    public static final String COLLAPSING_TOOLBAR_LAYOUT = CLASS_COLLAPSING_TOOLBAR_LAYOUT;
-    public static final String NAVIGATION_VIEW = CLASS_NAVIGATION_VIEW;
-    public static final String SNACKBAR = CLASS_SNACKBAR;
-    public static final String TAB_LAYOUT = CLASS_TAB_LAYOUT;
-    public static final String TEXT_INPUT_LAYOUT = CLASS_TEXT_INPUT_LAYOUT;
-    // Tags: Drawables
-    public static final String TAG_BITMAP = "bitmap";                  //$NON-NLS-1$
-    // Tags: Data-Binding
-    public static final String TAG_LAYOUT = "layout";                  //$NON-NLS-1$
-    public static final String TAG_DATA = "data";                      //$NON-NLS-1$
-    public static final String TAG_VARIABLE = "variable";              //$NON-NLS-1$
-    public static final String TAG_IMPORT = "import";                  //$NON-NLS-1$
-    // Attributes: Manifest
-    public static final String ATTR_EXPORTED = "exported";             //$NON-NLS-1$
-    public static final String ATTR_PERMISSION = "permission";         //$NON-NLS-1$
-    public static final String ATTR_MIN_SDK_VERSION = "minSdkVersion"; //$NON-NLS-1$
-    public static final String ATTR_TARGET_SDK_VERSION = "targetSdkVersion"; //$NON-NLS-1$
-    public static final String ATTR_ICON = "icon";                     //$NON-NLS-1$
-    public static final String ATTR_PACKAGE = "package";               //$NON-NLS-1$
-    public static final String ATTR_CORE_APP = "coreApp";              //$NON-NLS-1$
-    public static final String ATTR_THEME = "theme";                   //$NON-NLS-1$
-    public static final String ATTR_SCHEME = "scheme";                 //$NON_NLS-1$
-    public static final String ATTR_HOST = "host";                     //$NON_NLS-1$
-    public static final String ATTR_PATH = "path";                     //$NON-NLS-1$
-    public static final String ATTR_PATH_PREFIX = "pathPrefix";        //$NON-NLS-1$
-    public static final String ATTR_PATH_PATTERN = "pathPattern";      //$NON-NLS-1$
-    public static final String ATTR_ALLOW_BACKUP = "allowBackup";      //$NON_NLS-1$
-    public static final String ATTR_DEBUGGABLE = "debuggable";         //$NON-NLS-1$
-    public static final String ATTR_READ_PERMISSION = "readPermission"; //$NON_NLS-1$
-    public static final String ATTR_WRITE_PERMISSION = "writePermission"; //$NON_NLS-1$
-    public static final String ATTR_VERSION_CODE = "versionCode";      //$NON_NLS-1$
-    public static final String ATTR_VERSION_NAME = "versionName";      //$NON_NLS-1$
-    // Attributes: Resources
-    public static final String ATTR_NAME = "name";                     //$NON-NLS-1$
-    public static final String ATTR_FRAGMENT = "fragment";             //$NON-NLS-1$
-    public static final String ATTR_TYPE = "type";                     //$NON-NLS-1$
-    public static final String ATTR_PARENT = "parent";                 //$NON-NLS-1$
-    public static final String ATTR_TRANSLATABLE = "translatable";     //$NON-NLS-1$
-    public static final String ATTR_COLOR = "color";                   //$NON-NLS-1$
-    public static final String ATTR_DRAWABLE = "drawable";             //$NON-NLS-1$
-    public static final String ATTR_VALUE = "value";                   //$NON-NLS-1$
-    public static final String ATTR_QUANTITY = "quantity";             //$NON-NLS-1$
-    public static final String ATTR_FORMAT = "format";                 //$NON-NLS-1$
-    public static final String ATTR_PREPROCESSING = "preprocessing";   //$NON-NLS-1$
-    // Attributes: Data-Binding
-    public static final String ATTR_ALIAS = "alias";                  //$NON-NLS-1$
-    // Attributes: Layout
-    public static final String ATTR_LAYOUT_RESOURCE_PREFIX = "layout_";//$NON-NLS-1$
-    public static final String ATTR_CLASS = "class";                   //$NON-NLS-1$
-    public static final String ATTR_STYLE = "style";                   //$NON-NLS-1$
-    public static final String ATTR_CONTEXT = "context";               //$NON-NLS-1$
-    public static final String ATTR_ID = "id";                         //$NON-NLS-1$
-    public static final String ATTR_TEXT = "text";                     //$NON-NLS-1$
-    public static final String ATTR_TEXT_SIZE = "textSize";            //$NON-NLS-1$
-    public static final String ATTR_LABEL = "label";                   //$NON-NLS-1$
-    public static final String ATTR_HINT = "hint";                     //$NON-NLS-1$
-    public static final String ATTR_PROMPT = "prompt";                 //$NON-NLS-1$
-    public static final String ATTR_ON_CLICK = "onClick";              //$NON-NLS-1$
-    public static final String ATTR_INPUT_TYPE = "inputType";          //$NON-NLS-1$
-    public static final String ATTR_INPUT_METHOD = "inputMethod";      //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_GRAVITY = "layout_gravity"; //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_WIDTH = "layout_width";     //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_HEIGHT = "layout_height";   //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_WEIGHT = "layout_weight";   //$NON-NLS-1$
-    public static final String ATTR_PADDING = "padding";               //$NON-NLS-1$
-    public static final String ATTR_PADDING_BOTTOM = "paddingBottom";  //$NON-NLS-1$
-    public static final String ATTR_PADDING_TOP = "paddingTop";        //$NON-NLS-1$
-    public static final String ATTR_PADDING_RIGHT = "paddingRight";    //$NON-NLS-1$
-    public static final String ATTR_PADDING_LEFT = "paddingLeft";      //$NON-NLS-1$
-    public static final String ATTR_PADDING_START = "paddingStart";    //$NON-NLS-1$
-    public static final String ATTR_PADDING_END = "paddingEnd";        //$NON-NLS-1$
-    public static final String ATTR_FOREGROUND = "foreground";         //$NON-NLS-1$
-    public static final String ATTR_BACKGROUND = "background";         //$NON-NLS-1$
-    public static final String ATTR_ORIENTATION = "orientation";       //$NON-NLS-1$
-    public static final String ATTR_LAYOUT = "layout";                 //$NON-NLS-1$
-    public static final String ATTR_ROW_COUNT = "rowCount";            //$NON-NLS-1$
-    public static final String ATTR_COLUMN_COUNT = "columnCount";      //$NON-NLS-1$
-    public static final String ATTR_LABEL_FOR = "labelFor";            //$NON-NLS-1$
-    public static final String ATTR_BASELINE_ALIGNED = "baselineAligned";       //$NON-NLS-1$
-    public static final String ATTR_CONTENT_DESCRIPTION = "contentDescription"; //$NON-NLS-1$
-    public static final String ATTR_IME_ACTION_LABEL = "imeActionLabel";        //$NON-NLS-1$
-    public static final String ATTR_PRIVATE_IME_OPTIONS = "privateImeOptions";  //$NON-NLS-1$
-    public static final String VALUE_NONE = "none";                    //$NON-NLS-1$
-    public static final String VALUE_NO = "no";                        //$NON-NLS-1$
-    public static final String ATTR_NUMERIC = "numeric";               //$NON-NLS-1$
-    public static final String ATTR_IME_ACTION_ID = "imeActionId";     //$NON-NLS-1$
-    public static final String ATTR_IME_OPTIONS = "imeOptions";        //$NON-NLS-1$
-    public static final String ATTR_FREEZES_TEXT = "freezesText";      //$NON-NLS-1$
-    public static final String ATTR_EDITOR_EXTRAS = "editorExtras";    //$NON-NLS-1$
-    public static final String ATTR_EDITABLE = "editable";             //$NON-NLS-1$
-    public static final String ATTR_DIGITS = "digits";                 //$NON-NLS-1$
-    public static final String ATTR_CURSOR_VISIBLE = "cursorVisible";  //$NON-NLS-1$
-    public static final String ATTR_CAPITALIZE = "capitalize";         //$NON-NLS-1$
-    public static final String ATTR_PHONE_NUMBER = "phoneNumber";      //$NON-NLS-1$
-    public static final String ATTR_PASSWORD = "password";             //$NON-NLS-1$
-    public static final String ATTR_BUFFER_TYPE = "bufferType";        //$NON-NLS-1$
-    public static final String ATTR_AUTO_TEXT = "autoText";            //$NON-NLS-1$
-    public static final String ATTR_ENABLED = "enabled";               //$NON-NLS-1$
-    public static final String ATTR_SINGLE_LINE = "singleLine";        //$NON-NLS-1$
-    public static final String ATTR_SCALE_TYPE = "scaleType";          //$NON-NLS-1$
-    public static final String ATTR_VISIBILITY = "visibility";         //$NON-NLS-1$
-    public static final String ATTR_TEXT_IS_SELECTABLE =
-            "textIsSelectable";                                        //$NON-NLS-1$
-    public static final String ATTR_IMPORTANT_FOR_ACCESSIBILITY =
-            "importantForAccessibility";                               //$NON-NLS-1$
-    public static final String ATTR_LIST_PREFERRED_ITEM_PADDING_LEFT =
-            "listPreferredItemPaddingLeft";                            //$NON-NLS-1$
-    public static final String ATTR_LIST_PREFERRED_ITEM_PADDING_RIGHT =
-            "listPreferredItemPaddingRight";                           //$NON-NLS-1$
-    public static final String ATTR_LIST_PREFERRED_ITEM_PADDING_START =
-            "listPreferredItemPaddingStart";                           //$NON-NLS-1$
-    public static final String ATTR_LIST_PREFERRED_ITEM_PADDING_END =
-            "listPreferredItemPaddingEnd";                             //$NON-NLS-1$
-    public static final String ATTR_INDEX = "index";                   //$NON-NLS-1$
-    // AbsoluteLayout layout params
-    public static final String ATTR_LAYOUT_Y = "layout_y";             //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_X = "layout_x";             //$NON-NLS-1$
-    // GridLayout layout params
-    public static final String ATTR_LAYOUT_ROW = "layout_row";         //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ROW_SPAN = "layout_rowSpan";//$NON-NLS-1$
-    public static final String ATTR_LAYOUT_COLUMN = "layout_column";   //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_COLUMN_SPAN = "layout_columnSpan";       //$NON-NLS-1$
-    // TableRow
-    public static final String ATTR_LAYOUT_SPAN = "layout_span";       //$NON-NLS-1$
-    // RelativeLayout layout params:
-    public static final String ATTR_LAYOUT_ALIGN_LEFT = "layout_alignLeft";        //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_RIGHT = "layout_alignRight";      //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_START = "layout_alignStart";      //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_END = "layout_alignEnd";          //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_TOP = "layout_alignTop";          //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_BOTTOM = "layout_alignBottom";    //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_PARENT_LEFT = "layout_alignParentLeft";        //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_PARENT_RIGHT = "layout_alignParentRight";      //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_PARENT_START = "layout_alignParentStart";      //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_PARENT_END = "layout_alignParentEnd";          //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_PARENT_TOP = "layout_alignParentTop";          //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_PARENT_BOTTOM = "layout_alignParentBottom";    //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_WITH_PARENT_MISSING = "layout_alignWithParentIfMissing";   //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ALIGN_BASELINE = "layout_alignBaseline";             //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_CENTER_IN_PARENT = "layout_centerInParent";          //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_CENTER_VERTICAL = "layout_centerVertical";           //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_CENTER_HORIZONTAL = "layout_centerHorizontal";       //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_TO_RIGHT_OF = "layout_toRightOf";        //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_TO_LEFT_OF = "layout_toLeftOf";          //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_TO_START_OF = "layout_toStartOf";        //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_TO_END_OF = "layout_toEndOf";            //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_BELOW = "layout_below";                  //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ABOVE = "layout_above";                  //$NON-NLS-1$
-    // Margins
-    public static final String ATTR_LAYOUT_MARGIN = "layout_margin";               //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_MARGIN_LEFT = "layout_marginLeft";      //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_MARGIN_RIGHT = "layout_marginRight";    //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_MARGIN_START = "layout_marginStart";    //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_MARGIN_END = "layout_marginEnd";        //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_MARGIN_TOP = "layout_marginTop";        //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_MARGIN_BOTTOM = "layout_marginBottom";  //$NON-NLS-1$
-    // Attributes: Drawables
-    public static final String ATTR_TILE_MODE = "tileMode";            //$NON-NLS-1$
-    // Attributes: CoordinatorLayout
-    public static final String ATTR_LAYOUT_ANCHOR = "layout_anchor";                //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_ANCHOR_GRAVITY = "layout_anchorGravity"; //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_BEHAVIOR = "layout_behavior";            //$NON-NLS-1$
-    public static final String ATTR_LAYOUT_KEYLINE = "layout_keyline";              //$NON-NLS-1$
-    // Values: Manifest
-    public static final String VALUE_SPLIT_ACTION_BAR_WHEN_NARROW = "splitActionBarWhenNarrow"; // NON-NLS-$1
-    // Values: Layouts
-    public static final String VALUE_FILL_PARENT = "fill_parent";       //$NON-NLS-1$
-    public static final String VALUE_MATCH_PARENT = "match_parent";     //$NON-NLS-1$
-    public static final String VALUE_VERTICAL = "vertical";             //$NON-NLS-1$
-    public static final String VALUE_TRUE = "true";                     //$NON-NLS-1$
-    public static final String VALUE_EDITABLE = "editable";             //$NON-NLS-1$
-    public static final String VALUE_AUTO_FIT = "auto_fit";             //$NON-NLS-1$
-    public static final String VALUE_SELECTABLE_ITEM_BACKGROUND =
-            "?android:attr/selectableItemBackground";                   //$NON-NLS-1$
-    // Values: Resources
-    public static final String VALUE_ID = "id";                        //$NON-NLS-1$
-    // Values: Drawables
-    public static final String VALUE_DISABLED = "disabled";            //$NON-NLS-1$
-    public static final String VALUE_CLAMP = "clamp";                  //$NON-NLS-1$
-    // Menus
-    public static final String ATTR_SHOW_AS_ACTION = "showAsAction";   //$NON-NLS-1$
-    public static final String ATTR_TITLE = "title";                   //$NON-NLS-1$
-    public static final String ATTR_VISIBLE = "visible";               //$NON-NLS-1$
-    public static final String VALUE_IF_ROOM = "ifRoom";               //$NON-NLS-1$
-    public static final String VALUE_ALWAYS = "always";                //$NON-NLS-1$
-    // Units
-    public static final String UNIT_DP = "dp";                         //$NON-NLS-1$
-    public static final String UNIT_DIP = "dip";                       //$NON-NLS-1$
-    public static final String UNIT_SP = "sp";                         //$NON-NLS-1$
-    public static final String UNIT_PX = "px";                         //$NON-NLS-1$
-    public static final String UNIT_IN = "in";                         //$NON-NLS-1$
-    public static final String UNIT_MM = "mm";                         //$NON-NLS-1$
-    public static final String UNIT_PT = "pt";                         //$NON-NLS-1$
-    // Filenames and folder names
-    public static final String ANDROID_MANIFEST_XML = "AndroidManifest.xml"; //$NON-NLS-1$
-    public static final String OLD_PROGUARD_FILE = "proguard.cfg";     //$NON-NLS-1$
-    public static final String CLASS_FOLDER =
-            "bin" + File.separator + "classes";                        //$NON-NLS-1$ //$NON-NLS-2$
-    public static final String GEN_FOLDER = "gen";                     //$NON-NLS-1$
-    public static final String SRC_FOLDER = "src";                     //$NON-NLS-1$
-    public static final String LIBS_FOLDER = "libs";                   //$NON-NLS-1$
-    public static final String BIN_FOLDER = "bin";                     //$NON-NLS-1$
-    public static final String RES_FOLDER = "res";                     //$NON-NLS-1$
-    public static final String DOT_XML = ".xml";                       //$NON-NLS-1$
-    public static final String DOT_XSD = ".xsd";                       //$NON-NLS-1$
-    public static final String DOT_GIF = ".gif";                       //$NON-NLS-1$
-    public static final String DOT_JPG = ".jpg";                       //$NON-NLS-1$
-    public static final String DOT_JPEG = ".jpeg";                     //$NON-NLS-1$
-    public static final String DOT_WEBP = ".webp";                     //$NON-NLS-1$
-    public static final String DOT_PNG = ".png";                       //$NON-NLS-1$
-    public static final String DOT_9PNG = ".9.png";                    //$NON-NLS-1$
-    public static final String DOT_JAVA = ".java";                     //$NON-NLS-1$
-    public static final String DOT_CLASS = ".class";                   //$NON-NLS-1$
-    public static final String DOT_JAR = ".jar";                       //$NON-NLS-1$
-    public static final String DOT_GRADLE = ".gradle";                 //$NON-NLS-1$
-    public static final String DOT_PROPERTIES = ".properties";         //$NON-NLS-1$
-    /** Extension of the Application package Files, i.e. "apk". */
-    public static final String EXT_ANDROID_PACKAGE = "apk"; //$NON-NLS-1$
-    /** Extension of java files, i.e. "java" */
-    public static final String EXT_JAVA = "java"; //$NON-NLS-1$
-    /** Extension of compiled java files, i.e. "class" */
-    public static final String EXT_CLASS = "class"; //$NON-NLS-1$
-    /** Extension of xml files, i.e. "xml" */
-    public static final String EXT_XML = "xml"; //$NON-NLS-1$
-    /** Extension of gradle files, i.e. "gradle" */
-    public static final String EXT_GRADLE = "gradle"; //$NON-NLS-1$
-    /** Extension of jar files, i.e. "jar" */
-    public static final String EXT_JAR = "jar"; //$NON-NLS-1$
-    /** Extension of ZIP files, i.e. "zip" */
-    public static final String EXT_ZIP = "zip"; //$NON-NLS-1$
-    /** Extension of aidl files, i.e. "aidl" */
-    public static final String EXT_AIDL = "aidl"; //$NON-NLS-1$
-    /** Extension of Renderscript files, i.e. "rs" */
-    public static final String EXT_RS = "rs"; //$NON-NLS-1$
-    /** Extension of Renderscript files, i.e. "rsh" */
-    public static final String EXT_RSH = "rsh"; //$NON-NLS-1$
-    /** Extension of FilterScript files, i.e. "fs" */
-    public static final String EXT_FS = "fs"; //$NON-NLS-1$
-    /** Extension of Renderscript bitcode files, i.e. "bc" */
-    public static final String EXT_BC = "bc"; //$NON-NLS-1$
-    /** Extension of dependency files, i.e. "d" */
-    public static final String EXT_DEP = "d"; //$NON-NLS-1$
-    /** Extension of native libraries, i.e. "so" */
-    public static final String EXT_NATIVE_LIB = "so"; //$NON-NLS-1$
-    /** Extension of dex files, i.e. "dex" */
-    public static final String EXT_DEX = "dex"; //$NON-NLS-1$
-    /** Extension for temporary resource files, ie "ap_ */
-    public static final String EXT_RES = "ap_"; //$NON-NLS-1$
-    /** Extension for pre-processable images. Right now pngs */
-    public static final String EXT_PNG = "png"; //$NON-NLS-1$
-    /** Extension for Android archive files */
-    public static final String EXT_AAR = "aar"; //$NON-NLS-1$
-    /** Extension for Java heap dumps. */
-    public static final String EXT_HPROF = "hprof"; //$NON-NLS-1$
-    private static final String DOT = "."; //$NON-NLS-1$
-    /** Dot-Extension of the Application package Files, i.e. ".apk". */
-    public static final String DOT_ANDROID_PACKAGE = DOT + EXT_ANDROID_PACKAGE;
-    /** Dot-Extension of aidl files, i.e. ".aidl" */
-    public static final String DOT_AIDL = DOT + EXT_AIDL;
-    /** Dot-Extension of renderscript files, i.e. ".rs" */
-    public static final String DOT_RS = DOT + EXT_RS;
-    /** Dot-Extension of renderscript header files, i.e. ".rsh" */
-    public static final String DOT_RSH = DOT + EXT_RSH;
-    /** Dot-Extension of FilterScript files, i.e. ".fs" */
-    public static final String DOT_FS = DOT + EXT_FS;
-    /** Dot-Extension of renderscript bitcode files, i.e. ".bc" */
-    public static final String DOT_BC = DOT + EXT_BC;
-    /** Dot-Extension of dependency files, i.e. ".d" */
-    public static final String DOT_DEP = DOT + EXT_DEP;
-    /** Dot-Extension of dex files, i.e. ".dex" */
-    public static final String DOT_DEX = DOT + EXT_DEX;
-    /** Dot-Extension for temporary resource files, ie "ap_ */
-    public static final String DOT_RES = DOT + EXT_RES;
-    /** Dot-Extension for BMP files, i.e. ".bmp" */
-    public static final String DOT_BMP = ".bmp"; //$NON-NLS-1$
-    /** Dot-Extension for SVG files, i.e. ".svg" */
-    public static final String DOT_SVG = ".svg"; //$NON-NLS-1$
-    /** Dot-Extension for template files */
-    public static final String DOT_FTL = ".ftl"; //$NON-NLS-1$
-    /** Dot-Extension of text files, i.e. ".txt" */
-    public static final String DOT_TXT = ".txt"; //$NON-NLS-1$
-    /** Dot-Extension for Android archive files */
-    public static final String DOT_AAR = DOT + EXT_AAR; //$NON-NLS-1$
-    /** Dot-Extension for Java heap dumps. */
-    public static final String DOT_HPROF = DOT + EXT_HPROF; //$NON-NLS-1$
-    /** Resource base name for java files and classes */
-    public static final String FN_RESOURCE_BASE = "R"; //$NON-NLS-1$
-    /** Resource java class  filename, i.e. "R.java" */
-    public static final String FN_RESOURCE_CLASS = FN_RESOURCE_BASE + DOT_JAVA;
-    /** Resource class file  filename, i.e. "R.class" */
-    public static final String FN_COMPILED_RESOURCE_CLASS = FN_RESOURCE_BASE + DOT_CLASS;
-    /** Resource text filename, i.e. "R.txt" */
-    public static final String FN_RESOURCE_TEXT = FN_RESOURCE_BASE + DOT_TXT;
-    /** Filename for public resources in AAR archives */
-    public static final String FN_PUBLIC_TXT = "public.txt";
-    /** Generated manifest class name */
-    public static final String FN_MANIFEST_BASE = "Manifest";          //$NON-NLS-1$
-    /** Generated BuildConfig class name */
-    public static final String FN_BUILD_CONFIG_BASE = "BuildConfig";   //$NON-NLS-1$
-    /** Manifest java class filename, i.e. "Manifest.java" */
-    public static final String FN_MANIFEST_CLASS = FN_MANIFEST_BASE + DOT_JAVA;
-    /** BuildConfig java class filename, i.e. "BuildConfig.java" */
-    public static final String FN_BUILD_CONFIG = FN_BUILD_CONFIG_BASE + DOT_JAVA;
-    public static final String DRAWABLE_FOLDER = "drawable";           //$NON-NLS-1$
-    public static final String DRAWABLE_XHDPI = "drawable-xhdpi";      //$NON-NLS-1$
-    public static final String DRAWABLE_XXHDPI = "drawable-xxhdpi";    //$NON-NLS-1$
-    public static final String DRAWABLE_XXXHDPI = "drawable-xxxhdpi";    //$NON-NLS-1$
-    public static final String DRAWABLE_HDPI = "drawable-hdpi";        //$NON-NLS-1$
-    public static final String DRAWABLE_MDPI = "drawable-mdpi";        //$NON-NLS-1$
-    public static final String DRAWABLE_LDPI = "drawable-ldpi";        //$NON-NLS-1$
-    // Resources
-    public static final String PREFIX_RESOURCE_REF = "@";               //$NON-NLS-1$
-    public static final String PREFIX_THEME_REF = "?";                  //$NON-NLS-1$
-    public static final String PREFIX_BINDING_EXPR = "@{";              //$NON-NLS-1$
-    public static final String ANDROID_PREFIX = "@android:";            //$NON-NLS-1$
-    public static final String ANDROID_THEME_PREFIX = "?android:";      //$NON-NLS-1$
-    public static final String LAYOUT_RESOURCE_PREFIX = "@layout/";     //$NON-NLS-1$
-    public static final String STYLE_RESOURCE_PREFIX = "@style/";       //$NON-NLS-1$
-    public static final String COLOR_RESOURCE_PREFIX = "@color/";       //$NON-NLS-1$
-    public static final String NEW_ID_PREFIX = "@+id/";                 //$NON-NLS-1$
-    public static final String ID_PREFIX = "@id/";                      //$NON-NLS-1$
-    public static final String DRAWABLE_PREFIX = "@drawable/";          //$NON-NLS-1$
-    public static final String STRING_PREFIX = "@string/";              //$NON-NLS-1$
-    public static final String DIMEN_PREFIX = "@dimen/";                //$NON-NLS-1$
-    public static final String MIPMAP_PREFIX = "@mipmap/";              //$NON-NLS-1$
-    public static final String ANDROID_LAYOUT_RESOURCE_PREFIX = "@android:layout/"; //$NON-NLS-1$
-    public static final String ANDROID_STYLE_RESOURCE_PREFIX = "@android:style/";   //$NON-NLS-1$
-    public static final String ANDROID_COLOR_RESOURCE_PREFIX = "@android:color/";   //$NON-NLS-1$
-    public static final String ANDROID_NEW_ID_PREFIX = "@android:+id/";             //$NON-NLS-1$
-    public static final String ANDROID_ID_PREFIX = "@android:id/";                  //$NON-NLS-1$
-    public static final String ANDROID_DRAWABLE_PREFIX = "@android:drawable/";      //$NON-NLS-1$
-    public static final String ANDROID_STRING_PREFIX = "@android:string/";          //$NON-NLS-1$
-    public static final String RESOURCE_CLZ_ID = "id";                  //$NON-NLS-1$
-    public static final String RESOURCE_CLZ_COLOR = "color";            //$NON-NLS-1$
-    public static final String RESOURCE_CLZ_ARRAY = "array";            //$NON-NLS-1$
-    public static final String RESOURCE_CLZ_ATTR = "attr";              //$NON-NLS-1$
-    public static final String RESOURCE_CLR_STYLEABLE = "styleable";    //$NON-NLS-1$
-    public static final String NULL_RESOURCE = "@null";                 //$NON-NLS-1$
-    public static final String TRANSPARENT_COLOR = "@android:color/transparent";      //$NON-NLS-1$
-    public static final String REFERENCE_STYLE = "style/";                     //$NON-NLS-1$
-    public static final String PREFIX_ANDROID = "android:";                    //$NON-NLS-1$
-    // Resource Types
-    public static final String DRAWABLE_TYPE = "drawable";              //$NON-NLS-1$
-    public static final String MENU_TYPE = "menu";                      //$NON-NLS-1$
-    // Packages
-    public static final String ANDROID_PKG_PREFIX = "android.";         //$NON-NLS-1$
-    public static final String WIDGET_PKG_PREFIX = "android.widget.";   //$NON-NLS-1$
-    public static final String VIEW_PKG_PREFIX = "android.view.";       //$NON-NLS-1$
-    // Project properties
-    public static final String ANDROID_LIBRARY = "android.library";     //$NON-NLS-1$
-    public static final String PROGUARD_CONFIG = "proguard.config";     //$NON-NLS-1$
-    public static final String ANDROID_LIBRARY_REFERENCE_FORMAT = "android.library.reference.%1$d";//$NON-NLS-1$
-    public static final String PROJECT_PROPERTIES = "project.properties";//$NON-NLS-1$
-    // Java References
-    public static final String ATTR_REF_PREFIX = "?attr/";               //$NON-NLS-1$
-    public static final String R_PREFIX = "R.";                          //$NON-NLS-1$
-    public static final String R_ID_PREFIX = "R.id.";                    //$NON-NLS-1$
-    public static final String R_LAYOUT_RESOURCE_PREFIX = "R.layout.";   //$NON-NLS-1$
-    public static final String R_DRAWABLE_PREFIX = "R.drawable.";        //$NON-NLS-1$
-    public static final String R_STYLEABLE_PREFIX = "R.styleable.";      //$NON-NLS-1$
-    public static final String R_ATTR_PREFIX = "R.attr.";                //$NON-NLS-1$
-    // Attributes related to tools
-    public static final String ATTR_IGNORE = "ignore";                   //$NON-NLS-1$
-    public static final String ATTR_LOCALE = "locale";                   //$NON-NLS-1$
-    // SuppressLint
-    public static final String SUPPRESS_ALL = "all";                     //$NON-NLS-1$
-    public static final String SUPPRESS_LINT = "SuppressLint";           //$NON-NLS-1$
-    public static final String TARGET_API = "TargetApi";                 //$NON-NLS-1$
-    public static final String ATTR_TARGET_API = "targetApi";            //$NON-NLS-1$
-    public static final String FQCN_SUPPRESS_LINT = "android.annotation." + SUPPRESS_LINT; //$NON-NLS-1$
-    public static final String FQCN_TARGET_API = "android.annotation." + TARGET_API; //$NON-NLS-1$
-    // Class Names
-    public static final String CONSTRUCTOR_NAME = "<init>";                          //$NON-NLS-1$
-    public static final String CLASS_CONSTRUCTOR = "<clinit>";                       //$NON-NLS-1$
-    public static final String FRAGMENT = "android/app/Fragment";                    //$NON-NLS-1$
-    public static final String FRAGMENT_V4 = "android/support/v4/app/Fragment";      //$NON-NLS-1$
-    public static final String ANDROID_APP_ACTIVITY = "android/app/Activity";        //$NON-NLS-1$
-    public static final String ANDROID_APP_SERVICE = "android/app/Service";          //$NON-NLS-1$
-    public static final String ANDROID_CONTENT_CONTENT_PROVIDER =
-            "android/content/ContentProvider";                                       //$NON-NLS-1$
-    public static final String ANDROID_CONTENT_BROADCAST_RECEIVER =
-            "android/content/BroadcastReceiver";                                     //$NON-NLS-1$
-    public static final String ANDROID_VIEW_VIEW = "android/view/View";              //$NON-NLS-1$
-    // Method Names
-    public static final String FORMAT_METHOD = "format";                             //$NON-NLS-1$
-    public static final String GET_STRING_METHOD = "getString";                      //$NON-NLS-1$
-    public static final String ATTR_TAG = "tag";                        //$NON-NLS-1$
-    public static final String ATTR_NUM_COLUMNS = "numColumns";         //$NON-NLS-1$
-    // Some common layout element names
-    public static final String CALENDAR_VIEW = "CalendarView";          //$NON-NLS-1$
-    public static final String SPACE = "Space";                         //$NON-NLS-1$
-    public static final String GESTURE_OVERLAY_VIEW = "GestureOverlayView";//$NON-NLS-1$
-    public static final String ATTR_HANDLE = "handle";                  //$NON-NLS-1$
-    public static final String ATTR_CONTENT = "content";                //$NON-NLS-1$
-    public static final String ATTR_CHECKED = "checked";                //$NON-NLS-1$
-    // TextView
-    public static final String ATTR_DRAWABLE_RIGHT = "drawableRight";              //$NON-NLS-1$
-    public static final String ATTR_DRAWABLE_LEFT = "drawableLeft";                //$NON-NLS-1$
-    public static final String ATTR_DRAWABLE_START = "drawableStart";              //$NON-NLS-1$
-    public static final String ATTR_DRAWABLE_END = "drawableEnd";                  //$NON-NLS-1$
-    public static final String ATTR_DRAWABLE_BOTTOM = "drawableBottom";            //$NON-NLS-1$
-    public static final String ATTR_DRAWABLE_TOP = "drawableTop";                  //$NON-NLS-1$
-    public static final String ATTR_DRAWABLE_PADDING = "drawablePadding";          //$NON-NLS-1$
-    public static final String ATTR_USE_DEFAULT_MARGINS = "useDefaultMargins";      //$NON-NLS-1$
-    public static final String ATTR_MARGINS_INCLUDED_IN_ALIGNMENT = "marginsIncludedInAlignment"; //$NON-NLS-1$
-    public static final String VALUE_WRAP_CONTENT = "wrap_content";             //$NON-NLS-1$
-    public static final String VALUE_FALSE= "false";                            //$NON-NLS-1$
-    public static final String VALUE_N_DP = "%ddp";                             //$NON-NLS-1$
-    public static final String VALUE_ZERO_DP = "0dp";                           //$NON-NLS-1$
-    public static final String VALUE_ONE_DP = "1dp";                            //$NON-NLS-1$
-    public static final String VALUE_TOP = "top";                               //$NON-NLS-1$
-    public static final String VALUE_BOTTOM = "bottom";                         //$NON-NLS-1$
-    public static final String VALUE_CENTER_VERTICAL = "center_vertical";       //$NON-NLS-1$
-    public static final String VALUE_CENTER_HORIZONTAL = "center_horizontal";   //$NON-NLS-1$
-    public static final String VALUE_FILL_HORIZONTAL = "fill_horizontal";       //$NON-NLS-1$
-    public static final String VALUE_FILL_VERTICAL = "fill_vertical";           //$NON-NLS-1$
-    public static final String VALUE_0 = "0";                                   //$NON-NLS-1$
-    public static final String VALUE_1 = "1";                                   //$NON-NLS-1$
-    // Gravity values. These have the GRAVITY_ prefix in front of value because we already
-    // have VALUE_CENTER_HORIZONTAL defined for layouts, and its definition conflicts
-    // (centerHorizontal versus center_horizontal)
-    public static final String GRAVITY_VALUE_ = "center";                             //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_CENTER = "center";                       //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_LEFT = "left";                           //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_RIGHT = "right";                         //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_START = "start";                         //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_END = "end";                             //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_BOTTOM = "bottom";                       //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_TOP = "top";                             //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_FILL_HORIZONTAL = "fill_horizontal";     //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_FILL_VERTICAL = "fill_vertical";         //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_CENTER_HORIZONTAL = "center_horizontal"; //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_CENTER_VERTICAL = "center_vertical";     //$NON-NLS-1$
-    public static final String GRAVITY_VALUE_FILL = "fill";                           //$NON-NLS-1$
-    /**
-     * The top level android package as a prefix, "android.".
-     */
-    public static final String ANDROID_SUPPORT_PKG_PREFIX = ANDROID_PKG_PREFIX + "support."; //$NON-NLS-1$
-    /** The android.view. package prefix */
-    public static final String ANDROID_VIEW_PKG = ANDROID_PKG_PREFIX + "view."; //$NON-NLS-1$
-    /** The android.widget. package prefix */
-    public static final String ANDROID_WIDGET_PREFIX = ANDROID_PKG_PREFIX + "widget."; //$NON-NLS-1$
-    /** The android.webkit. package prefix */
-    public static final String ANDROID_WEBKIT_PKG = ANDROID_PKG_PREFIX + "webkit."; //$NON-NLS-1$
-    /** The LayoutParams inner-class name suffix, .LayoutParams */
-    public static final String DOT_LAYOUT_PARAMS = ".LayoutParams"; //$NON-NLS-1$
-    /** The fully qualified class name of an EditText view */
-    public static final String FQCN_EDIT_TEXT = "android.widget.EditText"; //$NON-NLS-1$
-    /** The fully qualified class name of a LinearLayout view */
-    public static final String FQCN_LINEAR_LAYOUT = "android.widget.LinearLayout"; //$NON-NLS-1$
-    /** The fully qualified class name of a RelativeLayout view */
-    public static final String FQCN_RELATIVE_LAYOUT = "android.widget.RelativeLayout"; //$NON-NLS-1$
-    /** The fully qualified class name of a RelativeLayout view */
-    public static final String FQCN_GRID_LAYOUT = "android.widget.GridLayout"; //$NON-NLS-1$
-    public static final String FQCN_GRID_LAYOUT_V7 = "android.support.v7.widget.GridLayout"; //$NON-NLS-1$
-    /** The fully qualified class name of a FrameLayout view */
-    public static final String FQCN_FRAME_LAYOUT = "android.widget.FrameLayout"; //$NON-NLS-1$
-    /** The fully qualified class name of a TableRow view */
-    public static final String FQCN_TABLE_ROW = "android.widget.TableRow"; //$NON-NLS-1$
-    /** The fully qualified class name of a TableLayout view */
-    public static final String FQCN_TABLE_LAYOUT = "android.widget.TableLayout"; //$NON-NLS-1$
-    /** The fully qualified class name of a GridView view */
-    public static final String FQCN_GRID_VIEW = "android.widget.GridView"; //$NON-NLS-1$
-    /** The fully qualified class name of a TabWidget view */
-    public static final String FQCN_TAB_WIDGET = "android.widget.TabWidget"; //$NON-NLS-1$
-    /** The fully qualified class name of a Button view */
-    public static final String FQCN_BUTTON = "android.widget.Button"; //$NON-NLS-1$
-    /** The fully qualified class name of a RadioButton view */
-    public static final String FQCN_RADIO_BUTTON = "android.widget.RadioButton"; //$NON-NLS-1$
-    /** The fully qualified class name of a ToggleButton view */
-    public static final String FQCN_TOGGLE_BUTTON = "android.widget.ToggleButton"; //$NON-NLS-1$
-    /** The fully qualified class name of a Spinner view */
-    public static final String FQCN_SPINNER = "android.widget.Spinner"; //$NON-NLS-1$
-    /** The fully qualified class name of an AdapterView */
-    public static final String FQCN_ADAPTER_VIEW = "android.widget.AdapterView"; //$NON-NLS-1$
-    /** The fully qualified class name of a ListView */
-    public static final String FQCN_LIST_VIEW = "android.widget.ListView"; //$NON-NLS-1$
-    /** The fully qualified class name of an ExpandableListView */
-    public static final String FQCN_EXPANDABLE_LIST_VIEW = "android.widget.ExpandableListView"; //$NON-NLS-1$
-    /** The fully qualified class name of a GestureOverlayView */
-    public static final String FQCN_GESTURE_OVERLAY_VIEW = "android.gesture.GestureOverlayView"; //$NON-NLS-1$
-    /** The fully qualified class name of a DatePicker */
-    public static final String FQCN_DATE_PICKER = "android.widget.DatePicker"; //$NON-NLS-1$
-    /** The fully qualified class name of a TimePicker */
-    public static final String FQCN_TIME_PICKER = "android.widget.TimePicker"; //$NON-NLS-1$
-    /** The fully qualified class name of a RadioGroup */
-    public static final String FQCN_RADIO_GROUP = "android.widgets.RadioGroup";  //$NON-NLS-1$
-    /** The fully qualified class name of a Space */
-    public static final String FQCN_SPACE = "android.widget.Space"; //$NON-NLS-1$
-    public static final String FQCN_SPACE_V7 = "android.support.v7.widget.Space"; //$NON-NLS-1$
-    /** The fully qualified class name of a TextView view */
-    public static final String FQCN_TEXT_VIEW = "android.widget.TextView"; //$NON-NLS-1$
-    /** The fully qualified class name of an ImageView view */
-    public static final String FQCN_IMAGE_VIEW = "android.widget.ImageView"; //$NON-NLS-1$
-    public static final String ATTR_SRC = "src"; //$NON-NLS-1$
-    public static final String ATTR_GRAVITY = "gravity";        //$NON-NLS-1$
-    public static final String ATTR_WEIGHT_SUM = "weightSum"; //$NON-NLS-1$
-    public static final String ATTR_EMS = "ems"; //$NON-NLS-1$
-    public static final String VALUE_HORIZONTAL = "horizontal"; //$NON-NLS-1$
-    public static final String GRADLE_PLUGIN_NAME = "com.android.tools.build:gradle:";
-    public static final String GRADLE_MINIMUM_VERSION = "2.2.1";
-    public static final String GRADLE_LATEST_VERSION = "2.4";
-    public static final String GRADLE_PLUGIN_MINIMUM_VERSION = "1.0.0";
-    public static final String GRADLE_PLUGIN_RECOMMENDED_VERSION = "1.3.0";
-    public static final String GRADLE_PLUGIN_LATEST_VERSION = GRADLE_PLUGIN_RECOMMENDED_VERSION;
-    public static final String MIN_BUILD_TOOLS_VERSION = "19.1.0";
-    public static final String SUPPORT_LIB_ARTIFACT = "com.android.support:support-v4";
-    public static final String APPCOMPAT_LIB_ARTIFACT = "com.android.support:appcompat-v7";
-    // Annotations
-    public static final String SUPPORT_ANNOTATIONS_PREFIX = "android.support.annotation.";
-    public static final String INT_DEF_ANNOTATION = SUPPORT_ANNOTATIONS_PREFIX + "IntDef";
-    public static final String STRING_DEF_ANNOTATION = SUPPORT_ANNOTATIONS_PREFIX + "StringDef";
-    public static final String TYPE_DEF_VALUE_ATTRIBUTE = "value";
-    public static final String TYPE_DEF_FLAG_ATTRIBUTE = "flag";
-    public static final String FN_ANNOTATIONS_ZIP = "annotations.zip";
-    // Data Binding MISC
-    public static final String DATA_BINDING_LIB_ARTIFACT = "com.android.databinding:library";
-    public static final String[] TAGS_DATA_BINDING = new String[]{TAG_VARIABLE,
-            TAG_IMPORT, TAG_LAYOUT, TAG_DATA};
-    public static final String[] ATTRS_DATA_BINDING = new String[]{ATTR_NAME,
-            ATTR_TYPE, ATTR_CLASS, ATTR_ALIAS};
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/XmlAttribute.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlAttribute.java b/Build/src/main/java/com/tyron/build/compiler/manifest/XmlAttribute.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/XmlAttribute.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,382 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
-import com.google.common.base.Splitter;
-import com.google.common.collect.ImmutableSet;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-
-import org.w3c.dom.Attr;
-
-/**
- * Defines an XML attribute inside a {@link XmlElement}.
- *
- * Basically a facade object on {@link Attr} objects with some added features like automatic
- * namespace handling, manifest merger friendly identifiers and smart replacement of shortened
- * full qualified class names using manifest node's package setting from the the owning Android's
- * document.
- */
-public class XmlAttribute extends XmlNode {
-
-    private final XmlElement mOwnerElement;
-    private final Attr mXml;
-    @Nullable
-    private final AttributeModel mAttributeModel;
-
-    /**
-     * Creates a new facade object to a {@link Attr} xml attribute in a
-     * {@link XmlElement}.
-     *
-     * @param ownerElement the xml node object owning this attribute.
-     * @param xml the xml definition of the attribute.
-     */
-    public XmlAttribute(
-            @NonNull XmlElement ownerElement,
-            @NonNull Attr xml,
-            @Nullable AttributeModel attributeModel) {
-        this.mOwnerElement = Preconditions.checkNotNull(ownerElement);
-        this.mXml = Preconditions.checkNotNull(xml);
-        this.mAttributeModel = attributeModel;
-        if (mAttributeModel != null && mAttributeModel.isPackageDependent()) {
-            String value = mXml.getValue();
-            if (value == null || value.isEmpty()) return;
-            // placeholders are never expanded.
-            if (!PlaceholderHandler.isPlaceHolder(value)) {
-                String pkg = mOwnerElement.getDocument().getPackageNameForAttributeExpansion();
-                // We know it's a shortened FQCN if it starts with a dot
-                // or does not contain any dot.
-                if (value.indexOf('.') == -1 || value.charAt(0) == '.') {
-                    if (value.charAt(0) == '.') {
-                        value = pkg + value;
-                    } else {
-                        value = pkg + '.' + value;
-                    }
-                    mXml.setValue(value);
-                }
-            }
-        }
-    }
-
-    /**
-     * Returns the attribute's name, providing isolation from details like namespaces handling.
-     */
-    @Override
-    public NodeName getName() {
-        return XmlNode.unwrapName(mXml);
-    }
-
-    /**
-     * Returns the attribute's value
-     */
-    public String getValue() {
-        return mXml.getValue();
-    }
-
-    /**
-     * Returns a display friendly identification string that can be used in machine and user
-     * readable messages.
-     */
-    @Override
-    public NodeKey getId() {
-        // (Id of the parent element)@(my name)
-        String myName = mXml.getNamespaceURI() == null ? mXml.getName() : mXml.getLocalName();
-        return new NodeKey(mOwnerElement.getId() + "@" + myName);
-    }
-
-    @NonNull
-    @Override
-    public SourcePosition getPosition() {
-        try {
-            return mOwnerElement.getDocument().getNodePosition(this);
-        } catch(Exception e) {
-            return SourcePosition.UNKNOWN;
-        }
-    }
-
-    @NonNull
-    @Override
-    public Attr getXml() {
-        return mXml;
-    }
-
-    @Nullable
-    public AttributeModel getModel() {
-        return mAttributeModel;
-    }
-
-    XmlElement getOwnerElement() {
-        return mOwnerElement;
-    }
-
-    void mergeInHigherPriorityElement(XmlElement higherPriorityElement,
-                                      MergingReport.Builder mergingReport) {
-
-        // does the higher priority has the same attribute as myself ?
-        Optional<XmlAttribute> higherPriorityAttributeOptional =
-                higherPriorityElement.getAttribute(getName());
-
-        AttributeOperationType attributeOperationType =
-                higherPriorityElement.getAttributeOperationType(getName());
-
-        if (higherPriorityAttributeOptional.isPresent()) {
-
-            XmlAttribute higherPriorityAttribute = higherPriorityAttributeOptional.get();
-            handleBothAttributePresent(
-                    mergingReport, higherPriorityAttribute, attributeOperationType);
-            return;
-        }
-
-        // it does not exist, verify if we are supposed to remove it.
-        if (attributeOperationType == AttributeOperationType.REMOVE) {
-            // record the fact the attribute was actively removed.
-            mergingReport.getActionRecorder().recordAttributeAction(
-                    this,
-                    Actions.ActionType.REJECTED,
-                    AttributeOperationType.REMOVE);
-            return;
-        }
-
-        // the node is not defined in the higher priority element, it's defined in this lower
-        // priority element, we need to merge this lower priority attribute value with a potential
-        // higher priority default value (implicitly set on the higher priority element).
-        String mergedValue = mergeThisAndDefaultValue(mergingReport, higherPriorityElement);
-        if (mergedValue == null) {
-            return;
-        }
-
-        // ok merge it in the higher priority element.
-        getName().addToNode(higherPriorityElement.getXml(), mergedValue);
-
-        // and record the action.
-        mergingReport.getActionRecorder().recordAttributeAction(
-                this,
-                Actions.ActionType.ADDED,
-                getOwnerElement().getAttributeOperationType(getName()));
-    }
-
-    /**
-     * Handles merging of two attributes value explicitly declared in xml elements.
-     *
-     * @param report report to log errors and actions.
-     * @param higherPriority higher priority attribute we should merge this attribute with.
-     * @param operationType user operation type optionally requested by the user.
-     */
-    private void handleBothAttributePresent(
-            MergingReport.Builder report,
-            XmlAttribute higherPriority,
-            AttributeOperationType operationType) {
-
-        // handles tools: attribute separately.
-
-        if (getXml().getNamespaceURI() != null
-                && getXml().getNamespaceURI().equals(SdkConstants.TOOLS_URI)) {
-            handleBothToolsAttributePresent(higherPriority);
-            return;
-        }
-
-        // the attribute is present on both elements, there are 2 possibilities :
-        // 1. tools:replace was specified, replace the value.
-        // 2. nothing was specified, the values should be equal or this is an error.
-        if (operationType == AttributeOperationType.REPLACE) {
-            // record the fact the lower priority attribute was rejected.
-            report.getActionRecorder().recordAttributeAction(
-                    this,
-                    Actions.ActionType.REJECTED,
-                    AttributeOperationType.REPLACE);
-            return;
-        }
-        // if the values are the same, then it's fine, otherwise flag the error.
-        if (mAttributeModel != null) {
-            String mergedValue = mAttributeModel.getMergingPolicy()
-                    .merge(higherPriority.getValue(), getValue());
-            if (mergedValue != null) {
-                higherPriority.mXml.setValue(mergedValue);
-            } else {
-                addConflictingValueMessage(report, higherPriority);
-            }
-            return;
-        }
-        // no merging policy, for now revert on checking manually for equality.
-        if (!getValue().equals(higherPriority.getValue())) {
-            addConflictingValueMessage(report, higherPriority);
-        }
-    }
-
-    /**
-     * Handles tools: namespace attributes presence in both documents.
-     * @param higherPriority the higherPriority attribute
-     */
-    private void handleBothToolsAttributePresent(
-            XmlAttribute higherPriority) {
-
-        // do not merge tools:node attributes, the higher priority one wins.
-        if (getName().getLocalName().equals(NodeOperationType.NODE_LOCAL_NAME)) {
-            return;
-        }
-
-        // everything else should be merged, duplicates should be eliminated.
-        Splitter splitter = Splitter.on(',');
-        ImmutableSet.Builder<String> targetValues = ImmutableSet.builder();
-        targetValues.addAll(splitter.split(higherPriority.getValue()));
-        targetValues.addAll(splitter.split(getValue()));
-        higherPriority.getXml().setValue(Joiner.on(',').join(targetValues.build()));
-    }
-
-    /**
-     * Merge this attribute value (on a lower priority element) with a implicit default value
-     * (implicitly declared on the implicitNode).
-     * @param mergingReport report to log errors and actions.
-     * @param implicitNode the lower priority node where the implicit attribute value resides.
-     * @return the merged value that should be stored in the attribute or null if nothing should
-     * be stored.
-     */
-    private String mergeThisAndDefaultValue(MergingReport.Builder mergingReport,
-                                            XmlElement implicitNode) {
-
-        String mergedValue = getValue();
-        if (mAttributeModel == null || mAttributeModel.getDefaultValue() == null
-                || !mAttributeModel.getMergingPolicy().shouldMergeDefaultValues()) {
-            return mergedValue;
-        }
-        String defaultValue = mAttributeModel.getDefaultValue();
-        if (defaultValue.equals(mergedValue)) {
-            // even though the lower priority attribute is only declared and its value is the same
-            // as the default value, ensure it gets added to the higher priority node.
-            return mergedValue;
-        } else {
-            // ok, the default value and actual declaration are different, delegate to the
-            // merging policy to figure out what value should be used if any.
-            mergedValue = mAttributeModel.getMergingPolicy().merge(defaultValue, mergedValue);
-            if (mergedValue == null) {
-                addIllegalImplicitOverrideMessage(mergingReport, mAttributeModel, implicitNode);
-                return null;
-            }
-            if (mergedValue.equals(defaultValue)) {
-                // no need to forcefully add an attribute to the parent with its default value
-                // since it was not declared to start with.
-                return null;
-            }
-        }
-        return mergedValue;
-    }
-
-    /**
-     * Merge this attribute value with a lower priority node attribute default value.
-     * The attribute is not explicitly set on the implicitNode, yet it exist on this attribute
-     * {@link XmlElement} higher priority owner.
-     *
-     * @param mergingReport report to log errors and actions.
-     * @param implicitNode the lower priority node where the implicit attribute value resides.
-     */
-    void mergeWithLowerPriorityDefaultValue(
-            MergingReport.Builder mergingReport, XmlElement implicitNode) {
-
-        if (mAttributeModel == null || mAttributeModel.getDefaultValue() == null
-                || !mAttributeModel.getMergingPolicy().shouldMergeDefaultValues()) {
-            return;
-        }
-        // if this value has been explicitly set to replace the implicit default value, just
-        // log the action.
-        if (mOwnerElement.getAttributeOperationType(getName()) == AttributeOperationType.REPLACE) {
-            mergingReport.getActionRecorder().recordImplicitRejection(this, implicitNode);
-            return;
-        }
-        String mergedValue = mAttributeModel.getMergingPolicy().merge(
-                getValue(), mAttributeModel.getDefaultValue());
-        if (mergedValue == null) {
-            addIllegalImplicitOverrideMessage(mergingReport, mAttributeModel, implicitNode);
-        } else {
-            getXml().setValue(mergedValue);
-            mergingReport.getActionRecorder().recordAttributeAction(
-                    this,
-                    Actions.ActionType.MERGED,
-                    null /* attributeOperationType */);
-        }
-    }
-
-    private void addIllegalImplicitOverrideMessage(
-            @NonNull MergingReport.Builder mergingReport,
-            @NonNull AttributeModel attributeModel,
-            @NonNull XmlElement implicitNode) {
-        String error = String.format("Attribute %1$s value=(%2$s) at %3$s"
-                        + " cannot override implicit default value=(%4$s) at %5$s",
-                getId(),
-                getValue(),
-                printPosition(),
-                attributeModel.getDefaultValue(),
-                implicitNode.printPosition());
-        addMessage(mergingReport, MergingReport.Record.Severity.ERROR, error);
-    }
-
-    private void addConflictingValueMessage(
-            MergingReport.Builder report,
-            XmlAttribute higherPriority) {
-
-        Actions.AttributeRecord attributeRecord = report.getActionRecorder()
-                .getAttributeCreationRecord(higherPriority);
-
-        String error;
-        if (getOwnerElement().getType().getMergeType() == MergeType.MERGE_CHILDREN_ONLY) {
-            error = String.format(
-                    "Attribute %1$s value=(%2$s) from %3$s\n"
-                            + "\tis also present at %4$s value=(%5$s).\n"
-                            + "\tAttributes of <%6$s> elements are not merged.",
-                    higherPriority.getId(),
-                    higherPriority.getValue(),
-                    attributeRecord != null
-                            ? attributeRecord.getActionLocation().print(true /*shortFormat*/)
-                            : "(unknown)",
-                    printPosition(),
-                    getValue(),
-                    getOwnerElement().getType().toXmlName());
-        } else {
-            error = String.format(
-                    "Attribute %1$s value=(%2$s) from %3$s\n"
-                            + "\tis also present at %4$s value=(%5$s).\n"
-                            + "\tSuggestion: add 'tools:replace=\"%6$s\"' to <%7$s> element "
-                            + "at %8$s to override.",
-                    higherPriority.getId(),
-                    higherPriority.getValue(),
-                    attributeRecord != null
-                            ? attributeRecord.getActionLocation().print(true /*shortFormat*/)
-                            : "(unknown)",
-                    printPosition(),
-                    getValue(),
-                    mXml.getName(),
-                    getOwnerElement().getType().toXmlName(),
-                    higherPriority.getOwnerElement().printPosition());
-        }
-        higherPriority.addMessage(report,
-                attributeRecord != null
-                        ? attributeRecord.getActionLocation().getPosition()
-                        : SourcePosition.UNKNOWN,
-                MergingReport.Record.Severity.ERROR, error);
-    }
-
-    void addMessage(MergingReport.Builder report,
-                    MergingReport.Record.Severity severity,
-                    String message) {
-        addMessage(report, getPosition(), severity, message);
-    }
-
-    void addMessage(MergingReport.Builder report,
-                    SourcePosition position,
-                    MergingReport.Record.Severity severity,
-                    String message) {
-        report.addMessage(
-                new SourceFilePosition(getOwnerElement().getDocument().getSourceFile(), position),
-                severity, message);
-    }
-
-    @NonNull
-    @Override
-    public SourceFile getSourceFile() {
-        return getOwnerElement().getSourceFile();
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ManifestModel.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestModel.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestModel.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestModel.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,665 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.SdkConstants.ANDROID_URI;
-import static com.tyron.build.compiler.manifest.SdkConstants.ATTR_NAME;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Joiner;
-import com.google.common.base.Preconditions;
-import com.google.common.base.Strings;
-import com.google.common.collect.ImmutableList;
-import com.tyron.build.compiler.manifest.xml.AndroidManifest;
-import com.tyron.build.util.SdkUtils;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import com.google.errorprone.annotations.Immutable;
-
-/**
- * Model for the manifest file merging activities.
- * <p>
- *
- * This model will describe each element that is eligible for merging and associated merging
- * policies. It is not reusable as most of its interfaces are private but a future enhancement
- * could easily make this more generic/reusable if we need to merge more than manifest files.
- *
- */
-@Immutable
-class ManifestModel {
-
-    /**
-     * Interface responsible for providing a key extraction capability from a xml element.
-     * Some elements store their keys as an attribute, some as a sub-element attribute, some don't
-     * have any key.
-     */
-    @Immutable
-    interface NodeKeyResolver {
-
-        /**
-         * Returns the key associated with this xml element.
-         * @param xmlElement the xml element to get the key from
-         * @return the key as a string to uniquely identify xmlElement from similarly typed elements
-         * in the xml document or null if there is no key.
-         */
-        @Nullable String getKey(Element xmlElement);
-
-        /**
-         * Returns the attribute(s) used to store the xml element key.
-         * @return the key attribute(s) name(s) or null of this element does not have a key.
-         */
-        @NonNull
-        ImmutableList<String> getKeyAttributesNames();
-    }
-
-    /**
-     * Implementation of {@link ManifestModel.NodeKeyResolver} that do not
-     * provide any key (the element has to be unique in the xml document).
-     */
-    private static class NoKeyNodeResolver implements NodeKeyResolver {
-
-        @Override
-        @Nullable
-        public String getKey(Element xmlElement) {
-            return null;
-        }
-
-        @NonNull
-        @Override
-        public ImmutableList<String> getKeyAttributesNames() {
-            return ImmutableList.of();
-        }
-    }
-
-    /**
-     * Implementation of {@link ManifestModel.NodeKeyResolver} that uses an
-     * attribute to resolve the key value.
-     */
-    private static class AttributeBasedNodeKeyResolver implements NodeKeyResolver {
-
-        @Nullable
-        private final String mNamespaceUri;
-        private final String mAttributeName;
-
-        /**
-         * Build a new instance capable of resolving an xml element key from the passed attribute
-         * namespace and local name.
-         * @param namespaceUri optional namespace for the attribute name.
-         * @param attributeName attribute name
-         */
-        private AttributeBasedNodeKeyResolver(@Nullable String namespaceUri,
-                                              @NonNull String attributeName) {
-            this.mNamespaceUri = namespaceUri;
-            this.mAttributeName = Preconditions.checkNotNull(attributeName);
-        }
-
-        @Override
-        @Nullable
-        public String getKey(Element xmlElement) {
-            String key = mNamespaceUri == null
-                    ? xmlElement.getAttribute(mAttributeName)
-                    : xmlElement.getAttributeNS(mNamespaceUri, mAttributeName);
-            if (Strings.isNullOrEmpty(key)) return null;
-            return key;
-        }
-
-        @NonNull
-        @Override
-        public ImmutableList<String> getKeyAttributesNames() {
-            return ImmutableList.of(mAttributeName);
-        }
-    }
-
-    /**
-     * Subclass of {@link ManifestModel.AttributeBasedNodeKeyResolver} that
-     * uses "android:name" as the attribute.
-     */
-    private static final NodeKeyResolver DEFAULT_NAME_ATTRIBUTE_RESOLVER =
-            new AttributeBasedNodeKeyResolver(ANDROID_URI, SdkConstants.ATTR_NAME);
-
-    private static final NoKeyNodeResolver DEFAULT_NO_KEY_NODE_RESOLVER = new NoKeyNodeResolver();
-
-    /**
-     * A {@link ManifestModel.NodeKeyResolver} capable of extracting the
-     * element key first in an "android:name" attribute and if not value found there, in the
-     * "android:glEsVersion" attribute.
-     */
-    private static final NodeKeyResolver NAME_AND_GLESVERSION_KEY_RESOLVER = new NodeKeyResolver() {
-        private final NodeKeyResolver nameAttrResolver = DEFAULT_NAME_ATTRIBUTE_RESOLVER;
-        private final NodeKeyResolver glEsVersionResolver =
-                new AttributeBasedNodeKeyResolver(ANDROID_URI,
-                        AndroidManifest.ATTRIBUTE_GLESVERSION);
-
-        @Nullable
-        @Override
-        public String getKey(Element xmlElement) {
-            String key = nameAttrResolver.getKey(xmlElement);
-            return Strings.isNullOrEmpty(key)
-                    ? glEsVersionResolver.getKey(xmlElement)
-                    : key;
-        }
-
-        @NonNull
-        @Override
-        public ImmutableList<String> getKeyAttributesNames() {
-            return ImmutableList.of(SdkConstants.ATTR_NAME, AndroidManifest.ATTRIBUTE_GLESVERSION);
-        }
-    };
-
-    /**
-     * Specific {@link ManifestModel.NodeKeyResolver} for intent-filter
-     * elements.
-     * Intent filters do not have a proper key, therefore their identity is really carried by
-     * the presence of the action and category sub-elements.
-     * We concatenate such elements sub-keys (after sorting them to work around declaration order)
-     * and use that for the intent-filter unique key.
-     */
-    private static final NodeKeyResolver INTENT_FILTER_KEY_RESOLVER = new NodeKeyResolver() {
-        @Nullable
-        @Override
-        public String getKey(Element element) {
-            OrphanXmlElement xmlElement = new OrphanXmlElement(element);
-            assert(xmlElement.getType() == NodeTypes.INTENT_FILTER);
-            // concatenate all actions and categories attribute names.
-            List<String> allSubElementKeys = new ArrayList<String>();
-            NodeList childNodes = element.getChildNodes();
-            for (int i = 0; i < childNodes.getLength(); i++) {
-                Node child = childNodes.item(i);
-                if (child.getNodeType() != Node.ELEMENT_NODE) continue;
-                OrphanXmlElement subElement = new OrphanXmlElement((Element) child);
-                if (subElement.getType() == NodeTypes.ACTION
-                        || subElement.getType() == NodeTypes.CATEGORY) {
-                    Attr nameAttribute = subElement.getXml()
-                            .getAttributeNodeNS(ANDROID_URI, ATTR_NAME);
-                    if (nameAttribute != null) {
-                        allSubElementKeys.add(nameAttribute.getValue());
-                    }
-                }
-            }
-            Collections.sort(allSubElementKeys);
-            return Joiner.on('+').join(allSubElementKeys);
-        }
-
-        @NonNull
-        @Override
-        public ImmutableList<String> getKeyAttributesNames() {
-            return ImmutableList.of("action#name", "category#name");
-        }
-    };
-
-    /**
-     * Implementation of {@link ManifestModel.NodeKeyResolver} that
-     * combined two attributes values to create the key value.
-     */
-    private static final class TwoAttributesBasedKeyResolver implements NodeKeyResolver {
-        private final NodeKeyResolver firstAttributeKeyResolver;
-        private final NodeKeyResolver secondAttributeKeyResolver;
-
-        private TwoAttributesBasedKeyResolver(NodeKeyResolver firstAttributeKeyResolver,
-                                              NodeKeyResolver secondAttributeKeyResolver) {
-            this.firstAttributeKeyResolver = firstAttributeKeyResolver;
-            this.secondAttributeKeyResolver = secondAttributeKeyResolver;
-        }
-
-        @Nullable
-        @Override
-        public String getKey(Element xmlElement) {
-            String firstKey = firstAttributeKeyResolver.getKey(xmlElement);
-            String secondKey = secondAttributeKeyResolver.getKey(xmlElement);
-
-            return Strings.isNullOrEmpty(firstKey)
-                    ? secondKey
-                    : Strings.isNullOrEmpty(secondKey)
-                    ? firstKey
-                    : firstKey + "+" + secondKey;
-        }
-
-        @NonNull
-        @Override
-        public ImmutableList<String> getKeyAttributesNames() {
-            return ImmutableList.of(firstAttributeKeyResolver.getKeyAttributesNames().get(0),
-                    secondAttributeKeyResolver.getKeyAttributesNames().get(0));
-        }
-    }
-
-    private static final AttributeModel.BooleanValidator BOOLEAN_VALIDATOR =
-            new AttributeModel.BooleanValidator();
-
-    private static final boolean MULTIPLE_DECLARATION_FOR_SAME_KEY_ALLOWED = true;
-
-    /**
-     * Definitions of the support node types in the Android Manifest file.
-     * {@link <a href=http://developer.android.com/guide/topics/manifest/manifest-intro.html/>}
-     * for more details about the xml format.
-     *
-     * There is no DTD or schema associated with the file type so this is best effort in providing
-     * some metadata on the elements of the Android's xml file.
-     *
-     * Each xml element is defined as an enum value and for each node, extra metadata is added
-     * <ul>
-     *     <li>{@link MergeType} to identify how the merging engine
-     *     should process this element.</li>
-     *     <li>{@link ManifestModel.NodeKeyResolver} to resolve the
-     *     element's key. Elements can have an attribute like "android:name", others can use
-     *     a sub-element, and finally some do not have a key and are meant to be unique.</li>
-     *     <li>List of attributes models with special behaviors :
-     *     <ul>
-     *         <li>Smart substitution of class names to fully qualified class names using the
-     *         document's package declaration. The list's size can be 0..n</li>
-     *         <li>Implicit default value when no defined on the xml element.</li>
-     *         <li>{@link AttributeModel.Validator} to validate attribute value against.</li>
-     *     </ul>
-     * </ul>
-     *
-     * It is of the outermost importance to keep this model correct as it is used by the merging
-     * engine to make all its decisions. There should not be special casing in the engine, all
-     * decisions must be represented here.
-     *
-     * If you find yourself needing to extend the model to support future requirements, do it here
-     * and modify the engine to make proper decision based on the added metadata.
-     */
-    enum NodeTypes {
-
-        /**
-         * Action (contained in intent-filter)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/action-element.html>
-         *     Action Xml documentation</a>}
-         */
-        ACTION(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER),
-
-        /**
-         * Activity (contained in application)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/activity-element.html>
-         *     Activity Xml documentation</a>}
-         */
-        ACTIVITY(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel("parentActivityName").setIsPackageDependent(),
-                AttributeModel.newModel(SdkConstants.ATTR_NAME).setIsPackageDependent()),
-
-        /**
-         * Activity-alias (contained in application)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/activity-alias-element.html>
-         *     Activity-alias Xml documentation</a>}
-         */
-        ACTIVITY_ALIAS(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel("targetActivity").setIsPackageDependent(),
-                AttributeModel.newModel(SdkConstants.ATTR_NAME).setIsPackageDependent()),
-
-        /**
-         * Application (contained in manifest)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/application-element.html>
-         *     Application Xml documentation</a>}
-         */
-        APPLICATION(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER,
-                AttributeModel.newModel("backupAgent").setIsPackageDependent(),
-                AttributeModel.newModel(SdkConstants.ATTR_NAME).setIsPackageDependent()),
-
-        /**
-         * Category (contained in intent-filter)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/category-element.html>
-         *     Category Xml documentation</a>}
-         */
-        CATEGORY(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER),
-
-        /**
-         * Compatible-screens (contained in manifest)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/compatible-screens-element.html>
-         *     Category Xml documentation</a>}
-         */
-        COMPATIBLE_SCREENS(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER),
-
-        /**
-         * Data (contained in intent-filter)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/data-element.html>
-         *     Category Xml documentation</a>}
-         */
-        DATA(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER),
-
-        /**
-         * Grant-uri-permission (contained in intent-filter)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/grant-uri-permission-element.html>
-         *     Category Xml documentation</a>}
-         */
-        GRANT_URI_PERMISSION(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER),
-
-        /**
-         * Instrumentation (contained in intent-filter)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/instrumentation-element.html>
-         *     Instrunentation Xml documentation</a>}
-         */
-        INSTRUMENTATION(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(SdkConstants.ATTR_NAME).setIsPackageDependent()),
-
-        /**
-         * Intent-filter (contained in activity, activity-alias, service, receiver)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/intent-filter-element.html>
-         *     Intent-filter Xml documentation</a>}
-         */
-        INTENT_FILTER(MergeType.ALWAYS, INTENT_FILTER_KEY_RESOLVER,
-                MULTIPLE_DECLARATION_FOR_SAME_KEY_ALLOWED),
-
-        /**
-         * Manifest (top level node)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/manifest-element.html>
-         *     Manifest Xml documentation</a>}
-         */
-        MANIFEST(MergeType.MERGE_CHILDREN_ONLY, DEFAULT_NO_KEY_NODE_RESOLVER),
-
-        /**
-         * Meta-data (contained in activity, activity-alias, application, provider, receiver)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/meta-data-element.html>
-         *     Meta-data Xml documentation</a>}
-         */
-        META_DATA(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER),
-
-        /**
-         * Path-permission (contained in provider)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/path-permission-element.html>
-         *     Meta-data Xml documentation</a>}
-         */
-        PATH_PERMISSION(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER),
-
-        /**
-         * Permission-group (contained in manifest).
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/permission-group-element.html>
-         *     Permission-group Xml documentation</a>}
-         *
-         */
-        PERMISSION_GROUP(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(SdkConstants.ATTR_NAME)),
-
-        /**
-         * Permission (contained in manifest).
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/permission-element.html>
-         *     Permission Xml documentation</a>}
-         *
-         */
-        PERMISSION(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(SdkConstants.ATTR_NAME),
-                AttributeModel.newModel("protectionLevel")
-                        .setDefaultValue("normal")
-                        // TODO : this will need to be populated from
-                        // sdk/platforms/android-19/data/res/values.attrs_manifest.xml
-                        .setOnReadValidator(new AttributeModel.MultiValueValidator(
-                                "normal", "dangerous", "signature", "signatureOrSystem"))),
-
-        /**
-         * Permission-tree (contained in manifest).
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/permission-tree-element.html>
-         *     Permission-tree Xml documentation</a>}
-         *
-         */
-        PERMISSION_TREE(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(SdkConstants.ATTR_NAME)),
-
-        /**
-         * Provider (contained in application)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/provider-element.html>
-         *     Provider Xml documentation</a>}
-         */
-        PROVIDER(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(SdkConstants.ATTR_NAME)
-                        .setIsPackageDependent()),
-
-        /**
-         * Receiver (contained in application)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/receiver-element.html>
-         *     Receiver Xml documentation</a>}
-         */
-        RECEIVER(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(SdkConstants.ATTR_NAME).setIsPackageDependent()),
-
-        /**
-         * Screen (contained in compatible-screens)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/compatible-screens-element.html>
-         *     Receiver Xml documentation</a>}
-         */
-        SCREEN(MergeType.MERGE, new TwoAttributesBasedKeyResolver(
-                new AttributeBasedNodeKeyResolver(ANDROID_URI, "screenSize"),
-                new AttributeBasedNodeKeyResolver(ANDROID_URI, "screenDensity"))),
-
-        /**
-         * Service (contained in application)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/application-element.html>
-         *     Service Xml documentation</a>}
-         */
-        SERVICE(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(SdkConstants.ATTR_NAME).setIsPackageDependent()),
-
-        /**
-         * Supports-gl-texture (contained in manifest)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/supports-gl-texture-element.html>
-         *     Support-screens Xml documentation</a>}
-         */
-        SUPPORTS_GL_TEXTURE(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER),
-
-        /**
-         * Support-screens (contained in manifest)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/supports-screens-element.html>
-         *     Support-screens Xml documentation</a>}
-         */
-        SUPPORTS_SCREENS(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER),
-
-        /**
-         * Uses-configuration (contained in manifest)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/uses-configuration-element.html>
-         *     Support-screens Xml documentation</a>}
-         */
-        USES_CONFIGURATION(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER),
-
-        /**
-         * Uses-feature (contained in manifest)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/uses-feature-element.html>
-         *     Uses-feature Xml documentation</a>}
-         */
-        USES_FEATURE(MergeType.MERGE, NAME_AND_GLESVERSION_KEY_RESOLVER,
-                AttributeModel.newModel(AndroidManifest.ATTRIBUTE_REQUIRED)
-                        .setDefaultValue(SdkConstants.VALUE_TRUE)
-                        .setOnReadValidator(BOOLEAN_VALIDATOR)
-                        .setMergingPolicy(AttributeModel.OR_MERGING_POLICY),
-                AttributeModel.newModel(AndroidManifest.ATTRIBUTE_GLESVERSION)
-                        .setDefaultValue("0x00010000")
-                        .setOnReadValidator(new AttributeModel.Hexadecimal32BitsWithMinimumValue(0x00010000))),
-
-        /**
-         * Use-library (contained in application)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/uses-library-element.html>
-         *     Use-library Xml documentation</a>}
-         */
-        USES_LIBRARY(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER,
-                AttributeModel.newModel(AndroidManifest.ATTRIBUTE_REQUIRED)
-                        .setDefaultValue(SdkConstants.VALUE_TRUE)
-                        .setOnReadValidator(BOOLEAN_VALIDATOR)
-                        .setMergingPolicy(AttributeModel.OR_MERGING_POLICY)),
-
-        /**
-         * Uses-permission (contained in application)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/uses-permission-element.html>
-         *     Uses-permission Xml documentation</a>}
-         */
-        USES_PERMISSION(MergeType.MERGE, DEFAULT_NAME_ATTRIBUTE_RESOLVER),
-
-        /**
-         * Uses-sdk (contained in manifest)
-         * <br>
-         * <b>See also : </b>
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/uses-sdk-element.html>
-         *     Uses-sdk Xml documentation</a>}
-         */
-        USES_SDK(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER,
-                AttributeModel.newModel("minSdkVersion")
-                        .setDefaultValue(SdkConstants.VALUE_1)
-                        .setMergingPolicy(AttributeModel.NO_MERGING_POLICY),
-                AttributeModel.newModel("maxSdkVersion")
-                        .setMergingPolicy(AttributeModel.NO_MERGING_POLICY),
-                // TODO : model target's default value is minSdkVersion value.
-                AttributeModel.newModel("targetSdkVersion")
-                        .setMergingPolicy(AttributeModel.NO_MERGING_POLICY)
-        ),
-
-        /**
-         * Custom tag for any application specific element
-         */
-        CUSTOM(MergeType.MERGE, DEFAULT_NO_KEY_NODE_RESOLVER);
-
-
-        private final MergeType mMergeType;
-        private final NodeKeyResolver mNodeKeyResolver;
-        private final ImmutableList<AttributeModel> mAttributeModels;
-        private final boolean mMultipleDeclarationAllowed;
-
-        NodeTypes(
-                @NonNull MergeType mergeType,
-                @NonNull NodeKeyResolver nodeKeyResolver,
-                @Nullable AttributeModel.Builder... attributeModelBuilders) {
-            this(mergeType, nodeKeyResolver, false, attributeModelBuilders);
-        }
-
-        NodeTypes(
-                @NonNull MergeType mergeType,
-                @NonNull NodeKeyResolver nodeKeyResolver,
-                boolean mutipleDeclarationAllowed,
-                @Nullable AttributeModel.Builder... attributeModelBuilders) {
-            this.mMergeType = Preconditions.checkNotNull(mergeType);
-            this.mNodeKeyResolver = Preconditions.checkNotNull(nodeKeyResolver);
-            ImmutableList.Builder<AttributeModel> attributeModels =
-                    new ImmutableList.Builder<AttributeModel>();
-            if (attributeModelBuilders != null) {
-                for (AttributeModel.Builder attributeModelBuilder : attributeModelBuilders) {
-                    attributeModels.add(attributeModelBuilder.build());
-                }
-            }
-            this.mAttributeModels = attributeModels.build();
-            this.mMultipleDeclarationAllowed = mutipleDeclarationAllowed;
-        }
-
-        @NonNull
-        NodeKeyResolver getNodeKeyResolver() {
-            return mNodeKeyResolver;
-        }
-
-        ImmutableList<AttributeModel> getAttributeModels() {
-            return mAttributeModels.asList();
-        }
-
-        @Nullable
-        AttributeModel getAttributeModel(XmlNode.NodeName attributeName) {
-            // mAttributeModels could be replaced with a Map if the number of models grows.
-            for (AttributeModel attributeModel : mAttributeModels) {
-                if (attributeModel.getName().equals(attributeName)) {
-                    return attributeModel;
-                }
-            }
-            return null;
-        }
-
-        /**
-         * Returns the Xml name for this node type
-         */
-        String toXmlName() {
-            return SdkUtils.constantNameToXmlName(this.name());
-        }
-
-        /**
-         * Returns the {@link NodeTypes} instance from an xml element name (without namespace
-         * decoration). For instance, an xml element
-         * <pre>
-         *     {@code
-         *     <activity android:name="foo">
-         *         ...
-         *     </activity>}
-         * </pre>
-         * has a xml simple name of "activity" which will resolve to {@link NodeTypes#ACTIVITY} value.
-         *
-         * Note : a runtime exception will be generated if no mapping from the simple name to a
-         * {@link NodeTypes} exists.
-         *
-         * @param xmlSimpleName the xml (lower-hyphen separated words) simple name.
-         * @return the {@link NodeTypes} associated with that element name.
-         */
-        static NodeTypes fromXmlSimpleName(String xmlSimpleName) {
-            String constantName = SdkUtils.xmlNameToConstantName(xmlSimpleName);
-
-            try {
-                return NodeTypes.valueOf(constantName);
-            } catch (IllegalArgumentException e) {
-                // if this element name is not a known tag, we categorize it as 'custom' which will
-                // be simply merged. It will prevent us from catching simple spelling mistakes but
-                // extensibility is a must have feature.
-                return NodeTypes.CUSTOM;
-            }
-        }
-
-        MergeType getMergeType() {
-            return mMergeType;
-        }
-
-        /**
-         * Returns true if multiple declaration for the same type and key are allowed or false if
-         * there must be only one declaration of this element for a particular key value.
-         */
-        boolean areMultipleDeclarationAllowed() {
-            return mMultipleDeclarationAllowed;
-        }
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/MergeXmlUtils.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/MergeXmlUtils.java b/Build/src/main/java/com/tyron/build/compiler/manifest/MergeXmlUtils.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/MergeXmlUtils.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,936 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.VisibleForTesting;
-
-import com.tyron.build.model.FileAndLine;
-import com.tyron.build.compiler.manifest.IMergerLog.Severity;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.util.XmlUtils;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXParseException;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.Reader;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.transform.OutputKeys;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.stream.StreamResult;
-
-/**
- * A few XML handling utilities.
- */
-class MergerXmlUtils {
-
-    private static final String DATA_ORIGIN_FILE = "manif.merger.file";         //$NON-NLS-1$
-    private static final String DATA_FILE_NAME   = "manif.merger.filename";     //$NON-NLS-1$
-    private static final String DATA_LINE_NUMBER = "manif.merger.line#";        //$NON-NLS-1$
-
-    /**
-     * Parses the given XML file as a DOM document.
-     * The parser does not validate the DTD nor any kind of schema.
-     * It is namespace aware.
-     * <p/>
-     * This adds a user tag with the original {@link File} to the returned document.
-     * You can retrieve this file later by using {@link #extractXmlFilename(Node)}.
-     *
-     * @param xmlFile The XML {@link File} to parse. Must not be null.
-     * @param log An {@link ILogger} for reporting errors. Must not be null.
-     * @param merger The {@link ManifestMerger} this document is intended for
-     * @return A new DOM {@link Document}, or null.
-     */
-    @Nullable
-    static Document parseDocument(@NonNull final File xmlFile, @NonNull final IMergerLog log,
-                                  @NonNull ManifestMerger merger) {
-        try {
-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-            Reader reader = XmlUtils.getUtfReader(xmlFile);
-            InputSource is = new InputSource(reader);
-            factory.setNamespaceAware(true);
-            factory.setValidating(false);
-            DocumentBuilder builder = factory.newDocumentBuilder();
-
-            // We don't want the default handler which prints errors to stderr.
-            builder.setErrorHandler(new ErrorHandler() {
-                @Override
-                public void warning(SAXParseException e) {
-                    log.error(Severity.WARNING,
-                            new FileAndLine(xmlFile.getAbsolutePath(), 0),
-                            "Warning when parsing: %1$s",
-                            e.toString());
-                }
-                @Override
-                public void fatalError(SAXParseException e) {
-                    log.error(Severity.ERROR,
-                            new FileAndLine(xmlFile.getAbsolutePath(), 0),
-                            "Fatal error when parsing: %1$s",
-                            xmlFile.getName(), e.toString());
-                }
-                @Override
-                public void error(SAXParseException e) {
-                    log.error(Severity.ERROR,
-                            new FileAndLine(xmlFile.getAbsolutePath(), 0),
-                            "Error when parsing: %1$s",
-                            e.toString());
-                }
-            });
-
-            Document doc = builder.parse(is);
-            doc.setUserData(DATA_ORIGIN_FILE, xmlFile, null /*handler*/);
-            findLineNumbers(doc, 1);
-
-            if (merger.isInsertSourceMarkers()) {
-                setSource(doc, xmlFile);
-            }
-
-            return doc;
-
-        } catch (FileNotFoundException e) {
-            log.error(Severity.ERROR,
-                    new FileAndLine(xmlFile.getAbsolutePath(), 0),
-                    "XML file not found");
-
-        } catch (Exception e) {
-            log.error(Severity.ERROR,
-                    new FileAndLine(xmlFile.getAbsolutePath(), 0),
-                    "Failed to parse XML file: %1$s",
-                    e.toString());
-        }
-
-        return null;
-    }
-
-    /**
-     * Parses the given XML string as a DOM document.
-     * The parser does not validate the DTD nor any kind of schema.
-     * It is namespace aware.
-     *
-     * @param xml The XML string to parse. Must not be null.
-     * @param log An {@link ILogger} for reporting errors. Must not be null.
-     * @return A new DOM {@link Document}, or null.
-     */
-    @VisibleForTesting
-    @Nullable
-    static Document parseDocument(@NonNull String xml,
-                                  @NonNull IMergerLog log,
-                                  @NonNull FileAndLine errorContext) {
-        try {
-            Document doc = XmlUtils.parseDocument(xml, true);
-            findLineNumbers(doc, 1);
-            if (errorContext.getFileName() != null) {
-                setSource(doc, new File(errorContext.getFileName()));
-            }
-            return doc;
-        } catch (Exception e) {
-            log.error(Severity.ERROR, errorContext, "Failed to parse XML string");
-        }
-
-        return null;
-    }
-
-    /**
-     * Decorates the document with the specified file name, which can be
-     * retrieved later by calling {@link #extractLineNumber(Node)}.
-     * <p/>
-     * It also tries to add line number information, with the caveat that the
-     * current implementation is a gross approximation.
-     * <p/>
-     * There is no need to call this after calling one of the {@code parseDocument()}
-     * methods since they already decorated their own document.
-     *
-     * @param doc The document to decorate.
-     * @param fileName The name to retrieve later for that document.
-     */
-    static void decorateDocument(@NonNull Document doc, @NonNull String fileName) {
-        doc.setUserData(DATA_FILE_NAME, fileName, null /*handler*/);
-        findLineNumbers(doc, 1);
-    }
-
-    /**
-     * Returns a new {@link FileAndLine} structure that identifies
-     * the base filename & line number from which the XML node was parsed.
-     * <p/>
-     * When the line number is unknown (e.g. if a {@link Document} instance is given)
-     * then line number 0 will be used.
-     *
-     * @param node The node or document where the error occurs. Must not be null.
-     * @return A new non-null {@link FileAndLine} combining the file name and line number.
-     */
-    @NonNull
-    static FileAndLine xmlFileAndLine(@NonNull Node node) {
-        String name = extractXmlFilename(node);
-        int line = extractLineNumber(node); // 0 in case of error or unknown
-        return new FileAndLine(name, line);
-    }
-
-    /**
-     * Extracts the origin {@link File} that {@link #parseDocument(File, IMergerLog,
-     * ManifestMerger)} added to the XML document or the string added by
-     *
-     * @param xmlNode Any node from a document returned by {@link #parseDocument(File, IMergerLog,
-     *              ManifestMerger)}.
-     * @return The {@link File} object used to create the document or null.
-     */
-    @Nullable
-    static String extractXmlFilename(@Nullable Node xmlNode) {
-        if (xmlNode != null && xmlNode.getNodeType() != Node.DOCUMENT_NODE) {
-            xmlNode = xmlNode.getOwnerDocument();
-        }
-        if (xmlNode != null) {
-            Object data = xmlNode.getUserData(DATA_ORIGIN_FILE);
-            if (data instanceof File) {
-                return ((File) data).getPath();
-            }
-            data = xmlNode.getUserData(DATA_FILE_NAME);
-            if (data instanceof String) {
-                return (String) data;
-            }
-        }
-
-        return null;
-    }
-
-    public static void setSource(@NonNull Node node, @NonNull File source) {
-        //noinspection ConstantConditions
-        for (; node != null; node = node.getNextSibling()) {
-            short nodeType = node.getNodeType();
-            if (nodeType == Node.ELEMENT_NODE
-                    || nodeType == Node.COMMENT_NODE
-                    || nodeType == Node.DOCUMENT_NODE
-                    || nodeType == Node.CDATA_SECTION_NODE) {
-                node.setUserData(DATA_ORIGIN_FILE, source, null);
-            }
-            Node child = node.getFirstChild();
-            setSource(child, source);
-        }
-    }
-
-    /**
-     * This is a CRUDE INEXACT HACK to decorate the DOM with some kind of line number
-     * information for elements. It's inexact because by the time we get the DOM we
-     * already have lost all the information about whitespace between attributes.
-     * <p/>
-     * Also we don't even try to deal with \n vs \r vs \r\n insanity. This only counts
-     * the \n occurring in text nodes to determine line advances, which is clearly flawed.
-     * <p/>
-     * However it's good enough for testing, and we'll replace it by a PositionXmlParser
-     * once it's moved into com.android.util.
-     */
-    private static int findLineNumbers(Node node, int line) {
-        for (; node != null; node = node.getNextSibling()) {
-            node.setUserData(DATA_LINE_NUMBER, Integer.valueOf(line), null /*handler*/);
-
-            if (node.getNodeType() == Node.TEXT_NODE) {
-                String text = node.getNodeValue();
-                if (!text.isEmpty()) {
-                    for (int pos = 0; (pos = text.indexOf('\n', pos)) != -1; pos++) {
-                        ++line;
-                    }
-                }
-            }
-
-            Node child = node.getFirstChild();
-            if (child != null) {
-                line = findLineNumbers(child, line);
-            }
-        }
-        return line;
-    }
-
-    /**
-     * Extracts the line number that {@link #findLineNumbers} added to the XML nodes.
-     *
-     * @param xmlNode Any node from a document returned by {@link #parseDocument(File, IMergerLog,
-     *                ManifestMerger)}.
-     * @return The line number if found or 0.
-     */
-    static int extractLineNumber(@Nullable Node xmlNode) {
-        if (xmlNode != null) {
-            Object data = xmlNode.getUserData(DATA_LINE_NUMBER);
-            if (data instanceof Integer) {
-                return ((Integer) data).intValue();
-            }
-        }
-
-        return 0;
-    }
-
-    /**
-     * Outputs the given XML {@link Document} to the file {@code outFile}.
-     *
-     * TODO right now reformats the document. Needs to output as-is, respecting white-space.
-     *
-     * @param doc The document to output. Must not be null.
-     * @param outFile The {@link File} where to write the document.
-     * @param log A log in case of error.
-     * @return True if the file was written, false in case of error.
-     */
-    static boolean printXmlFile(
-            @NonNull Document doc,
-            @NonNull File outFile,
-            @NonNull IMergerLog log) {
-        // Quick thing based on comments from http://stackoverflow.com/questions/139076
-        try {
-            Transformer tf = TransformerFactory.newInstance().newTransformer();
-            tf.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");         //$NON-NLS-1$
-            tf.setOutputProperty(OutputKeys.ENCODING, "UTF-8");                   //$NON-NLS-1$
-            tf.setOutputProperty(OutputKeys.INDENT, "yes");                       //$NON-NLS-1$
-            tf.setOutputProperty("{http://xml.apache.org/xslt}indent-amount",     //$NON-NLS-1$
-                    "4");                                            //$NON-NLS-1$
-            tf.transform(new DOMSource(doc), new StreamResult(outFile));
-            return true;
-        } catch (TransformerException e) {
-            log.error(Severity.ERROR,
-                    new FileAndLine(outFile.getName(), 0),
-                    "Failed to write XML file: %1$s",
-                    e.toString());
-            return false;
-        }
-    }
-
-    /**
-     * Outputs the given XML {@link Document} as a string.
-     *
-     * TODO right now reformats the document. Needs to output as-is, respecting white-space.
-     *
-     * @param doc The document to output. Must not be null.
-     * @param log A log in case of error.
-     * @return A string representation of the XML. Null in case of error.
-     */
-    static String printXmlString(
-            @NonNull Document doc,
-            @NonNull IMergerLog log) {
-        try {
-            Transformer tf = TransformerFactory.newInstance().newTransformer();
-            tf.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");        //$NON-NLS-1$
-            tf.setOutputProperty(OutputKeys.ENCODING, "UTF-8");                  //$NON-NLS-1$
-            tf.setOutputProperty(OutputKeys.INDENT, "yes");                      //$NON-NLS-1$
-            tf.setOutputProperty("{http://xml.apache.org/xslt}indent-amount",    //$NON-NLS-1$
-                    "4");                                           //$NON-NLS-1$
-            StringWriter sw = new StringWriter();
-            tf.transform(new DOMSource(doc), new StreamResult(sw));
-            return sw.toString();
-        } catch (TransformerException e) {
-            log.error(Severity.ERROR,
-                    new FileAndLine(extractXmlFilename(doc), 0),
-                    "Failed to write XML file: %1$s",
-                    e.toString());
-            return null;
-        }
-    }
-
-    /**
-     * Dumps the structure of the DOM to a simple text string.
-     *
-     * @param node The first node to dump (recursively). Can be null.
-     * @param nextSiblings If true, will also dump the following siblings.
-     *   If false, it will just process the given node.
-     * @return A string representation of the Node structure, useful for debugging.
-     */
-    @NonNull
-    static String dump(@Nullable Node node, boolean nextSiblings) {
-        return dump(node, 0 /*offset*/, nextSiblings, true /*deep*/, null /*keyAttr*/);
-    }
-
-
-    /**
-     * Dumps the structure of the DOM to a simple text string.
-     * Each line is terminated with a \n separator.
-     *
-     * @param node The first node to dump. Can be null.
-     * @param offsetIndex The offset to add at the begining of each line. Each offset is
-     *   converted into 2 space characters.
-     * @param nextSiblings If true, will also dump the following siblings.
-     *   If false, it will just process the given node.
-     * @param deep If true, this will recurse into children.
-     * @param keyAttr An optional attribute *local* name to insert when writing an element.
-     *   For example when writing an Activity, it helps to always insert "name" attribute.
-     * @return A string representation of the Node structure, useful for debugging.
-     */
-    @NonNull
-    static String dump(
-            @Nullable Node node,
-            int offsetIndex,
-            boolean nextSiblings,
-            boolean deep,
-            @Nullable String keyAttr) {
-        StringBuilder sb = new StringBuilder();
-
-        String offset = "";                 //$NON-NLS-1$
-        for (int i = 0; i < offsetIndex; i++) {
-            offset += "  ";                 //$NON-NLS-1$
-        }
-
-        if (node == null) {
-            sb.append(offset).append("(end reached)\n");
-
-        } else {
-            for (; node != null; node = node.getNextSibling()) {
-                String type = null;
-                short t = node.getNodeType();
-                switch(t) {
-                    case Node.ELEMENT_NODE:
-                        String attr = "";
-                        if (keyAttr != null) {
-                            for (Node a : sortedAttributeList(node.getAttributes())) {
-                                if (a != null && keyAttr.equals(a.getLocalName())) {
-                                    attr = String.format(" %1$s=%2$s",
-                                            a.getNodeName(), a.getNodeValue());
-                                    break;
-                                }
-                            }
-                        }
-                        sb.append(String.format("%1$s<%2$s%3$s>\n",
-                                offset, node.getNodeName(), attr));
-                        break;
-                    case Node.COMMENT_NODE:
-                        sb.append(String.format("%1$s<!-- %2$s -->\n",
-                                offset, node.getNodeValue()));
-                        break;
-                    case Node.TEXT_NODE:
-                        String txt = node.getNodeValue().trim();
-                        if (txt.isEmpty()) {
-                            // Keep this for debugging. TODO make it a flag
-                            // to dump whitespace on debugging. Otherwise ignore it.
-                            // txt = "[whitespace]";
-                            break;
-                        }
-                        sb.append(String.format("%1$s%2$s\n", offset, txt));
-                        break;
-                    case Node.ATTRIBUTE_NODE:
-                        sb.append(String.format("%1$s    @%2$s = %3$s\n",
-                                offset, node.getNodeName(), node.getNodeValue()));
-                        break;
-                    case Node.CDATA_SECTION_NODE:
-                        type = "cdata";                 //$NON-NLS-1$
-                        break;
-                    case Node.DOCUMENT_NODE:
-                        type = "document";              //$NON-NLS-1$
-                        break;
-                    case Node.PROCESSING_INSTRUCTION_NODE:
-                        type = "PI";                    //$NON-NLS-1$
-                        break;
-                    default:
-                        type = Integer.toString(t);
-                }
-
-                if (type != null) {
-                    sb.append(String.format("%1$s[%2$s] <%3$s> %4$s\n",
-                            offset, type, node.getNodeName(), node.getNodeValue()));
-                }
-
-                if (deep) {
-                    for (Attr attr : sortedAttributeList(node.getAttributes())) {
-                        sb.append(String.format("%1$s    @%2$s = %3$s\n",
-                                offset, attr.getNodeName(), attr.getNodeValue()));
-                    }
-
-                    Node child = node.getFirstChild();
-                    if (child != null) {
-                        sb.append(dump(child, offsetIndex+1, true, true, keyAttr));
-                    }
-                }
-
-                if (!nextSiblings) {
-                    break;
-                }
-            }
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Returns a sorted list of attributes.
-     * The list is never null and does not contain null items.
-     *
-     * @param attrMap A Node map as returned by {@link Node#getAttributes()}.
-     *   Can be null, in which case an empty list is returned.
-     * @return A non-null, possible empty, list of all nodes that are actual {@link Attr},
-     *   sorted by increasing attribute name.
-     */
-    @NonNull
-    static List<Attr> sortedAttributeList(@Nullable NamedNodeMap attrMap) {
-        List<Attr> list = new ArrayList<Attr>();
-
-        if (attrMap != null) {
-            for (int i = 0; i < attrMap.getLength(); i++) {
-                Node attr = attrMap.item(i);
-                if (attr instanceof Attr) {
-                    list.add((Attr) attr);
-                }
-            }
-        }
-
-        if (list.size() > 1) {
-            // Sort it by attribute name
-            Collections.sort(list, getAttrComparator());
-        }
-
-        return list;
-    }
-
-    /**
-     * Returns a comparator for {@link Attr}, alphabetically sorted by name.
-     * The "name" attribute is special and always sorted to the front.
-     */
-    @NonNull
-    static Comparator<? super Attr> getAttrComparator() {
-        return new Comparator<Attr>() {
-            @Override
-            public int compare(Attr a1, Attr a2) {
-                String s1 = a1 == null ? "" : a1.getNodeName();         //$NON-NLS-1$
-                String s2 = a2 == null ? "" : a2.getNodeName();         //$NON-NLS-1$
-
-                boolean name1 = s1.equals("name");                      //$NON-NLS-1$
-                boolean name2 = s2.equals("name");                      //$NON-NLS-1$
-
-                if (name1 && name2) {
-                    return 0;
-                } else if (name1) {
-                    return -1;  // name is always first
-                } else if (name2) {
-                    return  1;  // name is always first
-                } else {
-                    return s1.compareTo(s2);
-                }
-            }
-        };
-    }
-
-    /**
-     * Inject attributes into an existing document.
-     * <p/>
-     * The map keys are "/manifest/elements...|attribute-ns-uri attribute-local-name",
-     * for example "/manifest/uses-sdk|http://schemas.android.com/apk/res/android minSdkVersion".
-     * (note the space separator between the attribute URI and its local name.)
-     * The elements will be created if they don't exists. Existing attributes will be modified.
-     * The replacement is done on the main document <em>before</em> merging.
-     * The value can be null to remove an existing attribute.
-     *
-     * @param doc The document to modify in-place.
-     * @param attributeMap A map of attributes to inject in the form [pseudo-xpath] => value.
-     * @param log A log in case of error.
-     */
-    static void injectAttributes(
-            @Nullable Document doc,
-            @Nullable Map<String, String> attributeMap,
-            @NonNull IMergerLog log) {
-        if (doc == null || attributeMap == null || attributeMap.isEmpty()) {
-            return;
-        }
-
-        //                                        1=path  2=URI    3=local name
-        final Pattern keyRx = Pattern.compile("^/([^\\|]+)\\|([^ ]*) +(.+)$");      //$NON-NLS-1$
-        final FileAndLine docInfo = xmlFileAndLine(doc);
-
-        nextAttribute: for (Entry<String, String> entry : attributeMap.entrySet()) {
-            String key = entry.getKey();
-            String value = entry.getValue();
-            if (key == null || key.isEmpty()) {
-                continue;
-            }
-
-            Matcher m = keyRx.matcher(key);
-            if (!m.matches()) {
-                log.error(Severity.WARNING, docInfo, "Invalid injected attribute key: %s", key);
-                continue;
-            }
-            String path = m.group(1);
-            String attrNsUri = m.group(2);
-            String attrName  = m.group(3);
-
-            String[] segment = path.split(Pattern.quote("/"));                      //$NON-NLS-1$
-
-            // Get the path elements. Create them as needed if they don't exist.
-            Node element = doc;
-            nextSegment: for (int i = 0; i < segment.length; i++) {
-                // Find a child with the segment's name
-                String name = segment[i];
-                for (Node child = element.getFirstChild();
-                     child != null;
-                     child = child.getNextSibling()) {
-                    if (child.getNodeType() == Node.ELEMENT_NODE &&
-                            child.getNamespaceURI() == null &&
-                            child.getNodeName().equals(name)) {
-                        // Found it. Continue to the next inner segment.
-                        element = child;
-                        continue nextSegment;
-                    }
-                }
-                // No such element. Create it.
-                if (value == null) {
-                    // If value is null, we want to remove, not create and if can't find the
-                    // element, then we're done: there's no such attribute to remove.
-                    break nextAttribute;
-                }
-
-                Element child = doc.createElement(name);
-                element = element.insertBefore(child, element.getFirstChild());
-            }
-
-            if (element == null) {
-                log.error(Severity.WARNING, docInfo, "Invalid injected attribute path: %s", path);
-                return;
-            }
-
-            NamedNodeMap attrs = element.getAttributes();
-            if (attrs != null) {
-
-
-                if (attrNsUri != null && attrNsUri.isEmpty()) {
-                    attrNsUri = null;
-                }
-                Node attr = attrs.getNamedItemNS(attrNsUri, attrName);
-
-                if (value == null) {
-                    // We want to remove the attribute from the attribute map.
-                    if (attr != null) {
-                        attrs.removeNamedItemNS(attrNsUri, attrName);
-                    }
-
-                } else {
-                    // We want to add or replace the attribute.
-                    if (attr == null) {
-                        attr = doc.createAttributeNS(attrNsUri, attrName);
-                        if (attrNsUri != null) {
-                            attr.setPrefix(XmlUtils.lookupNamespacePrefix(element, attrNsUri));
-                        }
-                        attrs.setNamedItemNS(attr);
-                    }
-                    attr.setNodeValue(value);
-                }
-            }
-        }
-    }
-
-    // -------
-
-    /**
-     * Flatten the element to a string. This "pretty prints" the XML tree starting
-     * from the given node and all its children and attributes.
-     * <p/>
-     * The output is designed to be printed using {@link #printXmlDiff}.
-     *
-     * @param node The root node to print.
-     * @param nsPrefix A map that is filled with all the URI=>prefix found.
-     *   The internal string only contains the expanded URIs but this is rather verbose
-     *   so when printing the diff these will be replaced by the prefixes collected here.
-     * @param prefix A "space" prefix added at the beginning of each line for indentation
-     *   purposes. The diff printer later relies on this to find out the structure.
-     */
-    @NonNull
-    static String printElement(
-            @NonNull Node node,
-            @NonNull Map<String, String> nsPrefix,
-            @NonNull String prefix) {
-        StringBuilder sb = new StringBuilder();
-        sb.append(prefix).append('<');
-        String uri = node.getNamespaceURI();
-        if (uri != null) {
-            sb.append(uri).append(':');
-            nsPrefix.put(uri, node.getPrefix());
-        }
-        sb.append(node.getLocalName());
-        printAttributes(sb, node, nsPrefix, prefix);
-        sb.append(">\n");                                                           //$NON-NLS-1$
-        printChildren(sb, node.getFirstChild(), true, nsPrefix, prefix + "    ");   //$NON-NLS-1$
-
-        sb.append(prefix).append("</");                                             //$NON-NLS-1$
-        if (uri != null) {
-            sb.append(uri).append(':');
-        }
-        sb.append(node.getLocalName());
-        sb.append(">\n");                                                           //$NON-NLS-1$
-
-        return sb.toString();
-    }
-
-    /**
-     * Flatten several children elements to a string.
-     * This is an implementation detail for {@link #printElement(Node, Map, String)}.
-     * <p/>
-     * If {@code nextSiblings} is false, the string conversion takes only the given
-     * child element and stops there.
-     * <p/>
-     * If {@code nextSiblings} is true, the string conversion also takes _all_ the siblings
-     * after the given element. The idea is the caller can call this with the first child
-     * of a parent and get a string showing all the children at the same time. They are
-     * sorted to avoid the ordering issue.
-     */
-    @NonNull
-    private static StringBuilder printChildren(
-            @NonNull StringBuilder sb,
-            @NonNull Node child,
-            boolean nextSiblings,
-            @NonNull Map<String, String> nsPrefix,
-            @NonNull String prefix) {
-        ArrayList<String> children = new ArrayList<String>();
-
-        boolean hasText = false;
-        for (; child != null; child = child.getNextSibling()) {
-            short t = child.getNodeType();
-            if (nextSiblings && t == Node.TEXT_NODE) {
-                // We don't typically have meaningful text nodes in an Android manifest.
-                // If there are, just dump them as-is into the element representation.
-                // We do trim whitespace and ignore all-whitespace or empty text nodes.
-                String s = child.getNodeValue().trim();
-                if (!s.isEmpty()) {
-                    sb.append(s);
-                    hasText = true;
-                }
-            } else if (t == Node.ELEMENT_NODE) {
-                children.add(printElement(child, nsPrefix, prefix));
-                if (!nextSiblings) {
-                    break;
-                }
-            }
-        }
-
-        if (hasText) {
-            sb.append('\n');
-        }
-
-        if (!children.isEmpty()) {
-            Collections.sort(children);
-            for (String s : children) {
-                sb.append(s);
-            }
-        }
-
-        return sb;
-    }
-
-    /**
-     * Flatten several attributes to a string using their alphabetical order.
-     * This is an implementation detail for {@link #printElement(Node, Map, String)}.
-     */
-    @NonNull
-    private static StringBuilder printAttributes(
-            @NonNull StringBuilder sb,
-            @NonNull Node node,
-            @NonNull Map<String, String> nsPrefix,
-            @NonNull String prefix) {
-        ArrayList<String> attrs = new ArrayList<String>();
-
-        NamedNodeMap attrMap = node.getAttributes();
-        if (attrMap != null) {
-            StringBuilder sb2 = new StringBuilder();
-            for (int i = 0; i < attrMap.getLength(); i++) {
-                Node attr = attrMap.item(i);
-                if (attr instanceof Attr) {
-                    sb2.setLength(0);
-                    sb2.append('@');
-                    String uri = attr.getNamespaceURI();
-                    if (uri != null) {
-                        sb2.append(uri).append(':');
-                        nsPrefix.put(uri, attr.getPrefix());
-                    }
-                    sb2.append(attr.getLocalName());
-                    sb2.append("=\"").append(attr.getNodeValue()).append('\"');     //$NON-NLS-1$
-                    attrs.add(sb2.toString());
-                }
-            }
-        }
-
-        Collections.sort(attrs);
-
-        for(String attr : attrs) {
-            sb.append('\n');
-            sb.append(prefix).append("    ").append(attr);                          //$NON-NLS-1$
-        }
-        return sb;
-    }
-
-    //------------
-
-    /**
-     * Computes a quick diff between two strings generated by
-     * {@link #printElement(Node, Map, String)}.
-     * <p/>
-     * This is a <em>not</em> designed to be a full contextual diff.
-     * It just stops at the first difference found, printing up to 3 lines of diff
-     * and backtracking to add prior contextual information to understand the
-     * structure of the element where the first diff line occurred (by printing
-     * each parent found till the root one as well as printing the attribute
-     * named by {@code keyAttr}).
-     *
-     * @param sb The string builder where to output is written.
-     * @param expected The expected XML tree (as generated by {@link #printElement}.)
-     *          For best result this would be the "destination" XML we're merging into,
-     *          e.g. the main manifest.
-     * @param actual   The actual XML tree (as generated by {@link #printElement}.)
-     *          For best result this would be the "source" XML we're merging from,
-     *          e.g. a library manifest.
-     * @param nsPrefixE The map of URI=>prefix for the expected XML tree.
-     * @param nsPrefixA The map of URI=>prefix for the actual XML tree.
-     * @param keyAttr An optional attribute *full* name (uri:local name) to always
-     *          insert when writing the contextual lines before a diff line.
-     *          For example when writing an Activity, it helps to always insert
-     *          the "name" attribute since that's the key element to help the user
-     *          identify which node is being dumped.
-     */
-    static void printXmlDiff(
-            StringBuilder sb,
-            String expected,
-            String actual,
-            Map<String, String> nsPrefixE,
-            Map<String, String> nsPrefixA,
-            String keyAttr) {
-        String[] aE = expected.split("\n");
-        String[] aA = actual.split("\n");
-        int lE = aE.length;
-        int lA = aA.length;
-        int lm = lE < lA ? lA : lE;
-        boolean eofE = false;
-        boolean eofA = false;
-        boolean contextE = true;
-        boolean contextA = true;
-        int numDiff = 0;
-
-        StringBuilder sE = new StringBuilder();
-        StringBuilder sA = new StringBuilder();
-
-        outerLoop: for (int i = 0, iE = 0, iA = 0; i < lm; i++) {
-            if (iE < lE && iA < lA && aE[iE].equals(aA[iA])) {
-                if (numDiff > 0) {
-                    // If we found a difference, stop now.
-                    break outerLoop;
-                }
-                iE++;
-                iA++;
-                continue;
-            } else {
-                // Try to print some context for each side based on previous lines's space prefix.
-                if (contextE) {
-                    if (iE > 0) {
-                        String p = diffGetPrefix(aE[iE]);
-                        for (int kE = iE-1; kE >= 0; kE--) {
-                            if (!aE[kE].startsWith(p)) {
-                                sE.insert(0, '\n').insert(0, diffReplaceNs(aE[kE], nsPrefixE)).insert(0, "  ");
-                                if (p.isEmpty()) {
-                                    break;
-                                }
-                                p = diffGetPrefix(aE[kE]);
-                            } else if (aE[kE].contains(keyAttr) || kE == 0) {
-                                sE.insert(0, '\n').insert(0, diffReplaceNs(aE[kE], nsPrefixE)).insert(0, "  ");
-                            }
-                        }
-                    }
-                    contextE = false;
-                }
-                if (iE >= lE) {
-                    if (!eofE) {
-                        sE.append("--(end reached)\n");
-                        eofE = true;
-                    }
-                } else {
-                    sE.append("--").append(diffReplaceNs(aE[iE++], nsPrefixE)).append('\n');
-                }
-
-                if (contextA) {
-                    if (iA > 0) {
-                        String p = diffGetPrefix(aA[iA]);
-                        for (int kA = iA-1; kA >= 0; kA--) {
-                            if (!aA[kA].startsWith(p)) {
-                                sA.insert(0, '\n').insert(0, diffReplaceNs(aA[kA], nsPrefixA)).insert(0, "  ");
-                                p = diffGetPrefix(aA[kA]);
-                                if (p.isEmpty()) {
-                                    break;
-                                }
-                            } else if (aA[kA].contains(keyAttr) || kA == 0) {
-                                sA.insert(0, '\n').insert(0, diffReplaceNs(aA[kA], nsPrefixA)).insert(0, "  ");
-                            }
-                        }
-                    }
-                    contextA = false;
-                }
-                if (iA >= lA) {
-                    if (!eofA) {
-                        sA.append("++(end reached)\n");
-                        eofA = true;
-                    }
-                } else {
-                    sA.append("++").append(diffReplaceNs(aA[iA++], nsPrefixA)).append('\n');
-                }
-
-                // Dump up to 3 lines of difference
-                numDiff++;
-                if (numDiff == 3) {
-                    break outerLoop;
-                }
-            }
-        }
-
-        sb.append(sE);
-        sb.append(sA);
-    }
-
-    /**
-     * Returns all the whitespace at the beginning of a string.
-     * Implementation details for {@link #printXmlDiff} used to find the "parent"
-     * element and include it in the context of the diff.
-     */
-    private static String diffGetPrefix(String str) {
-        int pos = 0;
-        int len = str.length();
-        while (pos < len && str.charAt(pos) == ' ') {
-            pos++;
-        }
-        return str.substring(0, pos);
-    }
-
-    /**
-     * Simplifies a diff line by replacing NS URIs by their prefix.
-     * Implementation details for {@link #printXmlDiff}.
-     */
-    private static String diffReplaceNs(String str, Map<String, String> nsPrefix) {
-        for (Entry<String, String> entry : nsPrefix.entrySet()) {
-            String uri = entry.getKey();
-            String prefix = entry.getValue();
-            if (prefix != null && str.contains(uri)) {
-                str = str.replaceAll(Pattern.quote(uri), Matcher.quoteReplacement(prefix));
-            }
-        }
-        return str;
-    }
-
-    /**
-     * Returns the file associated with the given specific node, if any.
-     * Note that this will not search upwards for parent nodes; it returns a
-     * file associated with this specific node, if any.
-     */
-    @Nullable
-    public static File getFileFor(@NonNull Node node) {
-        return (File) node.getUserData(DATA_ORIGIN_FILE);
-    }
-
-    /**
-     * Sets the file associated with the given node, if any
-     */
-    public static void setFileFor(Node node, File file) {
-        node.setUserData(MergerXmlUtils.DATA_ORIGIN_FILE, file, null);
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/MergingReport.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/MergingReport.java b/Build/src/main/java/com/tyron/build/compiler/manifest/MergingReport.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/MergingReport.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,295 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.VisibleForTesting;
-
-import com.google.common.base.CaseFormat;
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-import com.tyron.build.log.ILogger;
-
-import com.google.errorprone.annotations.Immutable;
-
-/**
- * Contains the result of 2 files merging.
- *
- * TODO: more work necessary, this is pretty raw as it stands.
- */
-@Immutable
-public class MergingReport {
-
-    private final Optional<XmlDocument> mMergedDocument;
-    private final Result mResult;
-    // list of logging events, ordered by their recording time.
-    private final ImmutableList<Record> mRecords;
-    private final ImmutableList<String> mIntermediaryStages;
-    private final Actions mActions;
-
-    private MergingReport(Optional<XmlDocument> mergedDocument,
-                          @NonNull Result result,
-                          @NonNull ImmutableList<Record> records,
-                          @NonNull ImmutableList<String> intermediaryStages,
-                          @NonNull Actions actions) {
-        mMergedDocument = mergedDocument;
-        mResult = result;
-        mRecords = records;
-        mIntermediaryStages = intermediaryStages;
-        mActions = actions;
-    }
-
-    /**
-     * dumps all logging records to a logger.
-     */
-    public void log(ILogger logger) {
-        for (Record record : mRecords) {
-            switch(record.mSeverity) {
-                case WARNING:
-                    logger.warning(record.toString());
-                    break;
-                case ERROR:
-                    logger.error(record.toString());
-                    break;
-                case INFO:
-                    logger.verbose(record.toString());
-                    break;
-                default:
-                    logger.error("Unhandled record type " + record.mSeverity);
-            }
-        }
-        mActions.log(logger);
-
-        if (!mResult.isSuccess()) {
-            logger.warning("\nSee http://g.co/androidstudio/manifest-merger for more information"
-                    + " about the manifest merger.\n");
-        }
-    }
-
-    /**
-     * Return the resulting merged document.
-     */
-    public Optional<XmlDocument> getMergedDocument() {
-        return mMergedDocument;
-    }
-
-    /**
-     * Returns all the merging intermediary stages if
-     * {@link ManifestMerger2.Invoker.Feature#KEEP_INTERMEDIARY_STAGES}
-     * is set.
-     */
-    public ImmutableList<String> getIntermediaryStages() {
-        return mIntermediaryStages;
-    }
-
-    /**
-     * Overall result of the merging process.
-     */
-    public enum Result {
-        SUCCESS,
-
-        WARNING,
-
-        ERROR;
-
-        public boolean isSuccess() {
-            return this == SUCCESS || this == WARNING;
-        }
-
-        public boolean isWarning() {
-            return this == WARNING;
-        }
-
-        public boolean isError() {
-            return this == ERROR;
-        }
-    }
-
-    @NonNull
-    public Result getResult() {
-        return mResult;
-    }
-
-    @NonNull
-    public ImmutableList<Record> getLoggingRecords() {
-        return mRecords;
-    }
-
-    @NonNull
-    public Actions getActions() {
-        return mActions;
-    }
-
-    @NonNull
-    public String getReportString() {
-        switch (mResult) {
-            case SUCCESS:
-                return "Manifest merger executed successfully";
-            case WARNING:
-                return mRecords.size() > 1
-                        ? "Manifest merger exited with warnings, see logs"
-                        : "Manifest merger warning : " + mRecords.get(0).mLog;
-            case ERROR:
-                return mRecords.size() > 1
-                        ? "Manifest merger failed with multiple errors, see logs"
-                        : "Manifest merger failed : " + mRecords.get(0).mLog;
-            default:
-                return "Manifest merger returned an invalid result " + mResult;
-        }
-    }
-
-    /**
-     * Log record. This is used to give users some information about what is happening and
-     * what might have gone wrong.
-     */
-    public static class Record {
-
-
-        public enum Severity {WARNING, ERROR, INFO }
-
-        private final Severity mSeverity;
-        private final String mLog;
-        private final SourceFilePosition mSourceLocation;
-
-        private Record(
-                @NonNull SourceFilePosition sourceLocation,
-                @NonNull Severity severity,
-                @NonNull String mLog) {
-            this.mSourceLocation = sourceLocation;
-            this.mSeverity = severity;
-            this.mLog = mLog;
-        }
-
-        public Severity getSeverity() {
-            return mSeverity;
-        }
-
-        public String getMessage() {
-            return mLog;
-        }
-
-        @Override
-        public String toString() {
-            return mSourceLocation.toString() // needs short string.
-                    + " "
-                    + CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, mSeverity.toString())
-                    + ":\n\t"
-                    + mLog;
-        }
-    }
-
-    /**
-     * This builder is used to accumulate logging, action recording and intermediary results as
-     * well as final result of the merging activity.
-     *
-     * Once the merging is finished, the {@link #build()} is called to return an immutable version
-     * of itself with all the logging, action recordings and xml files obtainable.
-     *
-     */
-    static class Builder {
-
-        private Optional<XmlDocument> mMergedDocument = Optional.absent();
-        private ImmutableList.Builder<Record> mRecordBuilder = new ImmutableList.Builder<Record>();
-        private ImmutableList.Builder<String> mIntermediaryStages = new ImmutableList.Builder<String>();
-        private boolean mHasWarnings = false;
-        private boolean mHasErrors = false;
-        private ActionRecorder mActionRecorder = new ActionRecorder();
-        private final ILogger mLogger;
-
-        Builder(ILogger logger) {
-            mLogger = logger;
-        }
-
-
-        Builder setMergedDocument(@NonNull XmlDocument mergedDocument) {
-            mMergedDocument = Optional.of(mergedDocument);
-            return this;
-        }
-
-        @VisibleForTesting
-        Builder addMessage(@NonNull SourceFile sourceFile,
-                           int line,
-                           int column,
-                           @NonNull Record.Severity severity,
-                           @NonNull String message) {
-            // The line and column used are 1-based, but SourcePosition uses zero-based.
-            return addMessage(
-                    new SourceFilePosition(sourceFile, new SourcePosition(line - 1, column -1, -1)),
-                    severity,
-                    message);
-        }
-
-        Builder addMessage(@NonNull SourceFile sourceFile,
-                           @NonNull Record.Severity severity,
-                           @NonNull String message) {
-            return addMessage(
-                    new SourceFilePosition(sourceFile, SourcePosition.UNKNOWN),
-                    severity,
-                    message);
-        }
-
-        Builder addMessage(@NonNull SourceFilePosition sourceFilePosition,
-                           @NonNull Record.Severity severity,
-                           @NonNull String message) {
-            switch (severity) {
-                case ERROR:
-                    mHasErrors = true;
-                    break;
-                case WARNING:
-                    mHasWarnings = true;
-                    break;
-            }
-            mRecordBuilder.add(new Record(sourceFilePosition,  severity, message));
-            return this;
-        }
-
-        Builder addMergingStage(String xml) {
-            mIntermediaryStages.add(xml);
-            return this;
-        }
-
-        /**
-         * Returns true if some fatal errors were reported.
-         */
-        boolean hasErrors() {
-            return mHasErrors;
-        }
-
-        ActionRecorder getActionRecorder() {
-            return mActionRecorder;
-        }
-
-        MergingReport build() {
-            Result result = mHasErrors
-                    ? Result.ERROR
-                    : mHasWarnings
-                    ? Result.WARNING
-                    : Result.SUCCESS;
-
-            return new MergingReport(
-                    mMergedDocument,
-                    result,
-                    mRecordBuilder.build(),
-                    mIntermediaryStages.build(),
-                    mActionRecorder.build());
-        }
-
-        public ILogger getLogger() {
-            return mLogger;
-        }
-
-        public Builder addMessage(XmlElement xmlElement, Record.Severity warning, String format) {
-            switch (warning) {
-                case ERROR:
-                    mHasErrors = true;
-                    break;
-                case WARNING:
-                    mHasWarnings = true;
-                    break;
-            }
-            mRecordBuilder.add(new Record(xmlElement.getSourceFilePosition(),  warning, format));
-            return this;
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/PostValidator.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/PostValidator.java b/Build/src/main/java/com/tyron/build/compiler/manifest/PostValidator.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/PostValidator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,455 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.Actions.ActionType;
-
-import androidx.annotation.NonNull;
-
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
-import com.tyron.build.util.XmlUtils;
-
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-/**
- * Validator that runs post merging activities and verifies that all "tools:" instructions
- * triggered an action by the merging tool.
- * <p>
- *
- * This is primarily to catch situations like a user entered a tools:remove="foo" directory on one
- * of its elements and that particular attribute was never removed during the merges possibly
- * indicating an unforeseen change of configuration.
- * <p>
- *
- * Most of the output from this validation should be warnings.
- */
-public class PostValidator {
-
-    /**
-     * Post validation of the merged document. This will essentially check that all merging
-     * instructions were applied at least once.
-     *
-     * @param xmlDocument merged document to check.
-     * @param mergingReport report for errors and warnings.
-     */
-    public static void validate(
-            @NonNull XmlDocument xmlDocument,
-            @NonNull MergingReport.Builder mergingReport) {
-
-        Preconditions.checkNotNull(xmlDocument);
-        Preconditions.checkNotNull(mergingReport);
-        enforceAndroidNamespaceDeclaration(xmlDocument);
-        reOrderElements(xmlDocument.getRootNode());
-        validate(
-                xmlDocument.getRootNode(),
-                mergingReport.getActionRecorder().build(),
-                mergingReport);
-        checkOnlyOneUsesSdk(xmlDocument, mergingReport);
-    }
-
-    /**
-     * Enforces {@link SdkConstants#ANDROID_URI} declaration in the top level element. It is
-     * possible that the original manifest file did not contain any attribute declaration, therefore
-     * not requiring a xmlns: declaration. Yet the implicit elements handling may have added
-     * attributes requiring the namespace declaration.
-     */
-    private static void enforceAndroidNamespaceDeclaration(@NonNull XmlDocument xmlDocument) {
-        final Element rootElement = xmlDocument.getRootNode().getXml();
-        XmlUtils.lookupNamespacePrefix(
-                rootElement, SdkConstants.ANDROID_URI, SdkConstants.ANDROID_NS_NAME, true);
-    }
-
-    /**
-     * Enforces {@link SdkConstants#TOOLS_URI} declaration in the top level element, if necessary.
-     * It is possible that the original manifest file did not contain any attribute declaration,
-     * therefore not requiring a xmlns: declaration. Yet the implicit elements handling may have
-     * added attributes requiring the namespace declaration.
-     */
-    protected static void enforceToolsNamespaceDeclaration(@NonNull XmlDocument xmlDocument) {
-        final Element rootElement = xmlDocument.getRootNode().getXml();
-        if (SdkConstants.TOOLS_PREFIX.equals(
-                XmlUtils.lookupNamespacePrefix(rootElement, SdkConstants.TOOLS_URI, null, false))) {
-            return;
-        }
-        // if we are here, we did not find the namespace declaration, so we add it if
-        // tools namespace is used anywhere in the xml document
-        if (elementUsesNamespacePrefix(rootElement, SdkConstants.TOOLS_NS_NAME)) {
-            XmlUtils.lookupNamespacePrefix(
-                    rootElement, SdkConstants.TOOLS_URI, SdkConstants.TOOLS_NS_NAME, true);
-        }
-    }
-
-    /**
-     * Check whether element or any of its descendants have an attribute with the given namespace
-     *
-     * @param element the element under consideration
-     * @param prefix the namespace prefix under consideration
-     * @return true if element or any of its descendants have an attribute with the given namespace,
-     *     false otherwise.
-     */
-    @VisibleForTesting
-    static boolean elementUsesNamespacePrefix(@NonNull Element element, @NonNull String prefix) {
-        NamedNodeMap namedNodeMap = element.getAttributes();
-        for (int i = 0; i < namedNodeMap.getLength(); i++) {
-            Node attribute = namedNodeMap.item(i);
-            if (prefix.equals(attribute.getPrefix())) {
-                return true;
-            }
-        }
-        NodeList childNodes = element.getChildNodes();
-        for (int i = 0; i < childNodes.getLength(); i++) {
-            Node childNode = childNodes.item(i);
-            if (childNode instanceof Element) {
-                if (elementUsesNamespacePrefix((Element) childNode, prefix)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-
-    /**
-     * Reorder child elements :
-     * <ul>
-     *     <li>&lt;activity-alias&gt; elements within &lt;application&gt; are moved after the
-     *     &lt;activity&gt; they target.</li>
-     *     <li>&lt;application&gt; is moved last in the list of children
-     *     of the <manifest> element.</li>
-     *     <li>uses-sdk is moved first in the list of children of the &lt;manifest&gt; element</li>
-     * </ul>
-     * @param xmlElement the root element of the manifest document.
-     */
-    private static void reOrderElements(@NonNull XmlElement xmlElement) {
-
-        reOrderActivityAlias(xmlElement);
-        reOrderApplication(xmlElement);
-        reOrderUsesSdk(xmlElement);
-    }
-
-    /**
-     * Reorder activity-alias elements to after the activity they reference
-     *
-     * @param xmlElement the root element of the manifest document.
-     */
-    private static void reOrderActivityAlias(@NonNull XmlElement xmlElement) {
-
-        // look up application element.
-        Optional<XmlElement> element = xmlElement
-                .getNodeByTypeAndKey(ManifestModel.NodeTypes.APPLICATION, null);
-        if (!element.isPresent()) {
-            return;
-        }
-        XmlElement applicationElement = element.get();
-
-        List<XmlElement> activityAliasElements = applicationElement
-                .getAllNodesByType(ManifestModel.NodeTypes.ACTIVITY_ALIAS);
-        for (XmlElement activityAlias : activityAliasElements) {
-            // get targetActivity attribute
-            Optional<XmlAttribute> attribute = activityAlias.getAttribute(
-                    XmlNode.fromNSName(SdkConstants.ANDROID_URI, "android", "targetActivity"));
-            if (!attribute.isPresent()) {
-                continue;
-            }
-            String targetActivity = attribute.get().getValue();
-
-            // look up target activity element
-            element = applicationElement
-                    .getNodeByTypeAndKey(ManifestModel.NodeTypes.ACTIVITY, targetActivity);
-            if (!element.isPresent()) {
-                continue;
-            }
-            XmlElement activity = element.get();
-
-            // move the activity-alias to after the activity
-            Node nextSibling = activity.getXml().getNextSibling();
-
-            // move the activity-alias's comments if any.
-            List<Node> comments = XmlElement.getLeadingComments(activityAlias.getXml());
-
-            if (!comments.isEmpty() && !comments.get(0).equals(nextSibling)) {
-                for (Node comment : comments) {
-                    applicationElement.getXml().removeChild(comment);
-                    applicationElement.getXml().insertBefore(comment, nextSibling);
-                }
-            }
-
-            // move the activity-alias element if neither it or its comments immediately follow the
-            // target activity.
-            if (!activityAlias.getXml().equals(nextSibling)
-                    && !(!comments.isEmpty() && comments.get(0).equals(nextSibling))) {
-                applicationElement.getXml().removeChild(activityAlias.getXml());
-                applicationElement.getXml().insertBefore(activityAlias.getXml(), nextSibling);
-            }
-        }
-    }
-
-    /**
-     * Reorder application element
-     *
-     * @param xmlElement the root element of the manifest document.
-     */
-    private static void reOrderApplication(@NonNull XmlElement xmlElement) {
-
-        // look up application element.
-        Optional<XmlElement> element = xmlElement
-                .getNodeByTypeAndKey(ManifestModel.NodeTypes.APPLICATION, null);
-        if (!element.isPresent()) {
-            return;
-        }
-        XmlElement applicationElement = element.get();
-
-        List<Node> comments = XmlElement.getLeadingComments(applicationElement.getXml());
-
-        // move the application's comments if any.
-        for (Node comment : comments) {
-            xmlElement.getXml().removeChild(comment);
-            xmlElement.getXml().appendChild(comment);
-        }
-        // remove the application element and add it back, it will be automatically placed last.
-        xmlElement.getXml().removeChild(applicationElement.getXml());
-        xmlElement.getXml().appendChild(applicationElement.getXml());
-    }
-
-    /**
-     * Reorder uses-sdk element
-     *
-     * @param xmlElement the root element of the manifest document.
-     */
-    private static void reOrderUsesSdk(@NonNull XmlElement xmlElement) {
-
-        // look up uses-sdk element.
-        Optional<XmlElement> element = xmlElement
-                .getNodeByTypeAndKey(ManifestModel.NodeTypes.USES_SDK, null);
-        if (!element.isPresent()) {
-            return;
-        }
-
-        XmlElement usesSdk = element.get();
-        Node firstChild = xmlElement.getXml().getFirstChild();
-        // already the first element ?
-        if (firstChild == usesSdk.getXml()) {
-            return;
-        }
-
-        List<Node> comments = XmlElement.getLeadingComments(usesSdk.getXml());
-
-        // move the application's comments if any.
-        for (Node comment : comments) {
-            xmlElement.getXml().removeChild(comment);
-            xmlElement.getXml().insertBefore(comment, firstChild);
-        }
-        // remove the application element and add it back, it will be automatically placed last.
-        xmlElement.getXml().removeChild(usesSdk.getXml());
-        xmlElement.getXml().insertBefore(usesSdk.getXml(), firstChild);
-    }
-
-    /**
-     * Validate an xml element and recursively its children elements, ensuring that all merging
-     * instructions were applied.
-     *
-     * @param xmlElement xml element to validate.
-     * @param actions the actions recorded during the merging activities.
-     * @param mergingReport report for errors and warnings.
-     * instructions were applied once or {@link MergingReport.Result#WARNING} otherwise.
-     */
-    private static void validate(
-            @NonNull XmlElement xmlElement,
-            @NonNull Actions actions,
-            @NonNull MergingReport.Builder mergingReport) {
-
-        NodeOperationType operationType = xmlElement.getOperationType();
-        boolean ignoreWarning = checkIgnoreWarning(xmlElement);
-        switch (operationType) {
-            case REPLACE:
-                // we should find at least one rejected twin.
-                if (!ignoreWarning
-                        && !isNodeOperationPresent(xmlElement, actions, ActionType.REJECTED)) {
-                    mergingReport.addMessage(
-                            xmlElement,
-                            MergingReport.Record.Severity.WARNING,
-                            String.format(
-                                    "%1$s was tagged at %2$s:%3$d to replace another declaration "
-                                            + "but no other declaration present",
-                                    xmlElement.getId(),
-                                    xmlElement.getDocument().getSourceFile().print(true),
-                                    xmlElement.getPosition().getStartLine() + 1));
-                }
-                break;
-            case REMOVE:
-            case REMOVE_ALL:
-                // we should find at least one rejected twin.
-                if (!ignoreWarning
-                        && !isNodeOperationPresent(xmlElement, actions, ActionType.REJECTED)) {
-                    mergingReport.addMessage(
-                            xmlElement,
-                            MergingReport.Record.Severity.WARNING,
-                            String.format(
-                                    "%1$s was tagged at %2$s:%3$d to remove other declarations "
-                                            + "but no other declaration present",
-                                    xmlElement.getId(),
-                                    xmlElement.getDocument().getSourceFile().print(true),
-                                    xmlElement.getPosition().getStartLine() + 1));
-                }
-                break;
-        }
-        validateAttributes(xmlElement, actions, mergingReport, ignoreWarning);
-        validateAndroidAttributes(xmlElement, mergingReport);
-        for (XmlElement child : xmlElement.getMergeableElements()) {
-            validate(child, actions, mergingReport);
-        }
-    }
-
-    /** Verifies that all merging attributes on a passed xml element were applied. */
-    private static void validateAttributes(
-            @NonNull XmlElement xmlElement,
-            @NonNull Actions actions,
-            @NonNull MergingReport.Builder mergingReport,
-            boolean ignoreWarning) {
-
-        @NonNull Collection<Map.Entry<XmlNode.NodeName, AttributeOperationType>> attributeOperations
-                = xmlElement.getAttributeOperations();
-        for (Map.Entry<XmlNode.NodeName, AttributeOperationType> attributeOperation :
-                attributeOperations) {
-            switch (attributeOperation.getValue()) {
-                case REMOVE:
-                    if (!ignoreWarning
-                            && !isAttributeOperationPresent(
-                            xmlElement, attributeOperation, actions, ActionType.REJECTED)) {
-                        mergingReport.addMessage(
-                                xmlElement,
-                                MergingReport.Record.Severity.WARNING,
-                                String.format(
-                                        "%1$s@%2$s was tagged at %3$s:%4$d to remove other"
-                                                + " declarations but no other declaration present",
-                                        xmlElement.getId(),
-                                        attributeOperation.getKey(),
-                                        xmlElement.getDocument().getSourceFile().print(true),
-                                        xmlElement.getPosition().getStartLine() + 1));
-                    }
-                    break;
-                case REPLACE:
-                    if (!ignoreWarning
-                            && !isAttributeOperationPresent(
-                            xmlElement, attributeOperation, actions, ActionType.REJECTED)) {
-                        mergingReport.addMessage(
-                                xmlElement,
-                                MergingReport.Record.Severity.WARNING,
-                                String.format(
-                                        "%1$s@%2$s was tagged at %3$s:%4$d to replace other"
-                                                + " declarations but no other declaration present",
-                                        xmlElement.getId(),
-                                        attributeOperation.getKey(),
-                                        xmlElement.getDocument().getSourceFile().print(true),
-                                        xmlElement.getPosition().getStartLine() + 1));
-                    }
-                    break;
-            }
-        }
-
-    }
-
-    /**
-     * Check in our list of applied actions that a particular {@link ActionType} action was recorded
-     * on the passed element.
-     *
-     * @return true if it was applied, false otherwise.
-     */
-    private static boolean isNodeOperationPresent(
-            @NonNull XmlElement xmlElement, @NonNull Actions actions, ActionType action) {
-
-        for (Actions.NodeRecord nodeRecord : actions.getNodeRecords(xmlElement.getId())) {
-            if (nodeRecord.getActionType() == action) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check in our list of attribute actions that a particular {@link ActionType} action was
-     * recorded on the passed element.
-     *
-     * @return true if it was applied, false otherwise.
-     */
-    private static boolean isAttributeOperationPresent(
-            @NonNull XmlElement xmlElement,
-            @NonNull Map.Entry<XmlNode.NodeName, AttributeOperationType> attributeOperation,
-            @NonNull Actions actions,
-            ActionType action) {
-
-        for (Actions.AttributeRecord attributeRecord : actions.getAttributeRecords(
-                xmlElement.getId(), attributeOperation.getKey())) {
-            if (attributeRecord.getActionType() == action) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Validates all {@link XmlElement} attributes belonging to the {@link SdkConstants#ANDROID_URI}
-     * namespace.
-     *
-     * @param xmlElement xml element to check the attributes from.
-     * @param mergingReport report for errors and warnings.
-     */
-    private static void validateAndroidAttributes(
-            @NonNull XmlElement xmlElement, @NonNull MergingReport.Builder mergingReport) {
-
-        for (XmlAttribute xmlAttribute : xmlElement.getAttributes()) {
-            if (xmlAttribute.getModel() != null) {
-                AttributeModel.Validator onWriteValidator = xmlAttribute.getModel()
-                        .getOnWriteValidator();
-                if (onWriteValidator != null) {
-                    onWriteValidator.validates(
-                            mergingReport, xmlAttribute, xmlAttribute.getValue());
-                }
-            }
-        }
-    }
-    /**
-     * check if the tools:ignore_warning is set
-     *
-     * @param xmlElement the current XmlElement
-     * @return whether the ignoreWarning flag is set
-     */
-    @VisibleForTesting
-    static boolean checkIgnoreWarning(@NonNull XmlElement xmlElement) {
-        @NonNull
-        Collection<Map.Entry<XmlNode.NodeName, AttributeOperationType>> attributeOperations =
-                xmlElement.getAttributeOperations();
-        for (Map.Entry<XmlNode.NodeName, AttributeOperationType> attributeOperation :
-                attributeOperations) {
-            if (attributeOperation.getValue() == AttributeOperationType.IGNORE_WARNING) {
-                if (attributeOperation.getKey().toString().equals("tools:true")) {
-                    return true;
-                }
-                return false;
-            }
-        }
-        return false;
-    }
-
-    private static void checkOnlyOneUsesSdk(
-            @NonNull XmlDocument manifest, @NonNull MergingReport.Builder mergingReport) {
-        XmlElement root = manifest.getRootNode();
-        Preconditions.checkNotNull(root);
-        List<XmlElement> list = root.getAllNodesByType(ManifestModel.NodeTypes.USES_SDK);
-        if (list.size() > 1) {
-            mergingReport.addMessage(
-                    manifest.getSourceFile(),
-                    MergingReport.Record.Severity.ERROR,
-                    "Multiple <uses-sdk>s cannot be present in the merged AndroidManifest.xml. ");
-            mergingReport.build();
-        }
-    }
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ActionRecorder.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ActionRecorder.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ActionRecorder.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ActionRecorder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,291 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.XmlNode.NodeKey;
-
-import androidx.annotation.GuardedBy;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import com.google.common.collect.ImmutableMap;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Records all the actions taken by the merging tool.
- * <p>
- * Each action generates at least one {@link com.tyron.build.compiler.manifest.Actions.Record}
- * containing enough information to generate a machine or human readable report.
- * <p>
- *
- * The records are not organized in a temporal structure as the merging tool takes such decisions
- * but are keyed by xml elements and attributes. For each node (elements or attributes), a linked
- * list of actions that happened to the node is recorded to display all decisions that were made
- * for that particular node.
- * <p>
- *
- * This structure will permit displaying logs with co-located decisions records for each element,
- * for instance :
- * <pre>
- * activity:com.foo.bar.MyApp
- *     Added from manifest.xml:31
- *     Rejected from lib1_manifest.xml:65
- * </pre>
- *
- * <p>
- * Each record for a node (element or attribute) will contain the following metadata :
- * <p>
- *
- * <ul>
- *     <li>{@link com.tyron.build.compiler.manifest.Actions.ActionType} to identify whether the action
- *     applies to an attribute or an element.</li>
- *     <li>{@link com.tyron.build.compiler.manifest.blame.SourceFilePosition} to identify the source xml
- *     location for the node.</li>
- * </ul>
- *
- * <p>
- * Elements will also contain:
- * <ul>
- *     <li>Element name : a name composed of the element type and its key.</li>
- *     <li>{@link NodeOperationType} the highest priority tool annotation justifying the merging
- *     tool decision.</li>
- * </ul>
- *
- * <p>
- * While attributes will have:
- * <ul>
- *     <li>element name</li>
- *     <li>attribute name : the namespace aware xml name</li>
- *     <li>{@link AttributeOperationType} the highest priority annotation justifying the merging
- *     tool decision.</li>
- * </ul>
- */
-public class ActionRecorder {
-
-    // defines all the records for the merging tool activity, indexed by element name+key.
-    // iterator should be ordered by the key insertion order. This is not a concurrent map so we
-    // will need to guard multi-threaded access when adding/removing elements.
-    @GuardedBy("this")
-    private final Map<NodeKey, Actions.DecisionTreeRecord> mRecords =
-            new LinkedHashMap<NodeKey, Actions.DecisionTreeRecord>();
-
-    /**
-     * When the first xml file is loaded, there is nothing to merge with, however, each xml element
-     * and attribute added to the initial merged file need to be recorded.
-     *
-     * @param xmlElement xml element added to the initial merged document.
-     */
-    void recordDefaultNodeAction(XmlElement xmlElement) {
-        if (!mRecords.containsKey(xmlElement.getOriginalId())) {
-            recordNodeAction(xmlElement, Actions.ActionType.ADDED);
-            for (XmlAttribute xmlAttribute : xmlElement.getAttributes()) {
-                AttributeOperationType attributeOperation = xmlElement
-                        .getAttributeOperationType(xmlAttribute.getName());
-                recordAttributeAction(
-                        xmlAttribute, Actions.ActionType.ADDED,
-                        attributeOperation);
-            }
-            for (XmlElement childNode : xmlElement.getMergeableElements()) {
-                recordDefaultNodeAction(childNode);
-            }
-        }
-    }
-
-    /**
-     * Record a node that was added due to an implicit presence in earlier SDK release but requires
-     * an explicit declaration in the application targeted SDK.
-     * @param xmlElement the implied element that was added to the resulting xml.
-     * @param reason optional contextual information whey the implied element was added.
-     */
-    void recordImpliedNodeAction(XmlElement xmlElement, String reason) {
-        NodeKey storageKey = xmlElement.getOriginalId();
-        Actions.DecisionTreeRecord nodeDecisionTree = mRecords.get(storageKey);
-        if (nodeDecisionTree == null) {
-            nodeDecisionTree = new Actions.DecisionTreeRecord();
-            mRecords.put(storageKey, nodeDecisionTree);
-        }
-        Actions.NodeRecord record = new Actions.NodeRecord(Actions.ActionType.IMPLIED,
-                new SourceFilePosition(
-                        xmlElement.getDocument().getSourceFile(),
-                        xmlElement.getDocument().getRootNode().getPosition()),
-                xmlElement.getOriginalId(),
-                reason,
-                xmlElement.getOperationType()
-        );
-        nodeDecisionTree.addNodeRecord(record);
-    }
-
-    /**
-     * Record a node action taken by the merging tool.
-     *
-     * @param xmlElement the action's target xml element
-     * @param actionType the action's type
-     */
-    synchronized void recordNodeAction(
-            XmlElement xmlElement,
-            Actions.ActionType actionType) {
-        recordNodeAction(xmlElement, actionType, xmlElement);
-    }
-
-    /**
-     * Record a node action taken by the merging tool.
-     *
-     * @param mergedElement the merged xml element
-     * @param actionType    the action's type
-     * @param targetElement the action's target when the action is rejected or replaced, it
-     *                      indicates what is the element being rejected or replaced.
-     */
-    synchronized void recordNodeAction(
-            XmlElement mergedElement,
-            Actions.ActionType actionType,
-            XmlElement targetElement) {
-
-        Actions.NodeRecord record = new Actions.NodeRecord(actionType,
-                new SourceFilePosition(
-                        targetElement.getDocument().getSourceFile(),
-                        targetElement.getPosition()),
-                targetElement.getOriginalId(),
-                null, /* reason */
-                mergedElement.getOperationType()
-        );
-        recordNodeAction(mergedElement, record);
-    }
-
-    /**
-     * Records a {@link com.tyron.build.compiler.manifest.Actions.NodeRecord} action on a xml element.
-     * @param mergedElement the target element of the action.
-     * @param nodeRecord the record of the action.
-     */
-    synchronized void recordNodeAction(
-            XmlElement mergedElement,
-            Actions.NodeRecord nodeRecord) {
-
-        NodeKey storageKey = mergedElement.getOriginalId();
-        Actions.DecisionTreeRecord nodeDecisionTree = mRecords.get(storageKey);
-        if (nodeDecisionTree == null) {
-            nodeDecisionTree = new Actions.DecisionTreeRecord();
-            mRecords.put(storageKey, nodeDecisionTree);
-        }
-        nodeDecisionTree.addNodeRecord(nodeRecord);
-    }
-
-    /**
-     * Records an attribute action taken by the merging tool
-     *
-     * @param attribute              the attribute in question.
-     * @param actionType             the action's type
-     * @param attributeOperationType the original tool annotation leading to the merging tool
-     *                               decision.
-     */
-    synchronized void recordAttributeAction(
-            @NonNull XmlAttribute attribute,
-            @NonNull Actions.ActionType actionType,
-            @Nullable AttributeOperationType attributeOperationType) {
-
-        recordAttributeAction(
-                attribute, attribute.getPosition(), actionType, attributeOperationType);
-    }
-
-    /**
-     * Records an attribute action taken by the merging tool
-     *
-     * @param attribute              the attribute in question.
-     * @param attributePosition      the attribute's position.
-     * @param actionType             the action's type
-     * @param attributeOperationType the original tool annotation leading to the merging tool
-     *                               decision.
-     */
-    synchronized void recordAttributeAction(
-            @NonNull XmlAttribute attribute,
-            @NonNull SourcePosition attributePosition,
-            @NonNull Actions.ActionType actionType,
-            @Nullable AttributeOperationType attributeOperationType) {
-
-        XmlElement originElement = attribute.getOwnerElement();
-        Actions.AttributeRecord attributeRecord = new Actions.AttributeRecord(
-                actionType,
-                new SourceFilePosition(
-                        originElement.getDocument().getSourceFile(),
-                        attributePosition),
-                attribute.getOriginalId(),
-                null, /* reason */
-                attributeOperationType
-        );
-        recordAttributeAction(attribute, attributeRecord);
-    }
-
-    /**
-     * Record a {@link com.tyron.build.compiler.manifest.Actions.AttributeRecord} action for an attribute of
-     * an xml element.
-     * @param attribute the attribute in question.
-     * @param attributeRecord the record of the action.
-     */
-    synchronized void recordAttributeAction(
-            XmlAttribute attribute,
-            Actions.AttributeRecord attributeRecord) {
-
-        List<Actions.AttributeRecord> attributeRecords = getAttributeRecords(attribute);
-        attributeRecords.add(attributeRecord);
-    }
-
-    /**
-     * Records when a default value that should be merged was rejected due to a tools:replace
-     * annotation.
-     *
-     * @param attribute              the attribute which default value was ignored.
-     * @param implicitAttributeOwner the element owning the implicit default value.
-     */
-    synchronized void recordImplicitRejection(
-            @NonNull XmlAttribute attribute,
-            @NonNull XmlElement implicitAttributeOwner) {
-
-        List<Actions.AttributeRecord> attributeRecords = getAttributeRecords(attribute);
-        Actions.AttributeRecord attributeRecord = new Actions.AttributeRecord(
-                Actions.ActionType.REJECTED,
-                new SourceFilePosition(
-                        implicitAttributeOwner.getDocument().getSourceFile(),
-                        implicitAttributeOwner.getPosition()),
-                attribute.getOriginalId(),
-                null, /* reason */
-                AttributeOperationType.REPLACE
-        );
-        attributeRecords.add(attributeRecord);
-    }
-
-    /**
-     * Returns the record for an attribute creation event. The attribute is "created" when it is
-     * added for the first time into the resulting merged xml document.
-     */
-    @Nullable
-    synchronized Actions.AttributeRecord getAttributeCreationRecord(XmlAttribute attribute) {
-        for (Actions.AttributeRecord attributeRecord : getAttributeRecords(attribute)) {
-            if (attributeRecord.getActionType() == Actions.ActionType.ADDED) {
-                return attributeRecord;
-            }
-        }
-        return null;
-    }
-
-    private List<Actions.AttributeRecord> getAttributeRecords(XmlAttribute attribute) {
-        XmlElement originElement = attribute.getOwnerElement();
-        NodeKey storageKey = originElement.getOriginalId();
-        Actions.DecisionTreeRecord nodeDecisionTree = mRecords.get(storageKey);
-        // by now the node should have been added for this element.
-        assert (nodeDecisionTree != null);
-        List<Actions.AttributeRecord> attributeRecords =
-                nodeDecisionTree.mAttributeRecords.get(attribute.getName());
-        if (attributeRecords == null) {
-            attributeRecords = new ArrayList<Actions.AttributeRecord>();
-            nodeDecisionTree.mAttributeRecords.put(attribute.getName(), attributeRecords);
-        }
-        return attributeRecords;
-    }
-
-    Actions build() {
-        return new Actions(new ImmutableMap.Builder<NodeKey, Actions.DecisionTreeRecord>()
-                .putAll(mRecords).build());
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/AttributeModel.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/AttributeModel.java b/Build/src/main/java/com/tyron/build/compiler/manifest/AttributeModel.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/AttributeModel.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,452 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Joiner;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Describes an attribute characteristics like if it supports smart package name replacement, has
- * a default value and a validator for its values.
- */
-class AttributeModel {
-
-    @NonNull private final XmlNode.NodeName mName;
-    private final boolean mIsPackageDependent;
-    @Nullable
-    private final String mDefaultValue;
-    @Nullable private final Validator mOnReadValidator;
-    @Nullable private final Validator mOnWriteValidator;
-    @NonNull private final MergingPolicy mMergingPolicy;
-
-    /**
-     * Define a new attribute with specific characteristics.
-     *
-     * @param name name of the attribute, so far assumed to be in the
-     *             {@link SdkConstants#ANDROID_URI} namespace.
-     * @param isPackageDependent true if the attribute support smart substitution of package name.
-     * @param defaultValue an optional default value.
-     * @param onReadValidator an optional validator to validate values against.
-     */
-    private AttributeModel(@NonNull XmlNode.NodeName name,
-                           boolean isPackageDependent,
-                           @Nullable String defaultValue,
-                           @Nullable Validator onReadValidator,
-                           @Nullable Validator onWriteValidator,
-                           @NonNull MergingPolicy mergingPolicy) {
-        mName = name;
-        mIsPackageDependent = isPackageDependent;
-        mDefaultValue = defaultValue;
-        mOnReadValidator = onReadValidator;
-        mOnWriteValidator = onWriteValidator;
-        mMergingPolicy = mergingPolicy;
-    }
-
-    @NonNull
-    XmlNode.NodeName getName() {
-        return mName;
-    }
-
-    /**
-     * Return true if the attribute support smart substitution of partially fully qualified
-     * class names with package settings as provided by the manifest node's package attribute
-     * {@link <a href=http://developer.android.com/guide/topics/manifest/manifest-element.html>}
-     *
-     * @return true if this attribute supports smart substitution or false if not.
-     */
-    boolean isPackageDependent() {
-        return mIsPackageDependent;
-    }
-
-    /**
-     * Returns the attribute's default value or null if none.
-     */
-    @Nullable
-    String getDefaultValue() {
-        return mDefaultValue;
-    }
-
-    /**
-     * Returns the attribute's {@link AttributeModel.Validator} to
-     * validate its value when read from xml files or null if no validation is necessary.
-     */
-    @Nullable
-    public Validator getOnReadValidator() {
-        return mOnReadValidator;
-    }
-
-    /**
-     * Returns the attribute's {@link AttributeModel.Validator} to
-     * validate its value when the merged file is about to be persisted.
-     */
-    @Nullable
-    public Validator getOnWriteValidator() {
-        return mOnWriteValidator;
-    }
-
-    /**
-     * Returns the {@link AttributeModel.MergingPolicy} for this
-     * attribute.
-     */
-    @NonNull
-    public MergingPolicy getMergingPolicy() {
-        return mMergingPolicy;
-    }
-
-    /**
-     * Creates a new {@link Builder} to describe an attribute.
-     * @param attributeName the to be described attribute name
-     */
-    static Builder newModel(String attributeName) {
-        return new Builder(attributeName);
-    }
-
-
-    static class Builder {
-
-        private final String mName;
-        private boolean mIsPackageDependent = false;
-        private String mDefaultValue;
-        private Validator mOnReadValidator;
-        private Validator mOnWriteValidator;
-        private MergingPolicy mMergingPolicy = STRICT_MERGING_POLICY;
-
-        Builder(String name) {
-            this.mName = name;
-        }
-
-        /**
-         * Sets the attribute support for smart substitution of partially fully qualified
-         * class names with package settings as provided by the manifest node's package attribute
-         * {@link <a href=http://developer.android.com/guide/topics/manifest/manifest-element.html>}
-         */
-        Builder setIsPackageDependent() {
-            mIsPackageDependent = true;
-            return this;
-        }
-
-        /**
-         * Sets the attribute default value.
-         */
-        Builder setDefaultValue(String value) {
-            mDefaultValue =  value;
-            return this;
-        }
-
-        /**
-         * Sets a {@link AttributeModel.Validator} to validate the
-         * attribute's values coming from xml files.
-         */
-        Builder setOnReadValidator(Validator validator) {
-            mOnReadValidator = validator;
-            return this;
-        }
-
-        /**
-         * Sets a {@link AttributeModel.Validator} to validate values
-         * before they are written to the final merged document.
-         */
-        Builder setOnWriteValidator(Validator validator) {
-            mOnWriteValidator = validator;
-            return this;
-        }
-
-        Builder setMergingPolicy(MergingPolicy mergingPolicy) {
-            mMergingPolicy = mergingPolicy;
-            return this;
-        }
-
-        /**
-         * Build an immutable {@link AttributeModel}
-         */
-        AttributeModel build() {
-            return new AttributeModel(
-                    XmlNode.fromXmlName("android:" + mName),
-                    mIsPackageDependent,
-                    mDefaultValue,
-                    mOnReadValidator,
-                    mOnWriteValidator,
-                    mMergingPolicy);
-        }
-    }
-
-    /**
-     * Defines a merging policy between two attribute values. Example of merging policies can be
-     * strict when it is illegal to try to merge or override a value by another. Another example
-     * is a OR merging policy on boolean attribute values.
-     */
-    interface MergingPolicy {
-
-        /**
-         * Returns true if it should be attempted to merge this attribute value with
-         * the attribute default value when merging with a node that does not contain
-         * the attribute declaration.
-         */
-        boolean shouldMergeDefaultValues();
-
-        /**
-         * Merges the two attributes values and returns the merged value. If the values cannot be
-         * merged, return null.
-         */
-        @Nullable
-        String merge(@NonNull String higherPriority, @NonNull String lowerPriority);
-    }
-
-    /**
-     * Standard attribute value merging policy, generates an error unless both values are equal.
-     */
-    static final MergingPolicy STRICT_MERGING_POLICY = new MergingPolicy() {
-
-        @Override
-        public boolean shouldMergeDefaultValues() {
-            return false;
-        }
-
-        @Nullable
-        @Override
-        public String merge(@NonNull String higherPriority, @NonNull String lowerPriority) {
-            // it's ok if the values are equal, otherwise it's not.
-            return higherPriority.equals(lowerPriority)
-                    ? higherPriority
-                    : null;
-        }
-    };
-
-    /**
-     * Boolean OR merging policy.
-     */
-    static final MergingPolicy OR_MERGING_POLICY = new MergingPolicy() {
-        @Override
-        public boolean shouldMergeDefaultValues() {
-            return true;
-        }
-
-        @Nullable
-        @Override
-        public String merge(@NonNull String higherPriority, @NonNull String lowerPriority) {
-            return Boolean.toString(BooleanValidator.isTrue(higherPriority) ||
-                    BooleanValidator.isTrue(lowerPriority));
-        }
-    };
-
-    /**
-     * Merging policy that will return the higher priority value regardless of the lower priority
-     * value
-     */
-    static final MergingPolicy NO_MERGING_POLICY = new MergingPolicy() {
-
-        @Override
-        public boolean shouldMergeDefaultValues() {
-            return true;
-        }
-
-        @Nullable
-        @Override
-        public String merge(@NonNull String higherPriority, @NonNull String lowerPriority) {
-            return higherPriority;
-        }
-    };
-
-    /**
-     * Decode a decimal or hexadecimal {@link String} into an {@link Integer}.
-     * String starting with 0 will be considered decimal, not octal.
-     */
-    private static int decodeDecOrHexString(String s) {
-        long decodedValue = s.startsWith("0x") || s.startsWith("0X")
-                ? Long.decode(s)
-                : Long.parseLong(s);
-        if (decodedValue < 0xFFFFFFFFL) {
-            return (int) decodedValue;
-        } else {
-            throw new IllegalArgumentException("Value " + s + " too big for 32 bits.");
-        }
-    }
-
-    /**
-     * Validates an attribute value.
-     *
-     * The validator can be called when xml documents are read to ensure the xml file contains
-     * valid statements.
-     *
-     * This is a poor-mans replacement for not having a proper XML Schema do perform such
-     * validations.
-     */
-    interface Validator {
-
-        /**
-         * Validates a value, issuing a warning or error in case of failure through the passed
-         * merging report.
-         * @param mergingReport to report validation warnings or error
-         * @param attribute the attribute to validate.
-         * @param value the proposed or existing attribute value.
-         * @return true if the value is legal for this attribute.
-         */
-        boolean validates(@NonNull MergingReport.Builder mergingReport,
-                          @NonNull XmlAttribute attribute,
-                          @NonNull String value);
-    }
-
-    /**
-     * Validates a boolean attribute type.
-     */
-    static class BooleanValidator implements Validator {
-
-        // TODO: check with @xav where to find the acceptable values by runtime.
-        private static final Pattern TRUE_PATTERN = Pattern.compile("true|True|TRUE");
-        private static final Pattern FALSE_PATTERN = Pattern.compile("false|False|FALSE");
-
-        private static boolean isTrue(String value) {
-            return TRUE_PATTERN.matcher(value).matches();
-        }
-
-        @Override
-        public boolean validates(@NonNull MergingReport.Builder mergingReport,
-                                 @NonNull XmlAttribute attribute,
-                                 @NonNull String value) {
-            boolean matches = TRUE_PATTERN.matcher(value).matches() ||
-                    FALSE_PATTERN.matcher(value).matches();
-            if (!matches) {
-                attribute.addMessage(mergingReport, MergingReport.Record.Severity.ERROR,
-                        String.format(
-                                "Attribute %1$s at %2$s has an illegal value=(%3$s), "
-                                        + "expected 'true' or 'false'",
-                                attribute.getId(),
-                                attribute.printPosition(),
-                                value
-                        )
-                );
-            }
-            return matches;
-        }
-    }
-
-    /**
-     * A {@link AttributeModel.Validator} for verifying that a proposed
-     * value is part of the acceptable list of possible values.
-     */
-    static class MultiValueValidator implements Validator {
-
-        private final String[] multiValues;
-        private final String allValues;
-
-        MultiValueValidator(String... multiValues) {
-            this.multiValues = multiValues;
-            allValues = Joiner.on(',').join(multiValues);
-        }
-
-        @Override
-        public boolean validates(@NonNull MergingReport.Builder mergingReport,
-                                 @NonNull XmlAttribute attribute, @NonNull String value) {
-            for (String multiValue : multiValues) {
-                if (multiValue.equals(value)) {
-                    return true;
-                }
-            }
-            attribute.addMessage(mergingReport, MergingReport.Record.Severity.ERROR,
-                    String.format(
-                            "Invalid value for attribute %1$s at %2$s, value=(%3$s), "
-                                    + "acceptable values are (%4$s)",
-                            attribute.getId(),
-                            attribute.printPosition(),
-                            value,
-                            allValues
-                    )
-            );
-            return false;
-        }
-    }
-
-    /**
-     * A {@link AttributeModel.Validator} for verifying that a proposed
-     * value is a numerical integer value.
-     */
-    static class IntegerValueValidator implements Validator {
-
-        @Override
-        public boolean validates(@NonNull MergingReport.Builder mergingReport,
-                                 @NonNull XmlAttribute attribute, @NonNull String value) {
-            try {
-                return Integer.parseInt(value) > 0;
-            } catch (NumberFormatException e) {
-                attribute.addMessage(mergingReport, MergingReport.Record.Severity.ERROR,
-                        String.format(
-                                "Attribute %1$s at %2$s must be an integer, found %3$s",
-                                attribute.getId(),
-                                attribute.printPosition(),
-                                value)
-                );
-                return false;
-            }
-        }
-    }
-
-    /**
-     * A {@link AttributeModel.Validator} to validate that a string is
-     * a valid 32 bits hexadecimal representation.
-     */
-    static class Hexadecimal32Bits implements Validator {
-        protected static final Pattern PATTERN = Pattern.compile("0[xX]([0-9a-fA-F]+)");
-
-        @Override
-        public boolean validates(@NonNull MergingReport.Builder mergingReport,
-                                 @NonNull XmlAttribute attribute, @NonNull String value) {
-            Matcher matcher = PATTERN.matcher(value);
-            boolean valid = matcher.matches() && matcher.group(1).length() <= 8;
-            if (!valid) {
-                attribute.addMessage(mergingReport, MergingReport.Record.Severity.ERROR,
-                        String.format(
-                                "Attribute %1$s at %2$s is not a valid hexadecimal 32 bit value,"
-                                        + " found %3$s",
-                                attribute.getId(),
-                                attribute.printPosition(),
-                                value
-                        ));
-            }
-            return valid;
-        }
-    }
-
-    /**
-     * A {@link AttributeModel.Validator} to validate that a string is
-     * a valid 32 positive hexadecimal representation with a minimum value requirement.
-     */
-    static class Hexadecimal32BitsWithMinimumValue extends Hexadecimal32Bits {
-
-        private final int mMinimumValue;
-
-        Hexadecimal32BitsWithMinimumValue(int minimumValue) {
-            mMinimumValue = minimumValue;
-        }
-
-        @Override
-        public boolean validates(@NonNull MergingReport.Builder mergingReport,
-                                 @NonNull XmlAttribute attribute, @NonNull String value) {
-            boolean valid = super.validates(mergingReport, attribute, value);
-            if (valid) {
-                try {
-                    Long decodedValue = Long.decode(value);
-                    valid = decodedValue >= mMinimumValue && decodedValue < 0xFFFFFFFFL;
-                } catch(NumberFormatException e) {
-                    valid = false;
-                }
-                if (!valid) {
-                    attribute.addMessage(mergingReport, MergingReport.Record.Severity.ERROR,
-                            String.format(
-                                    "Attribute %1$s at %2$s is not a valid hexadecimal value,"
-                                            + " minimum is 0x%3$08X, maximum is 0x%4$08X, found %5$s",
-                                    attribute.getId(),
-                                    attribute.printPosition(),
-                                    mMinimumValue,
-                                    Integer.MAX_VALUE,
-                                    value
-                            ));
-                }
-                return valid;
-            }
-            return false;
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1715 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import com.tyron.build.compiler.manifest.IMergerLog.Severity;
-import com.tyron.build.model.FileAndLine;
-import com.tyron.build.util.SdkUtils;
-import com.tyron.build.util.XmlUtils;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-import java.io.File;
-import java.net.MalformedURLException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPathExpressionException;
-
-/**
- * Merges a library manifest into a main application manifest.
- * <p/>
- * To use, create with {@link ManifestMerger#ManifestMerger(IMergerLog, ICallback)} then
- * call {@link ManifestMerger#process(File, File, File[], Map, String)}.
- * <p/>
- * <pre> Merge operations:
- * - root manifest: attributes ignored, warn if defined.
- * - application:
- *      G- {@code @attributes}: most attributes are ignored in libs
- *          except: application:name if defined, it must match.
- *          except: application:agentBackup if defined, it must match.
- *          (these represent class names and we don't want a lib to assume their app or backup
- *           classes are being used when that will never be the case.)
- *      C- activity / activity-alias / service / receiver / provider
- *          => Merge as-is. Error if exists in the destination (same {@code @name})
- *             unless the definitions are exactly the same.
- *             New elements are always merged at the end of the application element.
- *          => Indicate if there's a dup.
- *      D- uses-library
- *          => Merge. OK if already exists same {@code @name}.
- *          => Merge {@code @required}: true>false.
- *      C- meta-data
- *          => Merge as-is. Error if exists in the destination (same {@code @name})
- *             unless the definitions are exactly the same.
- *             New elements are always merged at the end of the application element.
- *          => Indicate if there's a dup.
- * A- instrumentation:
- *      => Do not merge. ignore the ones from libs.
- * C- permission / permission-group / permission-tree:
- *      => Merge as-is. Error if exists in the destination (same {@code @name})
- *         unless the definitions are exactly the same.
- * C- uses-permission:
- *      => Add. OK if already defined.
- * E- uses-sdk:
- *      {@code @minSdkVersion}: error if dest&lt;lib. Never automatically change dest minsdk.
- *                              Codenames are accepted if we can resolve their API level.
- *      {@code @targetSdkVersion}: warning if dest&lt;lib.
- *                                 Never automatically change dest targetsdk.
- *      {@code @maxSdkVersion}: obsolete, ignored. Not used in comparisons and not merged.
- * D- uses-feature with {@code @name}:
- *      => Merge with same {@code @name}
- *      => Merge {@code @required}: true>false.
- *      - Do not merge any {@code @glEsVersion} attribute at this point.
- * F- uses-feature with {@code @glEsVersion}:
- *      => Error if defined in lib+dest with dest&lt;lib. Never automatically change dest.
- * B- uses-configuration:
- *      => There can be many. Error if source defines one that is not an exact match in dest.
- *      (e.g. right now app must manually define something that matches exactly each lib)
- * B- supports-screens / compatible-screens:
- *      => Do not merge.
- *      => Error (warn?) if defined in lib and not strictly the same as in dest.
- * B- supports-gl-texture:
- *      => Do not merge. Can have more than one.
- *      => Error (warn?) if defined in lib and not present as-is in dest.
- *
- * Strategies:
- * A = Ignore, do not merge (no-op).
- * B = Do not merge but if defined in both must match equally.
- * C = Must not exist in dest or be exactly the same (key is the {@code @name} attribute).
- * D = Add new or merge with same key {@code @name}, adjust {@code @required} true>false.
- * E, F, G = Custom strategies; see above.
- *
- * What happens when merging libraries with conflicting information?
- * Say for example a main manifest has a minSdkVersion of 3, whereas libraries have
- * a minSdkVersion of 4 and 11. We could have 2 point of views:
- * - Play it safe: If we have a library with a minSdkVersion of 11, it means this
- *   library code knows it can't work reliably on a lower API level. So the safest end
- *   result would be a merged manifest with the highest minSdkVersion of all libraries.
- * - Trust the main manifest: When an app declares a given minSdkVersion, it also expects
- *   to run a given range of devices. If we change the final minSdkVersion, the app won't
- *   be available on as many devices as the developer might expect. And as a counterpoint
- *   to issue 1, the app may be careful and not call the library without checking the
- *   necessary features or APIs are available before hand.
- * Both points of views are conflicting. The solution taken here is to be conservative
- * and generate an error rather than merge and change a value that might be surprising.
- * On the other hand this can be problematic and force a developer to keep the main
- * manifest in sync with the libraries ones, in essence reducing the usefulness of the
- * automated merge to pure trivial cases. The idea is to just start this way and enhance
- * or revisit the mechanism later.
- * </pre>
- */
-public class ManifestMerger {
-
-    /** Logger object. Never null. */
-    private final IMergerLog mLog;
-    /** An optional callback that the merger can use to query the calling SDK. */
-    private final ICallback mCallback;
-    private XPath mXPath;
-    private Document mMainDoc;
-    /** Option to extract the package prefixes from the merged manifest. */
-    private boolean mExtractPackagePrefix;
-    /** Whether the merger should insert comments pointing to the merge source files */
-    private boolean mInsertSourceMarkers;
-
-    /** Namespace for Android attributes in an AndroidManifest.xml */
-    private static final String NS_URI    = SdkConstants.NS_RESOURCES;
-    /** Prefix for the Android namespace to use in XPath expressions. */
-    private static final String NS_PREFIX = AndroidXPathFactory.DEFAULT_NS_PREFIX;
-    /** Namespace used in XML files for Android Tooling attributes */
-    private static final String TOOLS_URI = SdkConstants.TOOLS_URI;
-    /** The name of the tool:merge attribute, to either override or ignore merges. */
-    private static final String MERGE_ATTR     = "merge";                           //$NON-NLS-1$
-    /** tool:merge="override" means to ignore what comes from libraries and only keep the
-     *  version from the main manifest. No conflict can be generated. */
-    private static final String MERGE_OVERRIDE = "override";                        //$NON-NLS-1$
-    /** tool:merge="remove" means to remove a node and prevent merging -- not only is the
-     *  node from the libraries not merged, but the element is removed from the main manifest. */
-    private static final String MERGE_REMOVE   = "remove";                          //$NON-NLS-1$
-
-    /**
-     * Sets of element/attribute that need to be treated as class names.
-     * The attribute name must be the local name for the Android namespace.
-     * For example "application/name" maps to &lt;application android:name=...&gt;.
-     */
-    private static final String[] sClassAttributes = {
-            "application/name",
-            "application/backupAgent",
-            "activity/name",
-            "activity/parentActivityName",
-            "activity-alias/name",
-            "activity-alias/targetActivity",
-            "receiver/name",
-            "service/name",
-            "provider/name",
-            "instrumentation/name"
-    };
-
-    /**
-     * Creates a new {@link ManifestMerger}.
-     *
-     * @param log A non-null merger log to capture all warnings, errors and their location.
-     * @param callback An optional callback that the merger can use to query the calling SDK.
-     */
-    public ManifestMerger(@NonNull IMergerLog log, @Nullable ICallback callback) {
-        mLog = log;
-        mCallback = callback;
-    }
-
-    /**
-     * Sets whether the manifest merger should extract package prefixes.
-     * <p/>
-     * When true, the merged document is revisited and class names attributes
-     * are shortened when possible, e.g. the package prefix is removed from the
-     * class name if it matches.
-     *
-     * @param extract If true, extract package prefixes.
-     * @return this, for constructor chaining
-     */
-    public ManifestMerger setExtractPackagePrefix(boolean extract) {
-        mExtractPackagePrefix = extract;
-        return this;
-    }
-
-    /**
-     * Performs the merge operation.
-     * <p/>
-     * This does NOT stop on errors, in an attempt to accumulate as much
-     * info as possible to return to the user.
-     * Unless it failed to read the main manifest, a result file will be
-     * created. However if process() returns false, the file should not
-     * be used except for debugging purposes.
-     *
-     * @param outputFile The output path to generate. Can be the same as the main path.
-     * @param mainFile The main manifest paths to read. What we merge into.
-     * @param libraryFiles The library manifest paths to read. Must not be null.
-     * @param injectAttributes A map of attributes to inject in the form [pseudo-xpath] => value.
-     *   The key is "/manifest/elements...|attribute-ns-uri attribute-local-name",
-     *   for example "/manifest/uses-sdk|http://schemas.android.com/apk/res/android minSdkVersion".
-     *   (note the space separator between the attribute URI and its local name.)
-     *   The elements will be created if they don't exists. Existing attributes will be modified.
-     *   The replacement is done on the main document <em>before</em> merging.
-     * @param packageOverride an optional package override. This only affects the package attribute,
-     *   all components (activities, receivers, etc...) are not affected by this.
-     * @return True if the merge was completed, false otherwise.
-     */
-    public boolean process(
-            File outputFile,
-            File mainFile,
-            File[] libraryFiles,
-            Map<String, String> injectAttributes,
-            String packageOverride) {
-        Document mainDoc = MergerXmlUtils.parseDocument(mainFile, mLog, this);
-        if (mainDoc == null) {
-            mLog.error(Severity.ERROR, new FileAndLine(mainFile.getAbsolutePath(), 0),
-                    "Failed to read manifest file.");
-            return false;
-        }
-
-        boolean success = process(mainDoc, libraryFiles, injectAttributes, packageOverride);
-
-        if (!MergerXmlUtils.printXmlFile(mainDoc, outputFile, mLog)) {
-            mLog.error(Severity.ERROR, new FileAndLine(outputFile.getAbsolutePath(), 0),
-                    "Failed to write manifest file.");
-            success = false;
-        }
-
-        return success;
-    }
-
-    /**
-     * Performs the merge operation in-place in the given DOM.
-     * <p/>
-     * This does NOT stop on errors, in an attempt to accumulate as much
-     * info as possible to return to the user.
-     * <p/>
-     * The method might modify the input XML document in-place for its own processing.
-     *
-     * @param mainDoc The document to merge into. Will be modified in-place.
-     * @param libraryFiles The library manifest paths to read. Must not be null.
-     *                     These will be modified in-place.
-     * @param injectAttributes A map of attributes to inject in the form [pseudo-xpath] => value.
-     *   The key is "/manifest/elements...|attribute-ns-uri attribute-local-name",
-     *   for example "/manifest/uses-sdk|http://schemas.android.com/apk/res/android minSdkVersion".
-     *   (note the space separator between the attribute URI and its local name.)
-     *   The elements will be created if they don't exists. Existing attributes will be modified.
-     *   The replacement is done on the main document <em>before</em> merging.
-     * @param packageOverride an optional package override. This only affects the package attribute,
-     *   all components (activities, receivers, etc...) are not affected by this.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    public boolean process(
-            Document mainDoc,
-            File[] libraryFiles,
-            Map<String, String> injectAttributes,
-            String packageOverride) {
-
-        boolean success = true;
-        mMainDoc = mainDoc;
-        MergerXmlUtils.decorateDocument(mainDoc, IMergerLog.MAIN_MANIFEST);
-        MergerXmlUtils.injectAttributes(mainDoc, injectAttributes, mLog);
-
-        String prefix = XmlUtils.lookupNamespacePrefix(mainDoc, SdkConstants.NS_RESOURCES);
-        mXPath = AndroidXPathFactory.newXPath(prefix);
-
-        expandFqcns(mainDoc);
-        for (File libFile : libraryFiles) {
-            Document libDoc = MergerXmlUtils.parseDocument(libFile, mLog, this);
-            if (libDoc == null || !mergeLibDoc(cleanupToolsAttributes(libDoc))) {
-                success = false;
-            }
-        }
-
-        if (packageOverride != null) {
-            MergerXmlUtils.injectAttributes(mainDoc,
-                    Collections.singletonMap("/manifest| package", packageOverride),
-                    mLog);
-        }
-
-        cleanupToolsAttributes(mainDoc);
-
-        if (mExtractPackagePrefix) {
-            extractFqcns(mainDoc);
-        }
-
-        if (mInsertSourceMarkers) {
-            insertSourceMarkers(mainDoc);
-        }
-
-        mXPath = null;
-        mMainDoc = null;
-        return success;
-    }
-
-    /**
-     * Performs the merge operation in-place in the given DOM.
-     * <p/>
-     * This does NOT stop on errors, in an attempt to accumulate as much
-     * info as possible to return to the user.
-     * <p/>
-     * The method might modify the input XML documents in-place for its own processing.
-     *
-     * @param mainDoc The document to merge into. Will be modified in-place.
-     * @param libraryDocs The library manifest documents to merge in. Must not be null.
-     *                    These will be modified in-place.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    public boolean process(@NonNull Document mainDoc, @NonNull Document... libraryDocs) {
-
-        boolean success = true;
-        mMainDoc = mainDoc;
-        MergerXmlUtils.decorateDocument(mainDoc, IMergerLog.MAIN_MANIFEST);
-
-        String prefix = XmlUtils.lookupNamespacePrefix(mainDoc, SdkConstants.NS_RESOURCES);
-        mXPath = AndroidXPathFactory.newXPath(prefix);
-
-        expandFqcns(mainDoc);
-        for (Document libDoc : libraryDocs) {
-            MergerXmlUtils.decorateDocument(libDoc, IMergerLog.LIBRARY);
-            if (!mergeLibDoc(cleanupToolsAttributes(libDoc))) {
-                success = false;
-            }
-        }
-
-        cleanupToolsAttributes(mainDoc);
-
-        if (mExtractPackagePrefix) {
-            extractFqcns(mainDoc);
-        }
-
-        if (mInsertSourceMarkers) {
-            insertSourceMarkers(mainDoc);
-        }
-
-        mXPath = null;
-        mMainDoc = null;
-        return success;
-    }
-
-    // --------
-
-    /**
-     * Merges the given library manifest into the destination manifest.
-     * See {@link ManifestMerger} for merge details.
-     *
-     * @param libDoc The library document to merge from. Must not be null.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    private boolean mergeLibDoc(Document libDoc) {
-
-        boolean err = false;
-
-        expandFqcns(libDoc);
-
-        // Strategy G (check <application> is compatible)
-        err |= !checkApplication(libDoc);
-
-        // Strategy B
-        err |= !doNotMergeCheckEqual("/manifest/uses-configuration",  libDoc);     //$NON-NLS-1$
-        err |= !doNotMergeCheckEqual("/manifest/supports-screens",    libDoc);     //$NON-NLS-1$
-        err |= !doNotMergeCheckEqual("/manifest/compatible-screens",  libDoc);     //$NON-NLS-1$
-        err |= !doNotMergeCheckEqual("/manifest/supports-gl-texture", libDoc);     //$NON-NLS-1$
-
-        boolean skipApplication = hasOverrideOrRemoveTag(
-                findFirstElement(mMainDoc, "/manifest/application"));  //$NON-NLS-1$
-
-        // Strategy C
-        if (!skipApplication) {
-            err |= !mergeNewOrEqual(
-                    "/manifest/application/activity",                           //$NON-NLS-1$
-                    "name",                                                     //$NON-NLS-1$
-                    libDoc,
-                    true);
-            err |= !mergeNewOrEqual(
-                    "/manifest/application/activity-alias",                     //$NON-NLS-1$
-                    "name",                                                     //$NON-NLS-1$
-                    libDoc,
-                    true);
-            err |= !mergeNewOrEqual(
-                    "/manifest/application/service",                            //$NON-NLS-1$
-                    "name",                                                     //$NON-NLS-1$
-                    libDoc,
-                    true);
-            err |= !mergeNewOrEqual(
-                    "/manifest/application/receiver",                           //$NON-NLS-1$
-                    "name",                                                     //$NON-NLS-1$
-                    libDoc,
-                    true);
-            err |= !mergeNewOrEqual(
-                    "/manifest/application/provider",                           //$NON-NLS-1$
-                    "name",                                                     //$NON-NLS-1$
-                    libDoc,
-                    true);
-        }
-        err |= !mergeNewOrEqual(
-                "/manifest/permission",                                         //$NON-NLS-1$
-                "name",                                                         //$NON-NLS-1$
-                libDoc,
-                false);
-        err |= !mergeNewOrEqual(
-                "/manifest/permission-group",                                   //$NON-NLS-1$
-                "name",                                                         //$NON-NLS-1$
-                libDoc,
-                false);
-        err |= !mergeNewOrEqual(
-                "/manifest/permission-tree",                                    //$NON-NLS-1$
-                "name",                                                         //$NON-NLS-1$
-                libDoc,
-                false);
-        err |= !mergeNewOrEqual(
-                "/manifest/uses-permission",                                    //$NON-NLS-1$
-                "name",                                                         //$NON-NLS-1$
-                libDoc,
-                false);
-
-        // Strategy D
-        if (!skipApplication) {
-            err |= !mergeAdjustRequired(
-                    "/manifest/application/uses-library",                       //$NON-NLS-1$
-                    "name",                                                     //$NON-NLS-1$
-                    "required",                                                 //$NON-NLS-1$
-                    libDoc,
-                    null /*alternateKeyAttr*/);
-            err |= !mergeNewOrEqual(
-                    "/manifest/application/meta-data",                          //$NON-NLS-1$
-                    "name",                                                     //$NON-NLS-1$
-                    libDoc,
-                    true);
-        }
-        err |= !mergeAdjustRequired(
-                "/manifest/uses-feature",                                       //$NON-NLS-1$
-                "name",                                                         //$NON-NLS-1$
-                "required",                                                     //$NON-NLS-1$
-                libDoc,
-                "glEsVersion" /*alternateKeyAttr*/);
-
-        // Strategy E
-        err |= !checkSdkVersion(libDoc);
-
-        // Strategy F
-        err |= !checkGlEsVersion(libDoc);
-
-        return !err;
-    }
-
-    /**
-     * Expand all possible class names attributes in the given document.
-     * <p/>
-     * Some manifest attributes represent class names. These can be specified as fully
-     * qualified class names or use a short notation consisting of just the terminal
-     * class simple name or a dot followed by a partial class name. Unfortunately this
-     * makes textual comparison of the attributes impossible. To simplify this, we can
-     * modify the document to fully expand all these class names. The list of elements
-     * and attributes to process is listed by {@link #sClassAttributes} and the expansion
-     * simply consists of appending the manifest' package if defined.
-     *
-     * @param doc The document in which to expand potential FQCNs.
-     */
-    private void expandFqcns(Document doc) {
-        // Find the package attribute of the manifest.
-        String pkg = null;
-        Element manifest = findFirstElement(doc, "/manifest");
-        if (manifest != null) {
-            pkg = manifest.getAttribute("package");
-        }
-
-        if (pkg == null || pkg.isEmpty()) {
-            // We can't adjust FQCNs if we don't know the root package name.
-            // It's not a proper manifest if this is missing anyway.
-            assert manifest != null;
-            mLog.error(Severity.WARNING,
-                    xmlFileAndLine(manifest),
-                    "Missing 'package' attribute in manifest.");
-            return;
-        }
-
-        for (String elementAttr : sClassAttributes) {
-            String[] names = elementAttr.split("/");
-            if (names.length != 2) {
-                continue;
-            }
-            String elemName = names[0];
-            String attrName = names[1];
-            NodeList elements = doc.getElementsByTagName(elemName);
-            for (int i = 0; i < elements.getLength(); i++) {
-                Node elem = elements.item(i);
-                if (elem instanceof Element) {
-                    Attr attr = ((Element) elem).getAttributeNodeNS(NS_URI, attrName);
-                    if (attr != null) {
-                        String value = attr.getNodeValue();
-
-                        // We know it's a shortened FQCN if it starts with a dot
-                        // or does not contain any dot.
-                        if (value != null && !value.isEmpty() &&
-                                (value.indexOf('.') == -1 || value.charAt(0) == '.')) {
-                            if (value.charAt(0) == '.') {
-                                value = pkg + value;
-                            } else {
-                                value = pkg + '.' + value;
-                            }
-                            attr.setNodeValue(value);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Extracts the fully qualified class names from the manifest and uses the
-     * prefix notation relative to the manifest package. This basically reverses
-     * the effects of {@link #expandFqcns(Document)}, though of course it may
-     * also remove prefixes which were inlined in the original documents.
-     *
-     * @param doc the document in which to extract the FQCNs.
-     */
-    private void extractFqcns(Document doc) {
-        // Find the package attribute of the manifest.
-        String pkg = null;
-        Element manifest = findFirstElement(doc, "/manifest");
-        if (manifest != null) {
-            pkg = manifest.getAttribute("package");
-        }
-
-        if (pkg == null || pkg.isEmpty()) {
-            return;
-        }
-
-        int pkgLength = pkg.length();
-        for (String elementAttr : sClassAttributes) {
-            String[] names = elementAttr.split("/");
-            if (names.length != 2) {
-                continue;
-            }
-            String elemName = names[0];
-            String attrName = names[1];
-            NodeList elements = doc.getElementsByTagName(elemName);
-            for (int i = 0; i < elements.getLength(); i++) {
-                Node elem = elements.item(i);
-                if (elem instanceof Element) {
-                    Attr attr = ((Element) elem).getAttributeNodeNS(NS_URI, attrName);
-                    if (attr != null) {
-                        String value = attr.getNodeValue();
-
-                        // We know it's a shortened FQCN if it starts with a dot
-                        // or does not contain any dot.
-                        if (value != null && value.length() > pkgLength &&
-                                value.startsWith(pkg) && value.charAt(pkgLength) == '.') {
-                            value = value.substring(pkgLength);
-                            attr.setNodeValue(value);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Checks (but does not merge) the application attributes using the following rules:
-     * <pre>
-     * - {@code @name}: Ignore if empty. Warning if its expanded FQCN doesn't match the main doc.
-     * - {@code @backupAgent}:  Ignore if empty. Warning if its expanded FQCN doesn't match main doc.
-     * - All other attributes are ignored.
-     * </pre>
-     * The name and backupAgent represent classes and the merger will warn since if a lib has
-     * these defined they will never be used anyway.
-     * @param libDoc The library document to merge from. Must not be null.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    private boolean checkApplication(Document libDoc) {
-
-        Element mainApp = findFirstElement(mMainDoc, "/manifest/application");  //$NON-NLS-1$
-        Element libApp  = findFirstElement(libDoc,   "/manifest/application");  //$NON-NLS-1$
-
-        // A manifest does not necessarily define an application.
-        // If the lib has none, there's nothing to check for.
-        if (libApp == null) {
-            return true;
-        }
-        if (hasOverrideOrRemoveTag(mainApp)) {
-            // Don't check the <application> element since it is tagged with override or remove.
-            return true;
-        }
-
-        for (String attrName : new String[] { "name", "backupAgent" }) {
-            String libValue  = getAttributeValue(libApp, attrName);
-            if (libValue == null || libValue.isEmpty()) {
-                // Nothing to do if the attribute is not defined in the lib.
-                continue;
-            }
-            // The main doc does not have to have an application node.
-            String mainValue = mainApp == null ? "" : getAttributeValue(mainApp, attrName);
-            if (!libValue.equals(mainValue)) {
-                assert mainApp != null;
-                mLog.conflict(Severity.WARNING,
-                        xmlFileAndLine(mainApp),
-                        xmlFileAndLine(libApp),
-                        mainApp == null ?
-                                "Library has <application android:%1$s='%3$s'> but main manifest has no application element." :
-                                "Main manifest has <application android:%1$s='%2$s'> but library uses %1$s='%3$s'.",
-                        attrName,
-                        mainValue,
-                        libValue);
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Do not merge anything. Instead it checks that the requested elements from the
-     * given library are all present and equal in the destination and prints a warning
-     * if it's not the case.
-     * <p/>
-     * For example if a library supports a given screen configuration, print a
-     * warning if the main manifest doesn't indicate the app supports the same configuration.
-     * We should not merge it since we don't want to silently give the impression an app
-     * supports a configuration just because it uses a library which does.
-     * On the other hand we don't want to silently ignore this fact.
-     * <p/>
-     * TODO there should be a way to silence this warning.
-     * The current behavior is certainly arbitrary and needs to be tweaked somehow.
-     *
-     * @param path The XPath of the elements to merge from the library. Must not be null.
-     * @param libDoc The library document to merge from. Must not be null.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    private boolean doNotMergeCheckEqual(String path, Document libDoc) {
-
-        for (Element src : findElements(libDoc, path)) {
-
-            boolean found = false;
-
-            for (Element dest : findElements(mMainDoc, path)) {
-                if (hasOverrideOrRemoveTag(dest)) {
-                    continue;
-                }
-                if (compareElements(dest, src, false, null /*diff*/, null /*keyAttr*/)) {
-                    found = true;
-                    break;
-                }
-            }
-
-            if (!found) {
-                mLog.conflict(Severity.WARNING,
-                        xmlFileAndLine(mMainDoc),
-                        xmlFileAndLine(src),
-                        "%1$s defined in library, missing from main manifest:\n%2$s",
-                        path,
-                        MergerXmlUtils.dump(src, false /*nextSiblings*/));
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Merges the requested elements from the library in the main document.
-     * The key attribute name is used to identify the same elements.
-     * Merged elements must either not exist in the destination or be identical.
-     * <p/>
-     * When merging, append to the end of the application element.
-     * Also merges any preceding whitespace and up to one comment just prior to the merged element.
-     *
-     * @param path The XPath of the elements to merge from the library. Must not be null.
-     * @param keyAttr The Android-namespace attribute used as key to identify similar elements.
-     *   E.g. "name" for "android:name"
-     * @param libDoc The library document to merge from. Must not be null.
-     * @param warnDups When true, will print a warning when a library definition is already
-     *   present in the destination and is equal.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    private boolean mergeNewOrEqual(
-            String path,
-            String keyAttr,
-            Document libDoc,
-            boolean warnDups) {
-
-        // The parent of XPath /p1/p2/p3 is /p1/p2. To find it, delete the last "/segment"
-        int pos = path.lastIndexOf('/');
-        assert pos > 1;
-        String parentPath = path.substring(0, pos);
-        Element parent = findFirstElement(mMainDoc, parentPath);
-        assert parent != null;
-        if (parent == null) {
-            mLog.error(Severity.ERROR,
-                    xmlFileAndLine(mMainDoc),
-                    "Could not find element %1$s.",
-                    parentPath);
-            return false;
-        }
-
-        boolean success = true;
-
-        nextSource: for (Element src : findElements(libDoc, path)) {
-            String name = getAttributeValue(src, keyAttr);
-            if (name.isEmpty()) {
-                mLog.error(Severity.ERROR,
-                        xmlFileAndLine(src),
-                        "Undefined '%1$s' attribute in %2$s.",
-                        keyAttr, path);
-                success = false;
-                continue;
-            }
-
-            // Look for the same item in the destination
-            List<Element> dests = findElements(mMainDoc, path, keyAttr, name);
-            if (dests.size() > 1) {
-                // This should not be happening. We'll just use the first one found in this case.
-                mLog.error(Severity.WARNING,
-                        xmlFileAndLine(dests.get(0)),
-                        "Manifest has more than one %1$s[@%2$s=%3$s] element.",
-                        path, keyAttr, name);
-            }
-            boolean doMerge = true;
-            for (Element dest : dests) {
-                // Don't try to merge this element since it has tools:merge=override|remove.
-                if (hasOverrideOrRemoveTag(dest)) {
-                    doMerge = false;
-                    continue;
-                }
-                // If there's already a similar node in the destination, check it's identical.
-                StringBuilder diff = new StringBuilder();
-                if (compareElements(dest, src, false, diff, keyAttr)) {
-                    // Same element. Skip.
-                    if (warnDups) {
-                        mLog.conflict(Severity.INFO,
-                                xmlFileAndLine(dest),
-                                xmlFileAndLine(src),
-                                "Skipping identical %1$s[@%2$s=%3$s] element.",
-                                path, keyAttr, name);
-                    }
-                    continue nextSource;
-                } else {
-                    // Print the diff we got from the comparison.
-                    mLog.conflict(Severity.ERROR,
-                            xmlFileAndLine(dest),
-                            xmlFileAndLine(src),
-                            "Trying to merge incompatible %1$s[@%2$s=%3$s] element:\n%4$s",
-                            path, keyAttr, name, diff.toString());
-                    success = false;
-                    continue nextSource;
-                }
-            }
-
-            if (doMerge) {
-                // Ready to merge element src. Select which previous siblings to merge.
-                Node start = selectPreviousSiblings(src);
-
-                insertAtEndOf(parent, start, src);
-            }
-        }
-
-        return success;
-    }
-
-    /**
-     * Returns the value of the given "android:attribute" in the given element.
-     *
-     * @param element The non-null element where to extract the attribute.
-     * @param attrName The local name of the attribute.
-     *                 It must use the {@link #NS_URI} but no prefix should be specified here.
-     * @return The value of the attribute or a non-null empty string if not found.
-     */
-    private String getAttributeValue(Element element, String attrName) {
-        Attr attr = element.getAttributeNodeNS(NS_URI, attrName);
-        String value = attr == null ? "" : attr.getNodeValue();  //$NON-NLS-1$
-        return value;
-    }
-
-    /**
-     * Merge elements as identified by their key name attribute.
-     * The element must have an option boolean "required" attribute which can be either "true" or
-     * "false". Default is true if the attribute is missing. When merging, a "false" is superseded
-     * by a "true" (explicit or implicit).
-     * <p/>
-     * When merging, this does NOT merge any other attributes than {@code keyAttr} and
-     * {@code requiredAttr}.
-     *
-     * @param path The XPath of the elements to merge from the library. Must not be null.
-     * @param keyAttr The Android-namespace attribute used as key to identify similar elements.
-     *   E.g. "name" for "android:name"
-     * @param requiredAttr The name of the Android-namespace boolean attribute that must be merged.
-     *   Typically should be "required".
-     * @param libDoc The library document to merge from. Must not be null.
-     * @param alternateKeyAttr When non-null, this is an alternate valid key attribute. If the
-     *   default key attribute is missing, we won't output a warning if the alternate one is
-     *   present.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    private boolean mergeAdjustRequired(
-            String path,
-            String keyAttr,
-            String requiredAttr,
-            Document libDoc,
-            @Nullable String alternateKeyAttr) {
-
-        // The parent of XPath /p1/p2/p3 is /p1/p2. To find it, delete the last "/segment"
-        int pos = path.lastIndexOf('/');
-        assert pos > 1;
-        String parentPath = path.substring(0, pos);
-        Element parent = findFirstElement(mMainDoc, parentPath);
-        assert parent != null;
-        if (parent == null) {
-            mLog.error(Severity.ERROR,
-                    xmlFileAndLine(mMainDoc),
-                    "Could not find element %1$s.",
-                    parentPath);
-            return false;
-        }
-
-        boolean success = true;
-
-        for (Element src : findElements(libDoc, path)) {
-            Attr attr = src.getAttributeNodeNS(NS_URI, keyAttr);
-            String name = attr == null ? "" : attr.getNodeValue().trim();  //$NON-NLS-1$
-            if (name.isEmpty()) {
-                if (alternateKeyAttr != null) {
-                    attr = src.getAttributeNodeNS(NS_URI, alternateKeyAttr);
-                    String s = attr == null ? "" : attr.getNodeValue().trim(); //$NON-NLS-1$
-                    if (!s.isEmpty()) {
-                        // This element lacks the keyAttr but has the alternateKeyAttr. Skip it.
-                        continue;
-                    }
-                }
-
-                mLog.error(Severity.ERROR,
-                        xmlFileAndLine(src),
-                        "Undefined '%1$s' attribute in %2$s.",
-                        keyAttr, path);
-                success = false;
-                continue;
-            }
-
-            // Look for the same item in the destination
-            List<Element> dests = findElements(mMainDoc, path, keyAttr, name);
-            if (dests.size() > 1) {
-                // This should not be happening. We'll just use the first one found in this case.
-                mLog.error(Severity.WARNING,
-                        xmlFileAndLine(dests.get(0)),
-                        "Manifest has more than one %1$s[@%2$s=%3$s] element.",
-                        path, keyAttr, name);
-            }
-            if (!dests.isEmpty()) {
-
-                attr = src.getAttributeNodeNS(NS_URI, requiredAttr);
-                String value = attr == null ? "true" : attr.getNodeValue();    //$NON-NLS-1$
-                if (value == null || !(value.equals("true") || value.equals("false"))) {
-                    mLog.error(Severity.WARNING,
-                            xmlFileAndLine(src),
-                            "Invalid attribute '%1$s' in %2$s[@%3$s=%4$s] element:\nExpected 'true' or 'false' but found '%5$s'.",
-                            requiredAttr, path, keyAttr, name, value);
-                    continue;
-                }
-                boolean boolE = Boolean.parseBoolean(value);
-
-                for (Element dest : dests) {
-                    // Don't try to merge this element since it has tools:merge=override|remove.
-                    if (hasOverrideOrRemoveTag(dest)) {
-                        continue;
-                    }
-
-                    // Compare the required attributes.
-                    attr = dest.getAttributeNodeNS(NS_URI, requiredAttr);
-                    value = attr == null ? "true" : attr.getNodeValue();    //$NON-NLS-1$
-                    if (value == null || !(value.equals("true") || value.equals("false"))) {
-                        mLog.error(Severity.WARNING,
-                                xmlFileAndLine(dest),
-                                "Invalid attribute '%1$s' in %2$s[@%3$s=%4$s] element:\nExpected 'true' or 'false' but found '%5$s'.",
-                                requiredAttr, path, keyAttr, name, value);
-                        continue;
-                    }
-                    boolean boolD = Boolean.parseBoolean(value);
-
-                    if (!boolD && boolE) {
-                        // Required attributes differ: destination is false and source was true
-                        // so we need to change the destination to true.
-
-                        // If attribute was already in the destination, change it in place
-                        if (attr != null) {
-                            attr.setNodeValue("true");                        //$NON-NLS-1$
-                        } else {
-                            // Otherwise, do nothing. The destination doesn't have the
-                            // required=true attribute, and true is the default value.
-                            // Consequently not setting is the right thing to do.
-
-                            // -- code snippet for reference --
-                            // If we wanted to create a new attribute, we'd use the code
-                            // below. There's a simpler call to d.setAttributeNS(ns, name, value)
-                            // but experience shows that it would create a new prefix out of the
-                            // blue instead of looking it up.
-                            //
-                            // Attr a=d.getOwnerDocument().createAttributeNS(NS_URI, requiredAttr);
-                            // String prefix = d.lookupPrefix(NS_URI);
-                            // if (prefix != null) {
-                            //     a.setPrefix(prefix);
-                            // }
-                            // a.setValue("true");  //$NON-NLS-1$
-                            // d.setAttributeNodeNS(attr);
-                        }
-                    }
-                }
-            } else {
-                // Destination doesn't exist. We simply merge the source element.
-                // Select which previous siblings to merge.
-                Node start = selectPreviousSiblings(src);
-
-                Node node = insertAtEndOf(parent, start, src);
-
-                NamedNodeMap attrs = node.getAttributes();
-                if (attrs != null) {
-                    for (int i = 0; i < attrs.getLength(); i++) {
-                        Node a = attrs.item(i);
-                        if (a.getNodeType() == Node.ATTRIBUTE_NODE) {
-                            boolean keep = NS_URI.equals(a.getNamespaceURI());
-                            if (keep) {
-                                name = a.getLocalName();
-                                keep = keyAttr.equals(name) || requiredAttr.equals(name);
-                            }
-                            if (!keep) {
-                                attrs.removeNamedItemNS(NS_URI, name);
-                                // Restart the loop from index 0 since there's no
-                                // guarantee on the order of the nodes in the "map".
-                                // This makes it O(n+2n) at most, where n is [2..3] in
-                                // a typical case.
-                                i = -1;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return success;
-    }
-
-
-
-    /**
-     * Checks (but does not merge) uses-feature glEsVersion attribute using the following rules:
-     * <pre>
-     * - Error if defined in lib+dest with dest&lt;lib.
-     * - Never automatically change dest.
-     * - Default implied value is 1.0 (0x00010000).
-     * </pre>
-     *
-     * @param libDoc The library document to merge from. Must not be null.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    private boolean checkGlEsVersion(Document libDoc) {
-
-        String parentPath = "/manifest";                                    //$NON-NLS-1$
-        Element parent = findFirstElement(mMainDoc, parentPath);
-        assert parent != null;
-        if (parent == null) {
-            mLog.error(Severity.ERROR,
-                    xmlFileAndLine(mMainDoc),
-                    "Could not find element %1$s.",
-                    parentPath);
-            return false;
-        }
-
-        // Find the max glEsVersion on the destination side
-        String path = "/manifest/uses-feature";                             //$NON-NLS-1$
-        String keyAttr = "glEsVersion";                                     //$NON-NLS-1$
-        long destGlEsVersion = 0x00010000L; // default minimum is 1.0
-        Element destNode = null;
-        boolean result = true;
-        for (Element dest : findElements(mMainDoc, path)) {
-            Attr attr = dest.getAttributeNodeNS(NS_URI, keyAttr);
-            String value = attr == null ? "" : attr.getNodeValue().trim();   //$NON-NLS-1$
-            if (!value.isEmpty()) {
-                try {
-                    // Note that the value can be an hex number such as 0x00020001 so we
-                    // need Integer.decode instead of Integer.parseInt.
-                    // Note: Integer.decode cannot handle "ffffffff", see JDK issue 6624867
-                    // so we just treat the version as a long and test like this, ignoring
-                    // the fact that a value of 0xFFFF/.0xFFFF is probably invalid anyway
-                    // in the context of glEsVersion.
-                    long version = Long.decode(value);
-                    if (version >= destGlEsVersion) {
-                        destGlEsVersion = version;
-                        destNode = dest;
-                    } else if (version < 0x00010000) {
-                        mLog.error(Severity.WARNING,
-                                xmlFileAndLine(dest),
-                                "Ignoring <uses-feature android:glEsVersion='%1$s'> because it's smaller than 1.0.",
-                                value);
-                    }
-                } catch (NumberFormatException e) {
-                    // Note: NumberFormatException.toString() has no interesting information
-                    // so we don't output it.
-                    mLog.error(Severity.ERROR,
-                            xmlFileAndLine(dest),
-                            "Failed to parse <uses-feature android:glEsVersion='%1$s'>: must be an integer in the form 0x00020001.",
-                            value);
-                    result = false;
-                }
-            }
-        }
-
-        // If we found at least one valid with no error, use that, otherwise bail out.
-        if (!result && destNode == null) {
-            return false;
-        }
-
-        // Now find the max glEsVersion on the source side.
-
-        long srcGlEsVersion = 0x00010000L; // default minimum is 1.0
-        Element srcNode = null;
-        result = true;
-        for (Element src : findElements(libDoc, path)) {
-            Attr attr = src.getAttributeNodeNS(NS_URI, keyAttr);
-            String value = attr == null ? "" : attr.getNodeValue().trim();   //$NON-NLS-1$
-            if (!value.isEmpty()) {
-                try {
-                    // See comment on Long.decode above.
-                    long version = Long.decode(value);
-                    if (version >= srcGlEsVersion) {
-                        srcGlEsVersion = version;
-                        srcNode = src;
-                    } else if (version < 0x00010000) {
-                        mLog.error(Severity.WARNING,
-                                xmlFileAndLine(src),
-                                "Ignoring <uses-feature android:glEsVersion='%1$s'> because it's smaller than 1.0.",
-                                value);
-                    }
-                } catch (NumberFormatException e) {
-                    // Note: NumberFormatException.toString() has no interesting information
-                    // so we don't output it.
-                    mLog.error(Severity.ERROR,
-                            xmlFileAndLine(src),
-                            "Failed to parse <uses-feature android:glEsVersion='%1$s'>: must be an integer in the form 0x00020001.",
-                            value);
-                    result = false;
-                }
-            }
-        }
-
-        if (srcNode != null && destGlEsVersion < srcGlEsVersion) {
-            mLog.conflict(Severity.WARNING,
-                    xmlFileAndLine(destNode == null ? mMainDoc : destNode),
-                    xmlFileAndLine(srcNode),
-                    "Main manifest has <uses-feature android:glEsVersion='0x%1$08x'> but library uses glEsVersion='0x%2$08x'%3$s",
-                    destGlEsVersion,
-                    srcGlEsVersion,
-                    destNode != null ? "" :   //$NON-NLS-1$
-                            "\nNote: main manifest lacks a <uses-feature android:glEsVersion> declaration, and thus defaults to glEsVersion=0x00010000."
-            );
-            result = false;
-        }
-
-        return result;
-    }
-
-    /**
-     * Checks (but does not merge) uses-sdk attributes using the following rules:
-     * <pre>
-     * - {@code @minSdkVersion}: error if dest&lt;lib. Never automatically change dest minsdk.
-     * - {@code @targetSdkVersion}: warning if dest&lt;lib. Never automatically change destination.
-     * - {@code @maxSdkVersion}: obsolete, ignored. Not used in comparisons and not merged.
-     * - The API level can be a codename if we have a callback that can convert it to an integer.
-     * </pre>
-     * @param libDoc The library document to merge from. Must not be null.
-     * @return True on success, false if any error occurred (printed to the {@link IMergerLog}).
-     */
-    private boolean checkSdkVersion(Document libDoc) {
-
-        boolean result = true;
-
-        Element destUsesSdk = findFirstElement(mMainDoc, "/manifest/uses-sdk");  //$NON-NLS-1$
-
-        if (hasOverrideOrRemoveTag(destUsesSdk)) {
-            // Don't try to check this element since it has tools:merge=override|remove.
-            return true;
-        }
-
-        Element srcUsesSdk  = findFirstElement(libDoc,   "/manifest/uses-sdk");  //$NON-NLS-1$
-
-        AtomicInteger destValue = new AtomicInteger(1);
-        AtomicInteger srcValue  = new AtomicInteger(1);
-        AtomicBoolean destImplied = new AtomicBoolean(true);
-        AtomicBoolean srcImplied = new AtomicBoolean(true);
-
-        // Check minSdkVersion
-        int destMinSdk = 1;
-        result = extractSdkVersionAttribute(
-                libDoc,
-                destUsesSdk, srcUsesSdk,
-                "min",  //$NON-NLS-1$
-                destValue, srcValue,
-                destImplied, srcImplied);
-
-        if (result) {
-            // Make it an error for an application to use a library with a greater
-            // minSdkVersion. This means the library code may crash unexpectedly.
-            // TODO it would be nice to be able to work around this in case the
-            // user think s/he knows what s/he's doing.
-            // We could define a simple XML comment flag: <!-- @NoMinSdkVersionMergeError -->
-
-            destMinSdk = destValue.get();
-
-            if (destMinSdk < srcValue.get()) {
-                mLog.conflict(Severity.ERROR,
-                        xmlFileAndLine(destUsesSdk == null ? mMainDoc : destUsesSdk),
-                        xmlFileAndLine(srcUsesSdk == null ? libDoc : srcUsesSdk),
-                        "Main manifest has <uses-sdk android:minSdkVersion='%1$d'> but library uses minSdkVersion='%2$d'%3$s",
-                        destMinSdk,
-                        srcValue.get(),
-                        !destImplied.get() ? "" :   //$NON-NLS-1$
-                                "\nNote: main manifest lacks a <uses-sdk android:minSdkVersion> declaration, which defaults to value 1."
-                );
-                result = false;
-            }
-        }
-
-        // Check targetSdkVersion.
-
-        // Note that destValue/srcValue purposely defaults to whatever minSdkVersion was last read
-        // since that's their definition when missing.
-        destImplied.set(true);
-        srcImplied.set(true);
-
-        boolean result2 = extractSdkVersionAttribute(
-                libDoc,
-                destUsesSdk, srcUsesSdk,
-                "target",  //$NON-NLS-1$
-                destValue, srcValue,
-                destImplied, srcImplied);
-
-        result &= result2;
-        if (result2) {
-            // Make it a warning for an application to use a library with a greater
-            // targetSdkVersion.
-
-            int destTargetSdk = destImplied.get() ? destMinSdk : destValue.get();
-
-            if (destTargetSdk < srcValue.get()) {
-                mLog.conflict(Severity.WARNING,
-                        xmlFileAndLine(destUsesSdk == null ? mMainDoc : destUsesSdk),
-                        xmlFileAndLine(srcUsesSdk == null ? libDoc : srcUsesSdk),
-                        "Main manifest has <uses-sdk android:targetSdkVersion='%1$d'> but library uses targetSdkVersion='%2$d'%3$s",
-                        destTargetSdk,
-                        srcValue.get(),
-                        !destImplied.get() ? "" :   //$NON-NLS-1$
-                                "\nNote: main manifest lacks a <uses-sdk android:targetSdkVersion> declaration, which defaults to value minSdkVersion or 1."
-                );
-                result = false;
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * Implementation detail for {@link #checkSdkVersion(Document)}.
-     * Note that the various atomic out-variables must be preset to their default before
-     * the call.
-     * <p/>
-     * destValue/srcValue will be filled with the integer value of the field, if present
-     * and a correct number, in which case destImplied/destImplied are also set to true.
-     * Otherwise the values and the implied variables are left untouched.
-     */
-    private boolean extractSdkVersionAttribute(
-            Document libDoc,
-            Element destUsesSdk,
-            Element srcUsesSdk,
-            String attr,
-            AtomicInteger destValue,
-            AtomicInteger srcValue,
-            AtomicBoolean destImplied,
-            AtomicBoolean srcImplied) {
-        String s = destUsesSdk == null ? ""                                      //$NON-NLS-1$
-                : destUsesSdk.getAttributeNS(NS_URI, attr + "SdkVersion");  //$NON-NLS-1$
-
-        boolean result = true;
-        assert s != null;
-        s = s.trim();
-        try {
-            if (!s.isEmpty()) {
-                destValue.set(Integer.parseInt(s));
-                destImplied.set(false);
-            }
-        } catch (NumberFormatException e) {
-            boolean error = true;
-            if (mCallback != null) {
-                // Versions can contain codenames such as "JellyBean".
-                // We'll accept it only if have a callback that can give us the API level for it.
-                int apiLevel = mCallback.queryCodenameApiLevel(s);
-                if (apiLevel > ICallback.UNKNOWN_CODENAME) {
-                    destValue.set(apiLevel);
-                    destImplied.set(false);
-                    error = false;
-                }
-            }
-            if (error) {
-                // Note: NumberFormatException.toString() has no interesting information
-                // so we don't output it.
-                mLog.error(Severity.ERROR,
-                        xmlFileAndLine(destUsesSdk == null ? mMainDoc : destUsesSdk),
-                        "Failed to parse <uses-sdk %1$sSdkVersion='%2$s'>: must be an integer number or codename.",
-                        attr,
-                        s);
-                result = false;
-            }
-        }
-
-        s = srcUsesSdk == null ? ""                                      //$NON-NLS-1$
-                : srcUsesSdk.getAttributeNS(NS_URI, attr + "SdkVersion");  //$NON-NLS-1$
-        assert s != null;
-        s = s.trim();
-        try {
-            if (!s.isEmpty()) {
-                srcValue.set(Integer.parseInt(s));
-                srcImplied.set(false);
-            }
-        } catch (NumberFormatException e) {
-            boolean error = true;
-            if (mCallback != null) {
-                // Versions can contain codenames such as "JellyBean".
-                // We'll accept it only if have a callback that can give us the API level for it.
-                int apiLevel = mCallback.queryCodenameApiLevel(s);
-                if (apiLevel > ICallback.UNKNOWN_CODENAME) {
-                    srcValue.set(apiLevel);
-                    srcImplied.set(false);
-                    error = false;
-                }
-            }
-            if (error) {
-                mLog.error(Severity.ERROR,
-                        xmlFileAndLine(srcUsesSdk == null ? libDoc : srcUsesSdk),
-                        "Failed to parse <uses-sdk %1$sSdkVersion='%2$s'>: must be an integer number or codename.",
-                        attr,
-                        s);
-                result = false;
-            }
-        }
-
-        return result;
-    }
-
-
-    // -----
-
-
-    /**
-     * Given an element E, select which previous siblings we want to merge.
-     * We want to include any whitespace up to the closing of the previous element.
-     * We also want to include up preceding comment nodes and their preceding whitespace.
-     * <p/>
-     * This may returns either {@code end} or a previous sibling. Never returns null.
-     */
-    @NonNull
-    private Node selectPreviousSiblings(Node end) {
-
-        Node start = end;
-        Node prev = start.getPreviousSibling();
-        while (prev != null) {
-            short t = prev.getNodeType();
-            if (t == Node.TEXT_NODE) {
-                String text = prev.getNodeValue();
-                if (text == null || !text.trim().isEmpty()) {
-                    // Not whitespace, we don't want it.
-                    break;
-                }
-            } else if (t == Node.COMMENT_NODE) {
-                // It's a comment. We'll take it.
-            } else {
-                // Not a comment node nor a whitespace text. We don't want it.
-                break;
-            }
-            start = prev;
-            prev = start.getPreviousSibling();
-        }
-
-        return start;
-    }
-
-    /**
-     * Inserts all siblings from {@code start} to {@code end} at the end
-     * of the given destination element.
-     * <p/>
-     * Implementation detail: this clones the source nodes into the destination.
-     *
-     * @param dest The destination at the end of which to insert. Cannot be null.
-     * @param start The first element to insert. Must not be null.
-     * @param end The last element to insert (included). Must not be null.
-     *   Must be a direct "next sibling" of the start node.
-     *   Can be equal to the start node to insert just that one node.
-     * @return The copy of the {@code end} node in the destination document or null
-     *   if no such copy was created and added to the destination.
-     */
-    private Node insertAtEndOf(Element dest, Node start, Node end) {
-        // Check whether we'll need to adjust URI prefixes
-        String destPrefix = XmlUtils.lookupNamespacePrefix(mMainDoc, NS_URI);
-        String srcPrefix  = XmlUtils.lookupNamespacePrefix(start.getOwnerDocument(), NS_URI);
-        boolean needPrefixChange = destPrefix != null && !destPrefix.equals(srcPrefix);
-
-        // First let's figure out the insertion point.
-        // We want the end of the last 'content' element of the
-        // destination element and basically we want to insert right
-        // before the last whitespace of the destination element.
-        Node target = dest.getLastChild();
-        while (target != null) {
-            if (target.getNodeType() == Node.TEXT_NODE) {
-                String text = target.getNodeValue();
-                if (text == null || !text.trim().isEmpty()) {
-                    // Not whitespace, insert after.
-                    break;
-                }
-            } else {
-                // Not text. Insert after
-                break;
-            }
-            target = target.getPreviousSibling();
-        }
-        if (target != null) {
-            target = target.getNextSibling();
-        }
-
-        // Destination and start..end must not be part of the same document
-        // because we try to import below. If they were, it would mess the
-        // structure.
-        assert dest.getOwnerDocument() == mMainDoc;
-        assert dest.getOwnerDocument() != start.getOwnerDocument();
-        assert start.getOwnerDocument() == end.getOwnerDocument();
-
-        while (start != null) {
-            Node node = mMainDoc.importNode(start, true /*deep*/);
-            if (needPrefixChange) {
-                changePrefix(node, srcPrefix, destPrefix);
-            }
-
-            if (mInsertSourceMarkers) {
-                // Duplicate source node attribute
-                File file = MergerXmlUtils.getFileFor(start);
-                if (file != null) {
-                    MergerXmlUtils.setFileFor(node, file);
-                }
-            }
-
-            dest.insertBefore(node, target);
-
-            if (start == end) {
-                return node;
-            }
-            start = start.getNextSibling();
-        }
-        return null;
-    }
-
-    /**
-     * Changes the namespace prefix of all nodes, recursively.
-     *
-     * @param node The node to process, as well as all it's descendants. Can be null.
-     * @param srcPrefix The prefix to match.
-     * @param destPrefix The new prefix to replace with.
-     */
-    private void changePrefix(Node node, String srcPrefix, String destPrefix) {
-        for (; node != null; node = node.getNextSibling()) {
-            if (srcPrefix.equals(node.getPrefix())) {
-                node.setPrefix(destPrefix);
-            }
-            Node child = node.getFirstChild();
-            if (child != null) {
-                changePrefix(child, srcPrefix, destPrefix);
-            }
-        }
-    }
-
-    /**
-     * Compares two {@link Element}s recursively.
-     * They must be identical with the same structure.
-     * Order should not matter.
-     * Whitespace and comments are ignored.
-     *
-     * @param expected The first element to compare.
-     * @param actual The second element to compare with.
-     * @param nextSiblings If true, will also compare the following siblings.
-     *   If false, it will just compare the given node.
-     * @param diff An optional {@link StringBuilder} where to accumulate a diff output.
-     * @param keyAttr An optional key attribute to always add to elements when dumping a diff.
-     * @return True if {@code e1} and {@code e2} are equal.
-     */
-    private boolean compareElements(
-            @NonNull Node expected,
-            @NonNull Node actual,
-            boolean nextSiblings,
-            @Nullable StringBuilder diff,
-            @Nullable String keyAttr) {
-        Map<String, String> nsPrefixE = new HashMap<String, String>();
-        Map<String, String> nsPrefixA = new HashMap<String, String>();
-        String sE = MergerXmlUtils.printElement(expected, nsPrefixE, "");           //$NON-NLS-1$
-        String sA = MergerXmlUtils.printElement(actual,   nsPrefixA, "");           //$NON-NLS-1$
-        if (sE.equals(sA)) {
-            return true;
-        } else {
-            if (diff != null) {
-                MergerXmlUtils.printXmlDiff(diff, sE, sA, nsPrefixE, nsPrefixA, NS_URI + ':' + keyAttr);
-            }
-            return false;
-        }
-    }
-
-    /**
-     * Finds the first element matching the given XPath expression in the given document.
-     *
-     * @param doc The document where to find the expression.
-     * @param path The XPath expression. It must yield an {@link Element} node type.
-     * @return The {@link Element} found or null.
-     */
-    @Nullable
-    private Element findFirstElement(
-            @NonNull Document doc,
-            @NonNull String path) {
-        Node result;
-        try {
-            result = (Node) mXPath.evaluate(path, doc, XPathConstants.NODE);
-            if (result instanceof Element) {
-                return (Element) result;
-            }
-
-            if (result != null) {
-                mLog.error(Severity.ERROR,
-                        xmlFileAndLine(doc),
-                        "Unexpected Node type %s when evaluating %s",   //$NON-NLS-1$
-                        result.getClass().getName(), path);
-            }
-        } catch (XPathExpressionException e) {
-            mLog.error(Severity.ERROR,
-                    xmlFileAndLine(doc),
-                    "XPath error on expr %s: %s",                       //$NON-NLS-1$
-                    path, e.toString());
-        }
-        return null;
-    }
-
-    /**
-     * Finds zero or more elements matching the given XPath expression in the given document.
-     *
-     * @param doc The document where to find the expression.
-     * @param path The XPath expression. Only {@link Element}s nodes will be returned.
-     * @return A list of {@link Element} found, possibly empty but never null.
-     */
-    private List<Element> findElements(
-            @NonNull Document doc,
-            @NonNull String path) {
-        return findElements(doc, path, null, null);
-    }
-
-
-    /**
-     * Finds zero or more elements matching the given XPath expression in the given document.
-     * <p/>
-     * Furthermore, the elements must have an attribute matching the given attribute name
-     * and value if provided. (If you don't need to match an attribute, use the other version.)
-     * <p/>
-     * Note that if you provide {@code attrName} as non-null then the {@code attrValue}
-     * must be non-null too. In this case the XPath expression will be modified to add
-     * the check by naively appending a "[name='value']" filter.
-     *
-     * @param doc The document where to find the expression.
-     * @param path The XPath expression. Only {@link Element}s nodes will be returned.
-     * @param attrName The name of the optional attribute to match. Can be null.
-     * @param attrValue The value of the optional attribute to match.
-     *   Can be null if {@code attrName} is null, otherwise must be non-null.
-     * @return A list of {@link Element} found, possibly empty but never null.
-     *
-     * @see #findElements(Document, String)
-     */
-    private List<Element> findElements(
-            @NonNull Document doc,
-            @NonNull String path,
-            @Nullable String attrName,
-            @Nullable String attrValue) {
-        List<Element> elements = new ArrayList<Element>();
-
-        if (attrName != null) {
-            assert attrValue != null;
-            // Generate expression /manifest/application/activity[@android:name='my.fqcn']
-            path = String.format("%1$s[@%2$s:%3$s='%4$s']",                     //$NON-NLS-1$
-                    path, NS_PREFIX, attrName, attrValue);
-        }
-
-        try {
-            NodeList results = (NodeList) mXPath.evaluate(path, doc, XPathConstants.NODESET);
-            if (results != null && results.getLength() > 0) {
-                for (int i = 0; i < results.getLength(); i++) {
-                    Node n = results.item(i);
-                    assert n instanceof Element;
-                    if (n instanceof Element) {
-                        elements.add((Element) n);
-                    } else {
-                        mLog.error(Severity.ERROR,
-                                xmlFileAndLine(doc),
-                                "Unexpected Node type %s when evaluating %s",   //$NON-NLS-1$
-                                n.getClass().getName(), path);
-                    }
-                }
-            }
-
-        } catch (XPathExpressionException e) {
-            mLog.error(Severity.ERROR,
-                    xmlFileAndLine(doc),
-                    "XPath error on expr %s: %s",                       //$NON-NLS-1$
-                    path, e.toString());
-        }
-
-        return elements;
-    }
-
-    /**
-     * Returns a new {@link FileAndLine} structure that identifies
-     * the base filename & line number from which the XML node was parsed.
-     * <p/>
-     * When the line number is unknown (e.g. if a {@link Document} instance is given)
-     * then line number 0 will be used.
-     *
-     * @param node The node or document where the error occurs. Must not be null.
-     * @return A new non-null {@link FileAndLine} combining the file name and line number.
-     */
-    @NonNull
-    private FileAndLine xmlFileAndLine(@NonNull Node node) {
-        return MergerXmlUtils.xmlFileAndLine(node);
-    }
-
-    /**
-     * Checks whether the given element has a tools:merge=override or tools:merge=remove attribute.
-     * @param node The node to check.
-     * @return True if the element has a tools:merge=override or tools:merge=remove attribute.
-     */
-    private boolean hasOverrideOrRemoveTag(@Nullable Node node) {
-        if (node == null || node.getNodeType() != Node.ELEMENT_NODE) {
-            return false;
-        }
-        NamedNodeMap attrs = node.getAttributes();
-        Node merge = attrs.getNamedItemNS(TOOLS_URI, MERGE_ATTR);
-        String value = merge == null ? null : merge.getNodeValue();
-        return MERGE_OVERRIDE.equals(value) || MERGE_REMOVE.equals(value);
-    }
-
-    /**
-     * Cleans up all tools attributes from the given node hierarchy.
-     * <p/>
-     * If an element is marked with tools:merge=override, this attribute is removed.
-     * If an element is marked with tools:merge=remove, the <em>whole</em> element is removed.
-     *
-     * @param root The root node to parse and edit, recursively.
-     */
-    private void cleanupToolsAttributes(@Nullable Node root) {
-        if (root == null) {
-            return;
-        }
-        NamedNodeMap attrs = root.getAttributes();
-        if (attrs != null) {
-            for (int i = attrs.getLength() - 1; i >= 0; i--) {
-                Node attr = attrs.item(i);
-                if (SdkConstants.XMLNS_URI.equals(attr.getNamespaceURI()) &&
-                        TOOLS_URI.equals(attr.getNodeValue())) {
-                    attrs.removeNamedItem(attr.getNodeName());
-                } else if (TOOLS_URI.equals(attr.getNamespaceURI()) &&
-                        MERGE_ATTR.equals(attr.getLocalName())) {
-                    attrs.removeNamedItem(attr.getNodeName());
-                }
-            }
-            assert attrs.getNamedItemNS(TOOLS_URI, MERGE_ATTR) == null;
-        }
-
-        for (Node child = root.getFirstChild(); child != null; ) {
-            if (child.getNodeType() != Node.ELEMENT_NODE) {
-                child = child.getNextSibling();
-                continue;
-            }
-            attrs = child.getAttributes();
-            Node merge = attrs == null ? null : attrs.getNamedItemNS(TOOLS_URI, MERGE_ATTR);
-            String value = merge == null ? null : merge.getNodeValue();
-            Node sibling = child.getNextSibling();
-            if (MERGE_REMOVE.equals(value)) {
-                // Note: save the previous sibling since removing the child will clear its siblings.
-                Node prev = child.getPreviousSibling();
-                root.removeChild(child);
-                // If there's some whitespace just before that element, clean it up too.
-                while (prev != null && prev.getNodeType() == Node.TEXT_NODE) {
-                    if (prev.getNodeValue().trim().isEmpty()) {
-                        Node prevPrev = prev.getPreviousSibling();
-                        root.removeChild(prev);
-                        prev = prevPrev;
-                    } else {
-                        break;
-                    }
-                }
-            } else {
-                cleanupToolsAttributes(child);
-            }
-            child = sibling;
-        }
-    }
-
-    /**
-     * @see #cleanupToolsAttributes(Node)
-     */
-    private Document cleanupToolsAttributes(@NonNull Document doc) {
-        cleanupToolsAttributes(doc.getFirstChild());
-        return doc;
-    }
-
-    /**
-     * Sets whether this manifest merger will insert source markers into the merged source
-     *
-     * @param insertSourceMarkers if true, insert source markers
-     */
-    public void setInsertSourceMarkers(boolean insertSourceMarkers) {
-        mInsertSourceMarkers = insertSourceMarkers;
-    }
-
-    /**
-     * Returns whether this manifest merger will insert source markers into the merged source
-     *
-     * @return whether this manifest merger will insert source markers into the merged source
-     */
-    public boolean isInsertSourceMarkers() {
-        return mInsertSourceMarkers;
-    }
-
-    /** Inserts source markers in the given document */
-    private static void insertSourceMarkers(@NonNull Document mainDoc) {
-        Element root = mainDoc.getDocumentElement();
-        if (root != null) {
-            File file = MergerXmlUtils.getFileFor(root);
-            if (file != null) {
-                insertSourceMarker(mainDoc, root, file, false);
-            }
-
-            insertSourceMarkers(root, file);
-        }
-    }
-
-    private static File insertSourceMarkers(@NonNull Node node, @Nullable File currentFile) {
-        for (int i = 0; i < node.getChildNodes().getLength(); i++) {
-            Node child = node.getChildNodes().item(i);
-            short nodeType = child.getNodeType();
-            if (nodeType == Node.ELEMENT_NODE
-                    || nodeType == Node.COMMENT_NODE
-                    || nodeType == Node.DOCUMENT_NODE
-                    || nodeType == Node.CDATA_SECTION_NODE) {
-                File file = MergerXmlUtils.getFileFor(child);
-                if (file != null && !file.equals(currentFile)) {
-                    i += insertSourceMarker(node, child, file, false);
-                    currentFile = file;
-                }
-
-                currentFile = insertSourceMarkers(child, currentFile);
-            }
-        }
-
-        Node lastElement = node.getLastChild();
-        while (lastElement != null && lastElement.getNodeType() == Node.TEXT_NODE) {
-            lastElement = lastElement.getPreviousSibling();
-        }
-        if (lastElement != null && lastElement.getNodeType() == Node.ELEMENT_NODE) {
-            File parentFile = MergerXmlUtils.getFileFor(node);
-            File lastFile = MergerXmlUtils.getFileFor(lastElement);
-            if (lastFile != null && parentFile != null && !parentFile.equals(lastFile)) {
-                insertSourceMarker(node, lastElement, parentFile, true);
-                currentFile = parentFile;
-            }
-        }
-
-        return currentFile;
-    }
-
-    private static int insertSourceMarker(@NonNull Node parent, @NonNull Node node,
-                                          @NonNull File file, boolean after) {
-        int insertCount = 0;
-        Document doc = parent.getNodeType() ==
-                Node.DOCUMENT_NODE ? (Document) parent : parent.getOwnerDocument();
-
-        String comment;
-        try {
-            comment = SdkUtils.createPathComment(file, true);
-        } catch (MalformedURLException e) {
-            return insertCount;
-        }
-
-        Node prev = node.getPreviousSibling();
-        String newline;
-        if (prev != null && prev.getNodeType() == Node.TEXT_NODE) {
-            // Duplicate indentation from previous line. Once we switch the merger
-            // over to using the XmlPrettyPrinter, we won't need this.
-            newline = prev.getNodeValue();
-            int index = newline.lastIndexOf('\n');
-            if (index != -1) {
-                newline = newline.substring(index);
-            }
-        } else {
-            newline = "\n";
-        }
-
-        if (after) {
-            node = node.getNextSibling();
-        }
-
-        parent.insertBefore(doc.createComment(comment), node);
-        insertCount++;
-
-        // Can't add text nodes at the document level in Xerces, even though
-        // it will happily parse these
-        if (parent.getNodeType() != Node.DOCUMENT_NODE) {
-            parent.insertBefore(doc.createTextNode(newline), node);
-            insertCount++;
-        }
-
-        return insertCount;
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ConvertibleName.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ConvertibleName.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ConvertibleName.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ConvertibleName.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,18 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-/**
- * Defines conversion routines for named types that can be converted into Xml name or Camel case
- * names.
- */
-public interface ConvertibleName {
-
-    /**
-     * Returns a xml lower-hyphen separated name of itself.
-     */
-    String toXmlName();
-
-    /**
-     * Returns a camel case version of itself.
-     */
-    String toCamelCaseName();
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ElementsTrimmer.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ElementsTrimmer.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ElementsTrimmer.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ElementsTrimmer.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,136 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.SdkConstants.ANDROID_URI;
-
-import androidx.annotation.NonNull;
-
-import com.tyron.build.compiler.manifest.xml.AndroidManifest;
-
-import java.util.Map;
-import java.util.NavigableMap;
-import java.util.TreeMap;
-import org.w3c.dom.Attr;
-
-/**
- * Trims the document from unwanted, repeated elements.
- */
-public class ElementsTrimmer {
-
-    /**
-     * Trims unwanted, duplicated elements from the merged document.
-     * <p>
-     * Current trimmed elements are :
-     * <ul>
-     *     <li>uses-features with glEsVersion key
-     * <ul>
-     *     <li>The highest 1.x version element will be kept regardless of 'required' flag value</li>
-     *     <li>If the above element is present and has a 'false' required flag, there can be at most
-     *     one element of a lesser version with 'required' attribute set to true.</li>
-     *     <li>The highest 2.x or superior element will be kept regardless of 'required' flag value
-     *     </li>
-     *     <li>If the above element is present and has a 'false' required flag, there can be at
-     *     most one element of a lesser version (but higher than 2.0) with a 'required' attribute
-     *     set to true.</li>
-     * </ul>
-     * </li>
-     * </ul>
-     *
-     * @param xmlDocument the xml document to trim.
-     * @param mergingReport the report to log errors and actions.
-     */
-    public static void trim(
-            @NonNull XmlDocument xmlDocument,
-            @NonNull MergingReport.Builder mergingReport) {
-
-        // I sort the glEsVersion declaration by value.
-        NavigableMap<Integer, XmlElement> glEsVersionDeclarations = new TreeMap<Integer, XmlElement>();
-
-        for (XmlElement childElement : xmlDocument.getRootNode().getMergeableElements()) {
-            if (childElement.getType().equals(ManifestModel.NodeTypes.USES_FEATURE)) {
-                Integer value = getGlEsVersion(childElement);
-                if (value != null) {
-                    glEsVersionDeclarations.put(value, childElement);
-                }
-            }
-        }
-
-        // now eliminate all unwanted declarations, revert the sorted map, so we get the
-        // higher elements first.
-        glEsVersionDeclarations = glEsVersionDeclarations.descendingMap();
-        boolean doneWithAboveTwoTrue = false;
-        boolean doneWithAboveTwoFalse = false;
-        boolean doneWithBelowTwoTrue = false;
-        boolean doneWithBelowTwoFalse = false;
-        for (Map.Entry<Integer, XmlElement> glEsVersionDeclaration :
-                glEsVersionDeclarations.entrySet()) {
-
-            boolean removeElement;
-
-            Attr requiredAttribute = glEsVersionDeclaration.getValue().getXml().getAttributeNodeNS(
-                    ANDROID_URI, AndroidManifest.ATTRIBUTE_REQUIRED);
-
-            boolean isRequired = requiredAttribute == null ||
-                    Boolean.parseBoolean(requiredAttribute.getValue());
-
-            if (glEsVersionDeclaration.getKey() < 0x20000) {
-                // version one.
-                removeElement = (doneWithBelowTwoFalse && doneWithBelowTwoTrue)
-                        || (isRequired && doneWithBelowTwoTrue)
-                        || (!isRequired && doneWithBelowTwoFalse);
-
-                if (!removeElement) {
-                    doneWithBelowTwoFalse = true;
-                    doneWithBelowTwoTrue = isRequired;
-                }
-            } else {
-                // version two or above.
-                removeElement = (doneWithAboveTwoFalse && doneWithAboveTwoTrue)
-                        || (isRequired && doneWithAboveTwoTrue)
-                        || (!isRequired && doneWithAboveTwoFalse);
-
-                if (!removeElement) {
-                    doneWithAboveTwoFalse = true;
-                    doneWithAboveTwoTrue = isRequired;
-                }
-            }
-            if (removeElement) {
-                // if the node only contains glEsVersion, then remove the entire node,
-                // if it also contains android:name, just remove the glEsVersion attribute
-                if (glEsVersionDeclaration.getValue().getXml().getAttributeNodeNS(ANDROID_URI,
-                        SdkConstants.ATTR_NAME) != null) {
-                    glEsVersionDeclaration.getValue().getXml().removeAttributeNS(ANDROID_URI,
-                            AndroidManifest.ATTRIBUTE_GLESVERSION);
-                    mergingReport.getActionRecorder().recordAttributeAction(
-                            glEsVersionDeclaration.getValue().getAttribute(XmlNode.fromXmlName(
-                                    "android:" + AndroidManifest.ATTRIBUTE_GLESVERSION)).get(),
-                            Actions.ActionType.REJECTED,
-                            null /* attributeOperationType */);
-                } else {
-                    xmlDocument.getRootNode().getXml().removeChild(
-                            glEsVersionDeclaration.getValue().getXml());
-                    mergingReport.getActionRecorder().recordNodeAction(
-                            glEsVersionDeclaration.getValue(),
-                            Actions.ActionType.REJECTED);
-
-                }
-            }
-
-        }
-
-    }
-
-    private static Integer getGlEsVersion(@NonNull XmlElement xmlElement) {
-        Attr glEsVersion = xmlElement.getXml()
-                .getAttributeNodeNS(ANDROID_URI, AndroidManifest.ATTRIBUTE_GLESVERSION);
-        if (glEsVersion == null) {
-            return null;
-        }
-        return getHexValue(glEsVersion);
-    }
-
-    private static Integer getHexValue(@NonNull Attr attribute) {
-        return Integer.decode(attribute.getValue());
-    }
-}
-
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger2.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger2.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger2.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMerger2.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1107 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.PlaceholderHandler.APPLICATION_ID;
-import static com.tyron.build.compiler.manifest.PlaceholderHandler.KeyBasedValueResolver;
-import static com.tyron.build.compiler.manifest.PlaceholderHandler.PACKAGE_NAME;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.android.apksig.internal.util.Pair;
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
-import com.google.common.base.Strings;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.util.SdkUtils;
-import com.tyron.build.util.XmlUtils;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Element;
-import org.w3c.dom.NodeList;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import com.google.errorprone.annotations.Immutable;
-
-/**
- * merges android manifest files, idempotent.
- */
-@Immutable
-public class ManifestMerger2 {
-
-    @NonNull
-    private final File mManifestFile;
-
-    @NonNull
-    private final Map<String, Object> mPlaceHolderValues;
-
-    @NonNull
-    private final KeyBasedValueResolver<SystemProperty> mSystemPropertyResolver;
-
-    private final ILogger mLogger;
-    private final ImmutableList<Pair<String, File>> mLibraryFiles;
-    private final ImmutableList<File> mFlavorsAndBuildTypeFiles;
-    private final ImmutableList<Invoker.Feature> mOptionalFeatures;
-    private final MergeType mMergeType;
-    private final Optional<File> mReportFile;
-
-    private ManifestMerger2(
-            @NonNull ILogger logger,
-            @NonNull File mainManifestFile,
-            @NonNull ImmutableList<Pair<String, File>> libraryFiles,
-            @NonNull ImmutableList<File> flavorsAndBuildTypeFiles,
-            @NonNull ImmutableList<Invoker.Feature> optionalFeatures,
-            @NonNull Map<String, Object> placeHolderValues,
-            @NonNull KeyBasedValueResolver<SystemProperty> systemPropertiesResolver,
-            @NonNull MergeType mergeType,
-            @NonNull Optional<File> reportFile) {
-        this.mSystemPropertyResolver = systemPropertiesResolver;
-        this.mPlaceHolderValues = placeHolderValues;
-        this.mManifestFile = mainManifestFile;
-        this.mLogger = logger;
-        this.mLibraryFiles = libraryFiles;
-        this.mFlavorsAndBuildTypeFiles = flavorsAndBuildTypeFiles;
-        this.mOptionalFeatures = optionalFeatures;
-        this.mMergeType = mergeType;
-        this.mReportFile = reportFile;
-    }
-
-    /**
-     * Perform high level ordering of files merging and delegates actual merging to
-     * {@link XmlDocument#merge(XmlDocument, com.tyron.build.compiler.manifest.MergingReport.Builder)}
-     *
-     * @return the merging activity report.
-     * @throws MergeFailureException if the merging cannot be completed (for instance, if xml
-     * files cannot be loaded).
-     */
-    private MergingReport merge() throws MergeFailureException {
-        // initiate a new merging report
-        MergingReport.Builder mergingReportBuilder = new MergingReport.Builder(mLogger);
-
-        SelectorResolver selectors = new SelectorResolver();
-        // load all the libraries xml files up front to have a list of all possible node:selector
-        // values.
-        List<LoadedManifestInfo> loadedLibraryDocuments =
-                loadLibraries(selectors, mergingReportBuilder);
-
-        // load the main manifest file to do some checking along the way.
-        LoadedManifestInfo loadedMainManifestInfo = load(
-                new ManifestInfo(
-                        mManifestFile.getName(),
-                        mManifestFile,
-                        XmlDocument.Type.MAIN,
-                        Optional.<String>absent() /* mainManifestPackageName */),
-                selectors,
-                mergingReportBuilder);
-
-        // first do we have a package declaration in the main manifest ?
-        Optional<XmlAttribute> mainPackageAttribute =
-                loadedMainManifestInfo.getXmlDocument().getPackage();
-        if (!mainPackageAttribute.isPresent()) {
-            mergingReportBuilder.addMessage(
-                    loadedMainManifestInfo.getXmlDocument().getSourceFile(),
-                    MergingReport.Record.Severity.ERROR,
-                    String.format(
-                            "Main AndroidManifest.xml at %1$s manifest:package attribute "
-                                    + "is not declared",
-                            loadedMainManifestInfo.getXmlDocument().getSourceFile()
-                                    .print(true)));
-            return mergingReportBuilder.build();
-        }
-
-        // perform system property injection
-        performSystemPropertiesInjection(mergingReportBuilder,
-                loadedMainManifestInfo.getXmlDocument());
-
-        // force the re-parsing of the xml as elements may have been added through system
-        // property injection.
-        loadedMainManifestInfo = new LoadedManifestInfo(loadedMainManifestInfo,
-                loadedMainManifestInfo.getOriginalPackageName(),
-                loadedMainManifestInfo.getXmlDocument().reparse());
-
-        // invariant : xmlDocumentOptional holds the higher priority document and we try to
-        // merge in lower priority documents.
-        Optional<XmlDocument> xmlDocumentOptional = Optional.absent();
-        for (File inputFile : mFlavorsAndBuildTypeFiles) {
-            mLogger.info(String.format("Merging flavors and build manifest %s \n", inputFile.getPath()));
-            LoadedManifestInfo overlayDocument = load(
-                    new ManifestInfo(null, inputFile, XmlDocument.Type.OVERLAY,
-                            Optional.of(mainPackageAttribute.get().getValue())),
-                    selectors,
-                    mergingReportBuilder);
-
-            // check package declaration.
-            Optional<XmlAttribute> packageAttribute =
-                    overlayDocument.getXmlDocument().getPackage();
-            // if both files declare a package name, it should be the same.
-            if (loadedMainManifestInfo.getOriginalPackageName().isPresent() &&
-                    packageAttribute.isPresent()
-                    && !loadedMainManifestInfo.getOriginalPackageName().get().equals(
-                    packageAttribute.get().getValue())) {
-                // no suggestion for library since this is actually forbidden to change the
-                // the package name per flavor.
-                String message = mMergeType == MergeType.APPLICATION
-                        ? String.format(
-                        "Overlay manifest:package attribute declared at %1$s value=(%2$s)\n"
-                                + "\thas a different value=(%3$s) "
-                                + "declared in main manifest at %4$s\n"
-                                + "\tSuggestion: remove the overlay declaration at %5$s "
-                                + "\tand place it in the build.gradle:\n"
-                                + "\t\tflavorName {\n"
-                                + "\t\t\tapplicationId = \"%2$s\"\n"
-                                + "\t\t}",
-                        packageAttribute.get().printPosition(),
-                        packageAttribute.get().getValue(),
-                        mainPackageAttribute.get().getValue(),
-                        mainPackageAttribute.get().printPosition(),
-                        packageAttribute.get().getSourceFile().print(true))
-                        : String.format(
-                        "Overlay manifest:package attribute declared at %1$s value=(%2$s)\n"
-                                + "\thas a different value=(%3$s) "
-                                + "declared in main manifest at %4$s",
-                        packageAttribute.get().printPosition(),
-                        packageAttribute.get().getValue(),
-                        mainPackageAttribute.get().getValue(),
-                        mainPackageAttribute.get().printPosition());
-                mergingReportBuilder.addMessage(
-                        overlayDocument.getXmlDocument().getSourceFile(),
-                        MergingReport.Record.Severity.ERROR,
-                        message);
-                return mergingReportBuilder.build();
-            }
-
-            overlayDocument.getXmlDocument().getRootNode().getXml().setAttribute("package",
-                    mainPackageAttribute.get().getValue());
-            xmlDocumentOptional = merge(xmlDocumentOptional, overlayDocument, mergingReportBuilder);
-
-            if (!xmlDocumentOptional.isPresent()) {
-                return mergingReportBuilder.build();
-            }
-        }
-
-        mLogger.info(String.format("Merging main manifest %s\n", mManifestFile.getPath()));
-        xmlDocumentOptional =
-                merge(xmlDocumentOptional, loadedMainManifestInfo, mergingReportBuilder);
-
-        if (!xmlDocumentOptional.isPresent()) {
-            return mergingReportBuilder.build();
-        }
-
-        // force main manifest package into resulting merged file when creating a library manifest.
-        if (mMergeType == MergeType.LIBRARY) {
-            // extract the package name...
-            String mainManifestPackageName = loadedMainManifestInfo.getXmlDocument().getRootNode()
-                    .getXml().getAttribute("package");
-            // save it in the selector instance.
-            if (!Strings.isNullOrEmpty(mainManifestPackageName)) {
-                xmlDocumentOptional.get().getRootNode().getXml()
-                        .setAttribute("package", mainManifestPackageName);
-            }
-        }
-        for (LoadedManifestInfo libraryDocument : loadedLibraryDocuments) {
-            mLogger.verbose("Merging library manifest " + libraryDocument.getLocation());
-            xmlDocumentOptional = merge(
-                    xmlDocumentOptional, libraryDocument, mergingReportBuilder);
-            if (!xmlDocumentOptional.isPresent()) {
-                return mergingReportBuilder.build();
-            }
-        }
-
-        // done with proper merging phase, now we need to trim unwanted elements, placeholder
-        // substitution and system properties injection.
-        ElementsTrimmer.trim(xmlDocumentOptional.get(), mergingReportBuilder);
-        if (mergingReportBuilder.hasErrors()) {
-            return mergingReportBuilder.build();
-        }
-
-        if (!mOptionalFeatures.contains(Invoker.Feature.NO_PLACEHOLDER_REPLACEMENT)) {
-            // do one last placeholder substitution, this is useful as we don't stop the build
-            // when a library failed a placeholder substitution, but the element might have
-            // been overridden so the problem was transient. However, with the final document
-            // ready, all placeholders values must have been provided.
-            KeyBasedValueResolver<String> placeHolderValueResolver =
-                    new MapBasedKeyBasedValueResolver<String>(mPlaceHolderValues);
-            PlaceholderHandler placeholderHandler = new PlaceholderHandler();
-            placeholderHandler.visit(
-                    mMergeType,
-                    xmlDocumentOptional.get(),
-                    placeHolderValueResolver,
-                    mergingReportBuilder);
-            if (mergingReportBuilder.hasErrors()) {
-                return mergingReportBuilder.build();
-            }
-        }
-
-        // perform system property injection.
-        performSystemPropertiesInjection(mergingReportBuilder, xmlDocumentOptional.get());
-
-        XmlDocument finalMergedDocument = xmlDocumentOptional.get();
-        PostValidator.validate(finalMergedDocument, mergingReportBuilder);
-        if (mergingReportBuilder.hasErrors()) {
-            finalMergedDocument.getRootNode().addMessage(mergingReportBuilder,
-                    MergingReport.Record.Severity.WARNING,
-                    "Post merge validation failed");
-        }
-
-        // only remove tools annotations if we are packaging an application.
-        if (mOptionalFeatures.contains(Invoker.Feature.REMOVE_TOOLS_DECLARATIONS)) {
-            finalMergedDocument =
-                    ToolsInstructionsCleaner.cleanToolsReferences(finalMergedDocument, mLogger);
-        }
-
-        if (mOptionalFeatures.contains(Invoker.Feature.EXTRACT_FQCNS)) {
-            extractFcqns(finalMergedDocument);
-        }
-
-        if (finalMergedDocument != null) {
-            mergingReportBuilder.setMergedDocument(finalMergedDocument);
-        }
-
-        MergingReport mergingReport = mergingReportBuilder.build();
-       // StdLogger stdLogger = new StdLogger(StdLogger.Level.INFO);
-        //mergingReport.log(stdLogger);
-        //stdLogger.verbose(mergingReport.getMergedDocument().get().prettyPrint());
-
-        if (mReportFile.isPresent()) {
-            writeReport(mergingReport);
-        }
-
-        return mergingReport;
-    }
-
-    /**
-     * Creates the merging report file.
-     * @param mergingReport the merging activities report to serialize.
-     */
-    private void writeReport(MergingReport mergingReport) {
-        FileWriter fileWriter = null;
-        try {
-            if (!mReportFile.get().getParentFile().exists()
-                    && !mReportFile.get().getParentFile().mkdirs()) {
-                mLogger.warning(String.format(
-                        "Cannot create %1$s manifest merger report file,"
-                                + "build will continue but merging activities "
-                                + "will not be documented",
-                        mReportFile.get().getAbsolutePath()));
-            } else {
-                fileWriter = new FileWriter(mReportFile.get());
-                mergingReport.getActions().log(fileWriter);
-            }
-        } catch (IOException e) {
-            mLogger.warning(String.format(
-                    "Error '%1$s' while writing the merger report file, "
-                            + "build can continue but merging activities "
-                            + "will not be documented ",
-                    e.getMessage()));
-        } finally {
-            if (fileWriter != null) {
-                try {
-                    fileWriter.close();
-                } catch (IOException e) {
-                    mLogger.warning(String.format(
-                            "Error '%1$s' while closing the merger report file, "
-                                    + "build can continue but merging activities "
-                                    + "will not be documented ",
-                            e.getMessage()));
-                }
-            }
-        }
-    }
-
-    /**
-     * shorten all fully qualified class name that belong to the same package as the manifest's
-     * package attribute value.
-     * @param finalMergedDocument the AndroidManifest.xml document.
-     */
-    private void extractFcqns(XmlDocument finalMergedDocument) {
-        extractFcqns(finalMergedDocument.getPackageName(), finalMergedDocument.getRootNode());
-    }
-
-    /**
-     * shorten recursively all attributes that are package dependent of the passed nodes and all
-     * its child nodes.
-     * @param packageName the manifest package name.
-     * @param xmlElement the xml element to process recursively.
-     */
-    private void extractFcqns(String packageName, XmlElement xmlElement) {
-        for (XmlAttribute xmlAttribute : xmlElement.getAttributes()) {
-            if (xmlAttribute.getModel() !=null && xmlAttribute.getModel().isPackageDependent()) {
-                String value = xmlAttribute.getValue();
-                if (value != null && value.startsWith(packageName) &&
-                        value.charAt(packageName.length()) == '.') {
-                    xmlAttribute.getXml().setValue(value.substring(packageName.length()));
-                }
-            }
-        }
-        for (XmlElement child : xmlElement.getMergeableElements()) {
-            extractFcqns(packageName, child);
-        }
-    }
-
-    /**
-     * Load an xml file and perform placeholder substitution
-     * @param manifestInfo the android manifest information like if it is a library, an
-     *                     overlay or a main manifest file.
-     * @param selectors all the libraries selectors
-     * @param mergingReportBuilder the merging report to store events and errors.
-     * @return a loaded manifest info.
-     * @throws MergeFailureException
-     */
-    private LoadedManifestInfo load(
-            ManifestInfo manifestInfo,
-            KeyResolver<String> selectors,
-            MergingReport.Builder mergingReportBuilder) throws MergeFailureException {
-
-        XmlDocument xmlDocument;
-        try {
-            xmlDocument = XmlLoader.load(selectors,
-                    mSystemPropertyResolver,
-                    manifestInfo.mName,
-                    manifestInfo.mLocation,
-                    manifestInfo.getType(),
-                    manifestInfo.getMainManifestPackageName());
-        } catch (Exception e) {
-            throw new MergeFailureException(e);
-        }
-
-        String originalPackageName = xmlDocument.getPackageName();
-        MergingReport.Builder builder = manifestInfo.getType() == XmlDocument.Type.MAIN
-                ? mergingReportBuilder
-                : new MergingReport.Builder(mergingReportBuilder.getLogger());
-
-        builder.getActionRecorder().recordDefaultNodeAction(
-                xmlDocument.getRootNode());
-
-        // perform place holder substitution, this is necessary to do so early in case placeholders
-        // are used in key attributes.
-        performPlaceHolderSubstitution(manifestInfo, xmlDocument, builder);
-
-        return new LoadedManifestInfo(manifestInfo,
-                Optional.fromNullable(originalPackageName), xmlDocument);
-    }
-
-    private void performPlaceHolderSubstitution(ManifestInfo manifestInfo,
-                                                XmlDocument xmlDocument,
-                                                MergingReport.Builder mergingReportBuilder) {
-
-        if (mOptionalFeatures.contains(Invoker.Feature.NO_PLACEHOLDER_REPLACEMENT)) {
-            return;
-        }
-
-        // check for placeholders presence, switch first the packageName and application id if
-        // it is not explicitly set.
-        Map<String, Object> finalPlaceHolderValues = mPlaceHolderValues;
-        if (!mPlaceHolderValues.containsKey(APPLICATION_ID)) {
-            String packageName = manifestInfo.getMainManifestPackageName().isPresent()
-                    ? manifestInfo.getMainManifestPackageName().get()
-                    : xmlDocument.getPackageName();
-            // add all existing placeholders except package name that will be swapped.
-            ImmutableMap.Builder<String, Object> builder = ImmutableMap.<String, Object>builder();
-            for (Map.Entry<String, Object> entry : mPlaceHolderValues.entrySet()) {
-                if (!entry.getKey().equals(PACKAGE_NAME)) {
-                    builder.put(entry);
-                }
-            }
-            builder.put(PACKAGE_NAME, packageName);
-            if (mMergeType != MergeType.LIBRARY) {
-                builder.put(APPLICATION_ID, packageName);
-            }
-            finalPlaceHolderValues = builder.build();
-        }
-
-        KeyBasedValueResolver<String> placeHolderValueResolver =
-                new MapBasedKeyBasedValueResolver<String>(finalPlaceHolderValues);
-        PlaceholderHandler placeholderHandler = new PlaceholderHandler();
-        placeholderHandler.visit(
-                mMergeType,
-                xmlDocument,
-                placeHolderValueResolver,
-                mergingReportBuilder);
-    }
-
-    // merge the optionally existing xmlDocument with a lower priority xml file.
-    private Optional<XmlDocument> merge(
-            Optional<XmlDocument> xmlDocument,
-            LoadedManifestInfo lowerPriorityDocument,
-            MergingReport.Builder mergingReportBuilder) throws MergeFailureException {
-
-        MergingReport.Result validationResult = PreValidator
-                .validate(mergingReportBuilder, lowerPriorityDocument.getXmlDocument());
-        if (validationResult == MergingReport.Result.ERROR) {
-            mergingReportBuilder.addMessage(
-                    lowerPriorityDocument.getXmlDocument().getSourceFile(),
-                    MergingReport.Record.Severity.ERROR,
-                    "Validation failed, exiting");
-            return Optional.absent();
-        }
-        Optional<XmlDocument> result;
-        if (xmlDocument.isPresent()) {
-            result = xmlDocument.get().merge(
-                    lowerPriorityDocument.getXmlDocument(), mergingReportBuilder);
-        } else {
-            mergingReportBuilder.getActionRecorder().recordDefaultNodeAction(
-                    lowerPriorityDocument.getXmlDocument().getRootNode());
-            result = Optional.of(lowerPriorityDocument.getXmlDocument());
-        }
-
-        // if requested, dump each intermediary merging stage into the report.
-        if (mOptionalFeatures.contains(Invoker.Feature.KEEP_INTERMEDIARY_STAGES)
-                && result.isPresent()) {
-            mergingReportBuilder.addMergingStage(result.get().prettyPrint());
-        }
-
-        return result;
-    }
-
-    private List<LoadedManifestInfo> loadLibraries(SelectorResolver selectors,
-                                                   MergingReport.Builder mergingReportBuilder) throws MergeFailureException {
-
-        ImmutableList.Builder<LoadedManifestInfo> loadedLibraryDocuments = ImmutableList.builder();
-        for (Pair<String, File> libraryFile : mLibraryFiles) {
-            mLogger.verbose("Loading library manifest " + libraryFile.getSecond().getPath());
-            ManifestInfo manifestInfo = new ManifestInfo(libraryFile.getFirst(),
-                    libraryFile.getSecond(),
-                    XmlDocument.Type.LIBRARY, Optional.<String>absent());
-            XmlDocument libraryDocument;
-            try {
-                libraryDocument = XmlLoader.load(selectors,
-                        mSystemPropertyResolver,
-                        manifestInfo.mName, manifestInfo.mLocation,
-                        XmlDocument.Type.LIBRARY,
-                        Optional.<String>absent()  /* mainManifestPackageName */);
-            } catch (Exception e) {
-                throw new MergeFailureException(e);
-            }
-            // extract the package name...
-            String libraryPackage = libraryDocument.getRootNode().getXml().getAttribute("package");
-            // save it in the selector instance.
-            if (!Strings.isNullOrEmpty(libraryPackage)) {
-                selectors.addSelector(libraryPackage, libraryFile.getFirst());
-            }
-
-            // perform placeholder substitution, this is useful when the library is using
-            // a placeholder in a key element, we however do not need to record these
-            // substitutions so feed it with a fake merging report.
-            MergingReport.Builder builder = new MergingReport.Builder(mergingReportBuilder.getLogger());
-            builder.getActionRecorder().recordDefaultNodeAction(libraryDocument.getRootNode());
-            performPlaceHolderSubstitution(manifestInfo, libraryDocument, builder);
-            if (builder.hasErrors()) {
-                // we log the errors but continue, in case the error is of no consequence
-                // to the application consuming the library.
-                builder.build().log(mLogger);
-            }
-
-            loadedLibraryDocuments.add(new LoadedManifestInfo(manifestInfo,
-                    Optional.fromNullable(libraryDocument.getPackageName()),
-                    libraryDocument));
-        }
-        return loadedLibraryDocuments.build();
-    }
-
-    /**
-     * Creates a new {@link com.tyron.build.compiler.manifest.ManifestMerger2.Invoker} instance to invoke
-     * the merging tool to merge manifest files for an application.
-     *
-     * @param mainManifestFile application main manifest file.
-     * @param logger the logger interface to use.
-     * @return an {@link com.tyron.build.compiler.manifest.ManifestMerger2.Invoker} instance that will allow
-     * further customization and trigger the merging tool.
-     */
-    public static Invoker newMerger(@NonNull File mainManifestFile,
-                                    @NonNull ILogger logger,
-                                    @NonNull MergeType mergeType) {
-        return new Invoker(mainManifestFile, logger, mergeType);
-    }
-
-    /**
-     * List of manifest files properties that can be directly overridden without using a
-     * placeholder.
-     */
-    public enum SystemProperty implements AutoAddingProperty {
-
-        /**
-         * Allow setting the merged manifest file package name.
-         */
-        PACKAGE {
-            @Override
-            public void addTo(@NonNull ActionRecorder actionRecorder,
-                              @NonNull XmlDocument document,
-                              @NonNull String value) {
-                addToElement(this, actionRecorder, value, document.getRootNode());
-            }
-        },
-        /**
-         * http://developer.android.com/guide/topics/manifest/manifest-element.html#vcode
-         */
-        VERSION_CODE {
-            @Override
-            public void addTo(@NonNull ActionRecorder actionRecorder,
-                              @NonNull XmlDocument document,
-                              @NonNull String value) {
-                addToElementInAndroidNS(this, actionRecorder, value, document.getRootNode());
-            }
-        },
-        /**
-         * http://developer.android.com/guide/topics/manifest/manifest-element.html#vname
-         */
-        VERSION_NAME {
-            @Override
-            public void addTo(@NonNull ActionRecorder actionRecorder,
-                              @NonNull XmlDocument document,
-                              @NonNull String value) {
-                addToElementInAndroidNS(this, actionRecorder, value, document.getRootNode());
-            }
-        },
-        /**
-         * http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#min
-         */
-        MIN_SDK_VERSION {
-            @Override
-            public void addTo(@NonNull ActionRecorder actionRecorder,
-                              @NonNull XmlDocument document,
-                              @NonNull String value) {
-                addToElementInAndroidNS(this, actionRecorder, value,
-                        createOrGetUseSdk(actionRecorder, document));
-            }
-        },
-        /**
-         * http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#target
-         */
-        TARGET_SDK_VERSION {
-            @Override
-            public void addTo(@NonNull ActionRecorder actionRecorder,
-                              @NonNull XmlDocument document,
-                              @NonNull String value) {
-                addToElementInAndroidNS(this, actionRecorder, value,
-                        createOrGetUseSdk(actionRecorder, document));
-            }
-        },
-
-        MAX_SDK_VERSION {
-            @Override
-            public void addTo(@NonNull ActionRecorder actionRecorder,
-                              @NonNull XmlDocument document,
-                              @NonNull String value) {
-                addToElementInAndroidNS(this, actionRecorder, value,
-                        createOrGetUseSdk(actionRecorder, document));
-            }
-        };
-
-        public String toCamelCase() {
-            return SdkUtils.constantNameToCamelCase(name());
-        }
-
-        // utility method to add an attribute which name is derived from the enum name().
-        private static void addToElement(
-                SystemProperty systemProperty,
-                ActionRecorder actionRecorder,
-                String value,
-                XmlElement to) {
-
-            to.getXml().setAttribute(systemProperty.toCamelCase(), value);
-            XmlAttribute xmlAttribute = new XmlAttribute(to,
-                    to.getXml().getAttributeNode(systemProperty.toCamelCase()), null);
-            actionRecorder.recordAttributeAction(xmlAttribute, new Actions.AttributeRecord(
-                    Actions.ActionType.INJECTED,
-                    new SourceFilePosition(to.getSourceFile(), SourcePosition.UNKNOWN),
-                    xmlAttribute.getId(),
-                    null, /* reason */
-                    null /* attributeOperationType */));
-        }
-
-        // utility method to add an attribute in android namespace which local name is derived from
-        // the enum name().
-        private static void addToElementInAndroidNS(
-                SystemProperty systemProperty,
-                ActionRecorder actionRecorder,
-                String value,
-                XmlElement to) {
-
-            String toolsPrefix = getAndroidPrefix(to.getXml());
-            to.getXml().setAttributeNS(SdkConstants.ANDROID_URI,
-                    toolsPrefix + XmlUtils.NS_SEPARATOR + systemProperty.toCamelCase(),
-                    value);
-            Attr attr = to.getXml().getAttributeNodeNS(SdkConstants.ANDROID_URI,
-                    systemProperty.toCamelCase());
-
-            XmlAttribute xmlAttribute = new XmlAttribute(to, attr, null);
-            actionRecorder.recordAttributeAction(xmlAttribute,
-                    new Actions.AttributeRecord(
-                            Actions.ActionType.INJECTED,
-                            new SourceFilePosition(to.getSourceFile(), SourcePosition.UNKNOWN),
-                            xmlAttribute.getId(),
-                            null, /* reason */
-                            null /* attributeOperationType */
-                    )
-            );
-
-        }
-
-        // utility method to create or get an existing use-sdk xml element under manifest.
-        // this could be made more generic by adding more metadata to the enum but since there is
-        // only one case so far, keep it simple.
-        private static XmlElement createOrGetUseSdk(
-                ActionRecorder actionRecorder, XmlDocument document) {
-
-            Element manifest = document.getXml().getDocumentElement();
-            NodeList usesSdks = manifest
-                    .getElementsByTagName(ManifestModel.NodeTypes.USES_SDK.toXmlName());
-            if (usesSdks.getLength() == 0) {
-                usesSdks = manifest
-                        .getElementsByTagNameNS(
-                                SdkConstants.ANDROID_URI,
-                                ManifestModel.NodeTypes.USES_SDK.toXmlName());
-            }
-            if (usesSdks.getLength() == 0) {
-                // create it first.
-                Element useSdk = manifest.getOwnerDocument().createElement(
-                        ManifestModel.NodeTypes.USES_SDK.toXmlName());
-                manifest.appendChild(useSdk);
-                XmlElement xmlElement = new XmlElement(useSdk, document);
-                Actions.NodeRecord nodeRecord = new Actions.NodeRecord(
-                        Actions.ActionType.INJECTED,
-                        new SourceFilePosition(xmlElement.getSourceFile(),
-                                SourcePosition.UNKNOWN),
-                        xmlElement.getId(),
-                        "use-sdk injection requested",
-                        NodeOperationType.STRICT);
-                actionRecorder.recordNodeAction(xmlElement, nodeRecord);
-                return xmlElement;
-            } else {
-                return new XmlElement((Element) usesSdks.item(0), document);
-            }
-        }
-    }
-
-    private static String getAndroidPrefix(Element xml) {
-        String toolsPrefix = XmlUtils.lookupNamespacePrefix(
-                xml, SdkConstants.ANDROID_URI, SdkConstants.ANDROID_NS_NAME, false);
-        if (!toolsPrefix.equals(SdkConstants.ANDROID_NS_NAME) && xml.getOwnerDocument()
-                .getDocumentElement().getAttribute("xmlns:" + toolsPrefix) == null) {
-            // this is weird, the document is using "android" prefix but it's not bound
-            // to our namespace. Add the proper xmlns declaration.
-            xml.setAttribute("xmlns:" + toolsPrefix, SdkConstants.ANDROID_URI);
-        }
-        return toolsPrefix;
-    }
-
-    /**
-     * Defines the merging type expected from the tool.
-     */
-    public enum MergeType {
-        /**
-         * Application merging type is used when packaging an application with a set of imported
-         * libraries. The resulting merged android manifest is final and is not expected to be
-         * imported in another application.
-         */
-        APPLICATION,
-
-        /**
-         * Library merging typee is used when packaging a library. The resulting android manifest
-         * file will not merge in all the imported libraries this library depends on. Also the tools
-         * annotations will not be removed as they can be useful when later importing the resulting
-         * merged android manifest into an application.
-         */
-        LIBRARY
-    }
-
-    /**
-     * Defines a property that can add or override itself into an XML document.
-     */
-    public interface AutoAddingProperty {
-
-        /**
-         * Add itself (possibly just override the current value) with the passed value
-         * @param actionRecorder to record actions.
-         * @param document the xml document to add itself to.
-         * @param value the value to set of this property.
-         */
-        void addTo(@NonNull ActionRecorder actionRecorder,
-                   @NonNull XmlDocument document,
-                   @NonNull String value);
-    }
-
-    /**
-     * Perform {@link com.tyron.build.compiler.manifest.ManifestMerger2.SystemProperty} injection.
-     * @param mergingReport to log actions and errors.
-     * @param xmlDocument the xml document to inject into.
-     */
-    protected void performSystemPropertiesInjection(
-            MergingReport.Builder mergingReport,
-            XmlDocument xmlDocument) {
-        for (SystemProperty systemProperty : SystemProperty.values()) {
-            String propertyOverride = mSystemPropertyResolver.getValue(systemProperty);
-            if (propertyOverride != null) {
-                systemProperty.addTo(
-                        mergingReport.getActionRecorder(), xmlDocument, propertyOverride);
-            }
-        }
-    }
-
-    /**
-     * This class will hold all invocation parameters for the manifest merging tool.
-     *
-     * There are broadly three types of input to the merging tool :
-     * <ul>
-     *     <li>Build types and flavors overriding manifests</li>
-     *     <li>Application main manifest</li>
-     *     <li>Library manifest files</li></lib>
-     * </ul>
-     *
-     * Only the main manifest file is a mandatory parameter.
-     *
-     * High level description of the merging will be as follow :
-     * <ol>
-     *     <li>Build type and flavors will be merged first in the order they were added. Highest
-     *     priority file added first, lowest added last.</li>
-     *     <li>Resulting document is merged with lower priority application main manifest file.</li>
-     *     <li>Resulting document is merged with each library file manifest file in the order
-     *     they were added. Highest priority added first, lowest added last.</li>
-     *     <li>Resulting document is returned as results of the merging process.</li>
-     * </ol>
-     *
-     */
-    public static class Invoker<T extends Invoker<T>>{
-
-        protected final File mMainManifestFile;
-
-        protected final ImmutableMap.Builder<SystemProperty, Object> mSystemProperties =
-                new ImmutableMap.Builder<SystemProperty, Object>();
-
-        protected final ILogger mLogger;
-
-        protected final ImmutableMap.Builder<String, Object> mPlaceholders =
-                new ImmutableMap.Builder<String, Object>();
-
-        private final ImmutableList.Builder<Pair<String, File>> mLibraryFilesBuilder =
-                new ImmutableList.Builder<Pair<String, File>>();
-        private final ImmutableList.Builder<File> mFlavorsAndBuildTypeFiles =
-                new ImmutableList.Builder<File>();
-        private final ImmutableList.Builder<Feature> mFeaturesBuilder =
-                new ImmutableList.Builder<Feature>();
-        private final MergeType mMergeType;
-        @Nullable private File mReportFile;
-
-        /**
-         * Sets a value for a {@link com.tyron.build.compiler.manifest.ManifestMerger2.SystemProperty}
-         * @param override the property to set
-         * @param value the value for the property
-         * @return itself.
-         */
-        public Invoker setOverride(SystemProperty override, String value) {
-            mSystemProperties.put(override, value);
-            return thisAsT();
-        }
-
-        /**
-         * Adds placeholders names and associated values for substitution.
-         * @return itself.
-         */
-        public Invoker setPlaceHolderValues(Map<String, String> keyValuePairs) {
-            mPlaceholders.putAll(keyValuePairs);
-            return thisAsT();
-        }
-
-        /**
-         * Adds a new placeholder name and value for substitution.
-         * @return itself.
-         */
-        public Invoker setPlaceHolderValue(String placeHolderName, String value) {
-            mPlaceholders.put(placeHolderName, value);
-            return thisAsT();
-        }
-
-        /**
-         * Optional behavior of the merging tool can be turned on by setting these Feature.
-         */
-        public enum Feature {
-
-            /**
-             * Keep all intermediary merged files during the merging process. This is particularly
-             * useful for debugging/tracing purposes.
-             */
-            KEEP_INTERMEDIARY_STAGES,
-
-            /**
-             * When logging file names, use {@link java.io.File#getName()} rather than
-             * {@link java.io.File#getPath()}
-             */
-            PRINT_SIMPLE_FILENAMES,
-
-            /**
-             * Perform a sweep after all merging activities to remove all fully qualified class
-             * names and replace them with the equivalent short version.
-             */
-            EXTRACT_FQCNS,
-
-            /**
-             * Perform a sweep after all merging activities to remove all tools: decorations.
-             */
-            REMOVE_TOOLS_DECLARATIONS,
-
-            /**
-             * Do no perform placeholders replacement.
-             */
-            NO_PLACEHOLDER_REPLACEMENT
-        }
-
-        /**
-         * Creates a new builder with the mandatory main manifest file.
-         * @param mainManifestFile application main manifest file.
-         * @param logger the logger interface to use.
-         */
-        private Invoker(
-                @NonNull File mainManifestFile,
-                @NonNull ILogger logger,
-                MergeType mergeType) {
-            this.mMainManifestFile = Preconditions.checkNotNull(mainManifestFile);
-            this.mLogger = logger;
-            this.mMergeType = mergeType;
-        }
-
-        /**
-         * Sets the file to use to write the merging report. If not called,
-         * the merging process will not write a report.
-         * @param mergeReport the file to write the report in.
-         * @return itself.
-         */
-        public Invoker setMergeReportFile(@NonNull File mergeReport) {
-            mReportFile = mergeReport;
-            return this;
-        }
-
-        /**
-         * Add one library file manifest, will be added last in the list of library files which will
-         * make the parameter the lowest priority library manifest file.
-         * @param file the library manifest file to add.
-         * @return itself.
-         */
-        public Invoker addLibraryManifest(File file) {
-            if (mMergeType == MergeType.LIBRARY) {
-                throw new IllegalStateException(
-                        "Cannot add library dependencies manifests when creating a library");
-            }
-            mLibraryFilesBuilder.add(Pair.of(file.getName(), file));
-            return thisAsT();
-        }
-
-        public Invoker addLibraryManifests(List<Pair<String, File>> namesAndFiles) {
-            if (mMergeType == MergeType.LIBRARY && !namesAndFiles.isEmpty()) {
-                throw new IllegalStateException(
-                        "Cannot add library dependencies manifests when creating a library");
-            }
-            mLibraryFilesBuilder.addAll(namesAndFiles);
-            return thisAsT();
-        }
-
-        /**
-         * Add several library file manifests at then end of the list which will make them the
-         * lowest priority manifest files. The relative priority between all the files passed as
-         * parameters will be respected.
-         * @param files library manifest files to add last.
-         * @return itself.
-         */
-        public Invoker addLibraryManifests(File... files) {
-            for (File file : files) {
-                addLibraryManifest(file);
-            }
-            return thisAsT();
-        }
-
-        /**
-         * Add a flavor or build type manifest file last in the list.
-         * @param file build type or flavor manifest file
-         * @return itself.
-         */
-        public Invoker addFlavorAndBuildTypeManifest(File file) {
-            this.mFlavorsAndBuildTypeFiles.add(file);
-            return thisAsT();
-        }
-
-        /**
-         * Add several flavor or build type manifest files last in the list. Relative priorities
-         * between the passed files as parameters will be respected.
-         * @param files build type of flavor manifest files to add.
-         * @return itself.
-         */
-        public Invoker addFlavorAndBuildTypeManifests(File... files) {
-            this.mFlavorsAndBuildTypeFiles.add(files);
-            return thisAsT();
-        }
-
-        /**
-         * Sets some optional features for the merge tool.
-         *
-         * @param features one to many features to set.
-         * @return itself.
-         */
-        public Invoker withFeatures(Feature...features) {
-            mFeaturesBuilder.add(features);
-            return thisAsT();
-        }
-
-        /**
-         * Perform the merging and return the result.
-         *
-         * @return an instance of {@link com.tyron.build.compiler.manifest.MergingReport} that will give
-         * access to all the logging and merging records.
-         *
-         * This method can be invoked several time and will re-do the file merges.
-         *
-         * @throws com.tyron.build.compiler.manifest.ManifestMerger2.MergeFailureException if the merging
-         * cannot be completed successfully.
-         */
-        public MergingReport merge() throws MergeFailureException {
-
-            // provide some free placeholders values.
-            ImmutableMap<SystemProperty, Object> systemProperties = mSystemProperties.build();
-            if (systemProperties.containsKey(SystemProperty.PACKAGE)) {
-                // if the package is provided, make it available for placeholder replacement.
-                mPlaceholders.put(PACKAGE_NAME, systemProperties.get(SystemProperty.PACKAGE));
-                // as well as applicationId since package system property overrides everything
-                // but not when output is a library since only the final (application)
-                // application Id should be used to replace libraries "applicationId" placeholders.
-                if (mMergeType != MergeType.LIBRARY) {
-                    mPlaceholders.put(APPLICATION_ID, systemProperties.get(SystemProperty.PACKAGE));
-                }
-            }
-
-            ManifestMerger2 manifestMerger =
-                    new ManifestMerger2(
-                            mLogger,
-                            mMainManifestFile,
-                            mLibraryFilesBuilder.build(),
-                            mFlavorsAndBuildTypeFiles.build(),
-                            mFeaturesBuilder.build(),
-                            mPlaceholders.build(),
-                            new MapBasedKeyBasedValueResolver<SystemProperty>(systemProperties),
-                            mMergeType,
-                            Optional.fromNullable(mReportFile));
-            return manifestMerger.merge();
-        }
-
-        @SuppressWarnings("unchecked")
-        private T thisAsT() {
-            return (T) this;
-        }
-    }
-
-    /**
-     * Helper class for map based placeholders key value pairs.
-     */
-    public static class MapBasedKeyBasedValueResolver<T> implements KeyBasedValueResolver<T> {
-
-        private final ImmutableMap<T, Object> keyValues;
-
-        public MapBasedKeyBasedValueResolver(Map<T, Object> keyValues) {
-            this.keyValues = ImmutableMap.copyOf(keyValues);
-        }
-
-        @Nullable
-        @Override
-        public String getValue(@NonNull T key) {
-            Object value = keyValues.get(key);
-            return value == null ? null : value.toString();
-        }
-    }
-
-    private static class ManifestInfo {
-
-        private ManifestInfo(
-                String name,
-                File location,
-                XmlDocument.Type type,
-                Optional<String> mainManifestPackageName) {
-            mName = name;
-            mLocation = location;
-            mType = type;
-            mMainManifestPackageName = mainManifestPackageName;
-        }
-
-        private final String mName;
-        private final File mLocation;
-        private final XmlDocument.Type mType;
-        private final Optional<String> mMainManifestPackageName;
-
-        File getLocation() {
-            return mLocation;
-        }
-
-        XmlDocument.Type getType() {
-            return mType;
-        }
-
-        Optional<String> getMainManifestPackageName() {
-            return mMainManifestPackageName;
-        }
-    }
-
-    private static class LoadedManifestInfo extends ManifestInfo {
-
-        @NonNull private final XmlDocument mXmlDocument;
-        @NonNull private final Optional<String> mOriginalPackageName;
-
-        private LoadedManifestInfo(@NonNull ManifestInfo manifestInfo,
-                                   @NonNull Optional<String> originalPackageName,
-                                   @NonNull XmlDocument xmlDocument) {
-            super(manifestInfo.mName,
-                    manifestInfo.mLocation,
-                    manifestInfo.mType,
-                    manifestInfo.getMainManifestPackageName());
-            mXmlDocument = xmlDocument;
-            mOriginalPackageName = originalPackageName;
-        }
-
-        @NonNull
-        public XmlDocument getXmlDocument() {
-            return mXmlDocument;
-        }
-
-        @NonNull
-        public Optional<String> getOriginalPackageName() {
-            return mOriginalPackageName;
-        }
-    }
-
-    /**
-     * Implementation a {@link com.tyron.build.compiler.manifest.KeyResolver} capable of resolving all
-     * selectors value in the context of the passed libraries to this merging activities.
-     */
-    static class SelectorResolver implements KeyResolver<String> {
-
-        private final Map<String, String> mSelectors = new HashMap<String, String>();
-
-        protected void addSelector(String key, String value) {
-            mSelectors.put(key, value);
-        }
-
-        @Nullable
-        @Override
-        public String resolve(String key) {
-            return mSelectors.get(key);
-        }
-
-        @Override
-        public Iterable<String> getKeys() {
-            return mSelectors.keySet();
-        }
-    }
-
-    // a wrapper exception to all sorts of failure exceptions that can be thrown during merging.
-    public static class MergeFailureException extends Exception {
-
-        protected MergeFailureException(Exception cause) {
-            super(cause);
-        }
-    }
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/MergingException.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/MergingException.java b/Build/src/main/java/com/tyron/build/compiler/manifest/MergingException.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/MergingException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,205 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Joiner;
-import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.tyron.build.compiler.manifest.blame.Message;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourceFilePosition;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-
-import org.xml.sax.SAXParseException;
-
-import java.io.File;
-import java.util.Collection;
-import java.util.List;
-import java.util.Objects;
-
-/**
- * Exception for errors during merging.
- */
-public class MergingException extends Exception {
-
-    public static final String MULTIPLE_ERRORS = "Multiple errors:";
-
-    @NonNull
-    private final List<Message> mMessages;
-
-    /**
-     * For internal use. Creates a new MergingException
-     *
-     * @param cause    the original exception. May be null.
-     * @param messages the messaged. Must contain at least one item.
-     */
-    protected MergingException(@Nullable Throwable cause, @NonNull Message... messages) {
-        super(messages.length == 1 ? messages[0].getText() : MULTIPLE_ERRORS, cause);
-        mMessages = ImmutableList.copyOf(messages);
-    }
-
-    public static class Builder {
-
-        @Nullable
-        private Throwable mCause = null;
-
-        @Nullable
-        private String mMessageText = null;
-
-        @Nullable
-        private String mOriginalMessageText = null;
-
-        @NonNull
-        private SourceFile mFile = SourceFile.UNKNOWN;
-
-        @NonNull
-        private SourcePosition mPosition = SourcePosition.UNKNOWN;
-
-        private Builder() {
-        }
-
-        public Builder wrapException(@NonNull Throwable cause) {
-            mCause = cause;
-            mOriginalMessageText = Throwables.getStackTraceAsString(cause);
-            return this;
-        }
-
-        public Builder withFile(@NonNull File file) {
-            mFile = new SourceFile(file);
-            return this;
-        }
-
-        public Builder withFile(@NonNull SourceFile file) {
-            mFile = file;
-            return this;
-        }
-
-        public Builder withPosition(@NonNull SourcePosition position) {
-            mPosition = position;
-            return this;
-        }
-
-        public Builder withMessage(@NonNull String messageText, Object... args) {
-            mMessageText = args.length == 0 ? messageText : String.format(messageText, args);
-            return this;
-        }
-
-        public MergingException build() {
-            if (mCause != null) {
-                if (mMessageText == null) {
-                    mMessageText = java.util.Objects.requireNonNull(
-                            mCause.getLocalizedMessage(), mCause.getClass().getCanonicalName());
-                }
-                if (mPosition == SourcePosition.UNKNOWN && mCause instanceof SAXParseException) {
-                    SAXParseException exception = (SAXParseException) mCause;
-                    int lineNumber = exception.getLineNumber();
-                    if (lineNumber != -1) {
-                        // Convert positions to be 0-based for SourceFilePosition.
-                        mPosition = new SourcePosition(lineNumber - 1,
-                                exception.getColumnNumber() - 1, -1);
-                    }
-                }
-            }
-
-            if (mMessageText == null) {
-                mMessageText = "Unknown error.";
-            }
-
-            return new MergingException(
-                    mCause,
-                    new Message(
-                            Message.Kind.ERROR,
-                            mMessageText,
-                            Objects.requireNonNull(mOriginalMessageText, mMessageText),
-                            new SourceFilePosition(mFile, mPosition)));
-        }
-
-    }
-
-    public static Builder wrapException(@NonNull Throwable cause) {
-        return new Builder().wrapException(cause);
-    }
-
-    public static Builder withMessage(@NonNull String message, Object... args) {
-        return new Builder().withMessage(message, args);
-    }
-
-
-    public static void throwIfNonEmpty(Collection<Message> messages) throws MergingException {
-        if (!messages.isEmpty()) {
-            throw new MergingException(null, Iterables.toArray(messages, Message.class));
-        }
-    }
-
-    @NonNull
-    public List<Message> getMessages() {
-        return mMessages;
-    }
-
-    /**
-     * Computes the error message to display for this error
-     */
-    @NonNull
-    @Override
-    public String getMessage() {
-        List<String> messages = Lists.newArrayListWithCapacity(mMessages.size());
-        for (Message message : mMessages) {
-            StringBuilder sb = new StringBuilder();
-            List<SourceFilePosition> sourceFilePositions = message.getSourceFilePositions();
-            if (sourceFilePositions.size() > 1 || !sourceFilePositions.get(0)
-                    .equals(SourceFilePosition.UNKNOWN)) {
-                sb.append(Joiner.on('\t').join(sourceFilePositions));
-            }
-
-            String text = message.getText();
-            if (sb.length() > 0) {
-                sb.append(':').append(' ');
-
-                // ALWAYS insert the string "Error:" between the path and the message.
-                // This is done to make the error messages more simple to detect
-                // (since a generic path: message pattern can match a lot of output, basically
-                // any labeled output, and we don't want to do file existence checks on any random
-                // string to the left of a colon.)
-                if (!text.startsWith("Error: ")) {
-                    sb.append("Error: ");
-                }
-            } else if (!text.contains("Error: ")) {
-                sb.append("Error: ");
-            }
-
-            // If the error message already starts with the path, strip it out.
-            // This avoids redundant looking error messages you can end up with
-            // like for example for permission denied errors where the error message
-            // string itself contains the path as a prefix:
-            //    /my/full/path: /my/full/path (Permission denied)
-            if (sourceFilePositions.size() == 1) {
-                File file = sourceFilePositions.get(0).getFile().getSourceFile();
-                if (file != null) {
-                    String path = file.getAbsolutePath();
-                    if (text.startsWith(path)) {
-                        int stripStart = path.length();
-                        if (text.length() > stripStart && text.charAt(stripStart) == ':') {
-                            stripStart++;
-                        }
-                        if (text.length() > stripStart && text.charAt(stripStart) == ' ') {
-                            stripStart++;
-                        }
-                        text = text.substring(stripStart);
-                    }
-                }
-            }
-
-            sb.append(text);
-            messages.add(sb.toString());
-        }
-        return Joiner.on('\n').join(messages);
-    }
-
-    @Override
-    public String toString() {
-        return getMessage();
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/OrphanXmlElement.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/OrphanXmlElement.java b/Build/src/main/java/com/tyron/build/compiler/manifest/OrphanXmlElement.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/OrphanXmlElement.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,104 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.ManifestModel.NodeTypes;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Preconditions;
-import com.google.common.base.Strings;
-import com.tyron.build.compiler.manifest.blame.SourceFile;
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-import com.tyron.build.util.XmlUtils;
-
-import org.w3c.dom.Element;
-
-/**
- * An xml element that does not belong to a {@link }
- */
-public class OrphanXmlElement extends XmlNode {
-
-    @NonNull
-    private final Element mXml;
-
-    @NonNull
-    private final NodeTypes mType;
-
-    public OrphanXmlElement(@NonNull Element xml) {
-
-        mXml = Preconditions.checkNotNull(xml);
-        NodeTypes nodeType;
-        String elementName = mXml.getNodeName();
-        // this is bit more complicated than it should be. Look first if there is a namespace
-        // prefix in the name, most elements don't. If they do, however, strip it off if it is the
-        // android prefix, but if it's custom namespace prefix, classify the node as CUSTOM.
-        int indexOfColon = elementName.indexOf(':');
-        if (indexOfColon != -1) {
-            String androidPrefix = XmlUtils.lookupNamespacePrefix(xml, SdkConstants.ANDROID_URI);
-            if (androidPrefix.equals(elementName.substring(0, indexOfColon))) {
-                nodeType = NodeTypes.fromXmlSimpleName(elementName.substring(indexOfColon + 1));
-            } else {
-                nodeType = NodeTypes.CUSTOM;
-            }
-        } else {
-            nodeType = NodeTypes.fromXmlSimpleName(elementName);
-        }
-        mType = nodeType;
-    }
-
-    /**
-     * Returns true if this xml element's {@link NodeTypes} is
-     * the passed one.
-     */
-    public boolean isA(NodeTypes type) {
-        return this.mType == type;
-    }
-
-    @NonNull
-    @Override
-    public Element getXml() {
-        return mXml;
-    }
-
-
-    @Override
-    public NodeKey getId() {
-        return new NodeKey(Strings.isNullOrEmpty(getKey())
-                ? getName().toString()
-                : getName().toString() + "#" + getKey());
-    }
-
-    @Override
-    public NodeName getName() {
-        return XmlNode.unwrapName(mXml);
-    }
-
-    /**
-     * Returns this xml element {@link NodeTypes}
-     */
-    @NonNull
-    public NodeTypes getType() {
-        return mType;
-    }
-
-    /**
-     * Returns the unique key for this xml element within the xml file or null if there can be only
-     * one element of this type.
-     */
-    @Nullable
-    public String getKey() {
-        return mType.getNodeKeyResolver().getKey(mXml);
-    }
-
-    @NonNull
-    @Override
-    public SourcePosition getPosition() {
-        return SourcePosition.UNKNOWN;
-    }
-
-    @Override
-    @NonNull
-    public SourceFile getSourceFile() {
-        return SourceFile.UNKNOWN;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMergeTask.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMergeTask.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMergeTask.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ManifestMergeTask.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,112 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import com.tyron.build.compiler.Task;
-import com.tyron.build.model.Project;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import org.apache.commons.io.FileUtils;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
-public class ManifestMergeTask extends Task {
-
-    private ManifestMerger2 mMerger;
-    private File mOutputFile;
-    private File mMainManifest;
-    private File[] mLibraryManifestFiles;
-    private String mPackageName;
-
-    private ILogger mLogger;
-
-    @Override
-    public String getName() {
-        return "ManifestMerger";
-    }
-
-    @Override
-    public void prepare(Project project, ILogger logger) throws IOException {
-        mLogger = logger;
-
-        mPackageName = getApplicationId(project);
-
-        mOutputFile = new File(project.getBuildDirectory(), "bin");
-        if (!mOutputFile.exists()) {
-            if (!mOutputFile.mkdirs()) {
-                throw new IOException("Unable to create build directory");
-            }
-        }
-        mOutputFile = new File(mOutputFile, "AndroidManifest.xml");
-        if (!mOutputFile.exists()) {
-            if (!mOutputFile.createNewFile()) {
-                throw new IOException("Unable to create manifest file");
-            }
-        }
-
-        mMainManifest = project.getManifestFile();
-        if (!mMainManifest.exists()) {
-            throw new IOException("Unable to find the main manifest file");
-        }
-
-        List<File> manifests = new ArrayList<>();
-        Set<File> libraries = project.getLibraries();
-        // Filter the libraries and add all that has a AndroidManifest.xml file
-        for (File library : libraries) {
-            File parent = library.getParentFile();
-            if (parent == null) {
-                logger.warning("Unable to access parent directory of a library");
-                continue;
-            }
-
-            File manifest = new File(parent, "AndroidManifest.xml");
-            if (manifest.exists()) {
-                if (manifest.length() != 0) {
-                    manifests.add(manifest);
-                }
-            }
-        }
-
-        mLibraryManifestFiles = manifests.toArray(new File[0]);
-    }
-
-
-    @Override
-    public void run() throws IOException, CompilationFailedException {
-
-        if (mLibraryManifestFiles == null || mLibraryManifestFiles.length == 0) {
-            // no libraries to merge, just copy the manifest file to the output
-            FileUtils.copyFile(mMainManifest, mOutputFile);
-            return;
-        }
-
-        ManifestMerger2.Invoker invoker = ManifestMerger2.newMerger(mMainManifest,
-                mLogger, ManifestMerger2.MergeType.APPLICATION)
-                .addLibraryManifests(mLibraryManifestFiles);
-        invoker.setOverride(ManifestMerger2.SystemProperty.PACKAGE, mPackageName);
-
-        try {
-            MergingReport report = invoker.merge();
-            if (report.getResult().isError()) {
-                throw new CompilationFailedException(report.getReportString());
-            }
-            if (report.getMergedDocument().isPresent()) {
-                FileUtils.writeStringToFile(mOutputFile, report.getMergedDocument().get().prettyPrint(), Charset.defaultCharset());
-            }
-        } catch (ManifestMerger2.MergeFailureException e) {
-            throw new CompilationFailedException(e);
-        }
-    }
-
-    private String getApplicationId(Project project) throws IOException {
-        String packageName = project.getPackageName();
-        if (packageName == null) {
-            throw new IOException("Failed to parse package name");
-        }
-        return packageName;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/NodeOperationType.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/NodeOperationType.java b/Build/src/main/java/com/tyron/build/compiler/manifest/NodeOperationType.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/NodeOperationType.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,102 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import com.tyron.build.util.SdkUtils;
-
-/**
- * Defines node operation types as it can be provided by user's through attributes on the
- * target xml element.
- *
- * <p>
- * Example:
- * <pre>
- *     <activity android:name="com.foo.bar.ActivityUI"
- *          tools:node="remove_children">
- *     </activity>
- * </pre>
- *
- */
-public enum NodeOperationType implements ConvertibleName {
-
-    /**
-     * Merges further definitions of the same element with this one.
-     */
-    MERGE(false),
-
-    /**
-     * Remove all children from the target element before merging it into the resulting merged
-     * manifest. This basically merges attributes only (attributes annotation still applies).
-     */
-    MERGE_ONLY_ATTRIBUTES(false),
-
-    /**
-     * Replace further definitions of the same element with this one. There can be 0..n similar
-     * elements replaced with the annotated xml element.
-     */
-    REPLACE(false),
-
-    /**
-     * Remove the next definition of the same element from the resulting merged manifest. There can
-     * be only one similar element removed. If further definition are encountered, a merging
-     * failure will be initiated.
-     */
-    REMOVE(true),
-
-    /**
-     * Remove all definitions of the same element from the resulting merged manifest.
-     */
-    REMOVE_ALL(true),
-
-    /**
-     * Remove all children from the target element before merging it into the resulting merged
-     * manifest. This basically merges all attributes only (attributes annotation still applies).
-     */
-    REMOVE_CHILDREN(false),
-
-    /**
-     * No further definition of this element should be encountered. A merging tool failure will be
-     * generated if there is one.
-     */
-    STRICT(false);
-
-    // specifies whether the node operation can support an associated {@link Selector}
-    private final boolean mIsSelectable;
-
-    NodeOperationType(boolean isSelectable) {
-        mIsSelectable = isSelectable;
-    }
-
-    /**
-     * Returns true if this operation supports a {@link Selector}
-     */
-    public boolean isSelectable() {
-        return mIsSelectable;
-    }
-
-    @Override
-    public String toXmlName() {
-        return SdkUtils.constantNameToXmlName(name());
-    }
-
-    @Override
-    public String toCamelCaseName() {
-        return SdkUtils.constantNameToCamelCase(name());
-    }
-
-    /**
-     * Returns true if the element will override (remove or replace) lower priority elements.
-     */
-    public boolean isOverriding() {
-        return this == REMOVE || this == REMOVE_ALL || this == REPLACE;
-    }
-
-    /**
-     * Local xml name of node operation types.
-     */
-    static final String NODE_LOCAL_NAME = "node"; //$NON-NLS-1$
-
-    /**
-     * local xml name for overriding uses-sdk operation types.
-     */
-    static final String OVERRIDE_USES_SDK = "overrideLibrary";
-}
-
Index: Build/src/main/java/com/tyron/build/compiler/manifest/OtherOperationType.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/OtherOperationType.java b/Build/src/main/java/com/tyron/build/compiler/manifest/OtherOperationType.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/OtherOperationType.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,14 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-/**
- * List of other http://schemas.android.com/tools namespace instructions that can be present in a
- * manifest file.
- */
-public enum OtherOperationType {
-
-    // used to direct lint
-    ignore,
-
-    // used to direct lint
-    targetApi
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/PlaceholderHandler.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/PlaceholderHandler.java b/Build/src/main/java/com/tyron/build/compiler/manifest/PlaceholderHandler.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/PlaceholderHandler.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,127 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.tyron.build.compiler.manifest.blame.SourcePosition;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Replaces all placeholders of the form ${name} with a tool invocation provided value
- */
-public class PlaceholderHandler {
-
-    // interesting placeholders names that are documented to be automatically provided.
-    public static final String INSTRUMENTATION_RUNNER = "instrumentationRunner";
-    public static final String PACKAGE_NAME = "packageName";
-    public static final String APPLICATION_ID = "applicationId";
-
-    // regular expression to recognize placeholders like ${name}, potentially surrounded by a
-    // prefix and suffix string. this will split in 3 groups, the prefix, the placeholder name, and
-    // the suffix.
-    static final Pattern PATTERN = Pattern.compile("([^\\$]*)\\$\\{([^\\}]*)\\}(.*)");
-
-    /**
-     * Interface to provide a value for a placeholder key.
-     * @param <T> the key type
-     */
-    public interface KeyBasedValueResolver<T> {
-
-        /**
-         * Returns a placeholder value for the placeholder key or null if none exists.
-         */
-        @Nullable
-        String getValue(@NonNull T key);
-    }
-
-    /**
-     * Returns true if the passed string is a placeholder value, false otherwise.
-     */
-    public static boolean isPlaceHolder(@NonNull String string) {
-        return PATTERN.matcher(string).matches();
-    }
-
-    /**
-     * Visits a document's entire tree and check each attribute for a placeholder existence.
-     * If one is found, delegate to the provided {@link KeyBasedValueResolver} to provide a value
-     * for the placeholder.
-     * <p>
-     * If no value is provided, an error will be generated.
-     *
-     * @param xmlDocument the xml document to visit
-     * @param valueProvider the placeholder value provider.
-     * @param mergingReportBuilder to report errors and log actions.
-     */
-    public void visit(
-            @NonNull ManifestMerger2.MergeType mergeType,
-            @NonNull XmlDocument xmlDocument,
-            @NonNull KeyBasedValueResolver<String> valueProvider,
-            @NonNull MergingReport.Builder mergingReportBuilder) {
-
-        visit(mergeType, xmlDocument.getRootNode(), valueProvider, mergingReportBuilder);
-    }
-
-    private void visit(
-            @NonNull ManifestMerger2.MergeType mergeType,
-            @NonNull XmlElement xmlElement,
-            @NonNull KeyBasedValueResolver<String> valueProvider,
-            @NonNull MergingReport.Builder mergingReportBuilder) {
-
-        for (XmlAttribute xmlAttribute : xmlElement.getAttributes()) {
-
-            StringBuilder resultString = new StringBuilder();
-            String inputString = xmlAttribute.getValue();
-            Matcher matcher = PATTERN.matcher(inputString);
-            if (matcher.matches()) {
-                while (matcher.matches()) {
-                    String placeholderValue = valueProvider.getValue(matcher.group(2));
-                    // whatever precedes the placeholder key is added back to the string.
-                    resultString.append(matcher.group(1));
-                    if (placeholderValue == null) {
-                        // if this is a library, ignore the failure
-                        MergingReport.Record.Severity severity =
-                                mergeType == ManifestMerger2.MergeType.LIBRARY
-                                        ? MergingReport.Record.Severity.INFO
-                                        : MergingReport.Record.Severity.ERROR;
-
-                        xmlAttribute.addMessage(mergingReportBuilder, severity,
-                                String.format(
-                                        "Attribute %1$s at %2$s requires a placeholder substitution"
-                                                + " but no value for <%3$s> is provided.",
-                                        xmlAttribute.getId(),
-                                        xmlAttribute.printPosition(),
-                                        matcher.group(2)
-                                ));
-                        // we add back the placeholder key, since this is not an error for libraries
-                        resultString.append("${");
-                        resultString.append(matcher.group(2));
-                        resultString.append("}");
-                    } else {
-                        // record the attribute set
-                        mergingReportBuilder.getActionRecorder().recordAttributeAction(
-                                xmlAttribute,
-                                SourcePosition.UNKNOWN,
-                                Actions.ActionType.INJECTED,
-                                null /* attributeOperationType */);
-
-                        // substitute the placeholder key with its value.
-                        resultString.append(placeholderValue);
-                    }
-                    // the new input string is the tail of the previous match, as it may contain
-                    // more placeholders to substitute.
-                    inputString = matcher.group(3);
-                    // reset the pattern matching with that new string to test for more placeholders
-                    matcher = PATTERN.matcher(inputString);
-                }
-                // append the last remainder (without placeholders) in the result string.
-                resultString.append(inputString);
-                xmlAttribute.getXml().setValue(resultString.toString());
-            }
-        }
-        for (XmlElement childElement : xmlElement.getMergeableElements()) {
-            visit(mergeType, childElement, valueProvider, mergingReportBuilder);
-        }
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/AndroidXPathFactory.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/AndroidXPathFactory.java b/Build/src/main/java/com/tyron/build/compiler/manifest/AndroidXPathFactory.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/AndroidXPathFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,80 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import javax.xml.XMLConstants;
-import javax.xml.namespace.NamespaceContext;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathFactory;
-/**
- * XPath factory with automatic support for the android name space.
- */
-public class AndroidXPathFactory {
-    /** Default prefix for android name space: 'android' */
-    public static final String DEFAULT_NS_PREFIX = "android";
-    private static final XPathFactory sFactory = XPathFactory.newInstance();
-    /** Name space context for Android resource XML files. */
-    private static class AndroidNamespaceContext implements NamespaceContext {
-        private static final AndroidNamespaceContext sThis = new AndroidNamespaceContext(
-                DEFAULT_NS_PREFIX);
-        private final String mAndroidPrefix;
-        private final List<String> mAndroidPrefixes;
-        /**
-         * Returns the default {@link AndroidNamespaceContext}.
-         */
-        private static AndroidNamespaceContext getDefault() {
-            return sThis;
-        }
-        /**
-         * Construct the context with the prefix associated with the android namespace.
-         * @param androidPrefix the Prefix
-         */
-        public AndroidNamespaceContext(String androidPrefix) {
-            mAndroidPrefix = androidPrefix;
-            mAndroidPrefixes = Collections.singletonList(mAndroidPrefix);
-        }
-        @Override
-        public String getNamespaceURI(String prefix) {
-            if (prefix != null) {
-                if (prefix.equals(mAndroidPrefix)) {
-                    return SdkConstants.NS_RESOURCES;
-                }
-            }
-            return XMLConstants.NULL_NS_URI;
-        }
-        @Override
-        public String getPrefix(String namespaceURI) {
-            if (SdkConstants.NS_RESOURCES.equals(namespaceURI)) {
-                return mAndroidPrefix;
-            }
-            return null;
-        }
-        @Override
-        public Iterator<?> getPrefixes(String namespaceURI) {
-            if (SdkConstants.NS_RESOURCES.equals(namespaceURI)) {
-                return mAndroidPrefixes.iterator();
-            }
-            return null;
-        }
-    }
-    /**
-     * Creates a new XPath object, specifying which prefix in the query is used for the
-     * android namespace.
-     * @param androidPrefix The namespace prefix.
-     */
-    public static XPath newXPath(String androidPrefix) {
-        XPath xpath = sFactory.newXPath();
-        xpath.setNamespaceContext(new AndroidNamespaceContext(androidPrefix));
-        return xpath;
-    }
-    /**
-     * Creates a new XPath object using the default prefix for the android namespace.
-     * @see #DEFAULT_NS_PREFIX
-     */
-    public static XPath newXPath() {
-        XPath xpath = sFactory.newXPath();
-        xpath.setNamespaceContext(AndroidNamespaceContext.getDefault());
-        return xpath;
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/com/tyron/build/compiler/manifest/AttributeOperationType.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/AttributeOperationType.java b/Build/src/main/java/com/tyron/build/compiler/manifest/AttributeOperationType.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/AttributeOperationType.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,57 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-/**
- * Defines attributes operations as it can be provided by users through attributes on the target
- * xml element.
- * <p>
- *
- * For instance:
- * <pre>
- *     {@code
- *     <uses-permission
- *         android:name="android.permission.CAMERA"
- *         android:maxSdkVersion=25
- *         tools:replace="android:maxSdkVersion"/>
- *     }
- * </pre>
- *
- * <p>
- *
- * The operation type is provided as part of the tools attribute name itself, so you can find
- * tools:remove, tools:replace, tools:strict. The value of that attribute is a comma separated list
- * of attribute names on which the operation applies.
- *
- * <p>
- * For instance:
- * <pre>
- *     {@code
- *     <permission
- *         android:name="android.permission.CAMERA"
- *         android:icon="@Res/foo"
- *         android:protectionLevel="dangerous"
- *         tools:replace="android:maxSdkVersion, protectionLevel"/>
- *     }
- * </pre>
- * will replace maxSdkVersion and protectionLevel attributes values when merging lower level xml
- * elements.
- */
-enum AttributeOperationType {
-
-    /**
-     * Removes the attributes from all further merging activities.
-     */
-    REMOVE,
-
-    /**
-     * Replace the attributes values with the provided one. (Will generate a merging error if no
-     * new value is provided).
-     */
-    REPLACE,
-
-    /**
-     * The attributes should not be specified by any lower priority xml elements.
-     */
-    STRICT,
-
-    IGNORE_WARNING
-}
Index: Build/src/main/java/com/tyron/build/compiler/manifest/ToolsInstructionsCleaner.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/manifest/ToolsInstructionsCleaner.java b/Build/src/main/java/com/tyron/build/compiler/manifest/ToolsInstructionsCleaner.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/manifest/ToolsInstructionsCleaner.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,123 +0,0 @@
-package com.tyron.build.compiler.manifest;
-
-import static com.tyron.build.compiler.manifest.MergingReport.Result.ERROR;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
-import com.tyron.build.log.ILogger;
-
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import com.google.errorprone.annotations.Immutable;
-
-/**
- * Removes all "tools:" statements from the resulting xml.
- *
- * All attributes belonging to the {@link SdkConstants#ANDROID_URI} namespace will be
- * removed. If an element contained a "tools:node=\"remove\"" attribute, the element will be
- * deleted.
- */
-@Immutable
-public class ToolsInstructionsCleaner {
-
-    private static final String REMOVE_OPERATION_XML_MAME =
-            NodeOperationType.REMOVE.toCamelCaseName();
-    private static final String REMOVE_ALL_OPERATION_XML_MAME =
-            NodeOperationType.REMOVE_ALL.toCamelCaseName();
-
-    /**
-     * Cleans all attributes belonging to the {@link SdkConstants#TOOLS_URI} namespace.
-     *
-     * @param document the xml document to clean
-     * @param logger logger to use in case of errors and warnings.
-     * @return the cleaned document or null if an error occurred.
-     */
-    @Nullable
-    public static XmlDocument cleanToolsReferences(
-            @NonNull XmlDocument document,
-            @NonNull ILogger logger) {
-
-        document = Preconditions.checkNotNull(document);
-        logger = Preconditions.checkNotNull(logger);
-        MergingReport.Result result = cleanToolsReferences(document.getRootNode().getXml(),
-                logger);
-        return result == MergingReport.Result.SUCCESS
-                ? document.reparse()
-                : null;
-    }
-
-    private static MergingReport.Result cleanToolsReferences(
-            Element element,
-            ILogger logger) {
-
-        NamedNodeMap namedNodeMap = element.getAttributes();
-        if (namedNodeMap != null) {
-            // make a copy of the original list of attributes as we will remove some during this
-            // process.
-            List<Node> attributes = new ArrayList<Node>();
-            for (int i = 0; i < namedNodeMap.getLength(); i++) {
-                attributes.add(namedNodeMap.item(i));
-            }
-            for (Node attribute : attributes) {
-                if (SdkConstants.TOOLS_URI.equals(attribute.getNamespaceURI())) {
-                    // we need to special case when the element contained tools:node="remove"
-                    // since it also needs to be deleted unless it had a selector.
-                    // if this is ools:node="removeAll", we always delete the element whether or
-                    // not there is a tools:selector.
-                    boolean hasSelector = namedNodeMap.getNamedItemNS(
-                            SdkConstants.TOOLS_URI, "selector") != null;
-                    if (attribute.getLocalName().equals(NodeOperationType.NODE_LOCAL_NAME)
-                            && (attribute.getNodeValue().equals(REMOVE_ALL_OPERATION_XML_MAME)
-                            || (attribute.getNodeValue().equals(REMOVE_OPERATION_XML_MAME))
-                            && !hasSelector)) {
-
-                        if (element.getParentNode().getNodeType() == Node.DOCUMENT_NODE) {
-                            logger.error(String.format(
-                                            "tools:node=\"%1$s\" not allowed on top level %2$s element",
-                                            attribute.getNodeValue(),
-                                            XmlNode.unwrapName(element)));
-                            return ERROR;
-                        } else {
-                            element.getParentNode().removeChild(element);
-                        }
-                    } else {
-                        // anything else, we just clean the attribute.
-                        element.removeAttributeNS(
-                                attribute.getNamespaceURI(), attribute.getLocalName());
-                    }
-                }
-                // this could also be the xmlns:tools declaration.
-                if (attribute.getNodeName().startsWith(SdkConstants.XMLNS_PREFIX)
-                        && SdkConstants.TOOLS_URI.equals(attribute.getNodeValue())) {
-                    element.removeAttribute(attribute.getNodeName());
-                }
-            }
-        }
-        // make a copy of the element children since we will be removing some during
-        // this process, we don't want side effects.
-        NodeList childNodes = element.getChildNodes();
-        ImmutableList.Builder<Element> childElements = ImmutableList.builder();
-        for (int i = 0; i < childNodes.getLength(); i++) {
-            Node node = childNodes.item(i);
-            if (node.getNodeType() == Node.ELEMENT_NODE) {
-                childElements.add((Element) node);
-            }
-        }
-        for (Element childElement : childElements.build()) {
-            if (cleanToolsReferences(childElement, logger) == ERROR) {
-                return ERROR;
-            }
-        }
-        return MergingReport.Result.SUCCESS;
-    }
-
-}
Index: Build/src/main/java/com/tyron/build/compiler/resource/AAPT2Compiler.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/resource/AAPT2Compiler.java b/Build/src/main/java/com/tyron/build/compiler/resource/AAPT2Compiler.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/resource/AAPT2Compiler.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,227 +0,0 @@
-package com.tyron.build.compiler.resource;
-
-import android.util.Log;
-
-import java.io.File;
-import java.io.IOException;
-
-import com.tyron.build.BuildModule;
-import com.tyron.build.model.Project;
-
-import java.nio.file.Files;
-import java.util.List;
-import java.util.ArrayList;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import com.tyron.build.log.ILogger;
-import com.tyron.common.util.BinaryExecutor;
-import com.tyron.build.exception.CompilationFailedException;
-import com.tyron.build.parser.FileManager;
-
-public class AAPT2Compiler {
-
-	private static final Pattern MANIFEST_PACKAGE = Pattern.compile("\\s*(package)\\s*(=)\\s*(\")([a-zA-Z0-9.]+)(\")");
-	private static final String TAG = AAPT2Compiler.class.getSimpleName();
-
-	private final Project mProject;
-	private final ILogger mLogger;
-
-	public AAPT2Compiler(ILogger log, Project project) {
-		mLogger = log;
-		mProject = project;
-	}
-
-	public void run() throws IOException, CompilationFailedException {
-		long start = System.currentTimeMillis();
-
-		compileProject();
-		link();
-
-		Log.d(TAG, "Resource compilation took " + (System.currentTimeMillis() - start) + " ms");
-	}
-
-	private void compileProject() throws IOException, CompilationFailedException {
-
-		mLogger.debug("Compiling project resources.");
-
-		FileManager.deleteDir(getOutputPath());
-		FileManager.deleteDir(new File(mProject.getBuildDirectory(), "gen"));
-
-		List<String> args = new ArrayList<>();
-		args.add(getBinary().getAbsolutePath());
-		args.add("compile");
-		args.add("--dir");
-		args.add(mProject.getResourceDirectory().getAbsolutePath());
-		args.add("-o");
-		args.add(createNewFile(getOutputPath(), "project.zip").getAbsolutePath());
-
-		BinaryExecutor exec = new BinaryExecutor();
-		exec.setCommands(args);
-		if (!exec.execute().trim().isEmpty()) {
-			throw new CompilationFailedException(exec.getLog());
-		}
-
-		compileLibraries();
-
-	}
-
-	private void compileLibraries() throws IOException, CompilationFailedException {
-
-		mLogger.debug("Compiling libraries.");
-
-		for (File file : mProject.getLibraries()) {
-			File parent = file.getParentFile();
-			if (parent == null) {
-				throw new IOException("Library folder doesn't exist");
-			}
-
-			File resFolder = new File(parent, "res");
-			if (!resFolder.exists() || !resFolder.isDirectory()) {
-				continue;
-			}
-
-			Log.d(TAG, "Compiling library " + parent.getName());
-
-			List<String> args = new ArrayList<>();
-			args.add(getBinary().getAbsolutePath());
-			args.add("compile");
-			args.add("--dir");
-			args.add(resFolder.getAbsolutePath());
-			args.add("-o");
-			args.add(createNewFile(getOutputPath(), parent.getName() + ".zip").getAbsolutePath());
-
-			BinaryExecutor exec = new BinaryExecutor();
-			exec.setCommands(args);
-			if (!exec.execute().trim().isEmpty()) {
-				throw new CompilationFailedException(exec.getLog());
-			}
-		}
-	}
-	
-	private void link() throws IOException, CompilationFailedException {
-		mLogger.debug("Linking resources");
-
-		List<String> args = new ArrayList<>();
-		
-		args.add(getBinary().getAbsolutePath());
-		args.add("link");
-		args.add("-I");
-		args.add(FileManager.getInstance().getAndroidJar().getAbsolutePath());
-		args.add("--allow-reserved-package-id");
-        args.add("--no-version-vectors");
-        args.add("--no-version-transitions");
-        args.add("--auto-add-overlay");
-        args.add("--min-sdk-version");
-		args.add(String.valueOf(mProject.getMinSdk()));
-		args.add("--target-sdk-version");
-		args.add(String.valueOf(mProject.getTargetSdk()));
-		
-		File[] resources = getOutputPath().listFiles();
-		if (resources != null) {
-			for (File resource : resources) {
-				if (resource.isDirectory()) {
-					continue;
-				}
-				if (!resource.getName().endsWith(".zip")) {
-					continue;
-				}
-				args.add("-R");
-				args.add(resource.getAbsolutePath());
-			}
-		}
-		args.add("--java");
-		File gen = new File(mProject.getBuildDirectory(), "gen");
-		if (!gen.exists()) {
-			if (!gen.mkdirs()) {
-				throw  new CompilationFailedException("Failed to create gen folder");
-			}
-		}
-		args.add(gen.getAbsolutePath());
-
-		args.add("--manifest");
-		args.add(mProject.getManifestFile().getAbsolutePath());
-
-		args.add("-o");
-		args.add(getOutputPath().getParent() + "/generated.apk.res");
-
-		args.add("--output-text-symbols");
-		File file = new File(getOutputPath(), "R.txt");
-		Files.deleteIfExists(file.toPath());
-		if (!file.createNewFile()) {
-			throw new IOException("Unable to create R.txt file");
-		}
-		args.add(file.getAbsolutePath());
-
-		BinaryExecutor exec = new BinaryExecutor();
-		exec.setCommands(args);
-		if (!exec.execute().trim().isEmpty()) {
-			throw new CompilationFailedException(exec.getLog());
-		}
-	}
-	
-	private File getOutputPath() throws IOException {
-		File file = new File(mProject.getBuildDirectory(), "bin/res");
-		if (!file.exists()) {
-			if (!file.mkdirs()) {
-				throw new IOException("Failed to get resource directory");
-			}
-		}
-		return file;
-	}
-
-	private File createNewFile(File parent, String name) throws IOException {
-        File createdFile = new File(parent, name);
-        if (!parent.exists()) {
-			if (!parent.mkdirs()) {
-				throw new IOException("Unable to create directories");
-			}
-		}
-		if (!createdFile.createNewFile()) {
-			throw new IOException("Unable to create file " + name);
-		}
-		return createdFile;
-	}
-
-	/**
-	 * Retrieves the package names of libraries of has a resource file
-	 * @return list of package names in a form of string separated by ":" for use with AAPT2 directly
-	 */
-	private String getPackageNames() {
-		StringBuilder builder = new StringBuilder();
-
-		// getLibraries return list of classes.jar, get its parent
-		for (File library : mProject.getLibraries()) {
-			File parent = library.getParentFile();
-
-			String packageName = getPackageName(parent);
-			if (packageName != null) {
-				builder.append(packageName);
-				builder.append(":");
-			}
-		}
-
-		return builder.toString();
-	}
-
-	public static String getPackageName(File library) {
-		String manifestString = FileManager.readFile(library);
-		Matcher matcher = MANIFEST_PACKAGE.matcher(manifestString);
-		if (matcher.find()) {
-			return matcher.group(4);
-		}
-		return null;
-	}
-
-	private static File getBinary() throws IOException {
-		File check = new File(
-			BuildModule.getContext().getApplicationInfo().nativeLibraryDir,
-			"libaapt2.so"
-		);
-		if (check.exists()) {
-			return check;
-		}
-
-		throw new IOException("AAPT2 Binary not found");
-	}
-}
Index: Build/src/main/java/com/tyron/build/compiler/Task.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/Task.java b/Build/src/main/java/com/tyron/build/compiler/Task.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/Task.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,31 +0,0 @@
-package com.tyron.build.compiler;
-
-import com.tyron.build.model.Project;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import java.io.IOException;
-
-/**
- *
- */
-public abstract class Task {
-
-    /**
-     * Called by {@link ApkBuilder} to display the name of the task to the logs
-     */
-    public abstract String getName();
-
-    /**
-     * Called before run() to give the subclass information about the project
-     * @throws IOException if an exception occurred during a file operation
-     */
-    public abstract void prepare(Project project, ILogger logger) throws IOException;
-
-    /**
-     * Called by the {@link ApkBuilder} to perform the task needed to do by this subclass
-     * @throws IOException if an exception occurred in a File operation
-     * @throws CompilationFailedException if an exception occurred while the task is running
-     */
-    public abstract void run() throws IOException, CompilationFailedException;
-}
Index: Build/src/main/java/com/tyron/build/compiler/incremental/kotlin/IncrementalKotlinCompiler.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/incremental/kotlin/IncrementalKotlinCompiler.java b/Build/src/main/java/com/tyron/build/compiler/incremental/kotlin/IncrementalKotlinCompiler.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/incremental/kotlin/IncrementalKotlinCompiler.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,27 +0,0 @@
-package com.tyron.build.compiler.incremental.kotlin;
-
-public class IncrementalKotlinCompiler {
-    /**
-     * GOTEM GOTEM GOTEM GOTEM HA GOTEM
-     * GOOOOOOOOOOOOOOOOOOOOOOOOOOOOTEM
-     *
-     *      * GOTEM GOTEM GOTEM GOTEM HA GOTEM
-     *      * GOOOOOOOOOOOOOOOOOOOOOOOOOOOOTEM
-     *      *
-     *           * GOTEM GOTEM GOTEM GOTEM HA GOTEM
-     *      * GOOOOOOOOOOOOOOOOOOOOOOOOOOOOTEM
-     *      *
-     *           * GOTEM GOTEM GOTEM GOTEM HA GOTEM
-     *      * GOOOOOOOOOOOOOOOOOOOOOOOOOOOOTEM
-     *      *
-     *           * GOTEM GOTEM GOTEM GOTEM HA GOTEM
-     *      * GOOOOOOOOOOOOOOOOOOOOOOOOOOOOTEM
-     *      *
-     *           * GOTEM GOTEM GOTEM GOTEM HA GOTEM
-     *      * GOOOOOOOOOOOOOOOOOOOOOOOOOOOOTEM
-     *      *
-     *           * GOTEM GOTEM GOTEM GOTEM HA GOTEM
-     *      * GOOOOOOOOOOOOOOOOOOOOOOOOOOOOTEM
-     *      *
-     */
-}
Index: Build/src/main/java/com/tyron/build/compiler/incremental/resource/ResourceFile.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/incremental/resource/ResourceFile.java b/Build/src/main/java/com/tyron/build/compiler/incremental/resource/ResourceFile.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/incremental/resource/ResourceFile.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,41 +0,0 @@
-package com.tyron.build.compiler.incremental.resource;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import java.io.File;
-import java.net.URI;
-
-/**
- * Used by {@link IncrementalAapt2Task} to find differences between two files
- */
-public class ResourceFile extends File {
-
-    public ResourceFile(@NonNull String pathname) {
-        super(pathname);
-    }
-
-    public ResourceFile(@Nullable String parent, @NonNull String child) {
-        super(parent, child);
-    }
-
-    public ResourceFile(@Nullable File parent, @NonNull String child) {
-        super(parent, child);
-    }
-
-    public ResourceFile(@NonNull URI uri) {
-        super(uri);
-    }
-
-    public static ResourceFile fromFile(File file) {
-        return new ResourceFile(file.getAbsolutePath());
-    }
-
-    @Override
-    public boolean equals(@Nullable Object obj) {
-        if (obj instanceof ResourceFile) {
-            return ((ResourceFile)obj).getName().equals(this.getName());
-        }
-        return false;
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/incremental/resource/IncrementalAapt2Task.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/incremental/resource/IncrementalAapt2Task.java b/Build/src/main/java/com/tyron/build/compiler/incremental/resource/IncrementalAapt2Task.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/incremental/resource/IncrementalAapt2Task.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,469 +0,0 @@
-package com.tyron.build.compiler.incremental.resource;
-
-import android.util.Log;
-
-import com.tyron.build.BuildModule;
-import com.tyron.build.compiler.Task;
-import com.tyron.build.exception.CompilationFailedException;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.model.Project;
-import com.tyron.build.parser.FileManager;
-import com.tyron.common.util.BinaryExecutor;
-
-import org.apache.commons.io.FileUtils;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.file.Files;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.stream.Collectors;
-
-public class IncrementalAapt2Task extends Task {
-
-    private static final String TAG = "IncrementalAAPT2";
-
-    private Project mProject;
-    private ILogger mLogger;
-
-    @Override
-    public String getName() {
-        return TAG;
-    }
-
-    @Override
-    public void prepare(Project project, ILogger logger) throws IOException {
-        mProject = project;
-        mLogger = logger;
-    }
-
-    public void run() throws IOException, CompilationFailedException {
-        Map<String, List<File>> filesToCompile = getFiles();
-        List<File> librariesToCompile = getLibraries();
-
-        compileProject(filesToCompile);
-        compileLibraries(librariesToCompile);
-
-        link();
-    }
-
-    private void compileProject(Map<String, List<File>> files) throws IOException, CompilationFailedException {
-
-        List<String> args = new ArrayList<>();
-        args.add(getBinary().getAbsolutePath());
-        args.add("compile");
-
-        for (String resourceType : files.keySet()) {
-            List<File> filesToCompile = files.get(resourceType);
-            if (filesToCompile != null && !filesToCompile.isEmpty()) {
-                for (File fileToCompile : filesToCompile) {
-                    args.add(fileToCompile.getAbsolutePath());
-                }
-            }
-        }
-        args.add("-o");
-
-        File outputCompiled = new File(mProject.getBuildDirectory(), "bin/res/compiled");
-        if (!outputCompiled.exists() && !outputCompiled.mkdirs()) {
-            throw new IOException("Failed to create compiled directory");
-        }
-        args.add(outputCompiled.getAbsolutePath());
-
-        BinaryExecutor executor = new BinaryExecutor();
-        executor.setCommands(args);
-        if (!executor.execute().isEmpty()) {
-            throw new CompilationFailedException(executor.getLog());
-        }
-
-        copyMapToDir(files);
-    }
-
-    private void compileLibraries(List<File> libraries) throws IOException, CompilationFailedException {
-
-        mLogger.debug("Compiling libraries.");
-
-        File output = new File(mProject.getBuildDirectory(), "bin/res");
-        if (!output.exists()) {
-            if (!output.mkdirs()) {
-                throw new IOException("Failed to create resource output directory");
-            }
-        }
-
-        for (File file : libraries) {
-            File parent = file.getParentFile();
-            if (parent == null) {
-                throw new IOException("Library folder doesn't exist");
-            }
-            File[] files = parent.listFiles();
-            if (files == null) {
-                continue;
-            }
-
-            for (File inside : files) {
-                if (inside.isDirectory() && inside.getName().equals("res")) {
-                    Log.d(TAG, "Compiling library " + parent.getName());
-
-                    List<String> args = new ArrayList<>();
-                    args.add(getBinary().getAbsolutePath());
-                    args.add("compile");
-                    args.add("--dir");
-                    args.add(inside.getAbsolutePath());
-                    args.add("-o");
-                    args.add(createNewFile(output, parent.getName() + ".zip").getAbsolutePath());
-
-                    BinaryExecutor exec = new BinaryExecutor();
-                    exec.setCommands(args);
-                    if (!exec.execute().trim().isEmpty()) {
-                        throw new CompilationFailedException(exec.getLog());
-                    }
-                }
-            }
-        }
-    }
-
-    private void link() throws IOException, CompilationFailedException {
-        mLogger.debug("Linking resources");
-
-        List<String> args = new ArrayList<>();
-
-        args.add(getBinary().getAbsolutePath());
-        args.add("link");
-        args.add("-I");
-        args.add(FileManager.getInstance().getAndroidJar().getAbsolutePath());
-
-        File files = new File(getOutputPath(), "compiled");
-        File[] resources = files.listFiles();
-        if (resources == null) {
-            throw new CompilationFailedException("No files to compile");
-        }
-        for (File resource : resources) {
-            if (!resource.getName().endsWith(".flat")) {
-                mLogger.warning("Unrecognized file " + resource.getName() + " at compiled directory");
-                continue;
-            }
-            args.add(resource.getAbsolutePath());
-        }
-
-        args.add("--allow-reserved-package-id");
-        args.add("--no-version-vectors");
-        args.add("--no-version-transitions");
-        args.add("--auto-add-overlay");
-        args.add("--min-sdk-version");
-        args.add(String.valueOf(mProject.getMinSdk()));
-        args.add("--target-sdk-version");
-        args.add(String.valueOf(mProject.getTargetSdk()));
-
-        resources = getOutputPath().listFiles();
-        if (resources != null) {
-            for (File resource : resources) {
-                if (resource.isDirectory()) {
-                    continue;
-                }
-                if (!resource.getName().endsWith(".zip")) {
-                    mLogger.warning("Unrecognized file " + resource.getName());
-                    continue;
-                }
-
-                if (resource.length() == 0) {
-                    mLogger.warning("Empty zip file " + resource.getName());
-                }
-
-                args.add("-R");
-                args.add(resource.getAbsolutePath());
-            }
-        }
-
-        args.add("--java");
-        File gen = new File(mProject.getBuildDirectory(), "gen");
-        if (!gen.exists()) {
-            if (!gen.mkdirs()) {
-                throw  new CompilationFailedException("Failed to create gen folder");
-            }
-        }
-        args.add(gen.getAbsolutePath());
-
-        args.add("--manifest");
-        File mergedManifest = new File(mProject.getBuildDirectory(), "bin/AndroidManifest.xml");
-        if (!mergedManifest.exists()) {
-            throw new IOException("Unable to get merged manifest file");
-        }
-        args.add(mergedManifest.getAbsolutePath());
-
-        args.add("-o");
-        args.add(getOutputPath().getParent() + "/generated.apk.res");
-
-        args.add("--output-text-symbols");
-        File file = new File(getOutputPath(), "R.txt");
-        Files.deleteIfExists(file.toPath());
-        if (!file.createNewFile()) {
-            throw new IOException("Unable to create R.txt file");
-        }
-        args.add(file.getAbsolutePath());
-
-        BinaryExecutor exec = new BinaryExecutor();
-        exec.setCommands(args);
-        if (!exec.execute().trim().isEmpty()) {
-            throw new CompilationFailedException(exec.getLog());
-        }
-    }
-    /**
-     * Utility function to get all the files that needs to be recompiled
-     * @return resource files to compile
-     */
-    public Map<String, List<File>> getFiles() throws IOException {
-        Map<String, List<ResourceFile>> newFiles = findFiles(mProject.getResourceDirectory());
-        Map<String, List<ResourceFile>> oldFiles = findFiles(getOutputDirectory());
-        Map<String, List<File>> filesToCompile = new HashMap<>();
-
-        for (String resourceType : newFiles.keySet()) {
-
-            // if the cache doesn't contain the new files then its considered new
-            if (!oldFiles.containsKey(resourceType)) {
-                List<ResourceFile> files = newFiles.get(resourceType);
-                if (files != null) {
-                    addToMapList(filesToCompile, resourceType, files);
-                }
-                continue;
-            }
-
-            // both contain the resource type, compare the contents
-            if (oldFiles.containsKey(resourceType)) {
-                List<ResourceFile> newFilesResource = newFiles.get(resourceType);
-                List<ResourceFile> oldFilesResource = oldFiles.get(resourceType);
-
-                if (newFilesResource == null) {
-                    newFilesResource = Collections.emptyList();
-                }
-                if (oldFilesResource == null) {
-                    oldFilesResource = Collections.emptyList();
-                }
-
-                addToMapList(filesToCompile, resourceType, getModifiedFiles(newFilesResource, oldFilesResource));
-            }
-        }
-
-        for (String resourceType : oldFiles.keySet()) {
-            // if the new files doesn't contain the old file then its deleted
-            if (!newFiles.containsKey(resourceType)) {
-                Log.d("IncrementalAAPT2", "Deleting resource folder " + resourceType);
-                List<ResourceFile> files = oldFiles.get(resourceType);
-                if (files != null) {
-                    for (File file : files) {
-                        if (!file.delete()) {
-                            throw new IOException("Failed to delete file " + file);
-                        }
-                    }
-                }
-            }
-        }
-
-        return filesToCompile;
-    }
-
-    /**
-     * Utility method to add a list of files to a map, if it doesn't exist, it creates a new one
-     * @param map The map to add to
-     * @param key Key to add the value
-     * @param values The list of files to add
-     */
-    private void addToMapList(Map<String, List<File>> map, String key, List<ResourceFile> values) {
-        List<File> mapValues = map.get(key);
-        if (mapValues == null) {
-            mapValues = new ArrayList<>();
-        }
-
-        mapValues.addAll(values);
-        map.put(key, mapValues);
-    }
-
-    private void copyMapToDir(Map<String, List<File>> map) throws IOException {
-        File output = new File(mProject.getBuildDirectory(), "intermediate/resources");
-        if (!output.exists()) {
-            if (!output.mkdirs()) {
-                throw new IOException("Failed to create intermediate directory");
-            }
-        }
-
-        for (String resourceType : map.keySet()) {
-            File outputDir = new File(output, resourceType);
-            if (!outputDir.exists()) {
-               if (!outputDir.mkdir()) {
-                   throw new IOException("Failed to create output directory for " + outputDir);
-               }
-            }
-
-            List<File> files = map.get(resourceType);
-            if (files != null) {
-                for (File file : files) {
-                    FileUtils.copyFileToDirectory(file, outputDir, true);
-                }
-            }
-        }
-    }
-
-    /**
-     * Utility method to compare to list of files
-     */
-    private List<ResourceFile> getModifiedFiles(List<ResourceFile> newFiles, List<ResourceFile> oldFiles) throws IOException {
-        List<ResourceFile> resourceFiles = new ArrayList<>();
-
-        for (ResourceFile newFile : newFiles) {
-            if (!oldFiles.contains(newFile)) {
-                resourceFiles.add(newFile);
-            } else {
-                File oldFile = oldFiles.get(oldFiles.indexOf(newFile));
-                if (contentModified(newFile, oldFile)) {
-                    resourceFiles.add(newFile);
-                    if (!oldFile.delete()) {
-                        throw new IOException("Failed to delete file " + oldFile.getName());
-                    }
-                }
-                oldFiles.remove(oldFile);
-            }
-        }
-
-        for (ResourceFile removedFile : oldFiles) {
-            if (!removedFile.delete()) {
-                throw new IOException("Failed to delete old file " + removedFile);
-            }
-        }
-
-        return resourceFiles;
-    }
-
-    private boolean contentModified(File newFile, File oldFile) {
-        if (!oldFile.exists() || !newFile.exists()) {
-            return true;
-        }
-
-        if (newFile.length() != oldFile.length()) {
-            return true;
-        }
-
-        return newFile.lastModified() > oldFile.lastModified();
-    }
-
-    /**
-     * Returns a map of resource type, and the files for a given resource directory
-     * @param file res directory
-     * @return Map of resource type and the files corresponding to it
-     */
-    private Map<String, List<ResourceFile>> findFiles(File file) {
-        File[] children = file.listFiles();
-        if (children == null) {
-            return Collections.emptyMap();
-        }
-
-        Map<String, List<ResourceFile>> map = new HashMap<>();
-        for (File child : children) {
-            if (!file.isDirectory()) {
-                continue;
-            }
-
-            String resourceType = child.getName();
-            File[] resourceFiles = child.listFiles();
-            List<File> files;
-            if (resourceFiles == null) {
-                files = Collections.emptyList();
-            } else {
-                files = Arrays.asList(resourceFiles);
-            }
-
-
-            map.put(resourceType, files.stream().map(ResourceFile::fromFile).collect(Collectors.toList()));
-        }
-
-        return map;
-    }
-
-    /**
-     * Returns the list of resource directories of libraries that needs to be compiled
-     * It determines whether the library should be compiled by checking the build/bin/res folder,
-     * if it contains a zip file with its name, then its most likely the same library
-     */
-    private List<File> getLibraries()  throws IOException {
-        File resDir = new File(mProject.getBuildDirectory(), "bin/res");
-        if (!resDir.exists()) {
-            if (!resDir.mkdirs()) {
-                throw new IOException("Failed to create resource directory");
-            }
-        }
-
-        List<File> libraries = new ArrayList<>();
-
-        for (File library : mProject.getLibraries()) {
-            File parent = library.getParentFile();
-            if (parent != null) {
-
-                if (!new File(parent, "res").exists()) {
-                    // we don't need to check it if it has no resource directory
-                    continue;
-                }
-
-                File check = new File(resDir, parent.getName() + ".zip");
-                if (!check.exists()) {
-                    libraries.add(library);
-                }
-            }
-        }
-
-        return libraries;
-    }
-
-    private File createNewFile(File parent, String name) throws IOException {
-        File createdFile = new File(parent, name);
-        if (!parent.exists()) {
-            if (!parent.mkdirs()) {
-                throw new IOException("Unable to create directories");
-            }
-        }
-        if (!createdFile.createNewFile()) {
-            throw new IOException("Unable to create file " + name);
-        }
-        return createdFile;
-    }
-
-    private File getOutputDirectory() throws IOException {
-        File intermediateDirectory = new File(mProject.getBuildDirectory(), "intermediate");
-
-        if (!intermediateDirectory.exists()) {
-            if (!intermediateDirectory.mkdirs()) {
-                throw new IOException("Failed to create intermediate directory");
-            }
-        }
-
-        File resourceDirectory = new File(intermediateDirectory, "resources");
-        if (!resourceDirectory.exists()) {
-            if (!resourceDirectory.mkdirs()) {
-                throw new IOException("Failed to create resource directory");
-            }
-        }
-        return resourceDirectory;
-    }
-
-    private File getOutputPath() throws IOException {
-        File file = new File(mProject.getBuildDirectory(), "bin/res");
-        if (!file.exists()) {
-            if (!file.mkdirs()) {
-                throw new IOException("Failed to get resource directory");
-            }
-        }
-        return file;
-    }
-
-    private static File getBinary() throws IOException {
-        File check = new File(
-                BuildModule.getContext().getApplicationInfo().nativeLibraryDir,
-                "libaapt2.so"
-        );
-        if (check.exists()) {
-            return check;
-        }
-
-        throw new IOException("AAPT2 Binary not found");
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/ApkSigner.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/ApkSigner.java b/Build/src/main/java/com/tyron/build/compiler/ApkSigner.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/ApkSigner.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,73 +0,0 @@
-package com.tyron.build.compiler;
-
-import com.tyron.build.BuildModule;
-import com.tyron.common.util.Decompress;
-
-import java.util.ArrayList;
-import java.io.File;
-
-
-public class ApkSigner {
-
-    public static class Mode {
-        public static int TEST = 0;
-        //ToDo add more modes
-    }
-
-
-    private final ArrayList<String> commands ;
-    private final String mApkInputPath ;
-    private final String mApkOutputPath;
-
-    public ApkSigner(String inputPath ,String outputPath,int mode){
-        commands = new ArrayList<>();
-        mApkInputPath = inputPath;
-        mApkOutputPath = outputPath;
-
-    }
-
-    //TODO: Adjust min and max sdk
-    public void sign() throws Exception{
-        commands.add("sign");
-        commands.add("--key");
-        commands.add(getTestKeyFilePath());
-        commands.add("--cert");
-        commands.add(getTestCertFilePath());
-        commands.add("--min-sdk-version");
-        commands.add("21");
-        commands.add("--max-sdk-version");
-        commands.add("30");
-        commands.add("--out");
-        commands.add(mApkOutputPath);
-        commands.add("--in");
-        commands.add(mApkInputPath);
-        com.android.apksigner.ApkSignerTool.main(commands.toArray(new String[0]));
-
-    }
-
-
-    private String getTestKeyFilePath() {
-        File check = new File(BuildModule.getContext().getFilesDir() + "/temp/testkey.pk8");
-
-        if (check.exists()) {
-            return check.getAbsolutePath();
-        }
-
-        Decompress.unzipFromAssets(BuildModule.getContext(), "testkey.pk8.zip", check.getParentFile().getAbsolutePath());
-
-        return check.getAbsolutePath();
-    }
-
-    private String getTestCertFilePath() {
-        File check = new File(BuildModule.getContext().getFilesDir() + "/temp/testkey.x509.pem");
-
-        if (check.exists()) {
-            return check.getAbsolutePath();
-        }
-
-        Decompress.unzipFromAssets(BuildModule.getContext(), "testkey.x509.pem.zip", check.getParentFile().getAbsolutePath());
-
-        return check.getAbsolutePath();
-    }
-
-}
Index: Build/src/main/java/com/tyron/build/compiler/ApkBuilder.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/ApkBuilder.java b/Build/src/main/java/com/tyron/build/compiler/ApkBuilder.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/ApkBuilder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,93 +0,0 @@
-package com.tyron.build.compiler;
-
-import android.os.Handler;
-import android.os.Looper;
-
-import com.tyron.build.compiler.apk.PackageTask;
-import com.tyron.build.compiler.apk.SignTask;
-import com.tyron.build.compiler.dex.D8Task;
-import com.tyron.build.compiler.incremental.resource.IncrementalAapt2Task;
-import com.tyron.build.compiler.java.JavaTask;
-import com.tyron.build.compiler.manifest.ManifestMergeTask;
-import com.tyron.build.compiler.symbol.MergeSymbolsTask;
-import com.tyron.build.model.Project;
-import com.tyron.build.log.ILogger;
-import com.tyron.build.exception.CompilationFailedException;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-/**
- * Main entry point for building apk files, this class does all
- * the necessary operations for building apk files such as compiling resources,
- * compiling java files, dexing and merging
- */
-public class ApkBuilder {
-
-    public interface OnResultListener {
-        void onComplete(boolean success, String message);
-    }
-
-    public interface TaskListener {
-        void onTaskStarted(String name, String message);
-    }
-
-    private final ILogger log;
-    private final Project mProject;
-    private final ExecutorService service = Executors.newFixedThreadPool(1);
-
-    private TaskListener mTaskListener;
-
-    public ApkBuilder(ILogger model, Project project) {
-        log = model;
-        mProject = project;
-    }
-
-    public void setTaskListener(TaskListener listener) {
-        mTaskListener = listener;
-    }
-
-    public void build(OnResultListener listener) {
-        service.execute(() -> {
-            try {
-                long initialStart = System.currentTimeMillis();
-                doBuild();
-
-                post(() -> listener.onComplete(true, "Build success. Took " + (System.currentTimeMillis() - initialStart) + " ms"));
-            } catch (IOException | CompilationFailedException e) {
-                post(() -> listener.onComplete(false, e.getMessage()));
-            }
-        });
-    }
-
-    private final Handler handler = new Handler(Looper.getMainLooper());
-
-    private void post(Runnable runnable) {
-        handler.post(runnable);
-    }
-
-    // TODO: run tasks in parallel if applicable
-    private void doBuild() throws IOException, CompilationFailedException {
-        List<Task> tasks = getTasks();
-
-        for (Task task : tasks) {
-            post(() -> mTaskListener.onTaskStarted(task.getName(), "Task started."));
-            task.prepare(mProject, log);
-            task.run();
-        }
-    }
-
-    private List<Task> getTasks() {
-        return Arrays.asList(
-                new ManifestMergeTask(),
-                new IncrementalAapt2Task(),
-                new MergeSymbolsTask(),
-                new JavaTask(),
-                new D8Task(),
-                new PackageTask(),
-                new SignTask());
-    }
-}
Index: Build/src/main/java/com/tyron/build/compiler/LibraryChecker.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/compiler/LibraryChecker.java b/Build/src/main/java/com/tyron/build/compiler/LibraryChecker.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/compiler/LibraryChecker.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,122 +0,0 @@
-package com.tyron.build.compiler;
-
-import android.util.Log;
-
-import com.tyron.build.model.Project;
-import com.tyron.build.parser.FileManager;
-import com.tyron.code.util.Decompress;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Checks libraries in app/libs and copies them to app/build/libs
- * This is done to support .aar files
- */
-public class LibraryChecker {
-
-    private static final String TAG = LibraryChecker.class.getSimpleName();
-
-    private final Project mProject;
-    private final File mLibsDir;
-
-    public LibraryChecker(Project project) {
-        mProject = project;
-        mLibsDir = new File(project.getBuildDirectory(), "libs");
-    }
-
-    public void check() {
-        if (!mLibsDir.exists()) {
-            if (!mLibsDir.mkdirs()) {
-                return;
-            }
-        }
-        File[] libs = mProject.getLibraryDirectory().listFiles();
-        if (libs == null) {
-            return;
-        }
-
-        List<String> files = new ArrayList<>();
-
-        for (File lib : libs) {
-            try {
-                if (lib.getName().endsWith(".jar")) {
-                    copyIfNeeded(lib);
-                    files.add(lib.getName().substring(0, lib.getName().lastIndexOf(".")));
-                } else if (lib.getName().endsWith(".aar")) {
-                    copyAarIfNeeded(lib);
-                    files.add(lib.getName().substring(0, lib.getName().lastIndexOf(".")));
-                }
-            } catch (IOException e) {
-                Log.e(TAG, e.getMessage());
-            }
-        }
-
-
-
-        File[] libraries = mLibsDir.listFiles();
-        if (libraries != null) {
-            for (File library : libraries) {
-                if (!files.contains(library.getName())) {
-                    Log.d(TAG, "Library " + library.getName() + " has been removed.");
-                    FileManager.deleteDir(library);
-                }
-            }
-        }
-
-    }
-
-    private void copyIfNeeded(File file) throws IOException {
-        String nameNoExt = file.getName().substring(0, file.getName().lastIndexOf("."));
-        File check = new File(mLibsDir, nameNoExt + "/classes.jar");
-        if (check.exists()) {
-            if (check.length() == file.length()) {
-                return;
-            }
-        }
-        Log.d(TAG, "Copying jar file " + file.getName());
-        File parent = check.getParentFile();
-        if (parent == null) {
-            throw new IOException("Unable to access parent file of " + check.getName());
-        }
-        if (!check.getParentFile().mkdirs()) {
-            throw new IOException("Couldn't create directories for " + nameNoExt);
-        }
-        if (!check.createNewFile()) {
-            throw new IOException("Couldn't create the jar file for " + nameNoExt);
-        }
-        copy(file, check);
-    }
-
-    private void copyAarIfNeeded(File aar) throws IOException {
-        String nameNoExt = aar.getName().substring(0, aar.getName().lastIndexOf("."));
-        File check = new File(mLibsDir, nameNoExt);
-        if (check.exists()) {
-            return;
-        }
-
-        Log.d(TAG, "Copying aar file " + aar.getName());
-        if (!check.mkdirs()) {
-            throw new IOException("Couldn't create directories for " + nameNoExt);
-        }
-        Decompress.unzip(aar.getAbsolutePath(), check.getAbsolutePath());
-    }
-
-
-    public static void copy(File src, File dst) throws IOException {
-        try (InputStream in = new FileInputStream(src)) {
-            try (OutputStream out = new FileOutputStream(dst)) {
-                byte[] buf = new byte[1024];
-                int len;
-                while ((len = in.read(buf)) > 0) out.write(buf, 0, len);
-            }
-        }
-    }
-
-}
Index: Build/src/main/java/com/tyron/build/exception/CompilationFailedException.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/exception/CompilationFailedException.java b/Build/src/main/java/com/tyron/build/exception/CompilationFailedException.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/exception/CompilationFailedException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,12 +0,0 @@
-package com.tyron.build.exception;
-
-public class CompilationFailedException extends Exception {
-
-	public CompilationFailedException(Exception exception) {
-		super(exception);
-	}
-
-	public CompilationFailedException(String message) {
-		super(message);
-	}
-}
Index: Build/src/main/java/com/tyron/build/BuildModule.java
===================================================================
diff --git a/Build/src/main/java/com/tyron/build/BuildModule.java b/Build/src/main/java/com/tyron/build/BuildModule.java
deleted file mode 100644
--- a/Build/src/main/java/com/tyron/build/BuildModule.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,16 +0,0 @@
-package com.tyron.build;
-
-import android.content.Context;
-
-public class BuildModule {
-
-    private static Context mApplicationContext;
-
-    public static void initialize(Context applicationContext) {
-            mApplicationContext = applicationContext.getApplicationContext();
-    }
-
-    public static Context getContext() {
-        return mApplicationContext;
-    }
-}
Index: Build/src/main/java/org/w3c/dom/ls/LSSerializerFilter.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/ls/LSSerializerFilter.java b/Build/src/main/java/org/w3c/dom/ls/LSSerializerFilter.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/ls/LSSerializerFilter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,93 +0,0 @@
-package org.w3c.dom.ls;
-
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2004 World Wide Web Consortium,
- *
- * (Massachusetts Institute of Technology, European Research Consortium for
- * Informatics and Mathematics, Keio University). All Rights Reserved. This
- * work is distributed under the W3C(r) Software License [1] in the hope that
- * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
- * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
- */
-
-
-import org.w3c.dom.traversal.NodeFilter;
-
-/**
- *  <code>LSSerializerFilter</code>s provide applications the ability to
- * examine nodes as they are being serialized and decide what nodes should
- * be serialized or not. The <code>LSSerializerFilter</code> interface is
- * based on the <code>NodeFilter</code> interface defined in [<a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>DOM Level 2 Traversal and      Range</a>]
- * .
- * <p> <code>Document</code>, <code>DocumentType</code>,
- * <code>DocumentFragment</code>, <code>Notation</code>, <code>Entity</code>
- * , and children of <code>Attr</code> nodes are not passed to the filter.
- * The child nodes of an <code>EntityReference</code> node are only passed
- * to the filter if the <code>EntityReference</code> node is skipped by the
- * method <code>LSParserFilter.acceptNode()</code>.
- * <p> When serializing an <code>Element</code>, the element is passed to the
- * filter before any of its attributes are passed to the filter. Namespace
- * declaration attributes, and default attributes (except in the case when "
- * discard-default-content" is set to <code>false</code>), are never passed
- * to the filter.
- * <p> The result of any attempt to modify a node passed to a
- * <code>LSSerializerFilter</code> is implementation dependent.
- * <p> DOM applications must not raise exceptions in a filter. The effect of
- * throwing exceptions from a filter is DOM implementation dependent.
- * <p> For efficiency, a node passed to the filter may not be the same as the
- * one that is actually in the tree. And the actual node (node object
- * identity) may be reused during the process of filtering and serializing a
- * document.
- * <p>See also the <a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407'>Document Object Model (DOM) Level 3 Load
- and Save Specification</a>.
- */
-public interface LSSerializerFilter extends NodeFilter {
-    /**
-     *  Tells the <code>LSSerializer</code> what types of nodes to show to the
-     * filter. If a node is not shown to the filter using this attribute, it
-     * is automatically serialized. See <code>NodeFilter</code> for
-     * definition of the constants. The constants <code>SHOW_DOCUMENT</code>
-     * , <code>SHOW_DOCUMENT_TYPE</code>, <code>SHOW_DOCUMENT_FRAGMENT</code>
-     * , <code>SHOW_NOTATION</code>, and <code>SHOW_ENTITY</code> are
-     * meaningless here, such nodes will never be passed to a
-     * <code>LSSerializerFilter</code>.
-     * <br> Unlike [<a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>DOM Level 2 Traversal and      Range</a>]
-     * , the <code>SHOW_ATTRIBUTE</code> constant indicates that the
-     * <code>Attr</code> nodes are shown and passed to the filter.
-     * <br> The constants used here are defined in [<a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>DOM Level 2 Traversal and      Range</a>]
-     * .
-     */
-    public int getWhatToShow();
-
-}
Index: Build/src/main/java/org/w3c/dom/html/HTMLElement.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/html/HTMLElement.java b/Build/src/main/java/org/w3c/dom/html/HTMLElement.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/html/HTMLElement.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,94 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2000 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
- * details.
- */
-
-package org.w3c.dom.html;
-
-import org.w3c.dom.Element;
-
-/**
- *  All HTML element interfaces derive from this class. Elements that only
- * expose the HTML core attributes are represented by the base
- * <code>HTMLElement</code> interface. These elements are as follows:  HEAD
- * special: SUB, SUP, SPAN, BDO font: TT, I, B, U, S, STRIKE, BIG, SMALL
- * phrase: EM, STRONG, DFN, CODE, SAMP, KBD, VAR, CITE, ACRONYM, ABBR list:
- * DD, DT NOFRAMES, NOSCRIPT ADDRESS, CENTER The <code>style</code> attribute
- * of an HTML element is accessible through the
- * <code>ElementCSSInlineStyle</code> interface which is defined in the  .
- * <p>See also the <a href='http://www.w3.org/TR/2000/CR-DOM-Level-2-20000510'>Document Object Model (DOM) Level 2 Specification</a>.
- */
-public interface HTMLElement extends Element {
-    /**
-     *  The element's identifier. See the  id attribute definition in HTML 4.0.
-     */
-    public String getId();
-    public void setId(String id);
-
-    /**
-     *  The element's advisory title. See the  title attribute definition in
-     * HTML 4.0.
-     */
-    public String getTitle();
-    public void setTitle(String title);
-
-    /**
-     *  Language code defined in RFC 1766. See the  lang attribute definition
-     * in HTML 4.0.
-     */
-    public String getLang();
-    public void setLang(String lang);
-
-    /**
-     *  Specifies the base direction of directionally neutral text and the
-     * directionality of tables. See the  dir attribute definition in HTML
-     * 4.0.
-     */
-    public String getDir();
-    public void setDir(String dir);
-
-    /**
-     *  The class attribute of the element. This attribute has been renamed
-     * due to conflicts with the "class" keyword exposed by many languages.
-     * See the  class attribute definition in HTML 4.0.
-     */
-    public String getClassName();
-    public void setClassName(String className);
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/html/HTMLDocument.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/html/HTMLDocument.java b/Build/src/main/java/org/w3c/dom/html/HTMLDocument.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/html/HTMLDocument.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,183 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2000 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
- * details.
- */
-
-package org.w3c.dom.html;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.NodeList;
-
-/**
- *  An <code>HTMLDocument</code> is the root of the HTML hierarchy and holds
- * the entire content. Besides providing access to the hierarchy, it also
- * provides some convenience methods for accessing certain sets of
- * information from the document.
- * <p> The following properties have been deprecated in favor of the
- * corresponding ones for the <code>BODY</code> element: alinkColor background
- *  bgColor fgColor linkColor vlinkColor In DOM Level 2, the method
- * <code>getElementById</code> is inherited from the <code>Document</code>
- * interface where it was moved.
- * <p>See also the <a href='http://www.w3.org/TR/2000/CR-DOM-Level-2-20000510'>Document Object Model (DOM) Level 2 Specification</a>.
- */
-public interface HTMLDocument extends Document {
-    /**
-     *  The title of a document as specified by the <code>TITLE</code> element
-     * in the head of the document.
-     */
-    public String getTitle();
-    public void setTitle(String title);
-
-    /**
-     *  Returns the URI  of the page that linked to this page. The value is an
-     * empty string if the user navigated to the page directly (not through a
-     * link, but, for example, via a bookmark).
-     */
-    public String getReferrer();
-
-    /**
-     *  The domain name of the server that served the document, or
-     * <code>null</code> if the server cannot be identified by a domain name.
-     */
-    public String getDomain();
-
-    /**
-     *  The complete URI  of the document.
-     */
-    public String getURL();
-
-    /**
-     *  The element that contains the content for the document. In documents
-     * with <code>BODY</code> contents, returns the <code>BODY</code>
-     * element. In frameset documents, this returns the outermost
-     * <code>FRAMESET</code> element.
-     */
-    public HTMLElement getBody();
-    public void setBody(HTMLElement body);
-
-    /**
-     *  A collection of all the <code>IMG</code> elements in a document. The
-     * behavior is limited to <code>IMG</code> elements for backwards
-     * compatibility.
-     */
-    public HTMLCollection getImages();
-
-    /**
-     *  A collection of all the <code>OBJECT</code> elements that include
-     * applets and <code>APPLET</code> ( deprecated ) elements in a document.
-     */
-    public HTMLCollection getApplets();
-
-    /**
-     *  A collection of all <code>AREA</code> elements and anchor (
-     * <code>A</code> ) elements in a document with a value for the
-     * <code>href</code> attribute.
-     */
-    public HTMLCollection getLinks();
-
-    /**
-     *  A collection of all the forms of a document.
-     */
-    public HTMLCollection getForms();
-
-    /**
-     *  A collection of all the anchor (<code>A</code> ) elements in a document
-     *  with a value for the <code>name</code> attribute. Note. For reasons
-     * of backwards compatibility, the returned set of anchors only contains
-     * those anchors created with the <code>name</code>  attribute, not those
-     * created with the <code>id</code> attribute.
-     */
-    public HTMLCollection getAnchors();
-
-    /**
-     *  The cookies associated with this document. If there are none, the
-     * value is an empty string. Otherwise, the value is a string: a
-     * semicolon-delimited list of "name, value" pairs for all the cookies
-     * associated with the page. For example,
-     * <code>name=value;expires=date</code> .
-     */
-    public String getCookie();
-    public void setCookie(String cookie);
-
-    /**
-     *  Note. This method and the ones following  allow a user to add to or
-     * replace the structure model of a document using strings of unparsed
-     * HTML. At the time of  writing alternate methods for providing similar
-     * functionality for  both HTML and XML documents were being considered.
-     * The following methods may be deprecated at some point in the future in
-     * favor of a more general-purpose mechanism.
-     * <br> Open a document stream for writing. If a document exists in the
-     * target, this method clears it.
-     */
-    public void open();
-
-    /**
-     *  Closes a document stream opened by <code>open()</code> and forces
-     * rendering.
-     */
-    public void close();
-
-    /**
-     *  Write a string of text to a document stream opened by
-     * <code>open()</code> . The text is parsed into the document's structure
-     * model.
-     * @param text  The string to be parsed into some structure in the
-     *   document structure model.
-     */
-    public void write(String text);
-
-    /**
-     *  Write a string of text followed by a newline character to a document
-     * stream opened by <code>open()</code> . The text is parsed into the
-     * document's structure model.
-     * @param text  The string to be parsed into some structure in the
-     *   document structure model.
-     */
-    public void writeln(String text);
-
-    /**
-     *  Returns the (possibly empty) collection of elements whose
-     * <code>name</code> value is given by <code>elementName</code> .
-     * @param elementName  The <code>name</code> attribute value for an
-     *   element.
-     * @return  The matching elements.
-     */
-    public NodeList getElementsByName(String elementName);
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/html/HTMLCollection.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/html/HTMLCollection.java b/Build/src/main/java/org/w3c/dom/html/HTMLCollection.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/html/HTMLCollection.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,85 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2000 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
- * details.
- */
-
-package org.w3c.dom.html;
-
-import org.w3c.dom.Node;
-
-/**
- *  An <code>HTMLCollection</code> is a list of nodes. An individual node may
- * be accessed by either ordinal index or the node's<code>name</code> or
- * <code>id</code> attributes.  Note: Collections in the HTML DOM are assumed
- * to be  live meaning that they are automatically updated when the
- * underlying document is changed.
- * <p>See also the <a href='http://www.w3.org/TR/2000/CR-DOM-Level-2-20000510'>Document Object Model (DOM) Level 2 Specification</a>.
- */
-public interface HTMLCollection {
-    /**
-     *  This attribute specifies the length or  size of the list.
-     */
-    public int getLength();
-
-    /**
-     *  This method retrieves a node specified by ordinal index. Nodes are
-     * numbered in tree order (depth-first traversal order).
-     * @param index  The index of the node to be fetched. The index origin is
-     *   0.
-     * @return  The <code>Node</code> at the corresponding position upon
-     *   success. A value of <code>null</code> is returned if the index is
-     *   out of range.
-     */
-    public Node item(int index);
-
-    /**
-     *  This method retrieves a <code>Node</code> using a name. It first
-     * searches for a <code>Node</code> with a matching <code>id</code>
-     * attribute. If it doesn't find one, it then searches for a
-     * <code>Node</code> with a matching <code>name</code> attribute, but
-     * only on those elements that are allowed a name attribute.
-     * @param name  The name of the <code>Node</code> to be fetched.
-     * @return  The <code>Node</code> with a <code>name</code> or
-     *   <code>id</code> attribute whose value corresponds to the specified
-     *   string. Upon failure (e.g., no node with this name exists), returns
-     *   <code>null</code> .
-     */
-    public Node namedItem(String name);
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/xpath/XPathResult.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/xpath/XPathResult.java b/Build/src/main/java/org/w3c/dom/xpath/XPathResult.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/xpath/XPathResult.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,241 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2002 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE.
- * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
- */
-
-package org.w3c.dom.xpath;
-
-
-import org.w3c.dom.Node;
-import org.w3c.dom.DOMException;
-
-/**
- * The <code>XPathResult</code> interface represents the result of the
- * evaluation of an XPath 1.0 expression within the context of a particular
- * node. Since evaluation of an XPath expression can result in various
- * result types, this object makes it possible to discover and manipulate
- * the type and value of the result.
- * <p>See also the <a href='http://www.w3.org/2002/08/WD-DOM-Level-3-XPath-20020820'>Document Object Model (DOM) Level 3 XPath Specification</a>.
- */
-public interface XPathResult {
-    // XPathResultType
-    /**
-     * This code does not represent a specific type. An evaluation of an XPath
-     * expression will never produce this type. If this type is requested,
-     * then the evaluation returns whatever type naturally results from
-     * evaluation of the expression.
-     * <br>If the natural result is a node set when <code>ANY_TYPE</code> was
-     * requested, then <code>UNORDERED_NODE_ITERATOR_TYPE</code> is always
-     * the resulting type. Any other representation of a node set must be
-     * explicitly requested.
-     */
-    public static final short ANY_TYPE                  = 0;
-    /**
-     * The result is a number as defined by . Document modification does not
-     * invalidate the number, but may mean that reevaluation would not yield
-     * the same number.
-     */
-    public static final short NUMBER_TYPE               = 1;
-    /**
-     * The result is a string as defined by . Document modification does not
-     * invalidate the string, but may mean that the string no longer
-     * corresponds to the current document.
-     */
-    public static final short STRING_TYPE               = 2;
-    /**
-     * The result is a boolean as defined by . Document modification does not
-     * invalidate the boolean, but may mean that reevaluation would not
-     * yield the same boolean.
-     */
-    public static final short BOOLEAN_TYPE              = 3;
-    /**
-     * The result is a node set as defined by  that will be accessed
-     * iteratively, which may not produce nodes in a particular order.
-     * Document modification invalidates the iteration.
-     * <br>This is the default type returned if the result is a node set and
-     * <code>ANY_TYPE</code> is requested.
-     */
-    public static final short UNORDERED_NODE_ITERATOR_TYPE = 4;
-    /**
-     * The result is a node set as defined by  that will be accessed
-     * iteratively, which will produce document-ordered nodes. Document
-     * modification invalidates the iteration.
-     */
-    public static final short ORDERED_NODE_ITERATOR_TYPE = 5;
-    /**
-     * The result is a node set as defined by  that will be accessed as a
-     * snapshot list of nodes that may not be in a particular order.
-     * Document modification does not invalidate the snapshot but may mean
-     * that reevaluation would not yield the same snapshot and nodes in the
-     * snapshot may have been altered, moved, or removed from the document.
-     */
-    public static final short UNORDERED_NODE_SNAPSHOT_TYPE = 6;
-    /**
-     * The result is a node set as defined by  that will be accessed as a
-     * snapshot list of nodes that will be in original document order.
-     * Document modification does not invalidate the snapshot but may mean
-     * that reevaluation would not yield the same snapshot and nodes in the
-     * snapshot may have been altered, moved, or removed from the document.
-     */
-    public static final short ORDERED_NODE_SNAPSHOT_TYPE = 7;
-    /**
-     * The result is a node set as defined by  and will be accessed as a
-     * single node, which may be <code>null</code>if the node set is empty.
-     * Document modification does not invalidate the node, but may mean that
-     * the result node no longer corresponds to the current document. This
-     * is a convenience that permits optimization since the implementation
-     * can stop once any node in the in the resulting set has been found.
-     * <br>If there are more than one node in the actual result, the single
-     * node returned might not be the first in document order.
-     */
-    public static final short ANY_UNORDERED_NODE_TYPE   = 8;
-    /**
-     * The result is a node set as defined by  and will be accessed as a
-     * single node, which may be <code>null</code> if the node set is empty.
-     * Document modification does not invalidate the node, but may mean that
-     * the result node no longer corresponds to the current document. This
-     * is a convenience that permits optimization since the implementation
-     * can stop once the first node in document order of the resulting set
-     * has been found.
-     * <br>If there are more than one node in the actual result, the single
-     * node returned will be the first in document order.
-     */
-    public static final short FIRST_ORDERED_NODE_TYPE   = 9;
-
-    /**
-     * A code representing the type of this result, as defined by the type
-     * constants.
-     */
-    public short getResultType();
-
-    /**
-     * The value of this number result. If the native double type of the DOM
-     * binding does not directly support the exact IEEE 754 result of the
-     * XPath expression, then it is up to the definition of the binding
-     * binding to specify how the XPath number is converted to the native
-     * binding number.
-     * @exception XPathException
-     *   TYPE_ERR: raised if <code>resultType</code> is not
-     *   <code>NUMBER_TYPE</code>.
-     */
-    public double getNumberValue()
-            throws XPathException;
-
-    /**
-     * The value of this string result.
-     * @exception XPathException
-     *   TYPE_ERR: raised if <code>resultType</code> is not
-     *   <code>STRING_TYPE</code>.
-     */
-    public String getStringValue()
-            throws XPathException;
-
-    /**
-     * The value of this boolean result.
-     * @exception XPathException
-     *   TYPE_ERR: raised if <code>resultType</code> is not
-     *   <code>BOOLEAN_TYPE</code>.
-     */
-    public boolean getBooleanValue()
-            throws XPathException;
-
-    /**
-     * The value of this single node result, which may be <code>null</code>.
-     * @exception XPathException
-     *   TYPE_ERR: raised if <code>resultType</code> is not
-     *   <code>ANY_UNORDERED_NODE_TYPE</code> or
-     *   <code>FIRST_ORDERED_NODE_TYPE</code>.
-     */
-    public Node getSingleNodeValue()
-            throws XPathException;
-
-    /**
-     * Signifies that the iterator has become invalid. True if
-     * <code>resultType</code> is <code>UNORDERED_NODE_ITERATOR_TYPE</code>
-     * or <code>ORDERED_NODE_ITERATOR_TYPE</code> and the document has been
-     * modified since this result was returned.
-     */
-    public boolean getInvalidIteratorState();
-
-    /**
-     * The number of nodes in the result snapshot. Valid values for
-     * snapshotItem indices are <code>0</code> to
-     * <code>snapshotLength-1</code> inclusive.
-     * @exception XPathException
-     *   TYPE_ERR: raised if <code>resultType</code> is not
-     *   <code>UNORDERED_NODE_SNAPSHOT_TYPE</code> or
-     *   <code>ORDERED_NODE_SNAPSHOT_TYPE</code>.
-     */
-    public int getSnapshotLength()
-            throws XPathException;
-
-    /**
-     * Iterates and returns the next node from the node set or
-     * <code>null</code>if there are no more nodes.
-     * @return Returns the next node.
-     * @exception XPathException
-     *   TYPE_ERR: raised if <code>resultType</code> is not
-     *   <code>UNORDERED_NODE_ITERATOR_TYPE</code> or
-     *   <code>ORDERED_NODE_ITERATOR_TYPE</code>.
-     * @exception DOMException
-     *   INVALID_STATE_ERR: The document has been mutated since the result was
-     *   returned.
-     */
-    public Node iterateNext()
-            throws XPathException, DOMException;
-
-    /**
-     * Returns the <code>index</code>th item in the snapshot collection. If
-     * <code>index</code> is greater than or equal to the number of nodes in
-     * the list, this method returns <code>null</code>. Unlike the iterator
-     * result, the snapshot does not become invalid, but may not correspond
-     * to the current document if it is mutated.
-     * @param index Index into the snapshot collection.
-     * @return The node at the <code>index</code>th position in the
-     *   <code>NodeList</code>, or <code>null</code> if that is not a valid
-     *   index.
-     * @exception XPathException
-     *   TYPE_ERR: raised if <code>resultType</code> is not
-     *   <code>UNORDERED_NODE_SNAPSHOT_TYPE</code> or
-     *   <code>ORDERED_NODE_SNAPSHOT_TYPE</code>.
-     */
-    public Node snapshotItem(int index)
-            throws XPathException;
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/xpath/XPathEvaluator.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/xpath/XPathEvaluator.java b/Build/src/main/java/org/w3c/dom/xpath/XPathEvaluator.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/xpath/XPathEvaluator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,162 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2002 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE.
- * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
- */
-
-package org.w3c.dom.xpath;
-
-
-import org.w3c.dom.Node;
-import org.w3c.dom.DOMException;
-
-/**
- *  The evaluation of XPath expressions is provided by
- * <code>XPathEvaluator</code>. In a DOM implementation which supports the
- * XPath 3.0 feature, as described above, the <code>XPathEvaluator</code>
- * interface will be implemented on the same object which implements the
- * <code>Document</code> interface permitting it to be obtained by the usual
- * binding-specific method such as casting or by using the DOM Level 3
- * getInterface method. In this case the implementation obtained from the
- * Document supports the XPath DOM module and is compatible with the XPath
- * 1.0 specification.
- * <p>Evaluation of expressions with specialized extension functions or
- * variables may not work in all implementations and is, therefore, not
- * portable. <code>XPathEvaluator</code> implementations may be available
- * from other sources that could provide specific support for specialized
- * extension functions or variables as would be defined by other
- * specifications.
- * <p>See also the <a href='http://www.w3.org/2002/08/WD-DOM-Level-3-XPath-20020820'>Document Object Model (DOM) Level 3 XPath Specification</a>.
- */
-public interface XPathEvaluator {
-    /**
-     * Creates a parsed XPath expression with resolved namespaces. This is
-     * useful when an expression will be reused in an application since it
-     * makes it possible to compile the expression string into a more
-     * efficient internal form and preresolve all namespace prefixes which
-     * occur within the expression.
-     * @param expression The XPath expression string to be parsed.
-     * @param resolver The <code>resolver</code> permits translation of
-     *   prefixes within the XPath expression into appropriate namespace URIs
-     *   . If this is specified as <code>null</code>, any namespace prefix
-     *   within the expression will result in <code>DOMException</code>
-     *   being thrown with the code <code>NAMESPACE_ERR</code>.
-     * @return The compiled form of the XPath expression.
-     * @exception XPathException
-     *   INVALID_EXPRESSION_ERR: Raised if the expression is not legal
-     *   according to the rules of the <code>XPathEvaluator</code>i
-     * @exception DOMException
-     *   NAMESPACE_ERR: Raised if the expression contains namespace prefixes
-     *   which cannot be resolved by the specified
-     *   <code>XPathNSResolver</code>.
-     */
-    public XPathExpression createExpression(String expression,
-                                            XPathNSResolver resolver)
-            throws XPathException, DOMException;
-
-    /**
-     * Adapts any DOM node to resolve namespaces so that an XPath expression
-     * can be easily evaluated relative to the context of the node where it
-     * appeared within the document. This adapter works like the DOM Level 3
-     * method <code>lookupNamespaceURI</code> on nodes in resolving the
-     * namespaceURI from a given prefix using the current information
-     * available in the node's hierarchy at the time lookupNamespaceURI is
-     * called. also correctly resolving the implicit xml prefix.
-     * @param nodeResolver The node to be used as a context for namespace
-     *   resolution.
-     * @return <code>XPathNSResolver</code> which resolves namespaces with
-     *   respect to the definitions in scope for a specified node.
-     */
-    public XPathNSResolver createNSResolver(Node nodeResolver);
-
-    /**
-     * Evaluates an XPath expression string and returns a result of the
-     * specified type if possible.
-     * @param expression The XPath expression string to be parsed and
-     *   evaluated.
-     * @param contextNode The <code>context</code> is context node for the
-     *   evaluation of this XPath expression. If the XPathEvaluator was
-     *   obtained by casting the <code>Document</code> then this must be
-     *   owned by the same document and must be a <code>Document</code>,
-     *   <code>Element</code>, <code>Attribute</code>, <code>Text</code>,
-     *   <code>CDATASection</code>, <code>Comment</code>,
-     *   <code>ProcessingInstruction</code>, or <code>XPathNamespace</code>
-     *   node. If the context node is a <code>Text</code> or a
-     *   <code>CDATASection</code>, then the context is interpreted as the
-     *   whole logical text node as seen by XPath, unless the node is empty
-     *   in which case it may not serve as the XPath context.
-     * @param resolver The <code>resolver</code> permits translation of
-     *   prefixes within the XPath expression into appropriate namespace URIs
-     *   . If this is specified as <code>null</code>, any namespace prefix
-     *   within the expression will result in <code>DOMException</code>
-     *   being thrown with the code <code>NAMESPACE_ERR</code>.
-     * @param type If a specific <code>type</code> is specified, then the
-     *   result will be returned as the corresponding type.For XPath 1.0
-     *   results, this must be one of the codes of the
-     *   <code>XPathResult</code> interface.
-     * @param result The <code>result</code> specifies a specific result
-     *   object which may be reused and returned by this method. If this is
-     *   specified as <code>null</code>or the implementation does not reuse
-     *   the specified result, a new result object will be constructed and
-     *   returned.For XPath 1.0 results, this object will be of type
-     *   <code>XPathResult</code>.
-     * @return The result of the evaluation of the XPath expression.For XPath
-     *   1.0 results, this object will be of type <code>XPathResult</code>.
-     * @exception XPathException
-     *   INVALID_EXPRESSION_ERR: Raised if the expression is not legal
-     *   according to the rules of the <code>XPathEvaluator</code>i
-     *   <br>TYPE_ERR: Raised if the result cannot be converted to return the
-     *   specified type.
-     * @exception DOMException
-     *   NAMESPACE_ERR: Raised if the expression contains namespace prefixes
-     *   which cannot be resolved by the specified
-     *   <code>XPathNSResolver</code>.
-     *   <br>WRONG_DOCUMENT_ERR: The Node is from a document that is not
-     *   supported by this <code>XPathEvaluator</code>.
-     *   <br>NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath
-     *   context node or the request type is not permitted by this
-     *   <code>XPathEvaluator</code>.
-     */
-    public Object evaluate(String expression,
-                           Node contextNode,
-                           XPathNSResolver resolver,
-                           short type,
-                           Object result)
-            throws XPathException, DOMException;
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/xpath/XPathException.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/xpath/XPathException.java b/Build/src/main/java/org/w3c/dom/xpath/XPathException.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/xpath/XPathException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,68 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2002 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE.
- * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
- */
-
-package org.w3c.dom.xpath;
-
-/**
- * A new exception has been created for exceptions specific to these XPath
- * interfaces.
- * <p>See also the <a href='http://www.w3.org/2002/08/WD-DOM-Level-3-XPath-20020820'>Document Object Model (DOM) Level 3 XPath Specification</a>.
- */
-public class XPathException extends RuntimeException {
-    public XPathException(short code, String message) {
-        super(message);
-        this.code = code;
-    }
-    public short   code;
-    // XPathExceptionCode
-    /**
-     * If the expression has a syntax error or otherwise is not a legal
-     * expression according to the rules of the specific
-     * <code>XPathEvaluator</code> or contains specialized extension
-     * functions or variables not supported by this implementation.
-     */
-    public static final short INVALID_EXPRESSION_ERR    = 1;
-    /**
-     * If the expression cannot be converted to return the specified type.
-     */
-    public static final short TYPE_ERR                  = 2;
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/xpath/XPathNamespace.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/xpath/XPathNamespace.java b/Build/src/main/java/org/w3c/dom/xpath/XPathNamespace.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/xpath/XPathNamespace.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,94 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2002 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE.
- * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
- */
-
-package org.w3c.dom.xpath;
-
-
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-
-/**
- * The <code>XPathNamespace</code> interface is returned by
- * <code>XPathResult</code> interfaces to represent the XPath namespace node
- * type that DOM lacks. There is no public constructor for this node type.
- * Attempts to place it into a hierarchy or a NamedNodeMap result in a
- * <code>DOMException</code> with the code <code>HIERARCHY_REQUEST_ERR</code>
- * . This node is read only, so methods or setting of attributes that would
- * mutate the node result in a DOMException with the code
- * <code>NO_MODIFICATION_ALLOWED_ERR</code>.
- * <p>The core specification describes attributes of the <code>Node</code>
- * interface that are different for different node node types but does not
- * describe <code>XPATH_NAMESPACE_NODE</code>, so here is a description of
- * those attributes for this node type. All attributes of <code>Node</code>
- * not described in this section have a <code>null</code> or
- * <code>false</code> value.
- * <p><code>ownerDocument</code> matches the <code>ownerDocument</code> of the
- * <code>ownerElement</code> even if the element is later adopted.
- * <p><code>prefix</code> is the prefix of the namespace represented by the
- * node.
- * <p><code>nodeName</code> is the same as <code>prefix</code>.
- * <p><code>nodeType</code> is equal to <code>XPATH_NAMESPACE_NODE</code>.
- * <p><code>namespaceURI</code> is the namespace URI of the namespace
- * represented by the node.
- * <p><code>adoptNode</code>, <code>cloneNode</code>, and
- * <code>importNode</code> fail on this node type by raising a
- * <code>DOMException</code> with the code <code>NOT_SUPPORTED_ERR</code>.In
- * future versions of the XPath specification, the definition of a namespace
- * node may be changed incomatibly, in which case incompatible changes to
- * field values may be required to implement versions beyond XPath 1.0.
- * <p>See also the <a href='http://www.w3.org/2002/08/WD-DOM-Level-3-XPath-20020820'>Document Object Model (DOM) Level 3 XPath Specification</a>.
- */
-public interface XPathNamespace extends Node {
-    // XPathNodeType
-    /**
-     * The node is a <code>Namespace</code>.
-     */
-    public static final short XPATH_NAMESPACE_NODE      = 13;
-
-    /**
-     * The <code>Element</code> on which the namespace was in scope when it
-     * was requested. This does not change on a returned namespace node even
-     * if the document changes such that the namespace goes out of scope on
-     * that element and this node is no longer found there by XPath.
-     */
-    public Element getOwnerElement();
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/xpath/XPathExpression.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/xpath/XPathExpression.java b/Build/src/main/java/org/w3c/dom/xpath/XPathExpression.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/xpath/XPathExpression.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,95 +0,0 @@
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2002 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE.
- * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
- */
-
-package org.w3c.dom.xpath;
-
-
-import org.w3c.dom.Node;
-import org.w3c.dom.DOMException;
-
-/**
- * The <code>XPathExpression</code> interface represents a parsed and resolved
- * XPath expression.
- * <p>See also the <a href='http://www.w3.org/2002/08/WD-DOM-Level-3-XPath-20020820'>Document Object Model (DOM) Level 3 XPath Specification</a>.
- */
-public interface XPathExpression {
-    /**
-     * Evaluates this XPath expression and returns a result.
-     * @param contextNode The <code>context</code> is context node for the
-     *   evaluation of this XPath expression.If the XPathEvaluator was
-     *   obtained by casting the <code>Document</code> then this must be
-     *   owned by the same document and must be a <code>Document</code>,
-     *   <code>Element</code>, <code>Attribute</code>, <code>Text</code>,
-     *   <code>CDATASection</code>, <code>Comment</code>,
-     *   <code>ProcessingInstruction</code>, or <code>XPathNamespace</code>
-     *   node.If the context node is a <code>Text</code> or a
-     *   <code>CDATASection</code>, then the context is interpreted as the
-     *   whole logical text node as seen by XPath, unless the node is empty
-     *   in which case it may not serve as the XPath context.
-     * @param type If a specific <code>type</code> is specified, then the
-     *   result will be coerced to return the specified type relying on
-     *   XPath conversions and fail if the desired coercion is not possible.
-     *   This must be one of the type codes of <code>XPathResult</code>.
-     * @param result The <code>result</code> specifies a specific result
-     *   object which may be reused and returned by this method. If this is
-     *   specified as <code>null</code>or the implementation does not reuse
-     *   the specified result, a new result object will be constructed and
-     *   returned.For XPath 1.0 results, this object will be of type
-     *   <code>XPathResult</code>.
-     * @return The result of the evaluation of the XPath expression.For XPath
-     *   1.0 results, this object will be of type <code>XPathResult</code>.
-     * @exception XPathException
-     *   TYPE_ERR: Raised if the result cannot be converted to return the
-     *   specified type.
-     * @exception DOMException
-     *   WRONG_DOCUMENT_ERR: The Node is from a document that is not supported
-     *   by the XPathEvaluator that created this <code>XPathExpression</code>
-     *   .
-     *   <br>NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath
-     *   context node or the request type is not permitted by this
-     *   <code>XPathExpression</code>.
-     */
-    public Object evaluate(Node contextNode,
-                           short type,
-                           Object result)
-            throws XPathException, DOMException;
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/xpath/XPathNSResolver.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/xpath/XPathNSResolver.java b/Build/src/main/java/org/w3c/dom/xpath/XPathNSResolver.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/xpath/XPathNSResolver.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,65 +0,0 @@
-
-/*
- * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- *
- */
-
-/*
- *
- *
- *
- *
- *
- * Copyright (c) 2002 World Wide Web Consortium,
- * (Massachusetts Institute of Technology, Institut National de
- * Recherche en Informatique et en Automatique, Keio University). All
- * Rights Reserved. This program is distributed under the W3C's Software
- * Intellectual Property License. This program is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
- * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- * PURPOSE.
- * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
- */
-
-package org.w3c.dom.xpath;
-
-
-/**
- * The <code>XPathNSResolver</code> interface permit <code>prefix</code>
- * strings in the expression to be properly bound to
- * <code>namespaceURI</code> strings. <code>XPathEvaluator</code> can
- * construct an implementation of <code>XPathNSResolver</code> from a node,
- * or the interface may be implemented by any application.
- * <p>See also the <a href='http://www.w3.org/2002/08/WD-DOM-Level-3-XPath-20020820'>Document Object Model (DOM) Level 3 XPath Specification</a>.
- */
-public interface XPathNSResolver {
-    /**
-     * Look up the namespace URI associated to the given namespace prefix. The
-     * XPath evaluator must never call this with a <code>null</code> or
-     * empty argument, because the result of doing this is undefined.
-     * @param prefix The prefix to look for.
-     * @return Returns the associated namespace URI or <code>null</code> if
-     *   none is found.
-     */
-    public String lookupNamespaceURI(String prefix);
-
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/events/Event.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/events/Event.java b/Build/src/main/java/org/w3c/dom/events/Event.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/events/Event.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,118 +0,0 @@
-package org.w3c.dom.events;
-
-/**
- * The <code>Event</code> interface is used to provide contextual information
- * about an event to the handler processing the event. An object which
- * implements the <code>Event</code> interface is generally passed as the
- * first parameter to an event handler. More specific context information is
- * passed to event handlers by deriving additional interfaces from
- * <code>Event</code> which contain information directly relating to the
- * type of event they accompany. These derived interfaces are also
- * implemented by the object passed to the event listener.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113'>Document Object Model (DOM) Level 2 Events Specification</a>.
- * @since DOM Level 2
- */
-public interface Event {
-    // PhaseType
-    /**
-     * The current event phase is the capturing phase.
-     */
-    public static final short CAPTURING_PHASE           = 1;
-    /**
-     * The event is currently being evaluated at the target
-     * <code>EventTarget</code>.
-     */
-    public static final short AT_TARGET                 = 2;
-    /**
-     * The current event phase is the bubbling phase.
-     */
-    public static final short BUBBLING_PHASE            = 3;
-    /**
-     * The name of the event (case-insensitive). The name must be an XML name.
-     */
-    public String getType();
-    /**
-     * Used to indicate the <code>EventTarget</code> to which the event was
-     * originally dispatched.
-     */
-    public EventTarget getTarget();
-    /**
-     * Used to indicate the <code>EventTarget</code> whose
-     * <code>EventListeners</code> are currently being processed. This is
-     * particularly useful during capturing and bubbling.
-     */
-    public EventTarget getCurrentTarget();
-    /**
-     * Used to indicate which phase of event flow is currently being
-     * evaluated.
-     */
-    public short getEventPhase();
-    /**
-     * Used to indicate whether or not an event is a bubbling event. If the
-     * event can bubble the value is true, else the value is false.
-     */
-    public boolean getBubbles();
-    /**
-     * Used to indicate whether or not an event can have its default action
-     * prevented. If the default action can be prevented the value is true,
-     * else the value is false.
-     */
-    public boolean getCancelable();
-    /**
-     *  Used to specify the time (in milliseconds relative to the epoch) at
-     * which the event was created. Due to the fact that some systems may
-     * not provide this information the value of <code>timeStamp</code> may
-     * be not available for all events. When not available, a value of 0
-     * will be returned. Examples of epoch time are the time of the system
-     * start or 0:0:0 UTC 1st January 1970.
-     */
-    public long getTimeStamp();
-    /**
-     * The <code>stopPropagation</code> method is used prevent further
-     * propagation of an event during event flow. If this method is called
-     * by any <code>EventListener</code> the event will cease propagating
-     * through the tree. The event will complete dispatch to all listeners
-     * on the current <code>EventTarget</code> before event flow stops. This
-     * method may be used during any stage of event flow.
-     */
-    public void stopPropagation();
-    /**
-     * If an event is cancelable, the <code>preventDefault</code> method is
-     * used to signify that the event is to be canceled, meaning any default
-     * action normally taken by the implementation as a result of the event
-     * will not occur. If, during any stage of event flow, the
-     * <code>preventDefault</code> method is called the event is canceled.
-     * Any default action associated with the event will not occur. Calling
-     * this method for a non-cancelable event has no effect. Once
-     * <code>preventDefault</code> has been called it will remain in effect
-     * throughout the remainder of the event's propagation. This method may
-     * be used during any stage of event flow.
-     */
-    public void preventDefault();
-    /**
-     * The <code>initEvent</code> method is used to initialize the value of an
-     * <code>Event</code> created through the <code>DocumentEvent</code>
-     * interface. This method may only be called before the
-     * <code>Event</code> has been dispatched via the
-     * <code>dispatchEvent</code> method, though it may be called multiple
-     * times during that phase if necessary. If called multiple times the
-     * final invocation takes precedence. If called from a subclass of
-     * <code>Event</code> interface only the values specified in the
-     * <code>initEvent</code> method are modified, all other attributes are
-     * left unchanged.
-     * @param eventTypeArg Specifies the event type. This type may be any
-     *   event type currently defined in this specification or a new event
-     *   type.. The string must be an XML name. Any new event type must not
-     *   begin with any upper, lower, or mixed case version of the string
-     *   "DOM". This prefix is reserved for future DOM event sets. It is
-     *   also strongly recommended that third parties adding their own
-     *   events use their own prefix to avoid confusion and lessen the
-     *   probability of conflicts with other new events.
-     * @param canBubbleArg Specifies whether or not the event can bubble.
-     * @param cancelableArg Specifies whether or not the event's default
-     *   action can be prevented.
-     */
-    public void initEvent(String eventTypeArg,
-                          boolean canBubbleArg,
-                          boolean cancelableArg);
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/events/EventTarget.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/events/EventTarget.java b/Build/src/main/java/org/w3c/dom/events/EventTarget.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/events/EventTarget.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,87 +0,0 @@
-package org.w3c.dom.events;
-
-/**
- *  The <code>EventTarget</code> interface is implemented by all
- * <code>Nodes</code> in an implementation which supports the DOM Event
- * Model. Therefore, this interface can be obtained by using
- * binding-specific casting methods on an instance of the <code>Node</code>
- * interface. The interface allows registration and removal of
- * <code>EventListeners</code> on an <code>EventTarget</code> and dispatch
- * of events to that <code>EventTarget</code>.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113'>Document Object Model (DOM) Level 2 Events Specification</a>.
- * @since DOM Level 2
- */
-public interface EventTarget {
-    /**
-     * This method allows the registration of event listeners on the event
-     * target. If an <code>EventListener</code> is added to an
-     * <code>EventTarget</code> while it is processing an event, it will not
-     * be triggered by the current actions but may be triggered during a
-     * later stage of event flow, such as the bubbling phase.
-     * <br> If multiple identical <code>EventListener</code>s are registered
-     * on the same <code>EventTarget</code> with the same parameters the
-     * duplicate instances are discarded. They do not cause the
-     * <code>EventListener</code> to be called twice and since they are
-     * discarded they do not need to be removed with the
-     * <code>removeEventListener</code> method.
-     * @param type The event type for which the user is registering
-     * @param listener The <code>listener</code> parameter takes an interface
-     *   implemented by the user which contains the methods to be called
-     *   when the event occurs.
-     * @param useCapture If true, <code>useCapture</code> indicates that the
-     *   user wishes to initiate capture. After initiating capture, all
-     *   events of the specified type will be dispatched to the registered
-     *   <code>EventListener</code> before being dispatched to any
-     *   <code>EventTargets</code> beneath them in the tree. Events which
-     *   are bubbling upward through the tree will not trigger an
-     *   <code>EventListener</code> designated to use capture.
-     */
-    public void addEventListener(String type,
-                                 EventListener listener,
-                                 boolean useCapture);
-    /**
-     * This method allows the removal of event listeners from the event
-     * target. If an <code>EventListener</code> is removed from an
-     * <code>EventTarget</code> while it is processing an event, it will not
-     * be triggered by the current actions. <code>EventListener</code>s can
-     * never be invoked after being removed.
-     * <br>Calling <code>removeEventListener</code> with arguments which do
-     * not identify any currently registered <code>EventListener</code> on
-     * the <code>EventTarget</code> has no effect.
-     * @param type Specifies the event type of the <code>EventListener</code>
-     *   being removed.
-     * @param listener The <code>EventListener</code> parameter indicates the
-     *   <code>EventListener </code> to be removed.
-     * @param useCapture Specifies whether the <code>EventListener</code>
-     *   being removed was registered as a capturing listener or not. If a
-     *   listener was registered twice, one with capture and one without,
-     *   each must be removed separately. Removal of a capturing listener
-     *   does not affect a non-capturing version of the same listener, and
-     *   vice versa.
-     */
-    public void removeEventListener(String type,
-                                    EventListener listener,
-                                    boolean useCapture);
-    /**
-     * This method allows the dispatch of events into the implementations
-     * event model. Events dispatched in this manner will have the same
-     * capturing and bubbling behavior as events dispatched directly by the
-     * implementation. The target of the event is the
-     * <code> EventTarget</code> on which <code>dispatchEvent</code> is
-     * called.
-     * @param evt Specifies the event type, behavior, and contextual
-     *   information to be used in processing the event.
-     * @return The return value of <code>dispatchEvent</code> indicates
-     *   whether any of the listeners which handled the event called
-     *   <code>preventDefault</code>. If <code>preventDefault</code> was
-     *   called the value is false, else the value is true.
-     * @exception EventException
-     *   UNSPECIFIED_EVENT_TYPE_ERR: Raised if the <code>Event</code>'s type
-     *   was not specified by initializing the event before
-     *   <code>dispatchEvent</code> was called. Specification of the
-     *   <code>Event</code>'s type as <code>null</code> or an empty string
-     *   will also trigger this exception.
-     */
-    public boolean dispatchEvent(Event evt)
-            throws EventException;
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/events/DocumentEvent.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/events/DocumentEvent.java b/Build/src/main/java/org/w3c/dom/events/DocumentEvent.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/events/DocumentEvent.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,42 +0,0 @@
-package org.w3c.dom.events;
-
-import org.w3c.dom.DOMException;
-/**
- *  The <code>DocumentEvent</code> interface provides a mechanism by which the
- * user can create an Event of a type supported by the implementation. It is
- * expected that the <code>DocumentEvent</code> interface will be
- * implemented on the same object which implements the <code>Document</code>
- * interface in an implementation which supports the Event model.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113'>Document Object Model (DOM) Level 2 Events Specification</a>.
- * @since DOM Level 2
- */
-public interface DocumentEvent {
-    /**
-     *
-     * @param eventType The <code>eventType</code> parameter specifies the
-     *   type of <code>Event</code> interface to be created. If the
-     *   <code>Event</code> interface specified is supported by the
-     *   implementation this method will return a new <code>Event</code> of
-     *   the interface type requested. If the <code>Event</code> is to be
-     *   dispatched via the <code>dispatchEvent</code> method the
-     *   appropriate event init method must be called after creation in
-     *   order to initialize the <code>Event</code>'s values. As an example,
-     *   a user wishing to synthesize some kind of <code>UIEvent</code>
-     *   would call <code>createEvent</code> with the parameter "UIEvents".
-     *   The <code>initUIEvent</code> method could then be called on the
-     *   newly created <code>UIEvent</code> to set the specific type of
-     *   UIEvent to be dispatched and set its context information.The
-     *   <code>createEvent</code> method is used in creating
-     *   <code>Event</code>s when it is either inconvenient or unnecessary
-     *   for the user to create an <code>Event</code> themselves. In cases
-     *   where the implementation provided <code>Event</code> is
-     *   insufficient, users may supply their own <code>Event</code>
-     *   implementations for use with the <code>dispatchEvent</code> method.
-     * @return The newly created <code>Event</code>
-     * @exception DOMException
-     *   NOT_SUPPORTED_ERR: Raised if the implementation does not support the
-     *   type of <code>Event</code> interface requested
-     */
-    public Event createEvent(String eventType)
-            throws DOMException;
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/events/EventListener.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/events/EventListener.java b/Build/src/main/java/org/w3c/dom/events/EventListener.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/events/EventListener.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,29 +0,0 @@
-package org.w3c.dom.events;
-
-
-/**
- *  The <code>EventListener</code> interface is the primary method for
- * handling events. Users implement the <code>EventListener</code> interface
- * and register their listener on an <code>EventTarget</code> using the
- * <code>AddEventListener</code> method. The users should also remove their
- * <code>EventListener</code> from its <code>EventTarget</code> after they
- * have completed using the listener.
- * <p> When a <code>Node</code> is copied using the <code>cloneNode</code>
- * method the <code>EventListener</code>s attached to the source
- * <code>Node</code> are not attached to the copied <code>Node</code>. If
- * the user wishes the same <code>EventListener</code>s to be added to the
- * newly created copy the user must add them manually.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113'>Document Object Model (DOM) Level 2 Events Specification</a>.
- * @since DOM Level 2
- */
-public interface EventListener {
-    /**
-     *  This method is called whenever an event occurs of the type for which
-     * the <code> EventListener</code> interface was registered.
-     * @param evt  The <code>Event</code> contains contextual information
-     *   about the event. It also contains the <code>stopPropagation</code>
-     *   and <code>preventDefault</code> methods which are used in
-     *   determining the event's flow and default action.
-     */
-    public void handleEvent(Event evt);
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/events/MutationEvent.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/events/MutationEvent.java b/Build/src/main/java/org/w3c/dom/events/MutationEvent.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/events/MutationEvent.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,88 +0,0 @@
-package org.w3c.dom.events;
-
-import org.w3c.dom.Node;
-/**
- * The <code>MutationEvent</code> interface provides specific contextual
- * information associated with Mutation events.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113'>Document Object Model (DOM) Level 2 Events Specification</a>.
- * @since DOM Level 2
- */
-public interface MutationEvent extends Event {
-    // attrChangeType
-    /**
-     * The <code>Attr</code> was modified in place.
-     */
-    public static final short MODIFICATION              = 1;
-    /**
-     * The <code>Attr</code> was just added.
-     */
-    public static final short ADDITION                  = 2;
-    /**
-     * The <code>Attr</code> was just removed.
-     */
-    public static final short REMOVAL                   = 3;
-    /**
-     *  <code>relatedNode</code> is used to identify a secondary node related
-     * to a mutation event. For example, if a mutation event is dispatched
-     * to a node indicating that its parent has changed, the
-     * <code>relatedNode</code> is the changed parent. If an event is
-     * instead dispatched to a subtree indicating a node was changed within
-     * it, the <code>relatedNode</code> is the changed node. In the case of
-     * the DOMAttrModified event it indicates the <code>Attr</code> node
-     * which was modified, added, or removed.
-     */
-    public Node getRelatedNode();
-    /**
-     *  <code>prevValue</code> indicates the previous value of the
-     * <code>Attr</code> node in DOMAttrModified events, and of the
-     * <code>CharacterData</code> node in DOMCharacterDataModified events.
-     */
-    public String getPrevValue();
-    /**
-     *  <code>newValue</code> indicates the new value of the <code>Attr</code>
-     * node in DOMAttrModified events, and of the <code>CharacterData</code>
-     * node in DOMCharacterDataModified events.
-     */
-    public String getNewValue();
-    /**
-     *  <code>attrName</code> indicates the name of the changed
-     * <code>Attr</code> node in a DOMAttrModified event.
-     */
-    public String getAttrName();
-    /**
-     *  <code>attrChange</code> indicates the type of change which triggered
-     * the DOMAttrModified event. The values can be <code>MODIFICATION</code>
-     * , <code>ADDITION</code>, or <code>REMOVAL</code>.
-     */
-    public short getAttrChange();
-    /**
-     * The <code>initMutationEvent</code> method is used to initialize the
-     * value of a <code>MutationEvent</code> created through the
-     * <code>DocumentEvent</code> interface. This method may only be called
-     * before the <code>MutationEvent</code> has been dispatched via the
-     * <code>dispatchEvent</code> method, though it may be called multiple
-     * times during that phase if necessary. If called multiple times, the
-     * final invocation takes precedence.
-     * @param typeArg Specifies the event type.
-     * @param canBubbleArg Specifies whether or not the event can bubble.
-     * @param cancelableArg Specifies whether or not the event's default
-     *   action can be prevented.
-     * @param relatedNodeArg Specifies the <code>Event</code>'s related Node.
-     * @param prevValueArg Specifies the <code>Event</code>'s
-     *   <code>prevValue</code> attribute. This value may be null.
-     * @param newValueArg Specifies the <code>Event</code>'s
-     *   <code>newValue</code> attribute. This value may be null.
-     * @param attrNameArg Specifies the <code>Event</code>'s
-     *   <code>attrName</code> attribute. This value may be null.
-     * @param attrChangeArg Specifies the <code>Event</code>'s
-     *   <code>attrChange</code> attribute
-     */
-    public void initMutationEvent(String typeArg,
-                                  boolean canBubbleArg,
-                                  boolean cancelableArg,
-                                  Node relatedNodeArg,
-                                  String prevValueArg,
-                                  String newValueArg,
-                                  String attrNameArg,
-                                  short attrChangeArg);
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/events/EventException.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/events/EventException.java b/Build/src/main/java/org/w3c/dom/events/EventException.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/events/EventException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,23 +0,0 @@
-package org.w3c.dom.events;
-
-/**
- *  Event operations may throw an <code>EventException</code> as specified in
- * their method descriptions.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113'>Document Object Model (DOM) Level 2 Events Specification</a>.
- * @since DOM Level 2
- */
-public class EventException extends RuntimeException {
-    public EventException(short code, String message) {
-        super(message);
-        this.code = code;
-    }
-    public short   code;
-    // EventExceptionCode
-    /**
-     *  If the <code>Event</code>'s type was not specified by initializing the
-     * event before the method was called. Specification of the Event's type
-     * as <code>null</code> or an empty string will also trigger this
-     * exception.
-     */
-    public static final short UNSPECIFIED_EVENT_TYPE_ERR = 0;
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/ranges/Range.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/ranges/Range.java b/Build/src/main/java/org/w3c/dom/ranges/Range.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/ranges/Range.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,63 +0,0 @@
-package org.w3c.dom.ranges;
-
-import org.w3c.dom.DOMException;
-import org.w3c.dom.DocumentFragment;
-import org.w3c.dom.Node;
-
-public interface Range {
-
-    public Node getStartContainer() throws DOMException;
-
-    public int getStartOffset() throws DOMException;
-
-    public Node getEndContainer() throws DOMException;
-
-    public int getEndOffset() throws DOMException;
-
-    public boolean getCollapsed() throws DOMException;
-
-    public Node getCommonAncestorContainer() throws DOMException;
-
-    public void setStart(Node refNode, int offset) throws RangeException, DOMException;
-
-    public void setEnd(Node refNode, int offset) throws RangeException, DOMException;
-
-    public void setStartBefore(Node refNode) throws RangeException, DOMException;
-
-    public void setStartAfter(Node refNode) throws RangeException, DOMException;
-
-    public void setEndBefore(Node refNode) throws RangeException, DOMException;
-
-    public void setEndAfter(Node refNode) throws RangeException, DOMException;
-
-    public void collapse(boolean toStart) throws DOMException;
-    
-    public void selectNode(Node node) throws RangeException, DOMException;
-
-    public void selectNodeContents(Node node) throws RangeException, DOMException;
-
-    public static final short START_TO_START            = 0;
-    public static final short START_TO_END              = 1;
-    public static final short END_TO_END                = 2;
-    public static final short END_TO_START              = 3;
-
-    public short compareBoundaryPoints(short how,
-                                         Range sourceRange)
-                                         throws DOMException;
-
-    public void deleteContents() throws DOMException;
-
-    public DocumentFragment extractContents() throws DOMException;
-
-    public DocumentFragment cloneContents() throws DOMException;
-
-    public void insertNode(Node node) throws DOMException, RangeException;
-
-    public void surroundContents(Node newParent) throws DOMException, RangeException;
-
-    public Range cloneRange() throws DOMException;
-
-    public String toString() throws DOMException;
-
-    public void detach() throws DOMException;
-}
Index: Build/src/main/java/org/w3c/dom/ranges/DocumentRange.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/ranges/DocumentRange.java b/Build/src/main/java/org/w3c/dom/ranges/DocumentRange.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/ranges/DocumentRange.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,5 +0,0 @@
-package org.w3c.dom.ranges;
-
-public interface DocumentRange {
-    public Range createRange();
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/ranges/RangeException.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/ranges/RangeException.java b/Build/src/main/java/org/w3c/dom/ranges/RangeException.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/ranges/RangeException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,14 +0,0 @@
-package org.w3c.dom.ranges;
-
-public class RangeException extends RuntimeException {
-
-    public RangeException(short code, String message) {
-        super(message);
-        this.code = code;
-    }
-
-    public short code;
-
-    public static final short BAD_BOUNDARYPOINTS_ERR    = 1;
-    public static final short INVALID_NODE_TYPE_ERR     = 2;
-}
Index: Build/src/main/java/org/w3c/dom/traversal/NodeFilter.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/traversal/NodeFilter.java b/Build/src/main/java/org/w3c/dom/traversal/NodeFilter.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/traversal/NodeFilter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,130 +0,0 @@
-package org.w3c.dom.traversal;
-
-import org.w3c.dom.Node;
-/**
- * Filters are objects that know how to "filter out" nodes. If a
- * <code>NodeIterator</code> or <code>TreeWalker</code> is given a
- * <code>NodeFilter</code>, it applies the filter before it returns the next
- * node. If the filter says to accept the node, the traversal logic returns
- * it; otherwise, traversal looks for the next node and pretends that the
- * node that was rejected was not there.
- * <p>The DOM does not provide any filters. <code>NodeFilter</code> is just an
- * interface that users can implement to provide their own filters.
- * <p><code>NodeFilters</code> do not need to know how to traverse from node
- * to node, nor do they need to know anything about the data structure that
- * is being traversed. This makes it very easy to write filters, since the
- * only thing they have to know how to do is evaluate a single node. One
- * filter may be used with a number of different kinds of traversals,
- * encouraging code reuse.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
- * @since DOM Level 2
- *
- * @hide
- */
-public interface NodeFilter {
-    // Constants returned by acceptNode
-    /**
-     * Accept the node. Navigation methods defined for
-     * <code>NodeIterator</code> or <code>TreeWalker</code> will return this
-     * node.
-     */
-    public static final short FILTER_ACCEPT             = 1;
-    /**
-     * Reject the node. Navigation methods defined for
-     * <code>NodeIterator</code> or <code>TreeWalker</code> will not return
-     * this node. For <code>TreeWalker</code>, the children of this node
-     * will also be rejected. <code>NodeIterators</code> treat this as a
-     * synonym for <code>FILTER_SKIP</code>.
-     */
-    public static final short FILTER_REJECT             = 2;
-    /**
-     * Skip this single node. Navigation methods defined for
-     * <code>NodeIterator</code> or <code>TreeWalker</code> will not return
-     * this node. For both <code>NodeIterator</code> and
-     * <code>TreeWalker</code>, the children of this node will still be
-     * considered.
-     */
-    public static final short FILTER_SKIP               = 3;
-    // Constants for whatToShow
-    /**
-     * Show all <code>Nodes</code>.
-     */
-    public static final int SHOW_ALL                  = 0xFFFFFFFF;
-    /**
-     * Show <code>Element</code> nodes.
-     */
-    public static final int SHOW_ELEMENT              = 0x00000001;
-    /**
-     * Show <code>Attr</code> nodes. This is meaningful only when creating an
-     * <code>NodeIterator</code> or <code>TreeWalker</code> with an
-     * attribute node as its <code>root</code>; in this case, it means that
-     * the attribute node will appear in the first position of the iteration
-     * or traversal. Since attributes are never children of other nodes,
-     * they do not appear when traversing over the document tree.
-     */
-    public static final int SHOW_ATTRIBUTE            = 0x00000002;
-    /**
-     * Show <code>Text</code> nodes.
-     */
-    public static final int SHOW_TEXT                 = 0x00000004;
-    /**
-     * Show <code>CDATASection</code> nodes.
-     */
-    public static final int SHOW_CDATA_SECTION        = 0x00000008;
-    /**
-     * Show <code>EntityReference</code> nodes.
-     */
-    public static final int SHOW_ENTITY_REFERENCE     = 0x00000010;
-    /**
-     * Show <code>Entity</code> nodes. This is meaningful only when creating
-     * an <code>NodeIterator</code> or <code>TreeWalker</code> with an
-     * <code>Entity</code> node as its <code>root</code>; in this case, it
-     * means that the <code>Entity</code> node will appear in the first
-     * position of the traversal. Since entities are not part of the
-     * document tree, they do not appear when traversing over the document
-     * tree.
-     */
-    public static final int SHOW_ENTITY               = 0x00000020;
-    /**
-     * Show <code>ProcessingInstruction</code> nodes.
-     */
-    public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040;
-    /**
-     * Show <code>Comment</code> nodes.
-     */
-    public static final int SHOW_COMMENT              = 0x00000080;
-    /**
-     * Show <code>Document</code> nodes.
-     */
-    public static final int SHOW_DOCUMENT             = 0x00000100;
-    /**
-     * Show <code>DocumentType</code> nodes.
-     */
-    public static final int SHOW_DOCUMENT_TYPE        = 0x00000200;
-    /**
-     * Show <code>DocumentFragment</code> nodes.
-     */
-    public static final int SHOW_DOCUMENT_FRAGMENT    = 0x00000400;
-    /**
-     * Show <code>Notation</code> nodes. This is meaningful only when creating
-     * an <code>NodeIterator</code> or <code>TreeWalker</code> with a
-     * <code>Notation</code> node as its <code>root</code>; in this case, it
-     * means that the <code>Notation</code> node will appear in the first
-     * position of the traversal. Since notations are not part of the
-     * document tree, they do not appear when traversing over the document
-     * tree.
-     */
-    public static final int SHOW_NOTATION             = 0x00000800;
-    /**
-     * Test whether a specified node is visible in the logical view of a
-     * <code>TreeWalker</code> or <code>NodeIterator</code>. This function
-     * will be called by the implementation of <code>TreeWalker</code> and
-     * <code>NodeIterator</code>; it is not normally called directly from
-     * user code. (Though you could do so if you wanted to use the same
-     * filter to guide your own application logic.)
-     * @param n The node to check to see if it passes the filter or not.
-     * @return A constant to determine whether the node is accepted,
-     *   rejected, or skipped, as defined above.
-     */
-    public short acceptNode(Node n);
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/traversal/TreeWalker.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/traversal/TreeWalker.java b/Build/src/main/java/org/w3c/dom/traversal/TreeWalker.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/traversal/TreeWalker.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,154 +0,0 @@
-package org.w3c.dom.traversal;
-
-import org.w3c.dom.Node;
-import org.w3c.dom.DOMException;
-/**
- * <code>TreeWalker</code> objects are used to navigate a document tree or
- * subtree using the view of the document defined by their
- * <code>whatToShow</code> flags and filter (if any). Any function which
- * performs navigation using a <code>TreeWalker</code> will automatically
- * support any view defined by a <code>TreeWalker</code>.
- * <p>Omitting nodes from the logical view of a subtree can result in a
- * structure that is substantially different from the same subtree in the
- * complete, unfiltered document. Nodes that are siblings in the
- * <code>TreeWalker</code> view may be children of different, widely
- * separated nodes in the original view. For instance, consider a
- * <code>NodeFilter</code> that skips all nodes except for Text nodes and
- * the root node of a document. In the logical view that results, all text
- * nodes will be siblings and appear as direct children of the root node, no
- * matter how deeply nested the structure of the original document.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
- * @since DOM Level 2
- */
-public interface TreeWalker {
-    /**
-     * The <code>root</code> node of the <code>TreeWalker</code>, as specified
-     * when it was created.
-     */
-    public Node getRoot();
-    /**
-     * This attribute determines which node types are presented via the
-     * <code>TreeWalker</code>. The available set of constants is defined in
-     * the <code>NodeFilter</code> interface.  Nodes not accepted by
-     * <code>whatToShow</code> will be skipped, but their children may still
-     * be considered. Note that this skip takes precedence over the filter,
-     * if any.
-     */
-    public int getWhatToShow();
-    /**
-     * The filter used to screen nodes.
-     */
-    public NodeFilter getFilter();
-    /**
-     * The value of this flag determines whether the children of entity
-     * reference nodes are visible to the <code>TreeWalker</code>. If false,
-     * these children  and their descendants will be rejected. Note that
-     * this rejection takes precedence over <code>whatToShow</code> and the
-     * filter, if any.
-     * <br> To produce a view of the document that has entity references
-     * expanded and does not expose the entity reference node itself, use
-     * the <code>whatToShow</code> flags to hide the entity reference node
-     * and set <code>expandEntityReferences</code> to true when creating the
-     * <code>TreeWalker</code>. To produce a view of the document that has
-     * entity reference nodes but no entity expansion, use the
-     * <code>whatToShow</code> flags to show the entity reference node and
-     * set <code>expandEntityReferences</code> to false.
-     */
-    public boolean getExpandEntityReferences();
-    /**
-     * The node at which the <code>TreeWalker</code> is currently positioned.
-     * <br>Alterations to the DOM tree may cause the current node to no longer
-     * be accepted by the <code>TreeWalker</code>'s associated filter.
-     * <code>currentNode</code> may also be explicitly set to any node,
-     * whether or not it is within the subtree specified by the
-     * <code>root</code> node or would be accepted by the filter and
-     * <code>whatToShow</code> flags. Further traversal occurs relative to
-     * <code>currentNode</code> even if it is not part of the current view,
-     * by applying the filters in the requested direction; if no traversal
-     * is possible, <code>currentNode</code> is not changed.
-     */
-    public Node getCurrentNode();
-    /**
-     * The node at which the <code>TreeWalker</code> is currently positioned.
-     * <br>Alterations to the DOM tree may cause the current node to no longer
-     * be accepted by the <code>TreeWalker</code>'s associated filter.
-     * <code>currentNode</code> may also be explicitly set to any node,
-     * whether or not it is within the subtree specified by the
-     * <code>root</code> node or would be accepted by the filter and
-     * <code>whatToShow</code> flags. Further traversal occurs relative to
-     * <code>currentNode</code> even if it is not part of the current view,
-     * by applying the filters in the requested direction; if no traversal
-     * is possible, <code>currentNode</code> is not changed.
-     * @exception DOMException
-     *   NOT_SUPPORTED_ERR: Raised if an attempt is made to set
-     *   <code>currentNode</code> to <code>null</code>.
-     */
-    public void setCurrentNode(Node currentNode)
-            throws DOMException;
-    /**
-     * Moves to and returns the closest visible ancestor node of the current
-     * node. If the search for <code>parentNode</code> attempts to step
-     * upward from the <code>TreeWalker</code>'s <code>root</code> node, or
-     * if it fails to find a visible ancestor node, this method retains the
-     * current position and returns <code>null</code>.
-     * @return The new parent node, or <code>null</code> if the current node
-     *   has no parent  in the <code>TreeWalker</code>'s logical view.
-     */
-    public Node parentNode();
-    /**
-     * Moves the <code>TreeWalker</code> to the first visible child of the
-     * current node, and returns the new node. If the current node has no
-     * visible children, returns <code>null</code>, and retains the current
-     * node.
-     * @return The new node, or <code>null</code> if the current node has no
-     *   visible children  in the <code>TreeWalker</code>'s logical view.
-     */
-    public Node firstChild();
-    /**
-     * Moves the <code>TreeWalker</code> to the last visible child of the
-     * current node, and returns the new node. If the current node has no
-     * visible children, returns <code>null</code>, and retains the current
-     * node.
-     * @return The new node, or <code>null</code> if the current node has no
-     *   children  in the <code>TreeWalker</code>'s logical view.
-     */
-    public Node lastChild();
-    /**
-     * Moves the <code>TreeWalker</code> to the previous sibling of the
-     * current node, and returns the new node. If the current node has no
-     * visible previous sibling, returns <code>null</code>, and retains the
-     * current node.
-     * @return The new node, or <code>null</code> if the current node has no
-     *   previous sibling.  in the <code>TreeWalker</code>'s logical view.
-     */
-    public Node previousSibling();
-    /**
-     * Moves the <code>TreeWalker</code> to the next sibling of the current
-     * node, and returns the new node. If the current node has no visible
-     * next sibling, returns <code>null</code>, and retains the current node.
-     * @return The new node, or <code>null</code> if the current node has no
-     *   next sibling.  in the <code>TreeWalker</code>'s logical view.
-     */
-    public Node nextSibling();
-    /**
-     * Moves the <code>TreeWalker</code> to the previous visible node in
-     * document order relative to the current node, and returns the new
-     * node. If the current node has no previous node,  or if the search for
-     * <code>previousNode</code> attempts to step upward from the
-     * <code>TreeWalker</code>'s <code>root</code> node,  returns
-     * <code>null</code>, and retains the current node.
-     * @return The new node, or <code>null</code> if the current node has no
-     *   previous node  in the <code>TreeWalker</code>'s logical view.
-     */
-    public Node previousNode();
-    /**
-     * Moves the <code>TreeWalker</code> to the next visible node in document
-     * order relative to the current node, and returns the new node. If the
-     * current node has no next node, or if the search for nextNode attempts
-     * to step upward from the <code>TreeWalker</code>'s <code>root</code>
-     * node, returns <code>null</code>, and retains the current node.
-     * @return The new node, or <code>null</code> if the current node has no
-     *   next node  in the <code>TreeWalker</code>'s logical view.
-     */
-    public Node nextNode();
-}
Index: Build/src/main/java/org/w3c/dom/traversal/NodeIterator.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/traversal/NodeIterator.java b/Build/src/main/java/org/w3c/dom/traversal/NodeIterator.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/traversal/NodeIterator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,92 +0,0 @@
-package org.w3c.dom.traversal;
-
-
-import org.w3c.dom.DOMException;
-import org.w3c.dom.Node;
-/**
- * <code>NodeIterators</code> are used to step through a set of nodes, e.g.
- * the set of nodes in a <code>NodeList</code>, the document subtree
- * governed by a particular <code>Node</code>, the results of a query, or
- * any other set of nodes. The set of nodes to be iterated is determined by
- * the implementation of the <code>NodeIterator</code>. DOM Level 2
- * specifies a single <code>NodeIterator</code> implementation for
- * document-order traversal of a document subtree. Instances of these
- * <code>NodeIterators</code> are created by calling
- * <code>DocumentTraversal</code><code>.createNodeIterator()</code>.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
- * @since DOM Level 2
- *
- * @hide
- */
-public interface NodeIterator {
-    /**
-     * The root node of the <code>NodeIterator</code>, as specified when it
-     * was created.
-     */
-    public Node getRoot();
-    /**
-     * This attribute determines which node types are presented via the
-     * <code>NodeIterator</code>. The available set of constants is defined
-     * in the <code>NodeFilter</code> interface.  Nodes not accepted by
-     * <code>whatToShow</code> will be skipped, but their children may still
-     * be considered. Note that this skip takes precedence over the filter,
-     * if any.
-     */
-    public int getWhatToShow();
-    /**
-     * The <code>NodeFilter</code> used to screen nodes.
-     */
-    public NodeFilter getFilter();
-    /**
-     *  The value of this flag determines whether the children of entity
-     * reference nodes are visible to the <code>NodeIterator</code>. If
-     * false, these children  and their descendants will be rejected. Note
-     * that this rejection takes precedence over <code>whatToShow</code> and
-     * the filter. Also note that this is currently the only situation where
-     * <code>NodeIterators</code> may reject a complete subtree rather than
-     * skipping individual nodes.
-     * <br>
-     * <br> To produce a view of the document that has entity references
-     * expanded and does not expose the entity reference node itself, use
-     * the <code>whatToShow</code> flags to hide the entity reference node
-     * and set <code>expandEntityReferences</code> to true when creating the
-     * <code>NodeIterator</code>. To produce a view of the document that has
-     * entity reference nodes but no entity expansion, use the
-     * <code>whatToShow</code> flags to show the entity reference node and
-     * set <code>expandEntityReferences</code> to false.
-     */
-    public boolean getExpandEntityReferences();
-    /**
-     * Returns the next node in the set and advances the position of the
-     * <code>NodeIterator</code> in the set. After a
-     * <code>NodeIterator</code> is created, the first call to
-     * <code>nextNode()</code> returns the first node in the set.
-     * @return The next <code>Node</code> in the set being iterated over, or
-     *   <code>null</code> if there are no more members in that set.
-     * @exception DOMException
-     *   INVALID_STATE_ERR: Raised if this method is called after the
-     *   <code>detach</code> method was invoked.
-     */
-    public Node nextNode()
-            throws DOMException;
-    /**
-     * Returns the previous node in the set and moves the position of the
-     * <code>NodeIterator</code> backwards in the set.
-     * @return The previous <code>Node</code> in the set being iterated over,
-     *   or <code>null</code> if there are no more members in that set.
-     * @exception DOMException
-     *   INVALID_STATE_ERR: Raised if this method is called after the
-     *   <code>detach</code> method was invoked.
-     */
-    public Node previousNode()
-            throws DOMException;
-    /**
-     * Detaches the <code>NodeIterator</code> from the set which it iterated
-     * over, releasing any computational resources and placing the
-     * <code>NodeIterator</code> in the INVALID state. After
-     * <code>detach</code> has been invoked, calls to <code>nextNode</code>
-     * or <code>previousNode</code> will raise the exception
-     * INVALID_STATE_ERR.
-     */
-    public void detach();
-}
\ No newline at end of file
Index: Build/src/main/java/org/w3c/dom/traversal/DocumentTraversal.java
===================================================================
diff --git a/Build/src/main/java/org/w3c/dom/traversal/DocumentTraversal.java b/Build/src/main/java/org/w3c/dom/traversal/DocumentTraversal.java
deleted file mode 100644
--- a/Build/src/main/java/org/w3c/dom/traversal/DocumentTraversal.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,78 +0,0 @@
-package org.w3c.dom.traversal;
-
-import org.w3c.dom.Node;
-import org.w3c.dom.DOMException;
-/**
- * <code>DocumentTraversal</code> contains methods that create
- * <code>NodeIterators</code> and <code>TreeWalkers</code> to traverse a
- * node and its children in document order (depth first, pre-order
- * traversal, which is equivalent to the order in which the start tags occur
- * in the text representation of the document). In DOMs which support the
- * Traversal feature, <code>DocumentTraversal</code> will be implemented by
- * the same objects that implement the Document interface.
- * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
- * @since DOM Level 2
- */
-public interface DocumentTraversal {
-    /**
-     * Create a new <code>NodeIterator</code> over the subtree rooted at the
-     * specified node.
-     * @param root The node which will be iterated together with its
-     *   children. The <code>NodeIterator</code> is initially positioned
-     *   just before this node. The <code>whatToShow</code> flags and the
-     *   filter, if any, are not considered when setting this position. The
-     *   root must not be <code>null</code>.
-     * @param whatToShow This flag specifies which node types may appear in
-     *   the logical view of the tree presented by the
-     *   <code>NodeIterator</code>. See the description of
-     *   <code>NodeFilter</code> for the set of possible <code>SHOW_</code>
-     *   values.These flags can be combined using <code>OR</code>.
-     * @param filter The <code>NodeFilter</code> to be used with this
-     *   <code>NodeIterator</code>, or <code>null</code> to indicate no
-     *   filter.
-     * @param entityReferenceExpansion The value of this flag determines
-     *   whether entity reference nodes are expanded.
-     * @return The newly created <code>NodeIterator</code>.
-     * @exception DOMException
-     *   NOT_SUPPORTED_ERR: Raised if the specified <code>root</code> is
-     *   <code>null</code>.
-     */
-    public NodeIterator createNodeIterator(Node root,
-                                           int whatToShow,
-                                           NodeFilter filter,
-                                           boolean entityReferenceExpansion)
-            throws DOMException;
-    /**
-     * Create a new <code>TreeWalker</code> over the subtree rooted at the
-     * specified node.
-     * @param root The node which will serve as the <code>root</code> for the
-     *   <code>TreeWalker</code>. The <code>whatToShow</code> flags and the
-     *   <code>NodeFilter</code> are not considered when setting this value;
-     *   any node type will be accepted as the <code>root</code>. The
-     *   <code>currentNode</code> of the <code>TreeWalker</code> is
-     *   initialized to this node, whether or not it is visible. The
-     *   <code>root</code> functions as a stopping point for traversal
-     *   methods that look upward in the document structure, such as
-     *   <code>parentNode</code> and nextNode. The <code>root</code> must
-     *   not be <code>null</code>.
-     * @param whatToShow This flag specifies which node types may appear in
-     *   the logical view of the tree presented by the
-     *   <code>TreeWalker</code>. See the description of
-     *   <code>NodeFilter</code> for the set of possible <code>SHOW_</code>
-     *   values.These flags can be combined using <code>OR</code>.
-     * @param filter The <code>NodeFilter</code> to be used with this
-     *   <code>TreeWalker</code>, or <code>null</code> to indicate no filter.
-     * @param entityReferenceExpansion If this flag is false, the contents of
-     *   <code>EntityReference</code> nodes are not presented in the logical
-     *   view.
-     * @return The newly created <code>TreeWalker</code>.
-     * @exception DOMException
-     *    NOT_SUPPORTED_ERR: Raised if the specified <code>root</code> is
-     *   <code>null</code>.
-     */
-    public TreeWalker createTreeWalker(Node root,
-                                       int whatToShow,
-                                       NodeFilter filter,
-                                       boolean entityReferenceExpansion)
-            throws DOMException;
-}
\ No newline at end of file
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPath.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPath.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPath.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPath.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,319 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import org.xml.sax.InputSource;
-import javax.xml.namespace.QName;
-import javax.xml.namespace.NamespaceContext;
-
-/**
- * <p><code>XPath</code> provides access to the XPath evaluation environment and expressions.</p>
- *
- * <a name="XPath-evaluation"/>
- * <table border="1" cellpadding="2">
- *   <thead>
- *     <tr>
- *       <th colspan="2">Evaluation of XPath Expressions.</th>
- *     </tr>
- *   </thead>
- *   <tbody>
- *     <tr>
- *       <td>context</td>
- *       <td>
- *         If a request is made to evaluate the expression in the absence
- * of a context item, an empty document node will be used for the context.
- * For the purposes of evaluating XPath expressions, a DocumentFragment
- * is treated like a Document node.
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>variables</td>
- *      <td>
- *        If the expression contains a variable reference, its value will be found through the {@link javax.xml.xpath.XPathVariableResolver}
- *        set with {@link #setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver resolver)}.
- *        An {@link javax.xml.xpath.XPathExpressionException} is raised if the variable resolver is undefined or
- *        the resolver returns <code>null</code> for the variable.
- *        The value of a variable must be immutable through the course of any single evaluation.</p>
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>functions</td>
- *      <td>
- *        If the expression contains a function reference, the function will be found through the {@link javax.xml.xpath.XPathFunctionResolver}
- *        set with {@link #setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver resolver)}.
- *        An {@link javax.xml.xpath.XPathExpressionException} is raised if the function resolver is undefined or
- *        the function resolver returns <code>null</code> for the function.</p>
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>QNames</td>
- *      <td>
- *        QNames in the expression are resolved against the XPath namespace context
- *        set with {@link #setNamespaceContext(NamespaceContext nsContext)}.
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>result</td>
- *      <td>
- *        This result of evaluating an expression is converted to an instance of the desired return type.
- *        Valid return types are defined in {@link javax.xml.xpath.XPathConstants}.
- *        Conversion to the return type follows XPath conversion rules.</p>
- *      </td>
- *    </tr>
- * </table>
- *
- * <p>An XPath object is not thread-safe and not reentrant.
- * In other words, it is the application's responsibility to make
- * sure that one {@link XPath} object is not used from
- * more than one thread at any given time, and while the <code>evaluate</code>
- * method is invoked, applications may not recursively call
- * the <code>evaluate</code> method.
- * <p>
- *
- * @author  <a href="Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @see <a href="http://www.w3.org/TR/xpath">XML Path Language (XPath) Version 1.0</a>
- * @since 1.5
- */
-public interface XPath {
-
-        /**
-         * <p>Reset this <code>XPath</code> to its original configuration.</p>
-         *
-         * <p><code>XPath</code> is reset to the same state as when it was created with
-         * {@link XPathFactory#newXPath()}.
-         * <code>reset()</code> is designed to allow the reuse of existing <code>XPath</code>s
-         * thus saving resources associated with the creation of new <code>XPath</code>s.</p>
-         *
-         * <p>The reset <code>XPath</code> is not guaranteed to have the same {@link javax.xml.xpath.XPathFunctionResolver}, {@link javax.xml.xpath.XPathVariableResolver}
-         * or {@link NamespaceContext} <code>Object</code>s, e.g. {@link Object#equals(Object obj)}.
-         * It is guaranteed to have a functionally equal <code>XPathFunctionResolver</code>, <code>XPathVariableResolver</code>
-         * and <code>NamespaceContext</code>.</p>
-         */
-        public void reset();
-
-    /**
-     * <p>Establish a variable resolver.</p>
-     *
-     * <p>A <code>NullPointerException</code> is thrown if <code>resolver</code> is <code>null</code>.</p>
-     *
-     * @param resolver Variable resolver.
-     *
-     *  @throws NullPointerException If <code>resolver</code> is <code>null</code>.
-     */
-    public void setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver resolver);
-
-    /**
-       * <p>Return the current variable resolver.</p>
-       *
-       * <p><code>null</code> is returned in no variable resolver is in effect.</p>
-       *
-       * @return Current variable resolver.
-       */
-    public javax.xml.xpath.XPathVariableResolver getXPathVariableResolver();
-
-    /**
-       * <p>Establish a function resolver.</p>
-       *
-       * <p>A <code>NullPointerException</code> is thrown if <code>resolver</code> is <code>null</code>.</p>
-       *
-       * @param resolver XPath function resolver.
-       *
-       * @throws NullPointerException If <code>resolver</code> is <code>null</code>.
-       */
-    public void setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver resolver);
-
-    /**
-       * <p>Return the current function resolver.</p>
-       *
-       * <p><code>null</code> is returned in no function resolver is in effect.</p>
-       *
-       * @return Current function resolver.
-       */
-    public javax.xml.xpath.XPathFunctionResolver getXPathFunctionResolver();
-
-    /**
-       * <p>Establish a namespace context.</p>
-       *
-       * <p>A <code>NullPointerException</code> is thrown if <code>nsContext</code> is <code>null</code>.</p>
-       *
-       * @param nsContext Namespace context to use.
-       *
-       * @throws NullPointerException If <code>nsContext</code> is <code>null</code>.
-       */
-    public void setNamespaceContext(NamespaceContext nsContext);
-
-    /**
-       * <p>Return the current namespace context.</p>
-       *
-       * <p><code>null</code> is returned in no namespace context is in effect.</p>
-       *
-       * @return Current Namespace context.
-       */
-    public NamespaceContext getNamespaceContext();
-
-    /**
-       * <p>Compile an XPath expression for later evaluation.</p>
-       *
-       * <p>If <code>expression</code> contains any {@link XPathFunction}s,
-       * they must be available via the {@link XPathFunctionResolver}.
-       * An {@link javax.xml.xpath.XPathExpressionException} will be thrown if the
-       * <code>XPathFunction</code>
-       * cannot be resovled with the <code>XPathFunctionResolver</code>.</p>
-       *
-       * <p>If <code>expression</code> contains any variables, the
-       * {@link XPathVariableResolver} in effect
-       * <strong>at compile time</strong> will be used to resolve them.</p>
-       *
-       * <p>If <code>expression</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.</p>
-       *
-       * @param expression The XPath expression.
-       *
-       * @return Compiled XPath expression.
-
-       * @throws javax.xml.xpath.XPathExpressionException If <code>expression</code> cannot be compiled.
-       * @throws NullPointerException If <code>expression</code> is <code>null</code>.
-       */
-    public XPathExpression compile(String expression)
-        throws javax.xml.xpath.XPathExpressionException;
-
-    /**
-     * <p>Evaluate an <code>XPath</code> expression in the specified context and return the result as the specified type.</p>
-     *
-     * <p>See <a href="#XPath-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and <code>QName</code> resolution and return type conversion.</p>
-     *
-     * <p>If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants} (
-     * {@link javax.xml.xpath.XPathConstants#NUMBER NUMBER},
-     * {@link javax.xml.xpath.XPathConstants#STRING STRING},
-     * {@link javax.xml.xpath.XPathConstants#BOOLEAN BOOLEAN},
-     * {@link javax.xml.xpath.XPathConstants#NODE NODE} or
-     * {@link javax.xml.xpath.XPathConstants#NODESET NODESET})
-     * then an <code>IllegalArgumentException</code> is thrown.</p>
-     *
-     * <p>If a <code>null</code> value is provided for
-     * <code>item</code>, an empty document will be used for the
-     * context.
-     * If <code>expression</code> or <code>returnType</code> is <code>null</code>, then a
-     * <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param expression The XPath expression.
-     * @param item The starting context (a node, for example).
-     * @param returnType The desired return type.
-     *
-     * @return Result of evaluating an XPath expression as an <code>Object</code> of <code>returnType</code>.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If <code>expression</code> cannot be evaluated.
-     * @throws IllegalArgumentException If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants}.
-     * @throws NullPointerException If <code>expression</code> or <code>returnType</code> is <code>null</code>.
-     */
-    public Object evaluate(String expression, Object item, QName returnType)
-        throws javax.xml.xpath.XPathExpressionException;
-
-    /**
-     * <p>Evaluate an XPath expression in the specified context and return the result as a <code>String</code>.</p>
-     *
-     * <p>This method calls {@link #evaluate(String expression, Object item, QName returnType)} with a <code>returnType</code> of
-     * {@link javax.xml.xpath.XPathConstants#STRING}.</p>
-     *
-     * <p>See <a href="#XPath-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and QName resolution and return type conversion.</p>
-     *
-     * <p>If a <code>null</code> value is provided for
-     * <code>item</code>, an empty document will be used for the
-     * context.
-     * If <code>expression</code> is <code>null</code>, then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param expression The XPath expression.
-     * @param item The starting context (a node, for example).
-     *
-     * @return The <code>String</code> that is the result of evaluating the expression and
-     *   converting the result to a <code>String</code>.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If <code>expression</code> cannot be evaluated.
-     * @throws NullPointerException If <code>expression</code> is <code>null</code>.
-     */
-    public String evaluate(String expression, Object item)
-        throws javax.xml.xpath.XPathExpressionException;
-
-    /**
-     * <p>Evaluate an XPath expression in the context of the specified <code>InputSource</code>
-     * and return the result as the specified type.</p>
-     *
-     * <p>This method builds a data model for the {@link InputSource} and calls
-     * {@link #evaluate(String expression, Object item, QName returnType)} on the resulting document object.</p>
-     *
-     * <p>See <a href="#XPath-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and QName resolution and return type conversion.</p>
-     *
-     * <p>If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants},
-     * then an <code>IllegalArgumentException</code> is thrown.</p>
-     *
-     * <p>If <code>expression</code>, <code>source</code> or <code>returnType</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param expression The XPath expression.
-     * @param source The input source of the document to evaluate over.
-     * @param returnType The desired return type.
-     *
-     * @return The <code>Object</code> that encapsulates the result of evaluating the expression.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If expression cannot be evaluated.
-     * @throws IllegalArgumentException If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants}.
-     * @throws NullPointerException If <code>expression</code>, <code>source</code> or <code>returnType</code>
-     *   is <code>null</code>.
-     */
-    public Object evaluate(
-        String expression,
-        InputSource source,
-        QName returnType)
-        throws javax.xml.xpath.XPathExpressionException;
-
-    /**
-     * <p>Evaluate an XPath expression in the context of the specified <code>InputSource</code>
-     * and return the result as a <code>String</code>.</p>
-     *
-     * <p>This method calls {@link #evaluate(String expression, InputSource source, QName returnType)} with a
-     * <code>returnType</code> of {@link XPathConstants#STRING}.</p>
-     *
-     * <p>See <a href="#XPath-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and QName resolution and return type conversion.</p>
-     *
-     * <p>If <code>expression</code> or <code>source</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param expression The XPath expression.
-     * @param source The <code>InputSource</code> of the document to evaluate over.
-     *
-     * @return The <code>String</code> that is the result of evaluating the expression and
-     *   converting the result to a <code>String</code>.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If expression cannot be evaluated.
-     * @throws NullPointerException If <code>expression</code> or <code>source</code> is <code>null</code>.
-     */
-    public String evaluate(String expression, InputSource source)
-        throws XPathExpressionException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/package.html b/Build/src/main/java/org/openjdk/javax/xml/xpath/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,282 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-<head>
-<title>javax.xml.xpath</title>
-<meta name="@author" content="mailto:Ben@galbraiths.org" />
-<meta name="@author" content="mailto:Norman.Walsh@Sun.com" />
-<meta name="@author" content="mailto:Jeff.Suttor@Sun.com" />
-<meta name="@version" content="$Revision: 1.3 $, $Date: 2005/11/03 19:34:17 $" />
-<meta name="@see" content="http://www.w3.org/TR/xpath" />
-<meta name="@since" content="1.5" />
-</head>
-
-<body>
-
-<p>This package provides an <em>object-model neutral</em> API for the
-evaluation of XPath expressions and access to the evaluation
-environment.
-</p>
-
-<p>The following XML standards apply:</p>
-
-<ul>
-<li><a href="http://www.w3.org/TR/xpath">XML Path Language (XPath) Version 1.0</a></li>
-</ul>
-
-<hr />
-
-<h2>XPath Overview</h2>
-
-<p>The XPath language provides a simple, concise syntax for selecting
-nodes from an XML document. XPath also provides rules for converting a
-node in an XML document object model (DOM) tree to a boolean, double,
-or string value. XPath is a W3C-defined language and an official W3C
-recommendation; the W3C hosts the XML Path Language (XPath) Version
-1.0 specification.
-</p>
-
-<p>XPath started in life in 1999 as a supplement to the XSLT and
-XPointer languages, but has more recently become popular as a
-stand-alone language, as a single XPath expression can be used to
-replace many lines of DOM API code.
-</p>
-
-<h3>XPath Expressions</h3>
-
-<p>An XPath <em>expression</em> is composed of a <em>location
-path</em> and one or more optional <em>predicates</em>. Expressions
-may also include XPath variables.
-</p>
-
-<p>The following is an example of a simple XPath expression:</p>
-
-<pre>
-/foo/bar
-</pre>
-
-<p>This example would select the <code>&lt;bar&gt;</code> element in
-an XML document such as the following:</p>
-
-<pre>
-&lt;foo&gt;
-&lt;bar/&gt;
-&lt;/foo&gt;
-</pre>
-
-<p>The expression <code>/foo/bar</code> is an example of a location
-path. While XPath location paths resemble Unix-style file system
-paths, an important distinction is that XPath expressions return
-<em>all</em> nodes that match the expression. Thus, all three
-<code>&lt;bar&gt;</code> elements in the following document would be
-selected by the <code>/foo/bar</code> expression:</p>
-
-<pre>
-&lt;foo&gt;
-&lt;bar/&gt;
-&lt;bar/&gt;
-&lt;bar/&gt;
-&lt;/foo&gt;
-</pre>
-
-<p>A special location path operator, <code>//</code>, selects nodes at
-any depth in an XML document. The following example selects all
-<code>&lt;bar&gt;</code> elements regardless of their location in a
-document:</p>
-
-<pre>
-//bar
-</pre>
-
-<p>A wildcard operator, *, causes all element nodes to be selected.
-The following example selects all children elements of a
-<code>&lt;foo&gt;</code> element:</p>
-
-<pre>
-/foo/*
-</pre>
-
-<p>In addition to element nodes, XPath location paths may also address
-attribute nodes, text nodes, comment nodes, and processing instruction
-nodes. The following table gives examples of location paths for each
-of these node types:</p>
-
-<table border="1">
-<tr>
-<td>Location Path</td>
-<td>Description</td>
-</tr>
-<tr>
-<td>
-<code>/foo/bar/<strong>@id</strong></code>
-</td>
-<td>Selects the attribute <code>id</code> of the <code>&lt;bar&gt;</code> element
-</td>
-</tr>
-<tr>
-<td><code>/foo/bar/<strong>text()</strong></code>
-</td>
-<td>Selects the text nodes of the <code>&lt;bar&gt;</code> element. No
-distinction is made between escaped and non-escaped character data.
-</td>
-</tr>
-<tr>
-<td><code>/foo/bar/<strong>comment()</strong></code>
-</td>
-<td>Selects all comment nodes contained in the <code>&lt;bar&gt;</code> element.
-</td>
-</tr>
-<tr>
-<td><code>/foo/bar/<strong>processing-instruction()</strong></code>
-</td>
-<td>Selects all processing-instruction nodes contained in the
-<code>&lt;bar&gt;</code> element.
-</td>
-</tr>
-</table>
-
-<p>Predicates allow for refining the nodes selected by an XPath
-location path. Predicates are of the form
-<code>[<em>expression</em>]</code>. The following example selects all
-<code>&lt;foo&gt;</code> elements that contain an <code>include</code>
-attribute with the value of <code>true</code>:</p>
-
-<pre>
-//foo[@include='true']
-</pre>
-
-<p>Predicates may be appended to each other to further refine an
-expression, such as:</p>
-
-<pre>
-//foo[@include='true'][@mode='bar']
-</pre>
-
-<h3>Using the XPath API</h3>
-
-<p>
-The following example demonstrates using the XPath API to select one
-or more nodes from an XML document:</p>
-
-<pre>
-XPath xpath = XPathFactory.newInstance().newXPath();
-String expression = "/widgets/widget";
-InputSource inputSource = new InputSource("widgets.xml");
-NodeList nodes = (NodeList) xpath.evaluate(expression, inputSource, XPathConstants.NODESET);
-</pre>
-
-<h3>XPath Expressions and Types</h3>
-
-<p>While XPath expressions select nodes in the XML document, the XPath
-API allows the selected nodes to be coalesced into one of the
-following other data types:</p>
-
-<ul>
-<li><code>Boolean</code></li>
-<li><code>Number</code></li>
-<li><code>String</code></li>
-</ul>
-
-<p>The desired return type is specified by a {@link
-javax.xml.namespace.QName} parameter in method call used to evaluate
-the expression, which is either a call to
-<code>XPathExpression.evalute(...)</code> or to one of the
-<code>XPath.evaluate(...)</code> convenience methods. The allowed
-QName values are specified as constants in the {@link
-javax.xml.xpath.XPathConstants} class; they are:</p>
-
-<ul>
-<li>{@link javax.xml.xpath.XPathConstants#NODESET}</li>
-<li>{@link javax.xml.xpath.XPathConstants#NODE}</li>
-<li>{@link javax.xml.xpath.XPathConstants#STRING}</li>
-<li>{@link javax.xml.xpath.XPathConstants#BOOLEAN}</li>
-<li>{@link javax.xml.xpath.XPathConstants#NUMBER}</li>
-</ul>
-
-<p>When a <code>Boolean</code> return type is requested,
-<code>Boolean.TRUE</code> is returned if one or more nodes were
-selected; otherwise, <code>Boolean.FALSE</code> is returned.</p>
-
-<p>The <code>String</code> return type is a convenience for retrieving
-the character data from a text node, attribute node, comment node, or
-processing-instruction node. When used on an element node, the value
-of the child text nodes is returned.
-</p>
-
-<p>The <code>Number</code> return type attempts to coalesce the text
-of a node to a <code>double</code> data type.
-</p>
-
-<h3>XPath Context</h3>
-
-<p>XPath location paths may be relative to a particular node in the
-document, known as the <code>context</code>. Consider the following
-XML document:</p>
-
-<pre>
-&lt;widgets&gt;
-&lt;widget&gt;
-&lt;manufacturer/&gt;
-&lt;dimensions/&gt;
-&lt;/widget&gt;
-&lt;/widgets&gt;
-</pre>
-
-<p>The <code>&lt;widget&gt;</code> element can be selected with the
-following XPath API code:</p>
-
-<pre>
-// parse the XML as a W3C Document
-DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
-Document document = builder.parse(new File("/widgets.xml"));
-
-XPath xpath = XPathFactory.newInstance().newXPath();
-String expression = "/widgets/widget";
-Node widgetNode = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);
-</pre>
-
-<p>With a reference to the <code>&lt;widget&gt;</code> element, a
-relative XPath expression can now written to select the
-<code>&lt;manufacturer&gt;</code> child element:</p>
-
-<pre>
-XPath xpath = XPathFactory.newInstance().newXPath();
-<strong>String expression = "manufacturer";</strong>
-Node manufacturerNode = (Node) xpath.evaluate(expression, <strong>widgetNode</strong>, XPathConstants.NODE);
-</pre>
-
-<ul>
-<li>Author <a href="mailto:Ben@galbraiths.org">Ben Galbraith</a></li>
-<li>Author <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a></li>
-<li>Author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a></li>
-<li>See <a href="http://www.w3.org/TR/xpath">XML Path Language (XPath) Version 1.0</a></li>
-<li>Since 1.5</li>
-</ul>		
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactory.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,392 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import javax.xml.XMLConstants;
-
-/**
- * <p>An <code>XPathFactory</code> instance can be used to create
- * {@link javax.xml.xpath.XPath} objects.</p>
- *
- *<p>See {@link #newInstance(String uri)} for lookup mechanism.</p>
- *
- * <p>The {@link XPathFactory} class is not thread-safe. In other words,
- * it is the application's responsibility to ensure that at most
- * one thread is using a {@link XPathFactory} object at any
- * given moment. Implementations are encouraged to mark methods
- * as <code>synchronized</code> to protect themselves from broken clients.
- *
- * <p>{@link XPathFactory} is not re-entrant. While one of the
- * <code>newInstance</code> methods is being invoked, applications
- * may not attempt to recursively invoke a <code>newInstance</code> method,
- * even from the same thread.
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- *
- * @since 1.5
- */
-public abstract class XPathFactory {
-
-
-    /**
-     * <p>The default property name according to the JAXP spec.</p>
-     */
-    public static final String DEFAULT_PROPERTY_NAME = "javax.xml.xpath.XPathFactory";
-
-    /**
-     * <p>Default Object Model URI.</p>
-     */
-    public static final String DEFAULT_OBJECT_MODEL_URI = "http://java.sun.com/jaxp/xpath/dom";
-
-    /**
-     *<p> Take care of restrictions imposed by java security model </p>
-     */
-    private static SecuritySupport ss = new SecuritySupport() ;
-
-    /**
-     * <p>Protected constructor as {@link #newInstance()} or {@link #newInstance(String uri)}
-     * or {@link #newInstance(String uri, String factoryClassName, ClassLoader classLoader)}
-     * should be used to create a new instance of an <code>XPathFactory</code>.</p>
-     */
-    protected XPathFactory() {
-    }
-
-    /**
-     * <p>Get a new <code>XPathFactory</code> instance using the default object model,
-     * {@link #DEFAULT_OBJECT_MODEL_URI},
-     * the W3C DOM.</p>
-     *
-     * <p>This method is functionally equivalent to:</p>
-     * <pre>
-     *   newInstance(DEFAULT_OBJECT_MODEL_URI)
-     * </pre>
-     *
-     * <p>Since the implementation for the W3C DOM is always available, this method will never fail.</p>
-     *
-     * @return Instance of an <code>XPathFactory</code>.
-     *
-     * @throws RuntimeException When there is a failure in creating an
-     *   <code>XPathFactory</code> for the default object model.
-     */
-    public static XPathFactory newInstance() {
-
-        try {
-                return newInstance(DEFAULT_OBJECT_MODEL_URI);
-        } catch (javax.xml.xpath.XPathFactoryConfigurationException xpathFactoryConfigurationException) {
-                throw new RuntimeException(
-                        "XPathFactory#newInstance() failed to create an XPathFactory for the default object model: "
-                        + DEFAULT_OBJECT_MODEL_URI
-                        + " with the XPathFactoryConfigurationException: "
-                        + xpathFactoryConfigurationException.toString()
-                );
-        }
-    }
-
-    /**
-    * <p>Get a new <code>XPathFactory</code> instance using the specified object model.</p>
-    *
-    * <p>To find a <code>XPathFactory</code> object,
-    * this method looks the following places in the following order where "the class loader" refers to the context class loader:</p>
-    * <ol>
-    *   <li>
-    *     If the system property {@link #DEFAULT_PROPERTY_NAME} + ":uri" is present,
-    *     where uri is the parameter to this method, then its value is read as a class name.
-    *     The method will try to create a new instance of this class by using the class loader,
-    *     and returns it if it is successfully created.
-    *   </li>
-    *   <li>
-    *     ${java.home}/lib/jaxp.properties is read and the value associated with the key being the system property above is looked for.
-    *     If present, the value is processed just like above.
-    *   </li>
-    *   <li>
-    *     Use the service-provider loading facilities, defined by the
-    *     {@link java.util.ServiceLoader} class, to attempt to locate and load an
-    *     implementation of the service using the {@linkplain
-    *     java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-    *     the service-provider loading facility will use the {@linkplain
-    *     java.lang.Thread#getContextClassLoader() current thread's context class loader}
-    *     to attempt to load the service. If the context class
-    *     loader is null, the {@linkplain
-    *     ClassLoader#getSystemClassLoader() system class loader} will be used.
-    *     <br>
-    *     Each potential service provider is required to implement the method
-    *     {@link #isObjectModelSupported(String objectModel)}.
-    *     The first service provider found that supports the specified object
-    *     model is returned.
-    *     <br>
-    *     In case of {@link java.util.ServiceConfigurationError} an
-    *     {@link javax.xml.xpath.XPathFactoryConfigurationException} will be thrown.
-    *   </li>
-    *   <li>
-    *     Platform default <code>XPathFactory</code> is located in a platform specific way.
-    *     There must be a platform default XPathFactory for the W3C DOM, i.e. {@link #DEFAULT_OBJECT_MODEL_URI}.
-    *   </li>
-    * </ol>
-    * <p>If everything fails, an <code>XPathFactoryConfigurationException</code> will be thrown.</p>
-    *
-    * <p>Tip for Trouble-shooting:</p>
-    * <p>See {@link java.util.Properties#load(java.io.InputStream)} for exactly how a property file is parsed.
-    * In particular, colons ':' need to be escaped in a property file, so make sure the URIs are properly escaped in it.
-    * For example:</p>
-    * <pre>
-    *   http\://java.sun.com/jaxp/xpath/dom=org.acme.DomXPathFactory
-    * </pre>
-    *
-    * @param uri Identifies the underlying object model.
-    *   The specification only defines the URI {@link #DEFAULT_OBJECT_MODEL_URI},
-    *   <code>http://java.sun.com/jaxp/xpath/dom</code> for the W3C DOM,
-    *   the org.w3c.dom package, and implementations are free to introduce other URIs for other object models.
-    *
-    * @return Instance of an <code>XPathFactory</code>.
-    *
-    * @throws javax.xml.xpath.XPathFactoryConfigurationException If the specified object model
-    *      is unavailable, or if there is a configuration error.
-    * @throws NullPointerException If <code>uri</code> is <code>null</code>.
-    * @throws IllegalArgumentException If <code>uri</code> is <code>null</code>
-    *   or <code>uri.length() == 0</code>.
-    */
-    public static XPathFactory newInstance(final String uri)
-        throws javax.xml.xpath.XPathFactoryConfigurationException {
-
-        if (uri == null) {
-            throw new NullPointerException(
-                    "XPathFactory#newInstance(String uri) cannot be called with uri == null");
-        }
-
-        if (uri.length() == 0) {
-            throw new IllegalArgumentException(
-                    "XPathFactory#newInstance(String uri) cannot be called with uri == \"\"");
-        }
-
-        ClassLoader classLoader = ss.getContextClassLoader();
-
-        if (classLoader == null) {
-            //use the current class loader
-            classLoader = XPathFactory.class.getClassLoader();
-        }
-
-        XPathFactory xpathFactory = new XPathFactoryFinder(classLoader).newFactory(uri);
-
-        if (xpathFactory == null) {
-            throw new javax.xml.xpath.XPathFactoryConfigurationException(
-                    "No XPathFactory implementation found for the object model: "
-                    + uri);
-        }
-
-        return xpathFactory;
-    }
-
-    /**
-     * <p>Obtain a new instance of a <code>XPathFactory</code> from a factory class name. <code>XPathFactory</code>
-     * is returned if specified factory class supports the specified object model.
-     * This function is useful when there are multiple providers in the classpath.
-     * It gives more control to the application as it can specify which provider
-     * should be loaded.</p>
-     *
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     * @param uri         Identifies the underlying object model. The specification only defines the URI
-     *                    {@link #DEFAULT_OBJECT_MODEL_URI},<code>http://java.sun.com/jaxp/xpath/dom</code>
-     *                    for the W3C DOM, the org.w3c.dom package, and implementations are free to introduce
-     *                    other URIs for other object models.
-     *
-     * @param factoryClassName fully qualified factory class name that provides implementation of <code>javax.xml.xpath.XPathFactory</code>.
-     *
-     * @param classLoader <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     *                     current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     *
-     * @return New instance of a <code>XPathFactory</code>
-     *
-     * @throws javax.xml.xpath.XPathFactoryConfigurationException
-     *                   if <code>factoryClassName</code> is <code>null</code>, or
-     *                   the factory class cannot be loaded, instantiated
-     *                   or the factory class does not support the object model specified
-     *                   in the <code>uri</code> parameter.
-     *
-     * @throws NullPointerException If <code>uri</code> is <code>null</code>.
-     * @throws IllegalArgumentException If <code>uri</code> is <code>null</code>
-     *          or <code>uri.length() == 0</code>.
-     *
-     * @see #newInstance()
-     * @see #newInstance(String uri)
-     *
-     * @since 1.6
-     */
-    public static XPathFactory newInstance(String uri, String factoryClassName, ClassLoader classLoader)
-        throws javax.xml.xpath.XPathFactoryConfigurationException {
-        ClassLoader cl = classLoader;
-
-        if (uri == null) {
-            throw new NullPointerException(
-                    "XPathFactory#newInstance(String uri) cannot be called with uri == null");
-        }
-
-        if (uri.length() == 0) {
-            throw new IllegalArgumentException(
-                    "XPathFactory#newInstance(String uri) cannot be called with uri == \"\"");
-        }
-
-        if (cl == null) {
-            cl = ss.getContextClassLoader();
-        }
-
-        XPathFactory f = new XPathFactoryFinder(cl).createInstance(factoryClassName);
-
-        if (f == null) {
-            throw new javax.xml.xpath.XPathFactoryConfigurationException(
-                    "No XPathFactory implementation found for the object model: "
-                    + uri);
-        }
-        //if this factory supports the given schemalanguage return this factory else thrown exception
-        if (f.isObjectModelSupported(uri)) {
-            return f;
-        } else {
-            throw new javax.xml.xpath.XPathFactoryConfigurationException("Factory "
-                    + factoryClassName + " doesn't support given " + uri
-                    + " object model");
-        }
-
-    }
-
-    /**
-     * <p>Is specified object model supported by this <code>XPathFactory</code>?</p>
-     *
-     * @param objectModel Specifies the object model which the returned <code>XPathFactory</code> will understand.
-     *
-     * @return <code>true</code> if <code>XPathFactory</code> supports <code>objectModel</code>, else <code>false</code>.
-     *
-     * @throws NullPointerException If <code>objectModel</code> is <code>null</code>.
-     * @throws IllegalArgumentException If <code>objectModel.length() == 0</code>.
-     */
-    public abstract boolean isObjectModelSupported(String objectModel);
-
-    /**
-     * <p>Set a feature for this <code>XPathFactory</code> and
-     * <code>XPath</code>s created by this factory.</p>
-     *
-     * <p>
-     * Feature names are fully qualified {@link java.net.URI}s.
-     * Implementations may define their own features.
-     * An {@link javax.xml.xpath.XPathFactoryConfigurationException} is thrown if this
-     * <code>XPathFactory</code> or the <code>XPath</code>s
-     * it creates cannot support the feature.
-     * It is possible for an <code>XPathFactory</code> to expose a feature value
-     * but be unable to change its state.
-     * </p>
-     *
-     * <p>
-     * All implementations are required to support the {@link XMLConstants#FEATURE_SECURE_PROCESSING} feature.
-     * When the feature is <code>true</code>, any reference to  an external function is an error.
-     * Under these conditions, the implementation must not call the {@link javax.xml.xpath.XPathFunctionResolver}
-     * and must throw an {@link XPathFunctionException}.
-     * </p>
-     *
-     * @param name Feature name.
-     * @param value Is feature state <code>true</code> or <code>false</code>.
-     *
-     * @throws javax.xml.xpath.XPathFactoryConfigurationException if this <code>XPathFactory</code> or the <code>XPath</code>s
-     *   it creates cannot support this feature.
-     * @throws NullPointerException if <code>name</code> is <code>null</code>.
-     */
-    public abstract void setFeature(String name, boolean value)
-            throws javax.xml.xpath.XPathFactoryConfigurationException;
-
-    /**
-     * <p>Get the state of the named feature.</p>
-     *
-     * <p>
-     * Feature names are fully qualified {@link java.net.URI}s.
-     * Implementations may define their own features.
-     * An {@link javax.xml.xpath.XPathFactoryConfigurationException} is thrown if this
-     * <code>XPathFactory</code> or the <code>XPath</code>s
-     * it creates cannot support the feature.
-     * It is possible for an <code>XPathFactory</code> to expose a feature value
-     * but be unable to change its state.
-     * </p>
-     *
-     * @param name Feature name.
-     *
-     * @return State of the named feature.
-     *
-     * @throws javax.xml.xpath.XPathFactoryConfigurationException if this
-     *   <code>XPathFactory</code> or the <code>XPath</code>s
-     *   it creates cannot support this feature.
-     * @throws NullPointerException if <code>name</code> is <code>null</code>.
-     */
-    public abstract boolean getFeature(String name)
-            throws XPathFactoryConfigurationException;
-
-    /**
-     * <p>Establish a default variable resolver.</p>
-     *
-     * <p>Any <code>XPath</code> objects constructed from this factory will use
-     * the specified resolver by default.</p>
-     *
-     * <p>A <code>NullPointerException</code> is thrown if <code>resolver</code>
-     * is <code>null</code>.</p>
-     *
-     * @param resolver Variable resolver.
-     *
-     * @throws NullPointerException If <code>resolver</code> is
-     *   <code>null</code>.
-     */
-    public abstract void setXPathVariableResolver(XPathVariableResolver resolver);
-
-    /**
-     * <p>Establish a default function resolver.</p>
-     *
-     * <p>Any <code>XPath</code> objects constructed from this factory will
-     * use the specified resolver by default.</p>
-     *
-     * <p>A <code>NullPointerException</code> is thrown if
-     * <code>resolver</code> is <code>null</code>.</p>
-     *
-     * @param resolver XPath function resolver.
-     *
-     * @throws NullPointerException If <code>resolver</code> is
-     *   <code>null</code>.
-     */
-    public abstract void setXPathFunctionResolver(XPathFunctionResolver resolver);
-
-    /**
-    * <p>Return a new <code>XPath</code> using the underlying object
-    * model determined when the <code>XPathFactory</code> was instantiated.</p>
-    *
-    * @return New instance of an <code>XPath</code>.
-    */
-    public abstract XPath newXPath();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunction.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunction.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunction.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunction.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import java.util.List;
-
-/**
- * <p><code>XPathFunction</code> provides access to XPath functions.</p>
- *
- * <p>Functions are identified by QName and arity in XPath.</p>
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @since 1.5
- */
-public interface XPathFunction {
-  /**
-   * <p>Evaluate the function with the specified arguments.</p>
-   *
-   * <p>To the greatest extent possible, side-effects should be avoided in the
-   * definition of extension functions. The implementation evaluating an
-   * XPath expression is under no obligation to call extension functions in
-   * any particular order or any particular number of times.</p>
-   *
-   * @param args The arguments, <code>null</code> is a valid value.
-   *
-   * @return The result of evaluating the <code>XPath</code> function as an <code>Object</code>.
-   *
-   * @throws javax.xml.xpath.XPathFunctionException If <code>args</code> cannot be evaluated with this <code>XPath</code> function.
-   */
-  public Object evaluate(List args)
-    throws XPathFunctionException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathConstants.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathConstants.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathConstants.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathConstants.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import javax.xml.namespace.QName;
-
-/**
- * <p>XPath constants.</p>
- *
- * @author <a href="mailto:Norman.Walsh@Sun.COM">Norman Walsh</a>
- * @author <a href="mailto:Jeff.Suttor@Sun.COM">Jeff Suttor</a>
- * @see <a href="http://www.w3.org/TR/xpath">XML Path Language (XPath) Version 1.0</a>
- * @since 1.5
- */
-public class XPathConstants {
-
-    /**
-     * <p>Private constructor to prevent instantiation.</p>
-     */
-    private XPathConstants() { }
-
-    /**
-     * <p>The XPath 1.0 number data type.</p>
-     *
-     * <p>Maps to Java {@link Double}.</p>
-     */
-    public static final QName NUMBER = new QName("http://www.w3.org/1999/XSL/Transform", "NUMBER");
-
-    /**
-     * <p>The XPath 1.0 string data type.</p>
-     *
-     * <p>Maps to Java {@link String}.</p>
-     */
-    public static final QName STRING = new QName("http://www.w3.org/1999/XSL/Transform", "STRING");
-
-    /**
-     * <p>The XPath 1.0 boolean data type.</p>
-     *
-     * <p>Maps to Java {@link Boolean}.</p>
-     */
-    public static final QName BOOLEAN = new QName("http://www.w3.org/1999/XSL/Transform", "BOOLEAN");
-
-    /**
-     * <p>The XPath 1.0 NodeSet data type.</p>
-     *
-     * <p>Maps to Java {@link org.w3c.dom.NodeList}.</p>
-     */
-    public static final QName NODESET = new QName("http://www.w3.org/1999/XSL/Transform", "NODESET");
-
-    /**
-     * <p>The XPath 1.0 NodeSet data type.
-     *
-     * <p>Maps to Java {@link org.w3c.dom.Node}.</p>
-     */
-    public static final QName NODE = new QName("http://www.w3.org/1999/XSL/Transform", "NODE");
-
-    /**
-     * <p>The URI for the DOM object model, "http://java.sun.com/jaxp/xpath/dom".</p>
-     */
-    public static final String DOM_OBJECT_MODEL = "http://java.sun.com/jaxp/xpath/dom";
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathException.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,176 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import java.io.PrintWriter;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamField;
-import java.io.InvalidClassException;
-
-/**
- * <code>XPathException</code> represents a generic XPath exception.</p>
- *
- * @author  <a href="Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author <a href="mailto:Jeff.Suttor@Sun.COM">Jeff Suttor</a>
- * @since 1.5
- */
-public class XPathException extends Exception {
-
-    private static final ObjectStreamField[] serialPersistentFields = {
-        new ObjectStreamField( "cause", Throwable.class )
-    };
-
-    /**
-     * <p>Stream Unique Identifier.</p>
-     */
-    private static final long serialVersionUID = -1837080260374986980L;
-
-    /**
-     * <p>Constructs a new <code>XPathException</code>
-     * with the specified detail <code>message</code>.</p>
-     *
-     * <p>The <code>cause</code> is not initialized.</p>
-     *
-     * <p>If <code>message</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param message The detail message.
-     *
-     * @throws NullPointerException When <code>message</code> is
-     *   <code>null</code>.
-     */
-    public XPathException(String message) {
-        super(message);
-        if ( message == null ) {
-            throw new NullPointerException ( "message can't be null");
-        }
-    }
-
-    /**
-     * <p>Constructs a new <code>XPathException</code>
-     * with the specified <code>cause</code>.</p>
-     *
-     * <p>If <code>cause</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param cause The cause.
-     *
-     * @throws NullPointerException if <code>cause</code> is <code>null</code>.
-     */
-    public XPathException(Throwable cause) {
-        super(cause);
-        if ( cause == null ) {
-            throw new NullPointerException ( "cause can't be null");
-        }
-    }
-
-    /**
-     * <p>Get the cause of this XPathException.</p>
-     *
-     * @return Cause of this XPathException.
-     */
-    public Throwable getCause() {
-        return super.getCause();
-    }
-
-    /**
-     * Writes "cause" field to the stream.
-     * The cause is got from the parent class.
-     *
-     * @param out stream used for serialization.
-     * @throws IOException thrown by <code>ObjectOutputStream</code>
-     *
-     */
-    private void writeObject(ObjectOutputStream out)
-            throws IOException
-    {
-        ObjectOutputStream.PutField fields = out.putFields();
-        fields.put("cause", (Throwable) super.getCause());
-        out.writeFields();
-    }
-
-    /**
-     * Reads the "cause" field from the stream.
-     * And initializes the "cause" if it wasn't
-     * done before.
-     *
-     * @param in stream used for deserialization
-     * @throws IOException thrown by <code>ObjectInputStream</code>
-     * @throws ClassNotFoundException  thrown by <code>ObjectInputStream</code>
-     */
-    private void readObject(ObjectInputStream in)
-            throws IOException, ClassNotFoundException
-    {
-        ObjectInputStream.GetField fields = in.readFields();
-        Throwable scause = (Throwable) fields.get("cause", null);
-
-        if (super.getCause() == null && scause != null) {
-            try {
-                super.initCause(scause);
-            } catch(IllegalStateException e) {
-                throw new InvalidClassException("Inconsistent state: two causes");
-            }
-        }
-    }
-
-    /**
-     * <p>Print stack trace to specified <code>PrintStream</code>.</p>
-     *
-     * @param s Print stack trace to this <code>PrintStream</code>.
-     */
-    public void printStackTrace(java.io.PrintStream s) {
-        if (getCause() != null) {
-            getCause().printStackTrace(s);
-          s.println("--------------- linked to ------------------");
-        }
-
-        super.printStackTrace(s);
-    }
-
-    /**
-     * <p>Print stack trace to <code>System.err</code>.</p>
-     */
-    public void printStackTrace() {
-        printStackTrace(System.err);
-    }
-
-    /**
-     * <p>Print stack trace to specified <code>PrintWriter</code>.</p>
-     *
-     * @param s Print stack trace to this <code>PrintWriter</code>.
-     */
-    public void printStackTrace(PrintWriter s) {
-
-        if (getCause() != null) {
-            getCause().printStackTrace(s);
-          s.println("--------------- linked to ------------------");
-        }
-
-        super.printStackTrace(s);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/SecuritySupport.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/SecuritySupport.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/SecuritySupport.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/SecuritySupport.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,160 +0,0 @@
-/*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import java.net.URL;
-import java.security.*;
-import java.net.*;
-import java.io.*;
-import java.util.*;
-
-/**
- * This class is duplicated for each JAXP subpackage so keep it in sync.
- * It is package private and therefore is not exposed as part of the JAXP
- * API.
- *
- * Security related methods that only work on J2SE 1.2 and newer.
- */
-class SecuritySupport  {
-
-
-    ClassLoader getContextClassLoader() {
-        return (ClassLoader)
-                AccessController.doPrivileged(new PrivilegedAction() {
-            public Object run() {
-                ClassLoader cl = null;
-                try {
-                    cl = Thread.currentThread().getContextClassLoader();
-                } catch (SecurityException ex) { }
-                return cl;
-            }
-        });
-    }
-
-    String getSystemProperty(final String propName) {
-        return (String)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(propName);
-                }
-            });
-    }
-
-    FileInputStream getFileInputStream(final File file)
-        throws FileNotFoundException
-    {
-        try {
-            return (FileInputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws FileNotFoundException {
-                        return new FileInputStream(file);
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (FileNotFoundException)e.getException();
-        }
-    }
-
-    InputStream getURLInputStream(final URL url)
-        throws IOException
-    {
-        try {
-            return (InputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws IOException {
-                        return url.openStream();
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (IOException)e.getException();
-        }
-    }
-
-    URL getResourceAsURL(final ClassLoader cl,
-                                           final String name)
-    {
-        return (URL)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    URL url;
-                    if (cl == null) {
-                        url = Object.class.getResource(name);
-                    } else {
-                        url = cl.getResource(name);
-                    }
-                    return url;
-                }
-            });
-    }
-
-    Enumeration getResources(final ClassLoader cl,
-                                           final String name) throws IOException
-    {
-        try{
-        return (Enumeration)
-            AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                public Object run() throws IOException{
-                    Enumeration enumeration;
-                    if (cl == null) {
-                        enumeration = ClassLoader.getSystemResources(name);
-                    } else {
-                        enumeration = cl.getResources(name);
-                    }
-                    return enumeration;
-                }
-            });
-        }catch(PrivilegedActionException e){
-            throw (IOException)e.getException();
-        }
-    }
-
-    InputStream getResourceAsStream(final ClassLoader cl,
-                                           final String name)
-    {
-        return (InputStream)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    InputStream ris;
-                    if (cl == null) {
-                        ris = Object.class.getResourceAsStream(name);
-                    } else {
-                        ris = cl.getResourceAsStream(name);
-                    }
-                    return ris;
-                }
-            });
-    }
-
-    boolean doesFileExist(final File f) {
-    return ((Boolean)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return new Boolean(f.exists());
-                }
-            })).booleanValue();
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpression.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpression.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpression.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpression.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,200 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import org.xml.sax.InputSource;
-import javax.xml.namespace.QName;
-
-/**
- * <p><code>XPathExpression</code> provides access to compiled XPath expressions.</p>
- *
- * <a name="XPathExpression-evaluation"/>
- * <table border="1" cellpadding="2">
- *   <thead>
- *     <tr>
- *       <th colspan="2">Evaluation of XPath Expressions.</th>
- *     </tr>
- *   </thead>
- *   <tbody>
- *     <tr>
- *       <td>context</td>
- *       <td>
- *         If a request is made to evaluate the expression in the absence
- * of a context item, an empty document node will be used for the context.
- * For the purposes of evaluating XPath expressions, a DocumentFragment
- * is treated like a Document node.
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>variables</td>
- *      <td>
- *        If the expression contains a variable reference, its value will be found through the {@link XPathVariableResolver}.
- *        An {@link javax.xml.xpath.XPathExpressionException} is raised if the variable resolver is undefined or
- *        the resolver returns <code>null</code> for the variable.
- *        The value of a variable must be immutable through the course of any single evaluation.</p>
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>functions</td>
- *      <td>
- *        If the expression contains a function reference, the function will be found through the {@link XPathFunctionResolver}.
- *        An {@link javax.xml.xpath.XPathExpressionException} is raised if the function resolver is undefined or
- *        the function resolver returns <code>null</code> for the function.</p>
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>QNames</td>
- *      <td>
- *        QNames in the expression are resolved against the XPath namespace context.
- *      </td>
- *    </tr>
- *    <tr>
- *      <td>result</td>
- *      <td>
- *        This result of evaluating an expression is converted to an instance of the desired return type.
- *        Valid return types are defined in {@link javax.xml.xpath.XPathConstants}.
- *        Conversion to the return type follows XPath conversion rules.</p>
- *      </td>
- *    </tr>
- * </table>
- *
- * <p>An XPath expression is not thread-safe and not reentrant.
- * In other words, it is the application's responsibility to make
- * sure that one {@link XPathExpression} object is not used from
- * more than one thread at any given time, and while the <code>evaluate</code>
- * method is invoked, applications may not recursively call
- * the <code>evaluate</code> method.
- * <p>
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @see <a href="http://www.w3.org/TR/xpath#section-Expressions">XML Path Language (XPath) Version 1.0, Expressions</a>
- * @since 1.5
- */
-public interface XPathExpression {
-
-    /**
-     * <p>Evaluate the compiled XPath expression in the specified context and return the result as the specified type.</p>
-     *
-     * <p>See <a href="#XPathExpression-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and QName resolution and return type conversion.</p>
-     *
-     * <p>If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants},
-     * then an <code>IllegalArgumentException</code> is thrown.</p>
-     *
-     * <p>If a <code>null</code> value is provided for
-     * <code>item</code>, an empty document will be used for the
-     * context.
-     * If <code>returnType</code> is <code>null</code>, then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param item The starting context (a node, for example).
-     * @param returnType The desired return type.
-     *
-     * @return The <code>Object</code> that is the result of evaluating the expression and converting the result to
-     *   <code>returnType</code>.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If the expression cannot be evaluated.
-     * @throws IllegalArgumentException If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants}.
-     * @throws NullPointerException If  <code>returnType</code> is <code>null</code>.
-     */
-    public Object evaluate(Object item, QName returnType)
-        throws javax.xml.xpath.XPathExpressionException;
-
-    /**
-     * <p>Evaluate the compiled XPath expression in the specified context and return the result as a <code>String</code>.</p>
-     *
-     * <p>This method calls {@link #evaluate(Object item, QName returnType)} with a <code>returnType</code> of
-     * {@link javax.xml.xpath.XPathConstants#STRING}.</p>
-     *
-     * <p>See <a href="#XPathExpression-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and QName resolution and return type conversion.</p>
-     *
-     * <p>If a <code>null</code> value is provided for
-     * <code>item</code>, an empty document will be used for the
-     * context.
-     *
-     * @param item The starting context (a node, for example).
-     *
-     * @return The <code>String</code> that is the result of evaluating the expression and converting the result to a
-     *   <code>String</code>.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If the expression cannot be evaluated.
-     */
-    public String evaluate(Object item)
-        throws javax.xml.xpath.XPathExpressionException;
-
-    /**
-     * <p>Evaluate the compiled XPath expression in the context of the specified <code>InputSource</code> and return the result as the
-     * specified type.</p>
-     *
-     * <p>This method builds a data model for the {@link InputSource} and calls
-     * {@link #evaluate(Object item, QName returnType)} on the resulting document object.</p>
-     *
-     * <p>See <a href="#XPathExpression-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and QName resolution and return type conversion.</p>
-     *
-     * <p>If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants},
-     * then an <code>IllegalArgumentException</code> is thrown.</p>
-     *
-     * <p>If <code>source</code> or <code>returnType</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param source The <code>InputSource</code> of the document to evaluate over.
-     * @param returnType The desired return type.
-     *
-     * @return The <code>Object</code> that is the result of evaluating the expression and converting the result to
-     *   <code>returnType</code>.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If the expression cannot be evaluated.
-     * @throws IllegalArgumentException If <code>returnType</code> is not one of the types defined in {@link javax.xml.xpath.XPathConstants}.
-     * @throws NullPointerException If  <code>source</code> or <code>returnType</code> is <code>null</code>.
-     */
-    public Object evaluate(InputSource source, QName returnType)
-        throws javax.xml.xpath.XPathExpressionException;
-
-    /**
-     * <p>Evaluate the compiled XPath expression in the context of the specified <code>InputSource</code> and return the result as a
-     * <code>String</code>.</p>
-     *
-     * <p>This method calls {@link #evaluate(InputSource source, QName returnType)} with a <code>returnType</code> of
-     * {@link XPathConstants#STRING}.</p>
-     *
-     * <p>See <a href="#XPathExpression-evaluation">Evaluation of XPath Expressions</a> for context item evaluation,
-     * variable, function and QName resolution and return type conversion.</p>
-     *
-     * <p>If <code>source</code> is <code>null</code>, then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param source The <code>InputSource</code> of the document to evaluate over.
-     *
-     * @return The <code>String</code> that is the result of evaluating the expression and converting the result to a
-     *   <code>String</code>.
-     *
-     * @throws javax.xml.xpath.XPathExpressionException If the expression cannot be evaluated.
-     * @throws NullPointerException If  <code>source</code> is <code>null</code>.
-     */
-    public String evaluate(InputSource source)
-        throws XPathExpressionException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryFinder.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryFinder.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryFinder.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryFinder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,444 +0,0 @@
-/*
- * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import java.io.File;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.net.URL;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Properties;
-import java.util.ServiceConfigurationError;
-import java.util.ServiceLoader;
-
-/**
- * Implementation of {@link javax.xml.xpath.XPathFactory#newInstance(String)}.
- *
- * @author <a href="Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @version $Revision: 1.7 $, $Date: 2010-11-01 04:36:14 $
- * @since 1.5
- */
-class XPathFactoryFinder  {
-    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xpath.internal";
-
-    private static final SecuritySupport ss = new SecuritySupport() ;
-    /** debug support code. */
-    private static boolean debug = false;
-    static {
-        // Use try/catch block to support applets
-        try {
-            debug = ss.getSystemProperty("jaxp.debug") != null;
-        } catch (Exception unused) {
-            debug = false;
-        }
-    }
-
-    /**
-     * <p>Cache properties for performance.</p>
-     */
-    private static final Properties cacheProps = new Properties();
-
-    /**
-     * <p>First time requires initialization overhead.</p>
-     */
-    private volatile static boolean firstTime = true;
-
-    /**
-     * <p>Conditional debug printing.</p>
-     *
-     * @param msg to print
-     */
-    private static void debugPrintln(String msg) {
-        if (debug) {
-            System.err.println("JAXP: " + msg);
-        }
-    }
-
-    /**
-     * <p><code>ClassLoader</code> to use to find <code>XPathFactory</code>.</p>
-     */
-    private final ClassLoader classLoader;
-
-    /**
-     * <p>Constructor that specifies <code>ClassLoader</code> to use
-     * to find <code>XPathFactory</code>.</p>
-     *
-     * @param loader
-     *      to be used to load resource and {@link javax.xml.xpath.XPathFactory}
-     *      implementations during the resolution process.
-     *      If this parameter is null, the default system class loader
-     *      will be used.
-     */
-    public XPathFactoryFinder(ClassLoader loader) {
-        this.classLoader = loader;
-        if( debug ) {
-            debugDisplayClassLoader();
-        }
-    }
-
-    private void debugDisplayClassLoader() {
-        try {
-            if( classLoader == ss.getContextClassLoader() ) {
-                debugPrintln("using thread context class loader ("+classLoader+") for search");
-                return;
-            }
-        } catch( Throwable unused ) {
-             // getContextClassLoader() undefined in JDK1.1
-        }
-
-        if( classLoader==ClassLoader.getSystemClassLoader() ) {
-            debugPrintln("using system class loader ("+classLoader+") for search");
-            return;
-        }
-
-        debugPrintln("using class loader ("+classLoader+") for search");
-    }
-
-    /**
-     * <p>Creates a new {@link javax.xml.xpath.XPathFactory} object for the specified
-     * object model.</p>
-     *
-     * @param uri
-     *       Identifies the underlying object model.
-     *
-     * @return <code>null</code> if the callee fails to create one.
-     *
-     * @throws NullPointerException
-     *      If the parameter is null.
-     */
-    public javax.xml.xpath.XPathFactory newFactory(String uri) throws javax.xml.xpath.XPathFactoryConfigurationException {
-        if (uri == null) {
-            throw new NullPointerException();
-        }
-        javax.xml.xpath.XPathFactory f = _newFactory(uri);
-        if (f != null) {
-            debugPrintln("factory '" + f.getClass().getName() + "' was found for " + uri);
-        } else {
-            debugPrintln("unable to find a factory for " + uri);
-        }
-        return f;
-    }
-
-    /**
-     * <p>Lookup a {@link javax.xml.xpath.XPathFactory} for the given object model.</p>
-     *
-     * @param uri identifies the object model.
-     *
-     * @return {@link javax.xml.xpath.XPathFactory} for the given object model.
-     */
-    private javax.xml.xpath.XPathFactory _newFactory(String uri) throws javax.xml.xpath.XPathFactoryConfigurationException {
-        javax.xml.xpath.XPathFactory xpathFactory = null;
-
-        String propertyName = SERVICE_CLASS.getName() + ":" + uri;
-
-        // system property look up
-        try {
-            debugPrintln("Looking up system property '"+propertyName+"'" );
-            String r = ss.getSystemProperty(propertyName);
-            if(r!=null) {
-                debugPrintln("The value is '"+r+"'");
-                xpathFactory = createInstance(r, true);
-                if (xpathFactory != null) {
-                    return xpathFactory;
-                }
-            } else
-                debugPrintln("The property is undefined.");
-        } catch( Throwable t ) {
-            if( debug ) {
-                debugPrintln("failed to look up system property '"+propertyName+"'" );
-                t.printStackTrace();
-            }
-        }
-
-        String javah = ss.getSystemProperty( "java.home" );
-        String configFile = javah + File.separator +
-        "lib" + File.separator + "jaxp.properties";
-
-        // try to read from $java.home/lib/jaxp.properties
-        try {
-            if(firstTime){
-                synchronized(cacheProps){
-                    if(firstTime){
-                        File f=new File( configFile );
-                        firstTime = false;
-                        if(ss.doesFileExist(f)){
-                            debugPrintln("Read properties file " + f);
-                            cacheProps.load(ss.getFileInputStream(f));
-                        }
-                    }
-                }
-            }
-            final String factoryClassName = cacheProps.getProperty(propertyName);
-            debugPrintln("found " + factoryClassName + " in $java.home/jaxp.properties");
-
-            if (factoryClassName != null) {
-                xpathFactory = createInstance(factoryClassName, true);
-                if(xpathFactory != null){
-                    return xpathFactory;
-                }
-            }
-        } catch (Exception ex) {
-            if (debug) {
-                ex.printStackTrace();
-            }
-        }
-
-        // Try with ServiceLoader
-        assert xpathFactory == null;
-        xpathFactory = findServiceProvider(uri);
-
-        // The following assertion should always be true.
-        // Uncomment it, recompile, and run with -ea in case of doubts:
-        // assert xpathFactory == null || xpathFactory.isObjectModelSupported(uri);
-
-        if (xpathFactory != null) {
-            return xpathFactory;
-        }
-
-        // platform default
-        if(uri.equals(javax.xml.xpath.XPathFactory.DEFAULT_OBJECT_MODEL_URI)) {
-            debugPrintln("attempting to use the platform default W3C DOM XPath lib");
-            return createInstance("com.sun.org.apache.xpath.internal.jaxp.XPathFactoryImpl", true);
-        }
-
-        debugPrintln("all things were tried, but none was found. bailing out.");
-        return null;
-    }
-
-    /** <p>Create class using appropriate ClassLoader.</p>
-     *
-     * @param className Name of class to create.
-     * @return Created class or <code>null</code>.
-     */
-    private Class<?> createClass(String className) {
-        Class clazz;
-        // make sure we have access to restricted packages
-        boolean internal = false;
-        if (System.getSecurityManager() != null) {
-            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
-                internal = true;
-            }
-        }
-
-        // use approprite ClassLoader
-        try {
-            if (classLoader != null && !internal) {
-                    clazz = Class.forName(className, false, classLoader);
-            } else {
-                    clazz = Class.forName(className);
-            }
-        } catch (Throwable t) {
-            if(debug) {
-                t.printStackTrace();
-            }
-            return null;
-        }
-
-        return clazz;
-    }
-
-    /**
-     * <p>Creates an instance of the specified and returns it.</p>
-     *
-     * @param className
-     *      fully qualified class name to be instantiated.
-     *
-     * @return null
-     *      if it fails. Error messages will be printed by this method.
-     */
-    javax.xml.xpath.XPathFactory createInstance(String className )
-            throws javax.xml.xpath.XPathFactoryConfigurationException
-    {
-        return createInstance( className, false );
-    }
-
-    javax.xml.xpath.XPathFactory createInstance(String className, boolean useServicesMechanism  )
-            throws javax.xml.xpath.XPathFactoryConfigurationException
-    {
-        javax.xml.xpath.XPathFactory xPathFactory = null;
-
-        debugPrintln("createInstance(" + className + ")");
-
-        // get Class from className
-        Class<?> clazz = createClass(className);
-        if (clazz == null) {
-            debugPrintln("failed to getClass(" + className + ")");
-            return null;
-        }
-        debugPrintln("loaded " + className + " from " + which(clazz));
-
-        // instantiate Class as a XPathFactory
-        try {
-            if (!useServicesMechanism) {
-                xPathFactory = newInstanceNoServiceLoader(clazz);
-            }
-            if (xPathFactory == null) {
-                xPathFactory = (javax.xml.xpath.XPathFactory) clazz.newInstance();
-            }
-        } catch (ClassCastException classCastException) {
-                debugPrintln("could not instantiate " + clazz.getName());
-                if (debug) {
-                        classCastException.printStackTrace();
-                }
-                return null;
-        } catch (IllegalAccessException illegalAccessException) {
-                debugPrintln("could not instantiate " + clazz.getName());
-                if (debug) {
-                        illegalAccessException.printStackTrace();
-                }
-                return null;
-        } catch (InstantiationException instantiationException) {
-                debugPrintln("could not instantiate " + clazz.getName());
-                if (debug) {
-                        instantiationException.printStackTrace();
-                }
-                return null;
-        }
-
-        return xPathFactory;
-    }
-    /**
-     * Try to construct using newXPathFactoryNoServiceLoader
-     *   method if available.
-     */
-    private static javax.xml.xpath.XPathFactory newInstanceNoServiceLoader(
-         Class<?> providerClass
-    ) throws javax.xml.xpath.XPathFactoryConfigurationException {
-        // Retain maximum compatibility if no security manager.
-        if (System.getSecurityManager() == null) {
-            return null;
-        }
-        try {
-            Method creationMethod =
-                    providerClass.getDeclaredMethod(
-                        "newXPathFactoryNoServiceLoader"
-                    );
-            final int modifiers = creationMethod.getModifiers();
-
-            // Do not call "newXPathFactoryNoServiceLoader" if it's
-            // not public static.
-            if (!Modifier.isStatic(modifiers) || !Modifier.isPublic(modifiers)) {
-                return null;
-            }
-
-            // Only calls "newXPathFactoryNoServiceLoader" if it's
-            // declared to return an instance of XPathFactory.
-            final Class<?> returnType = creationMethod.getReturnType();
-            if (SERVICE_CLASS.isAssignableFrom(returnType)) {
-                return SERVICE_CLASS.cast(creationMethod.invoke(null, (Object[])null));
-            } else {
-                // Should not happen since
-                // XPathFactoryImpl.newXPathFactoryNoServiceLoader is
-                // declared to return XPathFactory.
-                throw new ClassCastException(returnType
-                            + " cannot be cast to " + SERVICE_CLASS);
-            }
-        } catch (ClassCastException e) {
-            throw new javax.xml.xpath.XPathFactoryConfigurationException(e);
-        } catch (NoSuchMethodException exc) {
-            return null;
-        } catch (Exception exc) {
-            return null;
-        }
-    }
-
-    // Call isObjectModelSupportedBy with initial context.
-    private boolean isObjectModelSupportedBy(final javax.xml.xpath.XPathFactory factory,
-            final String objectModel,
-            AccessControlContext acc) {
-        return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
-                    public Boolean run() {
-                        return factory.isObjectModelSupported(objectModel);
-                    }
-                }, acc);
-    }
-
-    /**
-     * Finds a service provider subclass of XPathFactory that supports the
-     * given object model using the ServiceLoader.
-     *
-     * @param objectModel URI of object model to support.
-     * @return An XPathFactory supporting the specified object model, or null
-     *         if none is found.
-     * @throws javax.xml.xpath.XPathFactoryConfigurationException if a configuration error is found.
-     */
-    private javax.xml.xpath.XPathFactory findServiceProvider(final String objectModel)
-            throws javax.xml.xpath.XPathFactoryConfigurationException {
-
-        assert objectModel != null;
-        // store current context.
-        final AccessControlContext acc = AccessController.getContext();
-        try {
-            return AccessController.doPrivileged(new PrivilegedAction<javax.xml.xpath.XPathFactory>() {
-                public javax.xml.xpath.XPathFactory run() {
-                    final ServiceLoader<javax.xml.xpath.XPathFactory> loader =
-                            ServiceLoader.load(SERVICE_CLASS);
-                    for (javax.xml.xpath.XPathFactory factory : loader) {
-                        // restore initial context to call
-                        // factory.isObjectModelSupportedBy
-                        if (isObjectModelSupportedBy(factory, objectModel, acc)) {
-                            return factory;
-                        }
-                    }
-                    return null; // no factory found.
-                }
-            });
-        } catch (ServiceConfigurationError error) {
-            throw new XPathFactoryConfigurationException(error);
-        }
-    }
-
-    private static final Class<javax.xml.xpath.XPathFactory> SERVICE_CLASS = XPathFactory.class;
-
-    private static String which( Class clazz ) {
-        return which( clazz.getName(), clazz.getClassLoader() );
-    }
-
-    /**
-     * <p>Search the specified classloader for the given classname.</p>
-     *
-     * @param classname the fully qualified name of the class to search for
-     * @param loader the classloader to search
-     *
-     * @return the source location of the resource, or null if it wasn't found
-     */
-    private static String which(String classname, ClassLoader loader) {
-
-        String classnameAsResource = classname.replace('.', '/') + ".class";
-
-        if( loader==null )  loader = ClassLoader.getSystemClassLoader();
-
-        //URL it = loader.getResource(classnameAsResource);
-        URL it = ss.getResourceAsURL(loader, classnameAsResource);
-        if (it != null) {
-            return it.toString();
-        } else {
-            return null;
-        }
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionResolver.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionResolver.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionResolver.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionResolver.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import javax.xml.namespace.QName;
-
-/**
- * <p><code>XPathFunctionResolver</code> provides access to the set of user defined <code>XPathFunction</code>s.</p>
- *
- * <p>XPath functions are resolved by name and arity.
- * The resolver is not needed for XPath built-in functions and the resolver
- * <strong><em>cannot</em></strong> be used to override those functions.</p>
- *
- * <p>In particular, the resolver is only called for functions in an another
- * namespace (functions with an explicit prefix). This means that you cannot
- * use the <code>XPathFunctionResolver</code> to implement specifications
- * like <a href="http://www.w3.org/TR/xmldsig-core/">XML-Signature Syntax
- * and Processing</a> which extend the function library of XPath 1.0 in the
- * same namespace. This is a consequence of the design of the resolver.</p>
- *
- * <p>If you wish to implement additional built-in functions, you will have to
- * extend the underlying implementation directly.</p>
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @see <a href="http://www.w3.org/TR/xpath#corelib">XML Path Language (XPath) Version 1.0, Core Function Library</a>
- * @since 1.5
- */
-public interface XPathFunctionResolver {
-  /**
-   * <p>Find a function in the set of available functions.</p>
-   *
-   * <p>If <code>functionName</code> or <code>arity</code> is <code>null</code>, then a <code>NullPointerException</code> is thrown.</p>
-   *
-   * @param functionName The function name.
-   * @param arity The number of arguments that the returned function must accept.
-   *
-   * @return The function or <code>null</code> if no function named <code>functionName</code> with <code>arity</code> arguments exists.
-   *
-   * @throws NullPointerException If <code>functionName</code> or <code>arity</code> is <code>null</code>.
-   */
-  public XPathFunction resolveFunction(QName functionName, int arity);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathVariableResolver.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathVariableResolver.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathVariableResolver.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathVariableResolver.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,58 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-import javax.xml.namespace.QName;
-
-/**
- * <p><code>XPathVariableResolver</code> provides access to the set of user defined XPath variables.</p>
- *
- * <p>The <code>XPathVariableResolver</code> and the XPath evaluator must adhere to a contract that
- * cannot be directly enforced by the API.  Although variables may be mutable,
- * that is, an application may wish to evaluate the same XPath expression more
- * than once with different variable values, in the course of evaluating any
- * single XPath expression, a variable's value <strong><em>must</em></strong>
- * not change.</p>
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @since 1.5
- */
-public interface XPathVariableResolver {
-  /**
-   * <p>Find a variable in the set of available variables.</p>
-   *
-   * <p>If <code>variableName</code> is <code>null</code>, then a <code>NullPointerException</code> is thrown.</p>
-   *
-   * @param variableName The <code>QName</code> of the variable name.
-   *
-   * @return The variables value, or <code>null</code> if no variable named <code>variableName</code>
-   *   exists.  The value returned must be of a type appropriate for the underlying object model.
-   *
-   * @throws NullPointerException If <code>variableName</code> is <code>null</code>.
-   */
-  public Object resolveVariable(QName variableName);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionException.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFunctionException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-/**
- * <code>XPathFunctionException</code> represents an error with an XPath function.</p>
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @since 1.5
- */
-public class XPathFunctionException extends XPathExpressionException {
-
-    /**
-     * <p>Stream Unique Identifier.</p>
-     */
-    private static final long serialVersionUID = -1837080260374986980L;
-
-    /**
-     * <p>Constructs a new <code>XPathFunctionException</code> with the specified detail <code>message</code>.</p>
-     *
-     * <p>The <code>cause</code> is not initialized.</p>
-     *
-     * <p>If <code>message</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param message The detail message.
-     *
-     * @throws NullPointerException When <code>message</code> is
-     *   <code>null</code>.
-     */
-    public XPathFunctionException(String message) {
-        super(message);
-    }
-
-    /**
-     * <p>Constructs a new <code>XPathFunctionException</code> with the specified <code>cause</code>.</p>
-     *
-     * <p>If <code>cause</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param cause The cause.
-     *
-     * @throws NullPointerException if <code>cause</code> is <code>null</code>.
-     */
-    public XPathFunctionException(Throwable cause) {
-        super(cause);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpressionException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpressionException.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpressionException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathExpressionException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,74 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-/**
- * <code>XPathExpressionException</code> represents an error in an XPath expression.</p>
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @since 1.5
- */
-public class XPathExpressionException extends XPathException {
-
-    /**
-     * <p>Stream Unique Identifier.</p>
-     */
-    private static final long serialVersionUID = -1837080260374986980L;
-
-    /**
-     * <p>Constructs a new <code>XPathExpressionException</code>
-     * with the specified detail <code>message</code>.</p>
-     *
-     * <p>The <code>cause</code> is not initialized.</p>
-     *
-     * <p>If <code>message</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param message The detail message.
-     *
-     * @throws NullPointerException When <code>message</code> is
-     *   <code>null</code>.
-     */
-    public XPathExpressionException(String message) {
-        super(message);
-    }
-
-    /**
-     * <p>Constructs a new <code>XPathExpressionException</code>
-     * with the specified <code>cause</code>.</p>
-     *
-     * <p>If <code>cause</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param cause The cause.
-     *
-     * @throws NullPointerException if <code>cause</code> is <code>null</code>.
-     */
-    public XPathExpressionException(Throwable cause) {
-        super(cause);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryConfigurationException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryConfigurationException.java b/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryConfigurationException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/xpath/XPathFactoryConfigurationException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.xpath;
-
-/**
- * <code>XPathFactoryConfigurationException</code> represents a configuration error in a <code>XPathFactory</code> environment.</p>
- *
- * @author  <a href="mailto:Norman.Walsh@Sun.com">Norman Walsh</a>
- * @author  <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @since 1.5
- */
-public class XPathFactoryConfigurationException extends XPathException {
-
-    /**
-     * <p>Stream Unique Identifier.</p>
-     */
-    private static final long serialVersionUID = -1837080260374986980L;
-
-    /**
-     * <p>Constructs a new <code>XPathFactoryConfigurationException</code> with the specified detail <code>message</code>.</p>
-     *
-     * <p>The <code>cause</code> is not initialized.</p>
-     *
-     * <p>If <code>message</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param message The detail message.
-     *
-     * @throws NullPointerException When <code>message</code> is
-     *   <code>null</code>.
-     */
-    public XPathFactoryConfigurationException(String message) {
-        super(message);
-    }
-
-    /**
-     * <p>Constructs a new <code>XPathFactoryConfigurationException</code>
-     * with the specified <code>cause</code>.</p>
-     *
-     * <p>If <code>cause</code> is <code>null</code>,
-     * then a <code>NullPointerException</code> is thrown.</p>
-     *
-     * @param cause The cause.
-     *
-     * @throws NullPointerException if <code>cause</code> is <code>null</code>.
-     */
-    public XPathFactoryConfigurationException(Throwable cause) {
-        super(cause);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventConsumer.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventConsumer.java b/Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventConsumer.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventConsumer.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,58 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.util;
-
-import javax.xml.stream.events.XMLEvent;
-import javax.xml.stream.XMLStreamException;
-
-/**
- * This interface defines an event consumer interface.  The contract of the
- * of a consumer is to accept the event.  This interface can be used to
- * mark an object as able to receive events.  Add may be called several
- * times in immediate succession so a consumer must be able to cache
- * events it hasn't processed yet.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface XMLEventConsumer {
-
-  /**
-   * This method adds an event to the consumer. Calling this method
-   * invalidates the event parameter. The client application should
-   * discard all references to this event upon calling add.
-   * The behavior of an application that continues to use such references
-   * is undefined.
-   *
-   * @param event the event to add, may not be null
-   */
-  public void add(XMLEvent event)
-    throws XMLStreamException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventAllocator.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventAllocator.java b/Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventAllocator.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/util/XMLEventAllocator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,84 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.util;
-
-import javax.xml.stream.XMLEventFactory;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.events.XMLEvent;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.XMLStreamException;
-
-/**
- * This interface defines a class that allows a user to register
- * a way to allocate events given an XMLStreamReader.  An implementation
- * is not required to use the XMLEventFactory implementation but this
- * is recommended.  The XMLEventAllocator can be set on an XMLInputFactory
- * using the property "javax.xml.stream.allocator"
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLInputFactory
- * @see XMLEventFactory
- * @since 1.6
- */
-public interface XMLEventAllocator {
-
-  /**
-   * This method creates an instance of the XMLEventAllocator. This
-   * allows the XMLInputFactory to allocate a new instance per reader.
-   */
-  public XMLEventAllocator newInstance();
-
-  /**
-   * This method allocates an event given the current
-   * state of the XMLStreamReader.  If this XMLEventAllocator
-   * does not have a one-to-one mapping between reader states
-   * and events this method will return null.  This method
-   * must not modify the state of the XMLStreamReader.
-   * @param reader The XMLStreamReader to allocate from
-   * @return the event corresponding to the current reader state
-   */
-  public XMLEvent allocate(XMLStreamReader reader)
-    throws XMLStreamException;
-
-  /**
-   * This method allocates an event or set of events
-   * given the current
-   * state of the XMLStreamReader and adds the event
-   * or set of events to the
-   * consumer that was passed in.  This method can be used
-   * to expand or contract reader states into event states.
-   * This method may modify the state of the XMLStreamReader.
-   * @param reader The XMLStreamReader to allocate from
-   * @param consumer The XMLEventConsumer to add to.
-   */
-  public void allocate(XMLStreamReader reader, XMLEventConsumer consumer)
-    throws XMLStreamException;
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/util/EventReaderDelegate.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/util/EventReaderDelegate.java b/Build/src/main/java/org/openjdk/javax/xml/stream/util/EventReaderDelegate.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/util/EventReaderDelegate.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,131 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.util;
-
-import javax.xml.stream.events.XMLEvent;
-import javax.xml.stream.XMLEventReader;
-import javax.xml.stream.XMLStreamException;
-
-/**
- * This is the base class for deriving an XMLEventReader
- * filter.
- *
- * This class is designed to sit between an XMLEventReader and an
- * application's XMLEventReader.  By default each method
- * does nothing but call the corresponding method on the
- * parent interface.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLEventReader
- * @see StreamReaderDelegate
- * @since 1.6
- */
-
-public class EventReaderDelegate implements XMLEventReader {
-  private XMLEventReader reader;
-
-  /**
-   * Construct an empty filter with no parent.
-   */
-  public EventReaderDelegate(){}
-
-  /**
-   * Construct an filter with the specified parent.
-   * @param reader the parent
-   */
-  public EventReaderDelegate(XMLEventReader reader) {
-    this.reader = reader;
-  }
-
-  /**
-   * Set the parent of this instance.
-   * @param reader the new parent
-   */
-  public void setParent(XMLEventReader reader) {
-    this.reader = reader;
-  }
-
-  /**
-   * Get the parent of this instance.
-   * @return the parent or null if none is set
-   */
-  public XMLEventReader getParent() {
-    return reader;
-  }
-
-  public XMLEvent nextEvent()
-    throws XMLStreamException
-  {
-    return reader.nextEvent();
-  }
-
-  public Object next() {
-    return reader.next();
-  }
-
-  public boolean hasNext()
-  {
-    return reader.hasNext();
-  }
-
-  public XMLEvent peek()
-    throws XMLStreamException
-  {
-    return reader.peek();
-  }
-
-  public void close()
-    throws XMLStreamException
-  {
-    reader.close();
-  }
-
-  public String getElementText()
-    throws XMLStreamException
-  {
-    return reader.getElementText();
-  }
-
-  public XMLEvent nextTag()
-    throws XMLStreamException
-  {
-    return reader.nextTag();
-  }
-
-  public Object getProperty(java.lang.String name)
-    throws java.lang.IllegalArgumentException
-  {
-    return reader.getProperty(name);
-  }
-
-  public void remove() {
-    reader.remove();
-  }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/util/StreamReaderDelegate.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/util/StreamReaderDelegate.java b/Build/src/main/java/org/openjdk/javax/xml/stream/util/StreamReaderDelegate.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/util/StreamReaderDelegate.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,286 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.util;
-
-import javax.xml.namespace.QName;
-import javax.xml.namespace.NamespaceContext;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.Location;
-import javax.xml.stream.XMLStreamException;
-
-/**
- * This is the base class for deriving an XMLStreamReader filter
- *
- * This class is designed to sit between an XMLStreamReader and an
- * application's XMLStreamReader.   By default each method
- * does nothing but call the corresponding method on the
- * parent interface.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLStreamReader
- * @see EventReaderDelegate
- * @since 1.6
- */
-
-public class StreamReaderDelegate implements XMLStreamReader {
-  private XMLStreamReader reader;
-
-  /**
-   * Construct an empty filter with no parent.
-   */
-  public StreamReaderDelegate(){}
-
-  /**
-   * Construct an filter with the specified parent.
-   * @param reader the parent
-   */
-  public StreamReaderDelegate(XMLStreamReader reader) {
-    this.reader = reader;
-  }
-
-  /**
-   * Set the parent of this instance.
-   * @param reader the new parent
-   */
-  public void setParent(XMLStreamReader reader) {
-    this.reader = reader;
-  }
-
-  /**
-   * Get the parent of this instance.
-   * @return the parent or null if none is set
-   */
-  public XMLStreamReader getParent() {
-    return reader;
-  }
-
-  public int next()
-    throws XMLStreamException
-  {
-    return reader.next();
-  }
-
-  public int nextTag()
-    throws XMLStreamException
-  {
-    return reader.nextTag();
-  }
-
-  public String getElementText()
-    throws XMLStreamException
-  {
-    return reader.getElementText();
-  }
-
-  public void require(int type, String namespaceURI, String localName)
-    throws XMLStreamException
-  {
-    reader.require(type,namespaceURI,localName);
-  }
-
-  public boolean hasNext()
-    throws XMLStreamException
-  {
-    return reader.hasNext();
-  }
-
-  public void close()
-    throws XMLStreamException
-  {
-    reader.close();
-  }
-
-  public String getNamespaceURI(String prefix)
-  {
-    return reader.getNamespaceURI(prefix);
-  }
-
-  public NamespaceContext getNamespaceContext() {
-    return reader.getNamespaceContext();
-  }
-
-  public boolean isStartElement() {
-    return reader.isStartElement();
-  }
-
-  public boolean isEndElement() {
-    return reader.isEndElement();
-  }
-
-  public boolean isCharacters() {
-    return reader.isCharacters();
-  }
-
-  public boolean isWhiteSpace() {
-    return reader.isWhiteSpace();
-  }
-
-  public String getAttributeValue(String namespaceUri,
-                                  String localName)
-  {
-    return reader.getAttributeValue(namespaceUri,localName);
-  }
-
-  public int getAttributeCount() {
-    return reader.getAttributeCount();
-  }
-
-  public QName getAttributeName(int index) {
-    return reader.getAttributeName(index);
-  }
-
-  public String getAttributePrefix(int index) {
-    return reader.getAttributePrefix(index);
-  }
-
-  public String getAttributeNamespace(int index) {
-    return reader.getAttributeNamespace(index);
-  }
-
-  public String getAttributeLocalName(int index) {
-    return reader.getAttributeLocalName(index);
-  }
-
-  public String getAttributeType(int index) {
-    return reader.getAttributeType(index);
-  }
-
-  public String getAttributeValue(int index) {
-    return reader.getAttributeValue(index);
-  }
-
-  public boolean isAttributeSpecified(int index) {
-    return reader.isAttributeSpecified(index);
-  }
-
-  public int getNamespaceCount() {
-    return reader.getNamespaceCount();
-  }
-
-  public String getNamespacePrefix(int index) {
-    return reader.getNamespacePrefix(index);
-  }
-
-  public String getNamespaceURI(int index) {
-    return reader.getNamespaceURI(index);
-  }
-
-  public int getEventType() {
-    return reader.getEventType();
-  }
-
-  public String getText() {
-    return reader.getText();
-  }
-
-  public int getTextCharacters(int sourceStart,
-                               char[] target,
-                               int targetStart,
-                               int length)
-    throws XMLStreamException {
-    return reader.getTextCharacters(sourceStart,
-                                    target,
-                                    targetStart,
-                                    length);
-  }
-
-
-  public char[] getTextCharacters() {
-    return reader.getTextCharacters();
-  }
-
-  public int getTextStart() {
-    return reader.getTextStart();
-  }
-
-  public int getTextLength() {
-    return reader.getTextLength();
-  }
-
-  public String getEncoding() {
-    return reader.getEncoding();
-  }
-
-  public boolean hasText() {
-    return reader.hasText();
-  }
-
-  public Location getLocation() {
-    return reader.getLocation();
-  }
-
-  public QName getName() {
-    return reader.getName();
-  }
-
-  public String getLocalName() {
-    return reader.getLocalName();
-  }
-
-  public boolean hasName() {
-    return reader.hasName();
-  }
-
-  public String getNamespaceURI() {
-    return reader.getNamespaceURI();
-  }
-
-  public String getPrefix() {
-    return reader.getPrefix();
-  }
-
-  public String getVersion() {
-    return reader.getVersion();
-  }
-
-  public boolean isStandalone() {
-    return reader.isStandalone();
-  }
-
-  public boolean standaloneSet() {
-    return reader.standaloneSet();
-  }
-
-  public String getCharacterEncodingScheme() {
-    return reader.getCharacterEncodingScheme();
-  }
-
-  public String getPITarget() {
-    return reader.getPITarget();
-  }
-
-  public String getPIData() {
-    return reader.getPIData();
-  }
-
-  public Object getProperty(String name) {
-    return reader.getProperty(name);
-  }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/DTD.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/DTD.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/DTD.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/DTD.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,74 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-import java.util.List;
-
-/**
- * This is the top level interface for events dealing with DTDs
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface DTD extends XMLEvent {
-
-  /**
-   * Returns the entire Document Type Declaration as a string, including
-   * the internal DTD subset.
-   * This may be null if there is not an internal subset.
-   * If it is not null it must return the entire
-   * Document Type Declaration which matches the doctypedecl
-   * production in the XML 1.0 specification
-   */
-  String getDocumentTypeDeclaration();
-
-  /**
-   * Returns an implementation defined representation of the DTD.
-   * This method may return null if no representation is available.
-   */
-  Object getProcessedDTD();
-
-  /**
-   * Return a List containing the notations declared in the DTD.
-   * This list must contain NotationDeclaration events.
-   * @see NotationDeclaration
-   * @return an unordered list of NotationDeclaration events
-   */
-  List getNotations();
-
-  /**
-   * Return a List containing the general entities,
-   * both external and internal, declared in the DTD.
-   * This list must contain EntityDeclaration events.
-   * @see EntityDeclaration
-   * @return an unordered list of EntityDeclaration events
-   */
-  List getEntities();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/Comment.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Comment.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/Comment.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Comment.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,45 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-/**
- * An interface for comment events
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface Comment extends XMLEvent {
-
-  /**
-   * Return the string data of the comment, returns empty string if it
-   * does not exist
-   */
-  public String getText();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/XMLEvent.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/XMLEvent.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/XMLEvent.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/XMLEvent.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,183 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-import java.io.Writer;
-import javax.xml.namespace.QName;
-import javax.xml.stream.Location;
-import javax.xml.stream.XMLEventReader;
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-
-/**
- * This is the base event interface for handling markup events.
- * Events are value objects that are used to communicate the
- * XML 1.0 InfoSet to the Application.  Events may be cached
- * and referenced after the parse has completed.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLEventReader
- * @see Characters
- * @see ProcessingInstruction
- * @see StartElement
- * @see EndElement
- * @see StartDocument
- * @see EndDocument
- * @see EntityReference
- * @see EntityDeclaration
- * @see NotationDeclaration
- * @since 1.6
- */
-public interface XMLEvent extends XMLStreamConstants {
-
-  /**
-   * Returns an integer code for this event.
-   * @see #START_ELEMENT
-   * @see #END_ELEMENT
-   * @see #CHARACTERS
-   * @see #ATTRIBUTE
-   * @see #NAMESPACE
-   * @see #PROCESSING_INSTRUCTION
-   * @see #COMMENT
-   * @see #START_DOCUMENT
-   * @see #END_DOCUMENT
-   * @see #DTD
-   */
-  public int getEventType();
-
-  /**
-   * Return the location of this event.  The Location
-   * returned from this method is non-volatile and
-   * will retain its information.
-   * @see Location
-   */
-  Location getLocation();
-
-  /**
-   * A utility function to check if this event is a StartElement.
-   * @see StartElement
-   */
-  public boolean isStartElement();
-
-  /**
-   * A utility function to check if this event is an Attribute.
-   * @see Attribute
-   */
-  public boolean isAttribute();
-
-  /**
-   * A utility function to check if this event is a Namespace.
-   * @see Namespace
-   */
-  public boolean isNamespace();
-
-
-  /**
-   * A utility function to check if this event is a EndElement.
-   * @see EndElement
-   */
-  public boolean isEndElement();
-
-  /**
-   * A utility function to check if this event is an EntityReference.
-   * @see EntityReference
-   */
-  public boolean isEntityReference();
-
-  /**
-   * A utility function to check if this event is a ProcessingInstruction.
-   * @see ProcessingInstruction
-   */
-  public boolean isProcessingInstruction();
-
-  /**
-   * A utility function to check if this event is Characters.
-   * @see Characters
-   */
-  public boolean isCharacters();
-
-  /**
-   * A utility function to check if this event is a StartDocument.
-   * @see StartDocument
-   */
-  public boolean isStartDocument();
-
-  /**
-   * A utility function to check if this event is an EndDocument.
-   * @see EndDocument
-   */
-  public boolean isEndDocument();
-
-  /**
-   * Returns this event as a start element event, may result in
-   * a class cast exception if this event is not a start element.
-   */
-  public StartElement asStartElement();
-
-  /**
-   * Returns this event as an end  element event, may result in
-   * a class cast exception if this event is not a end element.
-   */
-  public EndElement asEndElement();
-
-  /**
-   * Returns this event as Characters, may result in
-   * a class cast exception if this event is not Characters.
-   */
-  public Characters asCharacters();
-
-  /**
-   * This method is provided for implementations to provide
-   * optional type information about the associated event.
-   * It is optional and will return null if no information
-   * is available.
-   */
-  public QName getSchemaType();
-
-  /**
-   * This method will write the XMLEvent as per the XML 1.0 specification as Unicode characters.
-   * No indentation or whitespace should be outputted.
-   *
-   * Any user defined event type SHALL have this method
-   * called when being written to on an output stream.
-   * Built in Event types MUST implement this method,
-   * but implementations MAY choose not call these methods
-   * for optimizations reasons when writing out built in
-   * Events to an output stream.
-   * The output generated MUST be equivalent in terms of the
-   * infoset expressed.
-   *
-   * @param writer The writer that will output the data
-   * @throws XMLStreamException if there is a fatal error writing the event
-   */
-  public void writeAsEncodedUnicode(Writer writer)
-    throws XMLStreamException;
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/Attribute.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Attribute.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/Attribute.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Attribute.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,69 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-import javax.xml.namespace.QName;
-
-/**
- * An interface that contains information about an attribute.  Attributes are reported
- * as a set of events accessible from a StartElement.  Other applications may report
- * Attributes as first-order events, for example as the results of an XPath expression.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see StartElement
- * @since 1.6
- */
-public interface Attribute extends XMLEvent {
-
-  /**
-   * Returns the QName for this attribute
-   */
-  QName getName();
-
-  /**
-   * Gets the normalized value of this attribute
-   */
-  public String getValue();
-
-  /**
-   * Gets the type of this attribute, default is
-   * the String "CDATA"
-   * @return the type as a String, default is "CDATA"
-   */
-  public String getDTDType();
-
-  /**
-   * A flag indicating whether this attribute was actually
-   * specified in the start-tag of its element, or was defaulted from the schema.
-   * @return returns true if this was specified in the start element
-   */
-  public boolean isSpecified();
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/Namespace.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Namespace.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/Namespace.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Namespace.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,57 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-/**
- * An interface that contains information about a namespace.
- * Namespaces are accessed from a StartElement.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see StartElement
- * @since 1.6
- */
-public interface Namespace extends Attribute {
-
-  /**
-   * Gets the prefix, returns "" if this is a default
-   * namespace declaration.
-   */
-  public String getPrefix();
-
-  /**
-   * Gets the uri bound to the prefix of this namespace
-   */
-  public String getNamespaceURI();
-
-  /**
-   * returns true if this attribute declares the default namespace
-   */
-  public boolean isDefaultNamespaceDeclaration();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/Characters.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Characters.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/Characters.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/Characters.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,76 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-/**
- * This describes the interface to Characters events.
- * All text events get reported as Characters events.
- * Content, CData and whitespace are all reported as
- * Characters events.  IgnorableWhitespace, in most cases,
- * will be set to false unless an element declaration of element
- * content is present for the current element.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface Characters extends XMLEvent {
-  /**
-   * Get the character data of this event
-   */
-  public String getData();
-
-  /**
-   * Returns true if this set of Characters
-   * is all whitespace.  Whitespace inside a document
-   * is reported as CHARACTERS.  This method allows
-   * checking of CHARACTERS events to see if they
-   * are composed of only whitespace characters
-   */
-  public boolean isWhiteSpace();
-
-  /**
-   * Returns true if this is a CData section.  If this
-   * event is CData its event type will be CDATA
-   *
-   * If javax.xml.stream.isCoalescing is set to true CDATA Sections
-   * that are surrounded by non CDATA characters will be reported
-   * as a single Characters event. This method will return false
-   * in this case.
-   */
-  public boolean isCData();
-
-  /**
-   * Return true if this is ignorableWhiteSpace.  If
-   * this event is ignorableWhiteSpace its event type will
-   * be SPACE.
-   */
-  public boolean isIgnorableWhiteSpace();
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/EndElement.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EndElement.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/EndElement.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EndElement.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,59 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-import java.util.Iterator;
-import javax.xml.namespace.QName;
-/**
- * An interface for the end element event.  An EndElement is reported
- * for each End Tag in the document.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLEvent
- * @since 1.6
- */
-public interface EndElement extends XMLEvent {
-
-  /**
-   * Get the name of this event
-   * @return the qualified name of this event
-   */
-  public QName getName();
-
-  /**
-   * Returns an Iterator of namespaces that have gone out
-   * of scope.  Returns an empty iterator if no namespaces have gone
-   * out of scope.
-   * @return an Iterator over Namespace interfaces, or an
-   * empty iterator
-   */
-  public Iterator getNamespaces();
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/EndDocument.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EndDocument.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/EndDocument.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EndDocument.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,42 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-/**
- * A marker interface for the end of the document
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface EndDocument extends XMLEvent {
-  /**
-   * No methods are defined in this interface.
-   */
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/StartElement.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/StartElement.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/StartElement.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/StartElement.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,116 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-
-import javax.xml.namespace.QName;
-import javax.xml.namespace.NamespaceContext;
-
-import java.util.Iterator;
-
-/**
- * The StartElement interface provides access to information about
- * start elements.  A StartElement is reported for each Start Tag
- * in the document.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface StartElement extends XMLEvent {
-
-  /**
-   * Get the name of this event
-   * @return the qualified name of this event
-   */
-  public QName getName();
-
-  /**
-   * Returns an Iterator of non-namespace declared attributes declared on
-   * this START_ELEMENT,
-   * returns an empty iterator if there are no attributes.  The
-   * iterator must contain only implementations of the javax.xml.stream.Attribute
-   * interface.   Attributes are fundamentally unordered and may not be reported
-   * in any order.
-   *
-   * @return a readonly Iterator over Attribute interfaces, or an
-   * empty iterator
-   */
-  public Iterator getAttributes();
-
-  /**
-   * Returns an Iterator of namespaces declared on this element.
-   * This Iterator does not contain previously declared namespaces
-   * unless they appear on the current START_ELEMENT.
-   * Therefore this list may contain redeclared namespaces and duplicate namespace
-   * declarations. Use the getNamespaceContext() method to get the
-   * current context of namespace declarations.
-   *
-   * <p>The iterator must contain only implementations of the
-   * javax.xml.stream.Namespace interface.
-   *
-   * <p>A Namespace isA Attribute.  One
-   * can iterate over a list of namespaces as a list of attributes.
-   * However this method returns only the list of namespaces
-   * declared on this START_ELEMENT and does not
-   * include the attributes declared on this START_ELEMENT.
-   *
-   * Returns an empty iterator if there are no namespaces.
-   *
-   * @return a readonly Iterator over Namespace interfaces, or an
-   * empty iterator
-   *
-   */
-  public Iterator getNamespaces();
-
-  /**
-   * Returns the attribute referred to by this name
-   * @param name the qname of the desired name
-   * @return the attribute corresponding to the name value or null
-   */
-  public Attribute getAttributeByName(QName name);
-
-  /**
-   * Gets a read-only namespace context. If no context is
-   * available this method will return an empty namespace context.
-   * The NamespaceContext contains information about all namespaces
-   * in scope for this StartElement.
-   *
-   * @return the current namespace context
-   */
-  public NamespaceContext getNamespaceContext();
-
-  /**
-   * Gets the value that the prefix is bound to in the
-   * context of this element.  Returns null if
-   * the prefix is not bound in this context
-   * @param prefix the prefix to lookup
-   * @return the uri bound to the prefix or null
-   */
-  public String getNamespaceURI(String prefix);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/StartDocument.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/StartDocument.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/StartDocument.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/StartDocument.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,74 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-/**
- * An interface for the start document event
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface StartDocument extends XMLEvent {
-
-  /**
-   * Returns the system ID of the XML data
-   * @return the system ID, defaults to ""
-   */
-  public String getSystemId();
-
-  /**
-   * Returns the encoding style of the XML data
-   * @return the character encoding, defaults to "UTF-8"
-   */
-  public String getCharacterEncodingScheme();
-
-  /**
-   * Returns true if CharacterEncodingScheme was set in
-   * the encoding declaration of the document
-   */
-  public boolean encodingSet();
-
-  /**
-   * Returns if this XML is standalone
-   * @return the standalone state of XML, defaults to "no"
-   */
-  public boolean isStandalone();
-
-  /**
-   * Returns true if the standalone attribute was set in
-   * the encoding declaration of the document.
-   */
-  public boolean standaloneSet();
-
-  /**
-   * Returns the version of XML of this XML stream
-   * @return the version of XML, defaults to "1.0"
-   */
-  public String getVersion();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityReference.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityReference.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityReference.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityReference.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,62 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-/**
- * An interface for handling Entity events.
- *
- * This event reports entities that have not been resolved
- * and reports their replacement text unprocessed (if
- * available).  This event will be reported if javax.xml.stream.isReplacingEntityReferences
- * is set to false.  If javax.xml.stream.isReplacingEntityReferences is set to true
- * entity references will be resolved transparently.
- *
- * Entities are handled in two possible ways:
- *
- * (1) If javax.xml.stream.isReplacingEntityReferences is set to true
- * all entity references are resolved and reported as markup transparently.
- * (2) If javax.xml.stream.isReplacingEntityReferences is set to false
- * Entity references are reported as an EntityReference Event.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface EntityReference extends XMLEvent {
-
-  /**
-   * Return the declaration of this entity.
-   */
-  EntityDeclaration getDeclaration();
-
-  /**
-   * The name of the entity
-   * @return the entity's name, may not be null
-   */
-  String getName();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityDeclaration.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityDeclaration.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityDeclaration.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/EntityDeclaration.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,80 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-/**
- * An interface for handling Entity Declarations
- *
- * This interface is used to record and report unparsed entity declarations.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface EntityDeclaration extends XMLEvent {
-
-  /**
-   * The entity's public identifier, or null if none was given
-   * @return the public ID for this declaration or null
-   */
-  String getPublicId();
-
-  /**
-   * The entity's system identifier.
-   * @return the system ID for this declaration or null
-   */
-  String getSystemId();
-
-  /**
-   * The entity's name
-   * @return the name, may not be null
-   */
-  String getName();
-
-  /**
-   * The name of the associated notation.
-   * @return the notation name
-   */
-  String getNotationName();
-
-  /**
-   * The replacement text of the entity.
-   * This method will only return non-null
-   * if this is an internal entity.
-   * @return null or the replacment text
-   */
-  String getReplacementText();
-
-  /**
-   * Get the base URI for this reference
-   * or null if this information is not available
-   * @return the base URI or null
-   */
-  String getBaseURI();
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/NotationDeclaration.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/NotationDeclaration.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/NotationDeclaration.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/NotationDeclaration.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,58 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-/**
- * An interface for handling Notation Declarations
- *
- * Receive notification of a notation declaration event.
- * It is up to the application to record the notation for later reference,
- * At least one of publicId and systemId must be non-null.
- * There is no guarantee that the notation declaration
- * will be reported before any unparsed entities that use it.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface NotationDeclaration extends XMLEvent {
-  /**
-   * The notation name.
-   */
-  String getName();
-
-  /**
-   * The notation's public identifier, or null if none was given.
-   */
-  String getPublicId();
-
-  /**
-   * The notation's system identifier, or null if none was given.
-   */
-  String getSystemId();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/events/ProcessingInstruction.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/events/ProcessingInstruction.java b/Build/src/main/java/org/openjdk/javax/xml/stream/events/ProcessingInstruction.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/events/ProcessingInstruction.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,52 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream.events;
-/**
- * An interface that describes the data found in processing instructions
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface ProcessingInstruction extends XMLEvent {
-
-  /**
-   * The target section of the processing instruction
-   *
-   * @return the String value of the PI or null
-   */
-  public String getTarget();
-
-  /**
-   * The data section of the processing instruction
-   *
-   * @return the String value of the PI's data or null
-   */
-  public String getData();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/Location.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/Location.java b/Build/src/main/java/org/openjdk/javax/xml/stream/Location.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/Location.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,77 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-/**
- * Provides information on the location of an event.
- *
- * All the information provided by a Location is optional.  For example
- * an application may only report line numbers.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface Location {
-  /**
-   * Return the line number where the current event ends,
-   * returns -1 if none is available.
-   * @return the current line number
-   */
-  int getLineNumber();
-
-  /**
-   * Return the column number where the current event ends,
-   * returns -1 if none is available.
-   * @return the current column number
-   */
-  int getColumnNumber();
-
-  /**
-   * Return the byte or character offset into the input source this location
-   * is pointing to. If the input source is a file or a byte stream then
-   * this is the byte offset into that stream, but if the input source is
-   * a character media then the offset is the character offset.
-   * Returns -1 if there is no offset available.
-   * @return the current offset
-   */
-  int getCharacterOffset();
-
-  /**
-   * Returns the public ID of the XML
-   * @return the public ID, or null if not available
-   */
-  public String getPublicId();
-
-  /**
-   * Returns the system ID of the XML
-   * @return the system ID, or null if not available
-   */
-  public String getSystemId();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/EventFilter.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/EventFilter.java b/Build/src/main/java/org/openjdk/javax/xml/stream/EventFilter.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/EventFilter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,50 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-import javax.xml.stream.events.XMLEvent;
-
-/**
- * This interface declares a simple filter interface that one can
- * create to filter XMLEventReaders
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface EventFilter {
-  /**
-   * Tests whether this event is part of this stream.  This method
-   * will return true if this filter accepts this event and false
-   * otherwise.
-   *
-   * @param event the event to test
-   * @return true if this filter accepts this event, false otherwise
-   */
-  public boolean accept(XMLEvent event);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLReporter.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLReporter.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLReporter.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLReporter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,65 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-/**
- * This interface is used to report non-fatal errors.
- * Only warnings should be echoed through this interface.
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface XMLReporter {
-
-    /**
-
-     * Report the desired message in an application specific format.
-
-     * Only warnings and non-fatal errors should be reported through
-
-     * this interface.
-
-     * Fatal errors should be thrown as XMLStreamException.
-
-     *
-
-     * @param message the error message
-
-     * @param errorType an implementation defined error type
-
-     * @param relatedInformation information related to the error, if available
-
-     * @param location the location of the error, if available
-
-     * @throws XMLStreamException
-
-     */
-    public void report(String message, String errorType, Object relatedInformation, Location location)
-            throws XMLStreamException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLResolver.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLResolver.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLResolver.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLResolver.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,60 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-/**
- * This interface is used to resolve resources during an XML parse.  If an application wishes to
- * perform custom entity resolution it must register an instance of this interface with
- * the XMLInputFactory using the setXMLResolver method.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface XMLResolver {
-
-  /**
-   * Retrieves a resource.  This resource can be of the following three return types:
-   * (1) java.io.InputStream (2) javax.xml.stream.XMLStreamReader (3) java.xml.stream.XMLEventReader.
-   * If this method returns null the processor will attempt to resolve the entity using its
-   * default mechanism.
-   *
-   * @param publicID The public identifier of the external entity being referenced, or null if none was supplied.
-   * @param systemID The system identifier of the external entity being referenced.
-   * @param baseURI  Absolute base URI associated with systemId.
-   * @param namespace The namespace of the entity to resolve.
-   * @return The resource requested or null.
-   * @throws XMLStreamException if there was a failure attempting to resolve the resource.
-   */
-  public Object resolveEntity(String publicID,
-                              String systemID,
-                              String baseURI,
-                              String namespace)
-    throws XMLStreamException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/StreamFilter.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/StreamFilter.java b/Build/src/main/java/org/openjdk/javax/xml/stream/StreamFilter.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/StreamFilter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,51 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-/**
- * This interface declares a simple filter interface that one can
- * create to filter XMLStreamReaders
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public interface StreamFilter {
-
-  /**
-   * Tests whether the current state is part of this stream.  This method
-   * will return true if this filter accepts this event and false otherwise.
-   *
-   * The method should not change the state of the reader when accepting
-   * a state.
-   *
-   * @param reader the event to test
-   * @return true if this filter accepts this event, false otherwise
-   */
-  public boolean accept(XMLStreamReader reader);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/FactoryFinder.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/FactoryFinder.java b/Build/src/main/java/org/openjdk/javax/xml/stream/FactoryFinder.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/FactoryFinder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,375 +0,0 @@
-/*
- * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.stream;
-
-import java.io.File;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Iterator;
-import java.util.Properties;
-import java.util.ServiceConfigurationError;
-import java.util.ServiceLoader;
-
-/**
- * <p>Implements pluggable streams.</p>
- *
- * <p>This class is duplicated for each JAXP subpackage so keep it in
- * sync.  It is package private for secure class loading.</p>
- *
- * @author Santiago.PericasGeertsen@sun.com
- */
-class FactoryFinder {
-    // Check we have access to package.
-    private static final String DEFAULT_PACKAGE = "com.sun.xml.internal.";
-
-    /**
-     * Internal debug flag.
-     */
-    private static boolean debug = false;
-
-    /**
-     * Cache for properties in java.home/lib/jaxp.properties
-     */
-    final private static Properties cacheProps = new Properties();
-
-    /**
-     * Flag indicating if properties from java.home/lib/jaxp.properties
-     * have been cached.
-     */
-    private static volatile boolean firstTime = true;
-
-    /**
-     * Security support class use to check access control before
-     * getting certain system resources.
-     */
-    final private static SecuritySupport ss = new SecuritySupport();
-
-    // Define system property "jaxp.debug" to get output
-    static {
-        // Use try/catch block to support applets, which throws
-        // SecurityException out of this code.
-        try {
-            String val = ss.getSystemProperty("jaxp.debug");
-            // Allow simply setting the prop to turn on debug
-            debug = val != null && !"false".equals(val);
-        }
-        catch (SecurityException se) {
-            debug = false;
-        }
-    }
-
-    private static void dPrint(String msg) {
-        if (debug) {
-            System.err.println("JAXP: " + msg);
-        }
-    }
-
-    /**
-     * Attempt to load a class using the class loader supplied. If that fails
-     * and fall back is enabled, the current (i.e. bootstrap) class loader is
-     * tried.
-     *
-     * If the class loader supplied is <code>null</code>, first try using the
-     * context class loader followed by the current (i.e. bootstrap) class
-     * loader.
-     *
-     * Use bootstrap classLoader if cl = null and useBSClsLoader is true
-     */
-    static private Class getProviderClass(String className, ClassLoader cl,
-            boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException
-    {
-        try {
-            if (cl == null) {
-                if (useBSClsLoader) {
-                    return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-                } else {
-                    cl = ss.getContextClassLoader();
-                    if (cl == null) {
-                        throw new ClassNotFoundException();
-                    }
-                    else {
-                        return Class.forName(className, false, cl);
-                    }
-                }
-            }
-            else {
-                return Class.forName(className, false, cl);
-            }
-        }
-        catch (ClassNotFoundException e1) {
-            if (doFallback) {
-                // Use current class loader - should always be bootstrap CL
-                return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-            }
-            else {
-                throw e1;
-            }
-        }
-    }
-
-    /**
-     * Create an instance of a class. Delegates to method
-     * <code>getProviderClass()</code> in order to load the class.
-     *
-     * @param type Base class / Service interface  of the factory to
-     *             instantiate.
-     *
-     * @param className Name of the concrete class corresponding to the
-     * service provider
-     *
-     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     * current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @param doFallback True if the current ClassLoader should be tried as
-     * a fallback if the class is not found using cl
-     */
-    static <T> T newInstance(Class<T> type, String className, ClassLoader cl, boolean doFallback)
-        throws FactoryConfigurationError
-    {
-        return newInstance(type, className, cl, doFallback, false);
-    }
-
-    /**
-     * Create an instance of a class. Delegates to method
-     * <code>getProviderClass()</code> in order to load the class.
-     *
-     * @param type Base class / Service interface  of the factory to
-     *             instantiate.
-     *
-     * @param className Name of the concrete class corresponding to the
-     * service provider
-     *
-     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     * current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @param doFallback True if the current ClassLoader should be tried as
-     * a fallback if the class is not found using cl
-     *
-     * @param useBSClsLoader True if cl=null actually meant bootstrap classLoader. This parameter
-     * is needed since DocumentBuilderFactory/SAXParserFactory defined null as context classLoader.
-     */
-    static <T> T newInstance(Class<T> type, String className, ClassLoader cl,
-                              boolean doFallback, boolean useBSClsLoader)
-        throws FactoryConfigurationError
-    {
-        assert type != null;
-
-        // make sure we have access to restricted packages
-        if (System.getSecurityManager() != null) {
-            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
-                cl = null;
-                useBSClsLoader = true;
-            }
-        }
-
-        try {
-            Class<?> providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
-            if (!type.isAssignableFrom(providerClass)) {
-                throw new ClassCastException(className + " cannot be cast to " + type.getName());
-            }
-            Object instance = providerClass.newInstance();
-            if (debug) {    // Extra check to avoid computing cl strings
-                dPrint("created new instance of " + providerClass +
-                       " using ClassLoader: " + cl);
-            }
-            return type.cast(instance);
-        }
-        catch (ClassNotFoundException x) {
-            throw new FactoryConfigurationError(
-                "Provider " + className + " not found", x);
-        }
-        catch (Exception x) {
-            throw new FactoryConfigurationError(
-                "Provider " + className + " could not be instantiated: " + x,
-                x);
-        }
-    }
-
-    /**
-     * Finds the implementation Class object in the specified order.
-     *
-     * @return Class object of factory, never null
-     *
-     * @param type                  Base class / Service interface  of the
-     *                              factory to find.
-     *
-     * @param fallbackClassName     Implementation class name, if nothing else
-     *                              is found.  Use null to mean no fallback.
-     *
-     * Package private so this code can be shared.
-     */
-    static <T> T find(Class<T> type, String fallbackClassName)
-        throws FactoryConfigurationError
-    {
-        return find(type, type.getName(), null, fallbackClassName);
-    }
-
-    /**
-     * Finds the implementation Class object in the specified order.  Main
-     * entry point.
-     * @return Class object of factory, never null
-     *
-     * @param type                  Base class / Service interface  of the
-     *                              factory to find.
-     *
-     * @param factoryId             Name of the factory to find, same as
-     *                              a property name
-     *
-     * @param cl                    ClassLoader to be used to load the class, null means to use
-     * the bootstrap ClassLoader
-     *
-     * @param fallbackClassName     Implementation class name, if nothing else
-     *                              is found.  Use null to mean no fallback.
-     *
-     * Package private so this code can be shared.
-     */
-    static <T> T find(Class<T> type, String factoryId, ClassLoader cl, String fallbackClassName)
-        throws FactoryConfigurationError
-    {
-        dPrint("find factoryId =" + factoryId);
-
-        // Use the system property first
-        try {
-
-            final String systemProp;
-            if (type.getName().equals(factoryId)) {
-                systemProp = ss.getSystemProperty(factoryId);
-            } else {
-                systemProp = System.getProperty(factoryId);
-            }
-            if (systemProp != null) {
-                dPrint("found system property, value=" + systemProp);
-                return newInstance(type, systemProp, cl, true);
-            }
-        }
-        catch (SecurityException se) {
-            throw new FactoryConfigurationError(
-                    "Failed to read factoryId '" + factoryId + "'", se);
-        }
-
-        // Try read $java.home/lib/stax.properties followed by
-        // $java.home/lib/jaxp.properties if former not present
-        String configFile = null;
-        try {
-            if (firstTime) {
-                synchronized (cacheProps) {
-                    if (firstTime) {
-                        configFile = ss.getSystemProperty("java.home") + File.separator +
-                            "lib" + File.separator + "stax.properties";
-                        File f = new File(configFile);
-                        firstTime = false;
-                        if (ss.doesFileExist(f)) {
-                            dPrint("Read properties file "+f);
-                            cacheProps.load(ss.getFileInputStream(f));
-                        }
-                        else {
-                            configFile = ss.getSystemProperty("java.home") + File.separator +
-                                "lib" + File.separator + "jaxp.properties";
-                            f = new File(configFile);
-                            if (ss.doesFileExist(f)) {
-                                dPrint("Read properties file "+f);
-                                cacheProps.load(ss.getFileInputStream(f));
-                            }
-                        }
-                    }
-                }
-            }
-            final String factoryClassName = cacheProps.getProperty(factoryId);
-
-            if (factoryClassName != null) {
-                dPrint("found in " + configFile + " value=" + factoryClassName);
-                return newInstance(type, factoryClassName, cl, true);
-            }
-        }
-        catch (Exception ex) {
-            if (debug) ex.printStackTrace();
-        }
-
-        if (type.getName().equals(factoryId)) {
-            // Try Jar Service Provider Mechanism
-            final T provider = findServiceProvider(type, cl);
-            if (provider != null) {
-                return provider;
-            }
-        } else {
-            // We're in the case where a 'custom' factoryId was provided,
-            // and in every case where that happens, we expect that
-            // fallbackClassName will be null.
-            assert fallbackClassName == null;
-        }
-        if (fallbackClassName == null) {
-            throw new FactoryConfigurationError(
-                "Provider for " + factoryId + " cannot be found", null);
-        }
-
-        dPrint("loaded from fallback value: " + fallbackClassName);
-        return newInstance(type, fallbackClassName, cl, true);
-    }
-
-    /*
-     * Try to find provider using the ServiceLoader API
-     *
-     * @param type Base class / Service interface  of the factory to find.
-     *
-     * @return instance of provider class if found or null
-     */
-    private static <T> T findServiceProvider(final Class<T> type, final ClassLoader cl) {
-        try {
-            return AccessController.doPrivileged(new PrivilegedAction<T>() {
-                @Override
-                public T run() {
-                    final ServiceLoader<T> serviceLoader;
-                    if (cl == null) {
-                        //the current thread's context class loader
-                        serviceLoader = ServiceLoader.load(type);
-                    } else {
-                        serviceLoader = ServiceLoader.load(type, cl);
-                    }
-                    final Iterator<T> iterator = serviceLoader.iterator();
-                    if (iterator.hasNext()) {
-                        return iterator.next();
-                    } else {
-                        return null;
-                    }
-                }
-            });
-        } catch(ServiceConfigurationError e) {
-            // It is not possible to wrap an error directly in
-            // FactoryConfigurationError - so we need to wrap the
-            // ServiceConfigurationError in a RuntimeException.
-            // The alternative would be to modify the logic in
-            // FactoryConfigurationError to allow setting a
-            // Throwable as the cause, but that could cause
-            // compatibility issues down the road.
-            final RuntimeException x = new RuntimeException(
-                    "Provider for " + type + " cannot be created", e);
-            final FactoryConfigurationError error =
-                    new FactoryConfigurationError(x, x.getMessage());
-            throw error;
-          }
-      }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventReader.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventReader.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventReader.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventReader.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,106 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-import javax.xml.stream.events.XMLEvent;
-
-import java.util.Iterator;
-
-/**
- *
- * This is the top level interface for parsing XML Events.  It provides
- * the ability to peek at the next event and returns configuration
- * information through the property interface.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLInputFactory
- * @see XMLEventWriter
- * @since 1.6
- */
-public interface XMLEventReader extends Iterator {
-  /**
-   * Get the next XMLEvent
-   * @see XMLEvent
-   * @throws XMLStreamException if there is an error with the underlying XML.
-   * @throws NoSuchElementException iteration has no more elements.
-   */
-  public XMLEvent nextEvent() throws XMLStreamException;
-
-  /**
-   * Check if there are more events.
-   * Returns true if there are more events and false otherwise.
-   * @return true if the event reader has more events, false otherwise
-   */
-  public boolean hasNext();
-
-  /**
-   * Check the next XMLEvent without reading it from the stream.
-   * Returns null if the stream is at EOF or has no more XMLEvents.
-   * A call to peek() will be equal to the next return of next().
-   * @see XMLEvent
-   * @throws XMLStreamException
-   */
-  public XMLEvent peek() throws XMLStreamException;
-
-  /**
-   * Reads the content of a text-only element. Precondition:
-   * the current event is START_ELEMENT. Postcondition:
-   * The current event is the corresponding END_ELEMENT.
-   * @throws XMLStreamException if the current event is not a START_ELEMENT
-   * or if a non text element is encountered
-   */
-  public String getElementText() throws XMLStreamException;
-
-  /**
-   * Skips any insignificant space events until a START_ELEMENT or
-   * END_ELEMENT is reached. If anything other than space characters are
-   * encountered, an exception is thrown. This method should
-   * be used when processing element-only content because
-   * the parser is not able to recognize ignorable whitespace if
-   * the DTD is missing or not interpreted.
-   * @throws XMLStreamException if anything other than space characters are encountered
-   */
-  public XMLEvent nextTag() throws XMLStreamException;
-
-  /**
-   * Get the value of a feature/property from the underlying implementation
-   * @param name The name of the property
-   * @return The value of the property
-   * @throws IllegalArgumentException if the property is not supported
-   */
-  public Object getProperty(java.lang.String name) throws java.lang.IllegalArgumentException;
-
-  /**
-   * Frees any resources associated with this Reader.  This method does not close the
-   * underlying input source.
-   * @throws XMLStreamException if there are errors freeing associated resources
-   */
-  public void close() throws XMLStreamException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventWriter.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventWriter.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventWriter.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventWriter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,260 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-import javax.xml.stream.util.XMLEventConsumer;
-import javax.xml.namespace.NamespaceContext;
-import javax.xml.stream.events.Characters;
-import javax.xml.stream.events.EndElement;
-import javax.xml.stream.events.ProcessingInstruction;
-import javax.xml.stream.events.StartElement;
-import javax.xml.stream.events.XMLEvent;
-
-/**
- *
- * This is the top level interface for writing XML documents.
- *
- * Instances of this interface are not required to validate the
- * form of the XML.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLEventReader
- * @see XMLEvent
- * @see Characters
- * @see ProcessingInstruction
- * @see StartElement
- * @see EndElement
- * @since 1.6
- */
-public interface XMLEventWriter extends XMLEventConsumer {
-
-  /**
-   * Writes any cached events to the underlying output mechanism
-   * @throws XMLStreamException
-   */
-  public void flush() throws XMLStreamException;
-
-  /**
-   * Frees any resources associated with this stream
-   * @throws XMLStreamException
-   */
-  public void close() throws XMLStreamException;
-
-  /**
-   * Add an event to the output stream
-   * Adding a START_ELEMENT will open a new namespace scope that
-   * will be closed when the corresponding END_ELEMENT is written.
-   * <table border="2" rules="all" cellpadding="4">
-   *   <thead>
-   *     <tr>
-   *       <th align="center" colspan="2">
-   *         Required and optional fields for events added to the writer
-   *       </th>
-   *     </tr>
-   *   </thead>
-   *   <tbody>
-   *     <tr>
-   *       <th>Event Type</th>
-   *       <th>Required Fields</th>
-   *       <th>Optional Fields</th>
-   *       <th>Required Behavior</th>
-   *     </tr>
-   *     <tr>
-   *       <td> START_ELEMENT  </td>
-   *       <td> QName name </td>
-   *       <td> namespaces , attributes </td>
-   *       <td> A START_ELEMENT will be written by writing the name,
-   *       namespaces, and attributes of the event in XML 1.0 valid
-   *       syntax for START_ELEMENTs.
-   *       The name is written by looking up the prefix for
-   *       the namespace uri.  The writer can be configured to
-   *       respect prefixes of QNames.  If the writer is respecting
-   *       prefixes it must use the prefix set on the QName.  The
-   *       default behavior is to lookup the value for the prefix
-   *       on the EventWriter's internal namespace context.
-   *       Each attribute (if any)
-   *       is written using the behavior specified in the attribute
-   *       section of this table.  Each namespace (if any) is written
-   *       using the behavior specified in the namespace section of this
-   *       table.
-   *       </td>
-   *     </tr>
-   *     <tr>
-   *       <td> END_ELEMENT  </td>
-   *       <td> Qname name  </td>
-   *       <td> None </td>
-   *       <td> A well formed END_ELEMENT tag is written.
-   *       The name is written by looking up the prefix for
-   *       the namespace uri.  The writer can be configured to
-   *       respect prefixes of QNames.  If the writer is respecting
-   *       prefixes it must use the prefix set on the QName.  The
-   *       default behavior is to lookup the value for the prefix
-   *       on the EventWriter's internal namespace context.
-   *       If the END_ELEMENT name does not match the START_ELEMENT
-   *       name an XMLStreamException is thrown.
-   *       </td>
-   *     </tr>
-   *     <tr>
-   *       <td> ATTRIBUTE  </td>
-   *       <td> QName name , String value </td>
-   *       <td> QName type </td>
-   *       <td> An attribute is written using the same algorithm
-   *            to find the lexical form as used in START_ELEMENT.
-   *            The default is to use double quotes to wrap attribute
-   *            values and to escape any double quotes found in the
-   *            value.  The type value is ignored.
-   *       </td>
-   *     </tr>
-   *     <tr>
-   *       <td> NAMESPACE  </td>
-   *       <td> String prefix, String namespaceURI,
-   *            boolean isDefaultNamespaceDeclaration
-   *      </td>
-   *       <td> None  </td>
-   *       <td> A namespace declaration is written.  If the
-   *            namespace is a default namespace declaration
-   *            (isDefault is true) then xmlns="$namespaceURI"
-   *            is written and the prefix is optional.  If
-   *            isDefault is false, the prefix must be declared
-   *            and the writer must prepend xmlns to the prefix
-   *            and write out a standard prefix declaration.
-   *      </td>
-   *     </tr>
-   *     <tr>
-   *       <td> PROCESSING_INSTRUCTION  </td>
-   *       <td>   None</td>
-   *       <td>   String target, String data</td>
-   *       <td>   The data does not need to be present and may be
-   *              null.  Target is required and many not be null.
-   *              The writer
-   *              will write data section
-   *              directly after the target,
-   *              enclosed in appropriate XML 1.0 syntax
-   *      </td>
-   *     </tr>
-   *     <tr>
-   *       <td> COMMENT  </td>
-   *       <td> None  </td>
-   *       <td> String comment  </td>
-   *       <td> If the comment is present (not null) it is written, otherwise an
-   *            an empty comment is written
-   *      </td>
-   *     </tr>
-   *     <tr>
-   *       <td> START_DOCUMENT  </td>
-   *       <td> None  </td>
-   *       <td> String encoding , boolean standalone, String version  </td>
-   *       <td> A START_DOCUMENT event is not required to be written to the
-   *             stream.  If present the attributes are written inside
-   *             the appropriate XML declaration syntax
-   *      </td>
-   *     </tr>
-   *     <tr>
-   *       <td> END_DOCUMENT  </td>
-   *       <td> None </td>
-   *       <td> None  </td>
-   *       <td> Nothing is written to the output  </td>
-   *     </tr>
-   *     <tr>
-   *       <td> DTD  </td>
-   *       <td> String DocumentTypeDefinition  </td>
-   *       <td> None  </td>
-   *       <td> The DocumentTypeDefinition is written to the output  </td>
-   *     </tr>
-   *   </tbody>
-   * </table>
-   * @param event the event to be added
-   * @throws XMLStreamException
-   */
-  public void add(XMLEvent event) throws XMLStreamException;
-
-  /**
-   * Adds an entire stream to an output stream,
-   * calls next() on the inputStream argument until hasNext() returns false
-   * This should be treated as a convenience method that will
-   * perform the following loop over all the events in an
-   * event reader and call add on each event.
-   *
-   * @param reader the event stream to add to the output
-   * @throws XMLStreamException
-   */
-
-  public void add(XMLEventReader reader) throws XMLStreamException;
-
-  /**
-   * Gets the prefix the uri is bound to
-   * @param uri the uri to look up
-   * @throws XMLStreamException
-   */
-  public String getPrefix(String uri) throws XMLStreamException;
-
-  /**
-   * Sets the prefix the uri is bound to.  This prefix is bound
-   * in the scope of the current START_ELEMENT / END_ELEMENT pair.
-   * If this method is called before a START_ELEMENT has been written
-   * the prefix is bound in the root scope.
-   * @param prefix the prefix to bind to the uri
-   * @param uri the uri to bind to the prefix
-   * @throws XMLStreamException
-   */
-  public void setPrefix(String prefix, String uri) throws XMLStreamException;
-
-  /**
-   * Binds a URI to the default namespace
-   * This URI is bound
-   * in the scope of the current START_ELEMENT / END_ELEMENT pair.
-   * If this method is called before a START_ELEMENT has been written
-   * the uri is bound in the root scope.
-   * @param uri the uri to bind to the default namespace
-   * @throws XMLStreamException
-   */
-  public void setDefaultNamespace(String uri) throws XMLStreamException;
-
-  /**
-   * Sets the current namespace context for prefix and uri bindings.
-   * This context becomes the root namespace context for writing and
-   * will replace the current root namespace context.  Subsequent calls
-   * to setPrefix and setDefaultNamespace will bind namespaces using
-   * the context passed to the method as the root context for resolving
-   * namespaces.
-   * @param context the namespace context to use for this writer
-   * @throws XMLStreamException
-   */
-  public void setNamespaceContext(NamespaceContext context)
-    throws XMLStreamException;
-
-  /**
-   * Returns the current namespace context.
-   * @return the current namespace context
-   */
-  public NamespaceContext getNamespaceContext();
-
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/SecuritySupport.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/SecuritySupport.java b/Build/src/main/java/org/openjdk/javax/xml/stream/SecuritySupport.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/SecuritySupport.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.stream;
-
-import java.security.*;
-import java.net.*;
-import java.io.*;
-import java.util.*;
-
-/**
- * This class is duplicated for each JAXP subpackage so keep it in sync.
- * It is package private and therefore is not exposed as part of the JAXP
- * API.
- *
- * Security related methods that only work on J2SE 1.2 and newer.
- */
-class SecuritySupport  {
-
-
-    ClassLoader getContextClassLoader() throws SecurityException{
-        return (ClassLoader)
-                AccessController.doPrivileged(new PrivilegedAction() {
-            public Object run() {
-                ClassLoader cl = null;
-                //try {
-                cl = Thread.currentThread().getContextClassLoader();
-                //} catch (SecurityException ex) { }
-
-                if (cl == null)
-                    cl = ClassLoader.getSystemClassLoader();
-
-                return cl;
-            }
-        });
-    }
-
-    String getSystemProperty(final String propName) {
-        return (String)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(propName);
-                }
-            });
-    }
-
-    FileInputStream getFileInputStream(final File file)
-        throws FileNotFoundException
-    {
-        try {
-            return (FileInputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws FileNotFoundException {
-                        return new FileInputStream(file);
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (FileNotFoundException)e.getException();
-        }
-    }
-
-    InputStream getResourceAsStream(final ClassLoader cl,
-                                           final String name)
-    {
-        return (InputStream)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    InputStream ris;
-                    if (cl == null) {
-                        ris = Object.class.getResourceAsStream(name);
-                    } else {
-                        ris = cl.getResourceAsStream(name);
-                    }
-                    return ris;
-                }
-            });
-    }
-
-    boolean doesFileExist(final File f) {
-    return ((Boolean)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return new Boolean(f.exists());
-                }
-            })).booleanValue();
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventFactory.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLEventFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,475 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009, 2013, by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-import java.util.Iterator;
-import javax.xml.namespace.NamespaceContext;
-import javax.xml.namespace.QName;
-import javax.xml.stream.events.Attribute;
-import javax.xml.stream.events.Characters;
-import javax.xml.stream.events.Comment;
-import javax.xml.stream.events.DTD;
-import javax.xml.stream.events.EndDocument;
-import javax.xml.stream.events.EndElement;
-import javax.xml.stream.events.EntityDeclaration;
-import javax.xml.stream.events.EntityReference;
-import javax.xml.stream.events.Namespace;
-import javax.xml.stream.events.ProcessingInstruction;
-import javax.xml.stream.events.StartDocument;
-import javax.xml.stream.events.StartElement;
-
-/**
- * This interface defines a utility class for creating instances of
- * XMLEvents
- * @version 1.2
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see StartElement
- * @see EndElement
- * @see ProcessingInstruction
- * @see Comment
- * @see Characters
- * @see StartDocument
- * @see EndDocument
- * @see DTD
- * @since 1.6
- */
-public abstract class XMLEventFactory {
-  protected XMLEventFactory(){}
-
-    static final String JAXPFACTORYID = "javax.xml.stream.XMLEventFactory";
-    static final String DEFAULIMPL = "com.sun.xml.internal.stream.events.XMLEventFactoryImpl";
-
-
-  /**
-   * Creates a new instance of the factory in exactly the same manner as the
-   * {@link #newFactory()} method.
-   * @throws FactoryConfigurationError if an instance of this factory cannot be loaded
-   */
-  public static XMLEventFactory newInstance()
-    throws FactoryConfigurationError
-  {
-    return FactoryFinder.find(XMLEventFactory.class, DEFAULIMPL);
-  }
-
-  /**
-   * Create a new instance of the factory.
-   * <p>
-   * This static method creates a new factory instance.
-   * This method uses the following ordered lookup procedure to determine
-   * the XMLEventFactory implementation class to load:
-   * </p>
-   * <ul>
-   * <li>
-   *   Use the javax.xml.stream.XMLEventFactory system property.
-   * </li>
-   * <li>
-   *   Use the properties file "lib/stax.properties" in the JRE directory.
-   *     This configuration file is in standard java.util.Properties format
-   *     and contains the fully qualified name of the implementation class
-   *     with the key being the system property defined above.
-   * </li>
-   * <li>
-   *   Use the service-provider loading facilities, defined by the
-   *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-   *   implementation of the service using the {@linkplain
-   *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-   *   the service-provider loading facility will use the {@linkplain
-   *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-   *   to attempt to load the service. If the context class
-   *   loader is null, the {@linkplain
-   *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-   * </li>
-   * <li>
-   *   Otherwise, the system-default implementation is returned.
-   * </li>
-   * </ul>
-   * <p>
-   *   Once an application has obtained a reference to a XMLEventFactory it
-   *   can use the factory to configure and obtain stream instances.
-   * </p>
-   * <p>
-   *   Note that this is a new method that replaces the deprecated newInstance() method.
-   *     No changes in behavior are defined by this replacement method relative to
-   *     the deprecated method.
-   * </p>
-   * @throws FactoryConfigurationError in case of {@linkplain
-   *   java.util.ServiceConfigurationError service configuration error} or if
-   *   the implementation is not available or cannot be instantiated.
-   */
-  public static XMLEventFactory newFactory()
-    throws FactoryConfigurationError
-  {
-    return FactoryFinder.find(XMLEventFactory.class, DEFAULIMPL);
-  }
-
-  /**
-   * Create a new instance of the factory
-   *
-   * @param factoryId             Name of the factory to find, same as
-   *                              a property name
-   * @param classLoader           classLoader to use
-   * @return the factory implementation
-   * @throws FactoryConfigurationError if an instance of this factory cannot be loaded
-   *
-   * @deprecated  This method has been deprecated to maintain API consistency.
-   *              All newInstance methods have been replaced with corresponding
-   *              newFactory methods. The replacement {@link
-   *              #newFactory(java.lang.String, java.lang.ClassLoader)}
-   *              method defines no changes in behavior.
-   */
-  public static XMLEventFactory newInstance(String factoryId,
-          ClassLoader classLoader)
-          throws FactoryConfigurationError {
-      //do not fallback if given classloader can't find the class, throw exception
-      return FactoryFinder.find(XMLEventFactory.class, factoryId, classLoader, null);
-  }
-
-  /**
-   * Create a new instance of the factory.
-   * If the classLoader argument is null, then the ContextClassLoader is used.
-   * <p>
-   * This method uses the following ordered lookup procedure to determine
-   * the XMLEventFactory implementation class to load:
-   * </p>
-   * <ul>
-   * <li>
-   *   Use the value of the system property identified by {@code factoryId}.
-   * </li>
-   * <li>
-   *   Use the properties file "lib/stax.properties" in the JRE directory.
-   *     This configuration file is in standard java.util.Properties format
-   *     and contains the fully qualified name of the implementation class
-   *     with the key being the given {@code factoryId}.
-   * </li>
-   * <li>
-   *   If {@code factoryId} is "javax.xml.stream.XMLEventFactory",
-   *   use the service-provider loading facilities, defined by the
-   *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-   *   implementation of the service using the specified {@code ClassLoader}.
-   *   If {@code classLoader} is null, the {@linkplain
-   *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism} will apply:
-   *   That is, the service-provider loading facility will use the {@linkplain
-   *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-   *   to attempt to load the service. If the context class
-   *   loader is null, the {@linkplain
-   *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-   * </li>
-   * <li>
-   *   Otherwise, throws a {@link FactoryConfigurationError}.
-   * </li>
-   * </ul>
-   *
-   * <p>
-   * Note that this is a new method that replaces the deprecated
-   *   {@link #newInstance(java.lang.String, java.lang.ClassLoader)
-   *   newInstance(String factoryId, ClassLoader classLoader)} method.
-   * No changes in behavior are defined by this replacement method relative
-   * to the deprecated method.
-   * </p>
-   *
-   * @apiNote The parameter factoryId defined here is inconsistent with that
-   * of other JAXP factories where the first parameter is fully qualified
-   * factory class name that provides implementation of the factory.
-   *
-   * @param factoryId             Name of the factory to find, same as
-   *                              a property name
-   * @param classLoader           classLoader to use
-   * @return the factory implementation
-   * @throws FactoryConfigurationError in case of {@linkplain
-   *   java.util.ServiceConfigurationError service configuration error} or if
-   *   the implementation is not available or cannot be instantiated.
-   */
-  public static XMLEventFactory newFactory(String factoryId,
-                                           ClassLoader classLoader)
-          throws FactoryConfigurationError {
-      //do not fallback if given classloader can't find the class, throw exception
-      return FactoryFinder.find(XMLEventFactory.class, factoryId, classLoader, null);
-  }
-
- /**
-   * This method allows setting of the Location on each event that
-   * is created by this factory.  The values are copied by value into
-   * the events created by this factory.  To reset the location
-   * information set the location to null.
-   * @param location the location to set on each event created
-   */
-  public abstract void setLocation(Location location);
-
-  /**
-   * Create a new Attribute
-   * @param prefix the prefix of this attribute, may not be null
-   * @param namespaceURI the attribute value is set to this value, may not be null
-   * @param localName the local name of the XML name of the attribute, localName cannot be null
-   * @param value the attribute value to set, may not be null
-   * @return the Attribute with specified values
-   */
-  public abstract Attribute createAttribute(String prefix, String namespaceURI, String localName, String value);
-
-  /**
-   * Create a new Attribute
-   * @param localName the local name of the XML name of the attribute, localName cannot be null
-   * @param value the attribute value to set, may not be null
-   * @return the Attribute with specified values
-   */
-  public abstract Attribute createAttribute(String localName, String value);
-
-  /**
-   * Create a new Attribute
-   * @param name the qualified name of the attribute, may not be null
-   * @param value the attribute value to set, may not be null
-   * @return the Attribute with specified values
-   */
-  public abstract Attribute createAttribute(QName name, String value);
-
-  /**
-   * Create a new default Namespace
-   * @param namespaceURI the default namespace uri
-   * @return the Namespace with the specified value
-   */
-  public abstract Namespace createNamespace(String namespaceURI);
-
-  /**
-   * Create a new Namespace
-   * @param prefix the prefix of this namespace, may not be null
-   * @param namespaceUri the attribute value is set to this value, may not be null
-   * @return the Namespace with the specified values
-   */
-  public abstract Namespace createNamespace(String prefix, String namespaceUri);
-
-  /**
-   * Create a new StartElement.  Namespaces can be added to this StartElement
-   * by passing in an Iterator that walks over a set of Namespace interfaces.
-   * Attributes can be added to this StartElement by passing an iterator
-   * that walks over a set of Attribute interfaces.
-   *
-   * @param name the qualified name of the attribute, may not be null
-   * @param attributes an optional unordered set of objects that
-   * implement Attribute to add to the new StartElement, may be null
-   * @param namespaces an optional unordered set of objects that
-   * implement Namespace to add to the new StartElement, may be null
-   * @return an instance of the requested StartElement
-   */
-  public abstract StartElement createStartElement(QName name,
-                                                  Iterator attributes,
-                                                  Iterator namespaces);
-
-  /**
-   * Create a new StartElement.  This defaults the NamespaceContext to
-   * an empty NamespaceContext.  Querying this event for its namespaces or
-   * attributes will result in an empty iterator being returned.
-   *
-   * @param namespaceUri the uri of the QName of the new StartElement
-   * @param localName the local name of the QName of the new StartElement
-   * @param prefix the prefix of the QName of the new StartElement
-   * @return an instance of the requested StartElement
-   */
-  public abstract StartElement createStartElement(String prefix,
-                                                  String namespaceUri,
-                                                  String localName);
-  /**
-   * Create a new StartElement.  Namespaces can be added to this StartElement
-   * by passing in an Iterator that walks over a set of Namespace interfaces.
-   * Attributes can be added to this StartElement by passing an iterator
-   * that walks over a set of Attribute interfaces.
-   *
-   * @param namespaceUri the uri of the QName of the new StartElement
-   * @param localName the local name of the QName of the new StartElement
-   * @param prefix the prefix of the QName of the new StartElement
-   * @param attributes an unordered set of objects that implement
-   * Attribute to add to the new StartElement
-   * @param namespaces an unordered set of objects that implement
-   * Namespace to add to the new StartElement
-   * @return an instance of the requested StartElement
-   */
-  public abstract StartElement createStartElement(String prefix,
-                                                  String namespaceUri,
-                                                  String localName,
-                                                  Iterator attributes,
-                                                  Iterator namespaces
-                                                  );
-  /**
-   * Create a new StartElement.  Namespaces can be added to this StartElement
-   * by passing in an Iterator that walks over a set of Namespace interfaces.
-   * Attributes can be added to this StartElement by passing an iterator
-   * that walks over a set of Attribute interfaces.
-   *
-   * @param namespaceUri the uri of the QName of the new StartElement
-   * @param localName the local name of the QName of the new StartElement
-   * @param prefix the prefix of the QName of the new StartElement
-   * @param attributes an unordered set of objects that implement
-   * Attribute to add to the new StartElement, may be null
-   * @param namespaces an unordered set of objects that implement
-   * Namespace to add to the new StartElement, may be null
-   * @param context the namespace context of this element
-   * @return an instance of the requested StartElement
-   */
-  public abstract StartElement createStartElement(String prefix,
-                                                  String namespaceUri,
-                                                  String localName,
-                                                  Iterator attributes,
-                                                  Iterator namespaces,
-                                                  NamespaceContext context
-                                                  );
-
-  /**
-   * Create a new EndElement
-   * @param name the qualified name of the EndElement
-   * @param namespaces an optional unordered set of objects that
-   * implement Namespace that have gone out of scope, may be null
-   * @return an instance of the requested EndElement
-   */
-  public abstract EndElement createEndElement(QName name,
-                                              Iterator namespaces);
-
-  /**
-   * Create a new EndElement
-   * @param namespaceUri the uri of the QName of the new StartElement
-   * @param localName the local name of the QName of the new StartElement
-   * @param prefix the prefix of the QName of the new StartElement
-   * @return an instance of the requested EndElement
-   */
-  public abstract EndElement createEndElement(String prefix,
-                                              String namespaceUri,
-                                              String localName);
-  /**
-   * Create a new EndElement
-   * @param namespaceUri the uri of the QName of the new StartElement
-   * @param localName the local name of the QName of the new StartElement
-   * @param prefix the prefix of the QName of the new StartElement
-   * @param namespaces an unordered set of objects that implement
-   * Namespace that have gone out of scope, may be null
-   * @return an instance of the requested EndElement
-   */
-  public abstract EndElement createEndElement(String prefix,
-                                              String namespaceUri,
-                                              String localName,
-                                              Iterator namespaces);
-
-  /**
-   * Create a Characters event, this method does not check if the content
-   * is all whitespace.  To create a space event use #createSpace(String)
-   * @param content the string to create
-   * @return a Characters event
-   */
-  public abstract Characters createCharacters(String content);
-
-  /**
-   * Create a Characters event with the CData flag set to true
-   * @param content the string to create
-   * @return a Characters event
-   */
-  public abstract Characters createCData(String content);
-
-  /**
-   * Create a Characters event with the isSpace flag set to true
-   * @param content the content of the space to create
-   * @return a Characters event
-   */
-  public abstract Characters createSpace(String content);
-  /**
-   * Create an ignorable space
-   * @param content the space to create
-   * @return a Characters event
-   */
-  public abstract Characters createIgnorableSpace(String content);
-
-  /**
-   * Creates a new instance of a StartDocument event
-   * @return a StartDocument event
-   */
-  public abstract StartDocument createStartDocument();
-
-  /**
-   * Creates a new instance of a StartDocument event
-   *
-   * @param encoding the encoding style
-   * @param version the XML version
-   * @param standalone the status of standalone may be set to "true" or "false"
-   * @return a StartDocument event
-   */
-  public abstract StartDocument createStartDocument(String encoding,
-                                                  String version,
-                                                  boolean standalone);
-
-  /**
-   * Creates a new instance of a StartDocument event
-   *
-   * @param encoding the encoding style
-   * @param version the XML version
-   * @return a StartDocument event
-   */
-  public abstract StartDocument createStartDocument(String encoding,
-                                                  String version);
-
-  /**
-   * Creates a new instance of a StartDocument event
-   *
-   * @param encoding the encoding style
-   * @return a StartDocument event
-   */
-  public abstract StartDocument createStartDocument(String encoding);
-
-  /**
-   * Creates a new instance of an EndDocument event
-   * @return an EndDocument event
-   */
-  public abstract EndDocument createEndDocument();
-
-  /** Creates a new instance of a EntityReference event
-   *
-   * @param name The name of the reference
-   * @param declaration the declaration for the event
-   * @return an EntityReference event
-   */
-  public abstract EntityReference createEntityReference(String name,
-                                                        EntityDeclaration declaration);
-  /**
-   * Create a comment
-   * @param text The text of the comment
-   * a Comment event
-   */
-  public abstract Comment createComment(String text);
-
-  /**
-   * Create a processing instruction
-   * @param target The target of the processing instruction
-   * @param data The text of the processing instruction
-   * @return a ProcessingInstruction event
-   */
-  public abstract ProcessingInstruction createProcessingInstruction(String target,
-                                                                   String data);
-
-  /**
-   * Create a document type definition event
-   * This string contains the entire document type declaration that matches
-   * the doctypedecl in the XML 1.0 specification
-   * @param dtd the text of the document type definition
-   * @return a DTD event
-   */
-  public abstract DTD createDTD(String dtd);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLInputFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLInputFactory.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLInputFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLInputFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,511 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009, 2013, by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-import javax.xml.XMLConstants;
-import javax.xml.stream.util.XMLEventAllocator;
-
-import javax.xml.transform.Source;
-
-/**
- * Defines an abstract implementation of a factory for getting streams.
- *
- * The following table defines the standard properties of this specification.
- * Each property varies in the level of support required by each implementation.
- * The level of support required is described in the 'Required' column.
- *
- *   <table border="2" rules="all" cellpadding="4">
- *    <thead>
- *      <tr>
- *        <th align="center" colspan="5">
- *          Configuration parameters
- *        </th>
- *      </tr>
- *    </thead>
- *    <tbody>
- *      <tr>
- *        <th>Property Name</th>
- *        <th>Behavior</th>
- *        <th>Return type</th>
- *        <th>Default Value</th>
- *        <th>Required</th>
- *      </tr>
- * <tr><td>javax.xml.stream.isValidating</td><td>Turns on/off implementation specific DTD validation</td><td>Boolean</td><td>False</td><td>No</td></tr>
- * <tr><td>javax.xml.stream.isNamespaceAware</td><td>Turns on/off namespace processing for XML 1.0 support</td><td>Boolean</td><td>True</td><td>True (required) / False (optional)</td></tr>
- * <tr><td>javax.xml.stream.isCoalescing</td><td>Requires the processor to coalesce adjacent character data</td><td>Boolean</td><td>False</td><td>Yes</td></tr>
- * <tr><td>javax.xml.stream.isReplacingEntityReferences</td><td>replace internal entity references with their replacement text and report them as characters</td><td>Boolean</td><td>True</td><td>Yes</td></tr>
- *<tr><td>javax.xml.stream.isSupportingExternalEntities</td><td>Resolve external parsed entities</td><td>Boolean</td><td>Unspecified</td><td>Yes</td></tr>
- *<tr><td>javax.xml.stream.supportDTD</td><td>Use this property to request processors that do not support DTDs</td><td>Boolean</td><td>True</td><td>Yes</td></tr>
- *<tr><td>javax.xml.stream.reporter</td><td>sets/gets the impl of the XMLReporter </td><td>javax.xml.stream.XMLReporter</td><td>Null</td><td>Yes</td></tr>
- *<tr><td>javax.xml.stream.resolver</td><td>sets/gets the impl of the XMLResolver interface</td><td>javax.xml.stream.XMLResolver</td><td>Null</td><td>Yes</td></tr>
- *<tr><td>javax.xml.stream.allocator</td><td>sets/gets the impl of the XMLEventAllocator interface</td><td>javax.xml.stream.util.XMLEventAllocator</td><td>Null</td><td>Yes</td></tr>
- *    </tbody>
- *  </table>
- *
- *
- * @version 1.2
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLOutputFactory
- * @see XMLEventReader
- * @see XMLStreamReader
- * @see EventFilter
- * @see XMLReporter
- * @see XMLResolver
- * @see XMLEventAllocator
- * @since 1.6
- */
-
-public abstract class XMLInputFactory {
-  /**
-   * The property used to turn on/off namespace support,
-   * this is to support XML 1.0 documents,
-   * only the true setting must be supported
-   */
-  public static final String IS_NAMESPACE_AWARE=
-    "javax.xml.stream.isNamespaceAware";
-
-  /**
-   * The property used to turn on/off implementation specific validation
-   */
-  public static final String IS_VALIDATING=
-    "javax.xml.stream.isValidating";
-
-  /**
-   * The property that requires the parser to coalesce adjacent character data sections
-   */
-  public static final String IS_COALESCING=
-    "javax.xml.stream.isCoalescing";
-
-  /**
-   * Requires the parser to replace internal
-   * entity references with their replacement
-   * text and report them as characters
-   */
-  public static final String IS_REPLACING_ENTITY_REFERENCES=
-    "javax.xml.stream.isReplacingEntityReferences";
-
-  /**
-   *  The property that requires the parser to resolve external parsed entities
-   */
-  public static final String IS_SUPPORTING_EXTERNAL_ENTITIES=
-    "javax.xml.stream.isSupportingExternalEntities";
-
-  /**
-   *  The property that requires the parser to support DTDs
-   */
-  public static final String SUPPORT_DTD=
-    "javax.xml.stream.supportDTD";
-
-  /**
-   * The property used to
-   * set/get the implementation of the XMLReporter interface
-   */
-  public static final String REPORTER=
-    "javax.xml.stream.reporter";
-
-  /**
-   * The property used to set/get the implementation of the XMLResolver
-   */
-  public static final String RESOLVER=
-    "javax.xml.stream.resolver";
-
-  /**
-   * The property used to set/get the implementation of the allocator
-   */
-  public static final String ALLOCATOR=
-    "javax.xml.stream.allocator";
-
-  static final String DEFAULIMPL = "com.sun.xml.internal.stream.XMLInputFactoryImpl";
-
-  protected XMLInputFactory(){}
-
-  /**
-   * Creates a new instance of the factory in exactly the same manner as the
-   * {@link #newFactory()} method.
-   * @throws FactoryConfigurationError if an instance of this factory cannot be loaded
-   */
-  public static XMLInputFactory newInstance()
-    throws FactoryConfigurationError
-  {
-    return FactoryFinder.find(XMLInputFactory.class, DEFAULIMPL);
-  }
-
-  /**
-   * Create a new instance of the factory.
-   * <p>
-   * This static method creates a new factory instance.
-   * This method uses the following ordered lookup procedure to determine
-   * the XMLInputFactory implementation class to load:
-   * </p>
-   * <ul>
-   * <li>
-   *   Use the javax.xml.stream.XMLInputFactory system property.
-   * </li>
-   * <li>
-   *   Use the properties file "lib/stax.properties" in the JRE directory.
-   *     This configuration file is in standard java.util.Properties format
-   *     and contains the fully qualified name of the implementation class
-   *     with the key being the system property defined above.
-   * </li>
-   * <li>
-   *   Use the service-provider loading facilities, defined by the
-   *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-   *   implementation of the service using the {@linkplain
-   *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-   *   the service-provider loading facility will use the {@linkplain
-   *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-   *   to attempt to load the service. If the context class
-   *   loader is null, the {@linkplain
-   *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-   * </li>
-   * <li>
-   * Otherwise, the system-default implementation is returned.
-   * </li>
-   * </ul>
-   * <p>
-   *   Once an application has obtained a reference to a XMLInputFactory it
-   *   can use the factory to configure and obtain stream instances.
-   * </p>
-   * <p>
-   *   Note that this is a new method that replaces the deprecated newInstance() method.
-   *     No changes in behavior are defined by this replacement method relative to
-   *     the deprecated method.
-   * </p>
-   * @throws FactoryConfigurationError in case of {@linkplain
-   *   java.util.ServiceConfigurationError service configuration error} or if
-   *   the implementation is not available or cannot be instantiated.
-   */
-  public static XMLInputFactory newFactory()
-    throws FactoryConfigurationError
-  {
-    return FactoryFinder.find(XMLInputFactory.class, DEFAULIMPL);
-  }
-
-  /**
-   * Create a new instance of the factory
-   *
-   * @param factoryId             Name of the factory to find, same as
-   *                              a property name
-   * @param classLoader           classLoader to use
-   * @return the factory implementation
-   * @throws FactoryConfigurationError if an instance of this factory cannot be loaded
-   *
-   * @deprecated  This method has been deprecated to maintain API consistency.
-   *              All newInstance methods have been replaced with corresponding
-   *              newFactory methods. The replacement {@link
-   *              #newFactory(java.lang.String, java.lang.ClassLoader)} method
-   *              defines no changes in behavior.
-   */
-  public static XMLInputFactory newInstance(String factoryId,
-          ClassLoader classLoader)
-          throws FactoryConfigurationError {
-      //do not fallback if given classloader can't find the class, throw exception
-      return FactoryFinder.find(XMLInputFactory.class, factoryId, classLoader, null);
-  }
-
-  /**
-   * Create a new instance of the factory.
-   * If the classLoader argument is null, then the ContextClassLoader is used.
-   * <p>
-   * This method uses the following ordered lookup procedure to determine
-   * the XMLInputFactory implementation class to load:
-   * </p>
-   * <ul>
-   * <li>
-   *   Use the value of the system property identified by {@code factoryId}.
-   * </li>
-   * <li>
-   *   Use the properties file "lib/stax.properties" in the JRE directory.
-   *     This configuration file is in standard java.util.Properties format
-   *     and contains the fully qualified name of the implementation class
-   *     with the key being the given {@code factoryId}.
-   * </li>
-   * <li>
-   *   If {@code factoryId} is "javax.xml.stream.XMLInputFactory",
-   *   use the service-provider loading facilities, defined by the
-   *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-   *   implementation of the service using the specified {@code ClassLoader}.
-   *   If {@code classLoader} is null, the {@linkplain
-   *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism} will apply:
-   *   That is, the service-provider loading facility will use the {@linkplain
-   *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-   *   to attempt to load the service. If the context class
-   *   loader is null, the {@linkplain
-   *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-   * </li>
-   * <li>
-   *   Otherwise, throws a {@link FactoryConfigurationError}.
-   * </li>
-   * </ul>
-   *
-   * <p>
-   * Note that this is a new method that replaces the deprecated
-   *   {@link #newInstance(java.lang.String, java.lang.ClassLoader)
-   *   newInstance(String factoryId, ClassLoader classLoader)} method.
-   * No changes in behavior are defined by this replacement method relative
-   * to the deprecated method.
-   * </p>
-   *
-   * @apiNote The parameter factoryId defined here is inconsistent with that
-   * of other JAXP factories where the first parameter is fully qualified
-   * factory class name that provides implementation of the factory.
-   *
-   * @param factoryId             Name of the factory to find, same as
-   *                              a property name
-   * @param classLoader           classLoader to use
-   * @return the factory implementation
-   * @throws FactoryConfigurationError in case of {@linkplain
-   *   java.util.ServiceConfigurationError service configuration error} or if
-   *   the implementation is not available or cannot be instantiated.
-   * @throws FactoryConfigurationError if an instance of this factory cannot be loaded
-   */
-  public static XMLInputFactory newFactory(String factoryId,
-          ClassLoader classLoader)
-          throws FactoryConfigurationError {
-      //do not fallback if given classloader can't find the class, throw exception
-      return FactoryFinder.find(XMLInputFactory.class, factoryId, classLoader, null);
-  }
-
-  /**
-   * Create a new XMLStreamReader from a reader
-   * @param reader the XML data to read from
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamReader createXMLStreamReader(java.io.Reader reader)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamReader from a JAXP source.  This method is optional.
-   * @param source the source to read from
-   * @throws UnsupportedOperationException if this method is not
-   * supported by this XMLInputFactory
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamReader createXMLStreamReader(Source source)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamReader from a java.io.InputStream
-   * @param stream the InputStream to read from
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamReader createXMLStreamReader(java.io.InputStream stream)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamReader from a java.io.InputStream
-   * @param stream the InputStream to read from
-   * @param encoding the character encoding of the stream
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamReader createXMLStreamReader(java.io.InputStream stream, String encoding)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamReader from a java.io.InputStream
-   * @param systemId the system ID of the stream
-   * @param stream the InputStream to read from
-   */
-  public abstract XMLStreamReader createXMLStreamReader(String systemId, java.io.InputStream stream)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamReader from a java.io.InputStream
-   * @param systemId the system ID of the stream
-   * @param reader the InputStream to read from
-   */
-  public abstract XMLStreamReader createXMLStreamReader(String systemId, java.io.Reader reader)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventReader from a reader
-   * @param reader the XML data to read from
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventReader createXMLEventReader(java.io.Reader reader)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventReader from a reader
-   * @param systemId the system ID of the input
-   * @param reader the XML data to read from
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventReader createXMLEventReader(String systemId, java.io.Reader reader)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventReader from an XMLStreamReader.  After being used
-   * to construct the XMLEventReader instance returned from this method
-   * the XMLStreamReader must not be used.
-   * @param reader the XMLStreamReader to read from (may not be modified)
-   * @return a new XMLEventReader
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventReader createXMLEventReader(XMLStreamReader reader)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventReader from a JAXP source.
-   * Support of this method is optional.
-   * @param source the source to read from
-   * @throws UnsupportedOperationException if this method is not
-   * supported by this XMLInputFactory
-   */
-  public abstract XMLEventReader createXMLEventReader(Source source)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventReader from a java.io.InputStream
-   * @param stream the InputStream to read from
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventReader createXMLEventReader(java.io.InputStream stream)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventReader from a java.io.InputStream
-   * @param stream the InputStream to read from
-   * @param encoding the character encoding of the stream
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventReader createXMLEventReader(java.io.InputStream stream, String encoding)
-    throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventReader from a java.io.InputStream
-   * @param systemId the system ID of the stream
-   * @param stream the InputStream to read from
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventReader createXMLEventReader(String systemId, java.io.InputStream stream)
-    throws XMLStreamException;
-
-  /**
-   * Create a filtered reader that wraps the filter around the reader
-   * @param reader the reader to filter
-   * @param filter the filter to apply to the reader
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamReader createFilteredReader(XMLStreamReader reader, StreamFilter filter)
-    throws XMLStreamException;
-
-  /**
-   * Create a filtered event reader that wraps the filter around the event reader
-   * @param reader the event reader to wrap
-   * @param filter the filter to apply to the event reader
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventReader createFilteredReader(XMLEventReader reader, EventFilter filter)
-    throws XMLStreamException;
-
-  /**
-   * The resolver that will be set on any XMLStreamReader or XMLEventReader created
-   * by this factory instance.
-   */
-  public abstract XMLResolver getXMLResolver();
-
-  /**
-   * The resolver that will be set on any XMLStreamReader or XMLEventReader created
-   * by this factory instance.
-   * @param resolver the resolver to use to resolve references
-   */
-  public abstract void  setXMLResolver(XMLResolver resolver);
-
-  /**
-   * The reporter that will be set on any XMLStreamReader or XMLEventReader created
-   * by this factory instance.
-   */
-  public abstract XMLReporter getXMLReporter();
-
-  /**
-   * The reporter that will be set on any XMLStreamReader or XMLEventReader created
-   * by this factory instance.
-   * @param reporter the resolver to use to report non fatal errors
-   */
-  public abstract void setXMLReporter(XMLReporter reporter);
-
-  /**
-   * Allows the user to set specific feature/property on the underlying
-   * implementation. The underlying implementation is not required to support
-   * every setting of every property in the specification and may use
-   * IllegalArgumentException to signal that an unsupported property may not be
-   * set with the specified value.
-   * <p>
-   * All implementations that implement JAXP 1.5 or newer are required to
-   * support the {@link XMLConstants#ACCESS_EXTERNAL_DTD} property.
-   * </p>
-   * <ul>
-   *   <li>
-   *        <p>
-   *        Access to external DTDs, external Entity References is restricted to the
-   *        protocols specified by the property. If access is denied during parsing
-   *        due to the restriction of this property, {@link XMLStreamException}
-   *        will be thrown by the {@link XMLStreamReader#next()} or
-   *        {@link XMLEventReader#nextEvent()} method.
-   *        </p>
-   *   </li>
-   * </ul>
-   * @param name The name of the property (may not be null)
-   * @param value The value of the property
-   * @throws java.lang.IllegalArgumentException if the property is not supported
-   */
-  public abstract void setProperty(java.lang.String name, Object value)
-    throws java.lang.IllegalArgumentException;
-
-  /**
-   * Get the value of a feature/property from the underlying implementation
-   * @param name The name of the property (may not be null)
-   * @return The value of the property
-   * @throws IllegalArgumentException if the property is not supported
-   */
-  public abstract Object getProperty(java.lang.String name)
-    throws java.lang.IllegalArgumentException;
-
-
-  /**
-   * Query the set of properties that this factory supports.
-   *
-   * @param name The name of the property (may not be null)
-   * @return true if the property is supported and false otherwise
-   */
-  public abstract boolean isPropertySupported(String name);
-
-  /**
-   * Set a user defined event allocator for events
-   * @param allocator the user defined allocator
-   */
-  public abstract void setEventAllocator(XMLEventAllocator allocator);
-
-  /**
-   * Gets the allocator used by streams created with this factory
-   */
-  public abstract XMLEventAllocator getEventAllocator();
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamReader.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamReader.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamReader.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamReader.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,704 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-import javax.xml.namespace.NamespaceContext;
-import javax.xml.namespace.QName;
-import javax.xml.stream.events.XMLEvent;
-
-/**
- *  The XMLStreamReader interface allows forward, read-only access to XML.
- *  It is designed to be the lowest level and most efficient way to
- *  read XML data.
- *
- * <p> The XMLStreamReader is designed to iterate over XML using
- * next() and hasNext().  The data can be accessed using methods such as getEventType(),
- * getNamespaceURI(), getLocalName() and getText();
- *
- * <p> The <a href="#next()">next()</a> method causes the reader to read the next parse event.
- * The next() method returns an integer which identifies the type of event just read.
- * <p> The event type can be determined using <a href="#getEventType()">getEventType()</a>.
- * <p> Parsing events are defined as the XML Declaration, a DTD,
- * start tag, character data, white space, end tag, comment,
- * or processing instruction.  An attribute or namespace event may be encountered
- * at the root level of a document as the result of a query operation.
- *
- * <p>For XML 1.0 compliance an XML processor must pass the
- * identifiers of declared unparsed entities, notation declarations and their
- * associated identifiers to the application.  This information is
- * provided through the property API on this interface.
- * The following two properties allow access to this information:
- * javax.xml.stream.notations and javax.xml.stream.entities.
- * When the current event is a DTD the following call will return a
- * list of Notations
- *  <code>List l = (List) getProperty("javax.xml.stream.notations");</code>
- * The following call will return a list of entity declarations:
- * <code>List l = (List) getProperty("javax.xml.stream.entities");</code>
- * These properties can only be accessed during a DTD event and
- * are defined to return null if the information is not available.
- *
- * <p>The following table describes which methods are valid in what state.
- * If a method is called in an invalid state the method will throw a
- * java.lang.IllegalStateException.
- *
- * <table border="2" rules="all" cellpadding="4">
- *   <thead>
- *     <tr>
- *       <th align="center" colspan="2">
- *         Valid methods for each state
- *       </th>
- *     </tr>
- *   </thead>
- *   <tbody>
- *     <tr>
- *       <th>Event Type</th>
- *       <th>Valid Methods</th>
- *     </tr>
- *     <tr>
- *       <td> All States  </td>
- *       <td> getProperty(), hasNext(), require(), close(),
- *            getNamespaceURI(), isStartElement(),
- *            isEndElement(), isCharacters(), isWhiteSpace(),
- *            getNamespaceContext(), getEventType(),getLocation(),
- *            hasText(), hasName()
- *       </td>
- *     </tr>
- *     <tr>
- *       <td> START_ELEMENT  </td>
- *       <td> next(), getName(), getLocalName(), hasName(), getPrefix(),
- *            getAttributeXXX(), isAttributeSpecified(),
- *            getNamespaceXXX(),
- *            getElementText(), nextTag()
- *       </td>
- *     </tr>
- *       <td> ATTRIBUTE  </td>
- *       <td> next(), nextTag()
- *            getAttributeXXX(), isAttributeSpecified(),
- *       </td>
- *     </tr>
- *     </tr>
- *       <td> NAMESPACE  </td>
- *       <td> next(), nextTag()
- *            getNamespaceXXX()
- *       </td>
- *     </tr>
- *     <tr>
- *       <td> END_ELEMENT  </td>
- *       <td> next(), getName(), getLocalName(), hasName(), getPrefix(),
- *            getNamespaceXXX(), nextTag()
- *      </td>
- *     </tr>
- *     <tr>
- *       <td> CHARACTERS  </td>
- *       <td> next(), getTextXXX(), nextTag() </td>
- *     </tr>
- *     <tr>
- *       <td> CDATA  </td>
- *       <td> next(), getTextXXX(), nextTag() </td>
- *     </tr>
- *     <tr>
- *       <td> COMMENT  </td>
- *       <td> next(), getTextXXX(), nextTag() </td>
- *     </tr>
- *     <tr>
- *       <td> SPACE  </td>
- *       <td> next(), getTextXXX(), nextTag() </td>
- *     </tr>
- *     <tr>
- *       <td> START_DOCUMENT  </td>
- *       <td> next(), getEncoding(), getVersion(), isStandalone(), standaloneSet(),
- *            getCharacterEncodingScheme(), nextTag()</td>
- *     </tr>
- *     <tr>
- *       <td> END_DOCUMENT  </td>
- *       <td> close()</td>
- *     </tr>
- *     <tr>
- *       <td> PROCESSING_INSTRUCTION  </td>
- *       <td> next(), getPITarget(), getPIData(), nextTag() </td>
- *     </tr>
- *     <tr>
- *       <td> ENTITY_REFERENCE  </td>
- *       <td> next(), getLocalName(), getText(), nextTag() </td>
- *     </tr>
- *     <tr>
- *       <td> DTD  </td>
- *       <td> next(), getText(), nextTag() </td>
- *     </tr>
- *   </tbody>
- *  </table>
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLEvent
- * @see XMLInputFactory
- * @see XMLStreamWriter
- * @since 1.6
- */
-public interface XMLStreamReader extends XMLStreamConstants {
-  /**
-   * Get the value of a feature/property from the underlying implementation
-   * @param name The name of the property, may not be null
-   * @return The value of the property
-   * @throws IllegalArgumentException if name is null
-   */
-  public Object getProperty(java.lang.String name) throws java.lang.IllegalArgumentException;
-
-  /**
-   * Get next parsing event - a processor may return all contiguous
-   * character data in a single chunk, or it may split it into several chunks.
-   * If the property javax.xml.stream.isCoalescing is set to true
-   * element content must be coalesced and only one CHARACTERS event
-   * must be returned for contiguous element content or
-   * CDATA Sections.
-   *
-   * By default entity references must be
-   * expanded and reported transparently to the application.
-   * An exception will be thrown if an entity reference cannot be expanded.
-   * If element content is empty (i.e. content is "") then no CHARACTERS event will be reported.
-   *
-   * <p>Given the following XML:<br>
-   * &lt;foo>&lt;!--description-->content text&lt;![CDATA[&lt;greeting>Hello&lt;/greeting>]]>other content&lt;/foo><br>
-   * The behavior of calling next() when being on foo will be:<br>
-   * 1- the comment (COMMENT)<br>
-   * 2- then the characters section (CHARACTERS)<br>
-   * 3- then the CDATA section (another CHARACTERS)<br>
-   * 4- then the next characters section (another CHARACTERS)<br>
-   * 5- then the END_ELEMENT<br>
-   *
-   * <p><b>NOTE:</b> empty element (such as &lt;tag/>) will be reported
-   *  with  two separate events: START_ELEMENT, END_ELEMENT - This preserves
-   *   parsing equivalency of empty element to &lt;tag>&lt;/tag>.
-   *
-   * This method will throw an IllegalStateException if it is called after hasNext() returns false.
-   * @see XMLEvent
-   * @return the integer code corresponding to the current parse event
-   * @throws NoSuchElementException if this is called when hasNext() returns false
-   * @throws XMLStreamException  if there is an error processing the underlying XML source
-   */
-  public int next() throws XMLStreamException;
-
-  /**
-   * Test if the current event is of the given type and if the namespace and name match the current
-   * namespace and name of the current event.  If the namespaceURI is null it is not checked for equality,
-   * if the localName is null it is not checked for equality.
-   * @param type the event type
-   * @param namespaceURI the uri of the event, may be null
-   * @param localName the localName of the event, may be null
-   * @throws XMLStreamException if the required values are not matched.
-   */
-  public void require(int type, String namespaceURI, String localName) throws XMLStreamException;
-
-  /**
-   * Reads the content of a text-only element, an exception is thrown if this is
-   * not a text-only element.
-   * Regardless of value of javax.xml.stream.isCoalescing this method always returns coalesced content.
-   * <br /> Precondition: the current event is START_ELEMENT.
-   * <br /> Postcondition: the current event is the corresponding END_ELEMENT.
-   *
-   * <br />The method does the following (implementations are free to optimized
-   * but must do equivalent processing):
-   * <pre>
-   * if(getEventType() != XMLStreamConstants.START_ELEMENT) {
-   * throw new XMLStreamException(
-   * "parser must be on START_ELEMENT to read next text", getLocation());
-   * }
-   * int eventType = next();
-   * StringBuffer content = new StringBuffer();
-   * while(eventType != XMLStreamConstants.END_ELEMENT ) {
-   * if(eventType == XMLStreamConstants.CHARACTERS
-   * || eventType == XMLStreamConstants.CDATA
-   * || eventType == XMLStreamConstants.SPACE
-   * || eventType == XMLStreamConstants.ENTITY_REFERENCE) {
-   * buf.append(getText());
-   * } else if(eventType == XMLStreamConstants.PROCESSING_INSTRUCTION
-   * || eventType == XMLStreamConstants.COMMENT) {
-   * // skipping
-   * } else if(eventType == XMLStreamConstants.END_DOCUMENT) {
-   * throw new XMLStreamException(
-   * "unexpected end of document when reading element text content", this);
-   * } else if(eventType == XMLStreamConstants.START_ELEMENT) {
-   * throw new XMLStreamException(
-   * "element text content may not contain START_ELEMENT", getLocation());
-   * } else {
-   * throw new XMLStreamException(
-   * "Unexpected event type "+eventType, getLocation());
-   * }
-   * eventType = next();
-   * }
-   * return buf.toString();
-   * </pre>
-   *
-   * @throws XMLStreamException if the current event is not a START_ELEMENT
-   * or if a non text element is encountered
-   */
-  public String getElementText() throws XMLStreamException;
-
-  /**
-   * Skips any white space (isWhiteSpace() returns true), COMMENT,
-   * or PROCESSING_INSTRUCTION,
-   * until a START_ELEMENT or END_ELEMENT is reached.
-   * If other than white space characters, COMMENT, PROCESSING_INSTRUCTION, START_ELEMENT, END_ELEMENT
-   * are encountered, an exception is thrown. This method should
-   * be used when processing element-only content seperated by white space.
-   *
-   * <br /> Precondition: none
-   * <br /> Postcondition: the current event is START_ELEMENT or END_ELEMENT
-   * and cursor may have moved over any whitespace event.
-   *
-   * <br />Essentially it does the following (implementations are free to optimized
-   * but must do equivalent processing):
-   * <pre>
-   * int eventType = next();
-   * while((eventType == XMLStreamConstants.CHARACTERS &amp;&amp; isWhiteSpace()) // skip whitespace
-   * || (eventType == XMLStreamConstants.CDATA &amp;&amp; isWhiteSpace())
-   * // skip whitespace
-   * || eventType == XMLStreamConstants.SPACE
-   * || eventType == XMLStreamConstants.PROCESSING_INSTRUCTION
-   * || eventType == XMLStreamConstants.COMMENT
-   * ) {
-   * eventType = next();
-   * }
-   * if (eventType != XMLStreamConstants.START_ELEMENT &amp;&amp; eventType != XMLStreamConstants.END_ELEMENT) {
-   * throw new String XMLStreamException("expected start or end tag", getLocation());
-   * }
-   * return eventType;
-   * </pre>
-   *
-   * @return the event type of the element read (START_ELEMENT or END_ELEMENT)
-   * @throws XMLStreamException if the current event is not white space, PROCESSING_INSTRUCTION,
-   * START_ELEMENT or END_ELEMENT
-   * @throws NoSuchElementException if this is called when hasNext() returns false
-   */
-  public int nextTag() throws XMLStreamException;
-
-  /**
-   * Returns true if there are more parsing events and false
-   * if there are no more events.  This method will return
-   * false if the current state of the XMLStreamReader is
-   * END_DOCUMENT
-   * @return true if there are more events, false otherwise
-   * @throws XMLStreamException if there is a fatal error detecting the next state
-   */
-  public boolean hasNext() throws XMLStreamException;
-
-  /**
-   * Frees any resources associated with this Reader.  This method does not close the
-   * underlying input source.
-   * @throws XMLStreamException if there are errors freeing associated resources
-   */
-  public void close() throws XMLStreamException;
-
-  /**
-   * Return the uri for the given prefix.
-   * The uri returned depends on the current state of the processor.
-   *
-   * <p><strong>NOTE:</strong>The 'xml' prefix is bound as defined in
-   * <a href="http://www.w3.org/TR/REC-xml-names/#ns-using">Namespaces in XML</a>
-   * specification to "http://www.w3.org/XML/1998/namespace".
-   *
-   * <p><strong>NOTE:</strong> The 'xmlns' prefix must be resolved to following namespace
-   * <a href="http://www.w3.org/2000/xmlns/">http://www.w3.org/2000/xmlns/</a>
-   * @param prefix The prefix to lookup, may not be null
-   * @return the uri bound to the given prefix or null if it is not bound
-   * @throws IllegalArgumentException if the prefix is null
-   */
-  public String getNamespaceURI(String prefix);
-
-  /**
-   * Returns true if the cursor points to a start tag (otherwise false)
-   * @return true if the cursor points to a start tag, false otherwise
-   */
-  public boolean isStartElement();
-
-  /**
-   * Returns true if the cursor points to an end tag (otherwise false)
-   * @return true if the cursor points to an end tag, false otherwise
-   */
-  public boolean isEndElement();
-
-  /**
-   * Returns true if the cursor points to a character data event
-   * @return true if the cursor points to character data, false otherwise
-   */
-  public boolean isCharacters();
-
-  /**
-   * Returns true if the cursor points to a character data event
-   * that consists of all whitespace
-   * @return true if the cursor points to all whitespace, false otherwise
-   */
-  public boolean isWhiteSpace();
-
-
-  /**
-   * Returns the normalized attribute value of the
-   * attribute with the namespace and localName
-   * If the namespaceURI is null the namespace
-   * is not checked for equality
-   * @param namespaceURI the namespace of the attribute
-   * @param localName the local name of the attribute, cannot be null
-   * @return returns the value of the attribute , returns null if not found
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public String getAttributeValue(String namespaceURI,
-                                  String localName);
-
-  /**
-   * Returns the count of attributes on this START_ELEMENT,
-   * this method is only valid on a START_ELEMENT or ATTRIBUTE.  This
-   * count excludes namespace definitions.  Attribute indices are
-   * zero-based.
-   * @return returns the number of attributes
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public int getAttributeCount();
-
-  /** Returns the qname of the attribute at the provided index
-   *
-   * @param index the position of the attribute
-   * @return the QName of the attribute
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public QName getAttributeName(int index);
-
-  /**
-   * Returns the namespace of the attribute at the provided
-   * index
-   * @param index the position of the attribute
-   * @return the namespace URI (can be null)
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public String getAttributeNamespace(int index);
-
-  /**
-   * Returns the localName of the attribute at the provided
-   * index
-   * @param index the position of the attribute
-   * @return the localName of the attribute
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public String getAttributeLocalName(int index);
-
-  /**
-   * Returns the prefix of this attribute at the
-   * provided index
-   * @param index the position of the attribute
-   * @return the prefix of the attribute
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public String getAttributePrefix(int index);
-
-  /**
-   * Returns the XML type of the attribute at the provided
-   * index
-   * @param index the position of the attribute
-   * @return the XML type of the attribute
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public String getAttributeType(int index);
-
-  /**
-   * Returns the value of the attribute at the
-   * index
-   * @param index the position of the attribute
-   * @return the attribute value
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public String getAttributeValue(int index);
-
-  /**
-   * Returns a boolean which indicates if this
-   * attribute was created by default
-   * @param index the position of the attribute
-   * @return true if this is a default attribute
-   * @throws IllegalStateException if this is not a START_ELEMENT or ATTRIBUTE
-   */
-  public boolean isAttributeSpecified(int index);
-
-  /**
-   * Returns the count of namespaces declared on this START_ELEMENT or END_ELEMENT,
-   * this method is only valid on a START_ELEMENT, END_ELEMENT or NAMESPACE. On
-   * an END_ELEMENT the count is of the namespaces that are about to go
-   * out of scope.  This is the equivalent of the information reported
-   * by SAX callback for an end element event.
-   * @return returns the number of namespace declarations on this specific element
-   * @throws IllegalStateException if this is not a START_ELEMENT, END_ELEMENT or NAMESPACE
-   */
-  public int getNamespaceCount();
-
-  /**
-   * Returns the prefix for the namespace declared at the
-   * index.  Returns null if this is the default namespace
-   * declaration
-   *
-   * @param index the position of the namespace declaration
-   * @return returns the namespace prefix
-   * @throws IllegalStateException if this is not a START_ELEMENT, END_ELEMENT or NAMESPACE
-   */
-  public String getNamespacePrefix(int index);
-
-  /**
-   * Returns the uri for the namespace declared at the
-   * index.
-   *
-   * @param index the position of the namespace declaration
-   * @return returns the namespace uri
-   * @throws IllegalStateException if this is not a START_ELEMENT, END_ELEMENT or NAMESPACE
-   */
-  public String getNamespaceURI(int index);
-
-  /**
-   * Returns a read only namespace context for the current
-   * position.  The context is transient and only valid until
-   * a call to next() changes the state of the reader.
-   * @return return a namespace context
-   */
-  public NamespaceContext getNamespaceContext();
-
-  /**
-   * Returns a reader that points to the current start element
-   * and all of its contents.  Throws an XMLStreamException if the
-   * cursor does not point to a START_ELEMENT.<p>
-   * The sub stream is read from it MUST be read before the parent stream is
-   * moved on, if not any call on the sub stream will cause an XMLStreamException to be
-   * thrown.   The parent stream will always return the same result from next()
-   * whatever is done to the sub stream.
-   * @return an XMLStreamReader which points to the next element
-   */
-  //  public XMLStreamReader subReader() throws XMLStreamException;
-
-  /**
-   * Allows the implementation to reset and reuse any underlying tables
-   */
-  //  public void recycle() throws XMLStreamException;
-
-  /**
-   * Returns an integer code that indicates the type
-   * of the event the cursor is pointing to.
-   */
-  public int getEventType();
-
-  /**
-   * Returns the current value of the parse event as a string,
-   * this returns the string value of a CHARACTERS event,
-   * returns the value of a COMMENT, the replacement value
-   * for an ENTITY_REFERENCE, the string value of a CDATA section,
-   * the string value for a SPACE event,
-   * or the String value of the internal subset of the DTD.
-   * If an ENTITY_REFERENCE has been resolved, any character data
-   * will be reported as CHARACTERS events.
-   * @return the current text or null
-   * @throws java.lang.IllegalStateException if this state is not
-   * a valid text state.
-   */
-  public String getText();
-
-  /**
-   * Returns an array which contains the characters from this event.
-   * This array should be treated as read-only and transient. I.e. the array will
-   * contain the text characters until the XMLStreamReader moves on to the next event.
-   * Attempts to hold onto the character array beyond that time or modify the
-   * contents of the array are breaches of the contract for this interface.
-   * @return the current text or an empty array
-   * @throws java.lang.IllegalStateException if this state is not
-   * a valid text state.
-   */
-  public char[] getTextCharacters();
-
-  /**
-   * Gets the the text associated with a CHARACTERS, SPACE or CDATA event.
-   * Text starting a "sourceStart" is copied into "target" starting at "targetStart".
-   * Up to "length" characters are copied.  The number of characters actually copied is returned.
-   *
-   * The "sourceStart" argument must be greater or equal to 0 and less than or equal to
-   * the number of characters associated with the event.  Usually, one requests text starting at a "sourceStart" of 0.
-   * If the number of characters actually copied is less than the "length", then there is no more text.
-   * Otherwise, subsequent calls need to be made until all text has been retrieved. For example:
-   *
-   *<code>
-   * int length = 1024;
-   * char[] myBuffer = new char[ length ];
-   *
-   * for ( int sourceStart = 0 ; ; sourceStart += length )
-   * {
-   *    int nCopied = stream.getTextCharacters( sourceStart, myBuffer, 0, length );
-   *
-   *   if (nCopied < length)
-   *       break;
-   * }
-   * </code>
-   * XMLStreamException may be thrown if there are any XML errors in the underlying source.
-   * The "targetStart" argument must be greater than or equal to 0 and less than the length of "target",
-   * Length must be greater than 0 and "targetStart + length" must be less than or equal to length of "target".
-   *
-   * @param sourceStart the index of the first character in the source array to copy
-   * @param target the destination array
-   * @param targetStart the start offset in the target array
-   * @param length the number of characters to copy
-   * @return the number of characters actually copied
-   * @throws XMLStreamException if the underlying XML source is not well-formed
-   * @throws IndexOutOfBoundsException if targetStart < 0 or > than the length of target
-   * @throws IndexOutOfBoundsException if length < 0 or targetStart + length > length of target
-   * @throws UnsupportedOperationException if this method is not supported
-   * @throws NullPointerException is if target is null
-   */
-   public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length)
-     throws XMLStreamException;
-
-  /**
-   * Gets the text associated with a CHARACTERS, SPACE or CDATA event.  Allows the underlying
-   * implementation to return the text as a stream of characters.  The reference to the
-   * Reader returned by this method is only valid until next() is called.
-   *
-   * All characters must have been checked for well-formedness.
-   *
-   * <p> This method is optional and will throw UnsupportedOperationException if it is not supported.
-   * @throws UnsupportedOperationException if this method is not supported
-   * @throws IllegalStateException if this is not a valid text state
-   */
-  //public Reader getTextStream();
-
-  /**
-   * Returns the offset into the text character array where the first
-   * character (of this text event) is stored.
-   * @throws java.lang.IllegalStateException if this state is not
-   * a valid text state.
-   */
-  public int getTextStart();
-
-  /**
-   * Returns the length of the sequence of characters for this
-   * Text event within the text character array.
-   * @throws java.lang.IllegalStateException if this state is not
-   * a valid text state.
-   */
-  public int getTextLength();
-
-  /**
-   * Return input encoding if known or null if unknown.
-   * @return the encoding of this instance or null
-   */
-  public String getEncoding();
-
-  /**
-   * Return true if the current event has text, false otherwise
-   * The following events have text:
-   * CHARACTERS,DTD ,ENTITY_REFERENCE, COMMENT, SPACE
-   */
-  public boolean hasText();
-
-  /**
-   * Return the current location of the processor.
-   * If the Location is unknown the processor should return
-   * an implementation of Location that returns -1 for the
-   * location and null for the publicId and systemId.
-   * The location information is only valid until next() is
-   * called.
-   */
-  public Location getLocation();
-
-  /**
-   * Returns a QName for the current START_ELEMENT or END_ELEMENT event
-   * @return the QName for the current START_ELEMENT or END_ELEMENT event
-   * @throws IllegalStateException if this is not a START_ELEMENT or
-   * END_ELEMENT
-   */
-  public QName getName();
-
-  /**
-   * Returns the (local) name of the current event.
-   * For START_ELEMENT or END_ELEMENT returns the (local) name of the current element.
-   * For ENTITY_REFERENCE it returns entity name.
-   * The current event must be START_ELEMENT or END_ELEMENT,
-   * or ENTITY_REFERENCE
-   * @return the localName
-   * @throws IllegalStateException if this not a START_ELEMENT,
-   * END_ELEMENT or ENTITY_REFERENCE
-   */
-  public String getLocalName();
-
-  /**
-   * returns true if the current event has a name (is a START_ELEMENT or END_ELEMENT)
-   * returns false otherwise
-   */
-  public boolean hasName();
-
-  /**
-   * If the current event is a START_ELEMENT or END_ELEMENT  this method
-   * returns the URI of the prefix or the default namespace.
-   * Returns null if the event does not have a prefix.
-   * @return the URI bound to this elements prefix, the default namespace, or null
-   */
-  public String getNamespaceURI();
-
-  /**
-   * Returns the prefix of the current event or null if the event does not have a prefix
-   * @return the prefix or null
-   */
-  public String getPrefix();
-
-  /**
-   * Get the xml version declared on the xml declaration
-   * Returns null if none was declared
-   * @return the XML version or null
-   */
-  public String getVersion();
-
-  /**
-   * Get the standalone declaration from the xml declaration
-   * @return true if this is standalone, or false otherwise
-   */
-  public boolean isStandalone();
-
-  /**
-   * Checks if standalone was set in the document
-   * @return true if standalone was set in the document, or false otherwise
-   */
-  public boolean standaloneSet();
-
-  /**
-   * Returns the character encoding declared on the xml declaration
-   * Returns null if none was declared
-   * @return the encoding declared in the document or null
-   */
-  public String getCharacterEncodingScheme();
-
-  /**
-   * Get the target of a processing instruction
-   * @return the target or null
-   */
-  public String getPITarget();
-
-  /**
-   * Get the data section of a processing instruction
-   * @return the data or null
-   */
-  public String getPIData();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamWriter.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamWriter.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamWriter.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamWriter.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,528 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-import javax.xml.namespace.NamespaceContext;
-
-/**
- * The XMLStreamWriter interface specifies how to write XML.  The XMLStreamWriter  does
- * not perform well formedness checking on its input.  However
- * the writeCharacters method is required to escape &amp; , &lt; and &gt;
- * For attribute values the writeAttribute method will escape the
- * above characters plus &quot; to ensure that all character content
- * and attribute values are well formed.
- *
- * Each NAMESPACE
- * and ATTRIBUTE must be individually written.
- *
- * <table border="1" cellpadding="2" cellspacing="0">
- *     <thead>
- *         <tr>
- *             <th colspan="5">XML Namespaces, <code>javax.xml.stream.isRepairingNamespaces</code> and write method behaviour</th>
- *         </tr>
- *         <tr>
- *             <th>Method</th> <!-- method -->
- *             <th colspan="2"><code>isRepairingNamespaces</code> == true</th>
- *             <th colspan="2"><code>isRepairingNamespaces</code> == false</th>
- *         </tr>
- *         <tr>
- *             <th></th> <!-- method -->
- *             <th>namespaceURI bound</th>
- *             <th>namespaceURI unbound</th>
- *             <th>namespaceURI bound</th>
- *             <th>namespaceURI unbound</th>
- *         </tr>
- *     </thead>
- *
- *     <tbody>
- *         <tr>
- *             <th><code>writeAttribute(namespaceURI, localName, value)</code></th>
- *             <!-- isRepairingNamespaces == true -->
- *             <td>
- *                 <!-- namespaceURI bound -->
- *                 prefix:localName="value"&nbsp;<sup>[1]</sup>
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 xmlns:{generated}="namespaceURI" {generated}:localName="value"
- *             </td>
- *             <!-- isRepairingNamespaces == false -->
- *             <td>
- *                 <!-- namespaceURI bound -->
- *                 prefix:localName="value"&nbsp;<sup>[1]</sup>
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 <code>XMLStreamException</code>
- *             </td>
- *         </tr>
- *
- *         <tr>
- *             <th><code>writeAttribute(prefix, namespaceURI, localName, value)</code></th>
- *             <!-- isRepairingNamespaces == true -->
- *             <td>
- *                 <!-- namespaceURI bound -->
- *                 bound to same prefix:<br />
- *                 prefix:localName="value"&nbsp;<sup>[1]</sup><br />
- *                 <br />
- *                 bound to different prefix:<br />
- *                 xmlns:{generated}="namespaceURI" {generated}:localName="value"
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 xmlns:prefix="namespaceURI" prefix:localName="value"&nbsp;<sup>[3]</sup>
- *             </td>
- *             <!-- isRepairingNamespaces == false -->
- *             <td>
- *                 <!-- namespaceURI bound -->
- *                 bound to same prefix:<br />
- *                 prefix:localName="value"&nbsp;<sup>[1][2]</sup><br />
- *                 <br />
- *                 bound to different prefix:<br />
- *                 <code>XMLStreamException</code><sup>[2]</sup>
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 xmlns:prefix="namespaceURI" prefix:localName="value"&nbsp;<sup>[2][5]</sup>
- *             </td>
- *         </tr>
- *
- *         <tr>
- *             <th><code>writeStartElement(namespaceURI, localName)</code><br />
- *                 <br />
- *                 <code>writeEmptyElement(namespaceURI, localName)</code></th>
- *             <!-- isRepairingNamespaces == true -->
- *             <td >
- *                 <!-- namespaceURI bound -->
- *                 &lt;prefix:localName&gt;&nbsp;<sup>[1]</sup>
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 &lt;{generated}:localName xmlns:{generated}="namespaceURI"&gt;
- *             </td>
- *             <!-- isRepairingNamespaces == false -->
- *             <td>
- *                 <!-- namespaceURI bound -->
- *                 &lt;prefix:localName&gt;&nbsp;<sup>[1]</sup>
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 <code>XMLStreamException</code>
- *             </td>
- *         </tr>
- *
- *         <tr>
- *             <th><code>writeStartElement(prefix, localName, namespaceURI)</code><br />
- *                 <br />
- *                 <code>writeEmptyElement(prefix, localName, namespaceURI)</code></th>
- *             <!-- isRepairingNamespaces == true -->
- *             <td>
- *                 <!-- namespaceURI bound -->
- *                 bound to same prefix:<br />
- *                 &lt;prefix:localName&gt;&nbsp;<sup>[1]</sup><br />
- *                 <br />
- *                 bound to different prefix:<br />
- *                 &lt;{generated}:localName xmlns:{generated}="namespaceURI"&gt;
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 &lt;prefix:localName xmlns:prefix="namespaceURI"&gt;&nbsp;<sup>[4]</sup>
- *             </td>
- *             <!-- isRepairingNamespaces == false -->
- *             <td>
- *                 <!-- namespaceURI bound -->
- *                 bound to same prefix:<br />
- *                 &lt;prefix:localName&gt;&nbsp;<sup>[1]</sup><br />
- *                 <br />
- *                 bound to different prefix:<br />
- *                 <code>XMLStreamException</code>
- *             </td>
- *             <td>
- *                 <!-- namespaceURI unbound -->
- *                 &lt;prefix:localName&gt;&nbsp;
- *             </td>
- *         </tr>
- *     </tbody>
- *     <tfoot>
- *         <tr>
- *             <td colspan="5">
- *                 Notes:
- *                 <ul>
- *                     <li>[1] if namespaceURI == default Namespace URI, then no prefix is written</li>
- *                     <li>[2] if prefix == "" || null && namespaceURI == "", then no prefix or Namespace declaration is generated or written</li>
- *                     <li>[3] if prefix == "" || null, then a prefix is randomly generated</li>
- *                     <li>[4] if prefix == "" || null, then it is treated as the default Namespace and no prefix is generated or written, an xmlns declaration is generated and written if the namespaceURI is unbound</li>
- *                     <li>[5] if prefix == "" || null, then it is treated as an invalid attempt to define the default Namespace and an XMLStreamException is thrown</li>
- *                 </ul>
- *             </td>
- *         </tr>
- *     </tfoot>
- * </table>
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLOutputFactory
- * @see XMLStreamReader
- * @since 1.6
- */
-public interface XMLStreamWriter {
-
-  /**
-   * Writes a start tag to the output.  All writeStartElement methods
-   * open a new scope in the internal namespace context.  Writing the
-   * corresponding EndElement causes the scope to be closed.
-   * @param localName local name of the tag, may not be null
-   * @throws XMLStreamException
-   */
-  public void writeStartElement(String localName)
-    throws XMLStreamException;
-
-  /**
-   * Writes a start tag to the output
-   * @param namespaceURI the namespaceURI of the prefix to use, may not be null
-   * @param localName local name of the tag, may not be null
-   * @throws XMLStreamException if the namespace URI has not been bound to a prefix and
-   * javax.xml.stream.isRepairingNamespaces has not been set to true
-   */
-  public void writeStartElement(String namespaceURI, String localName)
-    throws XMLStreamException;
-
-  /**
-   * Writes a start tag to the output
-   * @param localName local name of the tag, may not be null
-   * @param prefix the prefix of the tag, may not be null
-   * @param namespaceURI the uri to bind the prefix to, may not be null
-   * @throws XMLStreamException
-   */
-  public void writeStartElement(String prefix,
-                                String localName,
-                                String namespaceURI)
-    throws XMLStreamException;
-
-  /**
-   * Writes an empty element tag to the output
-   * @param namespaceURI the uri to bind the tag to, may not be null
-   * @param localName local name of the tag, may not be null
-   * @throws XMLStreamException if the namespace URI has not been bound to a prefix and
-   * javax.xml.stream.isRepairingNamespaces has not been set to true
-   */
-  public void writeEmptyElement(String namespaceURI, String localName)
-    throws XMLStreamException;
-
-  /**
-   * Writes an empty element tag to the output
-   * @param prefix the prefix of the tag, may not be null
-   * @param localName local name of the tag, may not be null
-   * @param namespaceURI the uri to bind the tag to, may not be null
-   * @throws XMLStreamException
-   */
-  public void writeEmptyElement(String prefix, String localName, String namespaceURI)
-    throws XMLStreamException;
-
-  /**
-   * Writes an empty element tag to the output
-   * @param localName local name of the tag, may not be null
-   * @throws XMLStreamException
-   */
-  public void writeEmptyElement(String localName)
-    throws XMLStreamException;
-
-  /**
-   * Writes string data to the output without checking for well formedness.
-   * The data is opaque to the XMLStreamWriter, i.e. the characters are written
-   * blindly to the underlying output.  If the method cannot be supported
-   * in the currrent writing context the implementation may throw a
-   * UnsupportedOperationException.  For example note that any
-   * namespace declarations, end tags, etc. will be ignored and could
-   * interfere with proper maintanence of the writers internal state.
-   *
-   * @param data the data to write
-   */
-  //  public void writeRaw(String data) throws XMLStreamException;
-
-  /**
-   * Writes an end tag to the output relying on the internal
-   * state of the writer to determine the prefix and local name
-   * of the event.
-   * @throws XMLStreamException
-   */
-  public void writeEndElement()
-    throws XMLStreamException;
-
-  /**
-   * Closes any start tags and writes corresponding end tags.
-   * @throws XMLStreamException
-   */
-  public void writeEndDocument()
-    throws XMLStreamException;
-
-  /**
-   * Close this writer and free any resources associated with the
-   * writer.  This must not close the underlying output stream.
-   * @throws XMLStreamException
-   */
-  public void close()
-    throws XMLStreamException;
-
-  /**
-   * Write any cached data to the underlying output mechanism.
-   * @throws XMLStreamException
-   */
-  public void flush()
-    throws XMLStreamException;
-
-  /**
-   * Writes an attribute to the output stream without
-   * a prefix.
-   * @param localName the local name of the attribute
-   * @param value the value of the attribute
-   * @throws IllegalStateException if the current state does not allow Attribute writing
-   * @throws XMLStreamException
-   */
-  public void writeAttribute(String localName, String value)
-    throws XMLStreamException;
-
-  /**
-   * Writes an attribute to the output stream
-   * @param prefix the prefix for this attribute
-   * @param namespaceURI the uri of the prefix for this attribute
-   * @param localName the local name of the attribute
-   * @param value the value of the attribute
-   * @throws IllegalStateException if the current state does not allow Attribute writing
-   * @throws XMLStreamException if the namespace URI has not been bound to a prefix and
-   * javax.xml.stream.isRepairingNamespaces has not been set to true
-   */
-
-  public void writeAttribute(String prefix,
-                             String namespaceURI,
-                             String localName,
-                             String value)
-    throws XMLStreamException;
-
-  /**
-   * Writes an attribute to the output stream
-   * @param namespaceURI the uri of the prefix for this attribute
-   * @param localName the local name of the attribute
-   * @param value the value of the attribute
-   * @throws IllegalStateException if the current state does not allow Attribute writing
-   * @throws XMLStreamException if the namespace URI has not been bound to a prefix and
-   * javax.xml.stream.isRepairingNamespaces has not been set to true
-   */
-  public void writeAttribute(String namespaceURI,
-                             String localName,
-                             String value)
-    throws XMLStreamException;
-
-  /**
-   * Writes a namespace to the output stream
-   * If the prefix argument to this method is the empty string,
-   * "xmlns", or null this method will delegate to writeDefaultNamespace
-   *
-   * @param prefix the prefix to bind this namespace to
-   * @param namespaceURI the uri to bind the prefix to
-   * @throws IllegalStateException if the current state does not allow Namespace writing
-   * @throws XMLStreamException
-   */
-  public void writeNamespace(String prefix, String namespaceURI)
-    throws XMLStreamException;
-
-  /**
-   * Writes the default namespace to the stream
-   * @param namespaceURI the uri to bind the default namespace to
-   * @throws IllegalStateException if the current state does not allow Namespace writing
-   * @throws XMLStreamException
-   */
-  public void writeDefaultNamespace(String namespaceURI)
-    throws XMLStreamException;
-
-  /**
-   * Writes an xml comment with the data enclosed
-   * @param data the data contained in the comment, may be null
-   * @throws XMLStreamException
-   */
-  public void writeComment(String data)
-    throws XMLStreamException;
-
-  /**
-   * Writes a processing instruction
-   * @param target the target of the processing instruction, may not be null
-   * @throws XMLStreamException
-   */
-  public void writeProcessingInstruction(String target)
-    throws XMLStreamException;
-
-  /**
-   * Writes a processing instruction
-   * @param target the target of the processing instruction, may not be null
-   * @param data the data contained in the processing instruction, may not be null
-   * @throws XMLStreamException
-   */
-  public void writeProcessingInstruction(String target,
-                                         String data)
-    throws XMLStreamException;
-
-  /**
-   * Writes a CData section
-   * @param data the data contained in the CData Section, may not be null
-   * @throws XMLStreamException
-   */
-  public void writeCData(String data)
-    throws XMLStreamException;
-
-  /**
-   * Write a DTD section.  This string represents the entire doctypedecl production
-   * from the XML 1.0 specification.
-   *
-   * @param dtd the DTD to be written
-   * @throws XMLStreamException
-   */
-  public void writeDTD(String dtd)
-    throws XMLStreamException;
-
-  /**
-   * Writes an entity reference
-   * @param name the name of the entity
-   * @throws XMLStreamException
-   */
-  public void writeEntityRef(String name)
-    throws XMLStreamException;
-
-  /**
-   * Write the XML Declaration. Defaults the XML version to 1.0, and the encoding to utf-8
-   * @throws XMLStreamException
-   */
-  public void writeStartDocument()
-    throws XMLStreamException;
-
-  /**
-   * Write the XML Declaration. Defaults the XML version to 1.0
-   * @param version version of the xml document
-   * @throws XMLStreamException
-   */
-  public void writeStartDocument(String version)
-    throws XMLStreamException;
-
-  /**
-   * Write the XML Declaration.  Note that the encoding parameter does
-   * not set the actual encoding of the underlying output.  That must
-   * be set when the instance of the XMLStreamWriter is created using the
-   * XMLOutputFactory
-   * @param encoding encoding of the xml declaration
-   * @param version version of the xml document
-   * @throws XMLStreamException If given encoding does not match encoding
-   * of the underlying stream
-   */
-  public void writeStartDocument(String encoding,
-                                 String version)
-    throws XMLStreamException;
-
-  /**
-   * Write text to the output
-   * @param text the value to write
-   * @throws XMLStreamException
-   */
-  public void writeCharacters(String text)
-    throws XMLStreamException;
-
-  /**
-   * Write text to the output
-   * @param text the value to write
-   * @param start the starting position in the array
-   * @param len the number of characters to write
-   * @throws XMLStreamException
-   */
-  public void writeCharacters(char[] text, int start, int len)
-    throws XMLStreamException;
-
-  /**
-   * Gets the prefix the uri is bound to
-   * @return the prefix or null
-   * @throws XMLStreamException
-   */
-  public String getPrefix(String uri)
-    throws XMLStreamException;
-
-  /**
-   * Sets the prefix the uri is bound to.  This prefix is bound
-   * in the scope of the current START_ELEMENT / END_ELEMENT pair.
-   * If this method is called before a START_ELEMENT has been written
-   * the prefix is bound in the root scope.
-   * @param prefix the prefix to bind to the uri, may not be null
-   * @param uri the uri to bind to the prefix, may be null
-   * @throws XMLStreamException
-   */
-  public void setPrefix(String prefix, String uri)
-    throws XMLStreamException;
-
-
-  /**
-   * Binds a URI to the default namespace
-   * This URI is bound
-   * in the scope of the current START_ELEMENT / END_ELEMENT pair.
-   * If this method is called before a START_ELEMENT has been written
-   * the uri is bound in the root scope.
-   * @param uri the uri to bind to the default namespace, may be null
-   * @throws XMLStreamException
-   */
-  public void setDefaultNamespace(String uri)
-    throws XMLStreamException;
-
-  /**
-   * Sets the current namespace context for prefix and uri bindings.
-   * This context becomes the root namespace context for writing and
-   * will replace the current root namespace context.  Subsequent calls
-   * to setPrefix and setDefaultNamespace will bind namespaces using
-   * the context passed to the method as the root context for resolving
-   * namespaces.  This method may only be called once at the start of
-   * the document.  It does not cause the namespaces to be declared.
-   * If a namespace URI to prefix mapping is found in the namespace
-   * context it is treated as declared and the prefix may be used
-   * by the StreamWriter.
-   * @param context the namespace context to use for this writer, may not be null
-   * @throws XMLStreamException
-   */
-  public void setNamespaceContext(NamespaceContext context)
-    throws XMLStreamException;
-
-  /**
-   * Returns the current namespace context.
-   * @return the current NamespaceContext
-   */
-  public NamespaceContext getNamespaceContext();
-
-  /**
-   * Get the value of a feature/property from the underlying implementation
-   * @param name The name of the property, may not be null
-   * @return The value of the property
-   * @throws IllegalArgumentException if the property is not supported
-   * @throws NullPointerException if the name is null
-   */
-  public Object getProperty(java.lang.String name) throws IllegalArgumentException;
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLOutputFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLOutputFactory.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLOutputFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLOutputFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,358 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009, 2013, by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-import javax.xml.transform.Result;
-
-/**
- * Defines an abstract implementation of a factory for
- * getting XMLEventWriters and XMLStreamWriters.
- *
- * The following table defines the standard properties of this specification.
- * Each property varies in the level of support required by each implementation.
- * The level of support required is described in the 'Required' column.
- *
- *     <table border="2" rules="all" cellpadding="4">
- *     <thead>
- *      <tr>
- *        <th align="center" colspan="2">
- *          Configuration parameters
- *        </th>
- *      </tr>
- *    </thead>
- *    <tbody>
- *      <tr>
- *        <th>Property Name</th>
- *        <th>Behavior</th>
- *        <th>Return type</th>
- *        <th>Default Value</th>
- *        <th>Required</th>
- *              </tr>
- *         <tr><td>javax.xml.stream.isRepairingNamespaces</td><td>defaults prefixes on the output side</td><td>Boolean</td><td>False</td><td>Yes</td></tr>
- *      </tbody>
- *   </table>
- *
- * <p>The following paragraphs describe the namespace and prefix repair algorithm:</p>
- *
- * <p>The property can be set with the following code line:
- * <code>setProperty("javax.xml.stream.isRepairingNamespaces",new Boolean(true|false));</code></p>
- *
- * <p>This property specifies that the writer default namespace prefix declarations.
- * The default value is false. </p>
- *
- * <p>If a writer isRepairingNamespaces it will create a namespace declaration
- * on the current StartElement for
- * any attribute that does not
- * currently have a namespace declaration in scope.  If the StartElement
- * has a uri but no prefix specified a prefix will be assigned, if the prefix
- * has not been declared in a parent of the current StartElement it will be declared
- * on the current StartElement.  If the defaultNamespace is bound and in scope
- * and the default namespace matches the URI of the attribute or StartElement
- * QName no prefix will be assigned.</p>
- *
- * <p>If an element or attribute name has a prefix, but is not
- * bound to any namespace URI, then the prefix will be removed
- * during serialization.</p>
- *
- * <p>If element and/or attribute names in the same start or
- * empty-element tag are bound to different namespace URIs and
- * are using the same prefix then the element or the first
- * occurring attribute retains the original prefix and the
- * following attributes have their prefixes replaced with a
- * new prefix that is bound to the namespace URIs of those
- * attributes. </p>
- *
- * <p>If an element or attribute name uses a prefix that is
- * bound to a different URI than that inherited from the
- * namespace context of the parent of that element and there
- * is no namespace declaration in the context of the current
- * element then such a namespace declaration is added. </p>
- *
- * <p>If an element or attribute name is bound to a prefix and
- * there is a namespace declaration that binds that prefix
- * to a different URI then that namespace declaration is
- * either removed if the correct mapping is inherited from
- * the parent context of that element, or changed to the
- * namespace URI of the element or attribute using that prefix.</p>
- *
- * @version 1.2
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @see XMLInputFactory
- * @see XMLEventWriter
- * @see XMLStreamWriter
- * @since 1.6
- */
-public abstract class XMLOutputFactory {
-  /**
-   * Property used to set prefix defaulting on the output side
-   */
-  public static final String IS_REPAIRING_NAMESPACES=
-    "javax.xml.stream.isRepairingNamespaces";
-
-  static final String DEFAULIMPL = "com.sun.xml.internal.stream.XMLOutputFactoryImpl";
-
-  protected XMLOutputFactory(){}
-
-  /**
-   * Creates a new instance of the factory in exactly the same manner as the
-   * {@link #newFactory()} method.
-   * @throws FactoryConfigurationError if an instance of this factory cannot be loaded
-   */
-  public static XMLOutputFactory newInstance()
-    throws FactoryConfigurationError
-  {
-    return FactoryFinder.find(XMLOutputFactory.class, DEFAULIMPL);
-  }
-
-  /**
-   * Create a new instance of the factory.
-   * <p>
-   * This static method creates a new factory instance. This method uses the
-   * following ordered lookup procedure to determine the XMLOutputFactory
-   * implementation class to load:
-   * </p>
-   * <ul>
-   * <li>
-   *   Use the javax.xml.stream.XMLOutputFactory system property.
-   * </li>
-   * <li>
-   *   Use the properties file "lib/stax.properties" in the JRE directory.
-   *     This configuration file is in standard java.util.Properties format
-   *     and contains the fully qualified name of the implementation class
-   *     with the key being the system property defined above.
-   * </li>
-   * <li>
-   *   Use the service-provider loading facilities, defined by the
-   *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-   *   implementation of the service using the {@linkplain
-   *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-   *   the service-provider loading facility will use the {@linkplain
-   *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-   *   to attempt to load the service. If the context class
-   *   loader is null, the {@linkplain
-   *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-   * </li>
-   * <li>
-   *   Otherwise, the system-default implementation is returned.
-   * </li>
-   * <p>
-   * Once an application has obtained a reference to a XMLOutputFactory it
-   * can use the factory to configure and obtain stream instances.
-   * </p>
-   * <p>
-   * Note that this is a new method that replaces the deprecated newInstance() method.
-   *   No changes in behavior are defined by this replacement method relative to the
-   *   deprecated method.
-   * </p>
-   * @throws FactoryConfigurationError in case of {@linkplain
-   *   java.util.ServiceConfigurationError service configuration error} or if
-   *   the implementation is not available or cannot be instantiated.
-   */
-  public static XMLOutputFactory newFactory()
-    throws FactoryConfigurationError
-  {
-    return FactoryFinder.find(XMLOutputFactory.class, DEFAULIMPL);
-  }
-
-  /**
-   * Create a new instance of the factory.
-   *
-   * @param factoryId             Name of the factory to find, same as
-   *                              a property name
-   * @param classLoader           classLoader to use
-   * @return the factory implementation
-   * @throws FactoryConfigurationError if an instance of this factory cannot be loaded
-   *
-   * @deprecated  This method has been deprecated because it returns an
-   *              instance of XMLInputFactory, which is of the wrong class.
-   *              Use the new method {@link #newFactory(java.lang.String,
-   *              java.lang.ClassLoader)} instead.
-   */
-  public static XMLInputFactory newInstance(String factoryId,
-          ClassLoader classLoader)
-          throws FactoryConfigurationError {
-      //do not fallback if given classloader can't find the class, throw exception
-      return FactoryFinder.find(XMLInputFactory.class, factoryId, classLoader, null);
-  }
-
-  /**
-   * Create a new instance of the factory.
-   * If the classLoader argument is null, then the ContextClassLoader is used.
-   * <p>
-   * This method uses the following ordered lookup procedure to determine
-   * the XMLOutputFactory implementation class to load:
-   * </p>
-   * <ul>
-   * <li>
-   *   Use the value of the system property identified by {@code factoryId}.
-   * </li>
-   * <li>
-   *   Use the properties file "lib/stax.properties" in the JRE directory.
-   *     This configuration file is in standard java.util.Properties format
-   *     and contains the fully qualified name of the implementation class
-   *     with the key being the given {@code factoryId}.
-   * </li>
-   * <li>
-   *   If {@code factoryId} is "javax.xml.stream.XMLOutputFactory",
-   *   use the service-provider loading facilities, defined by the
-   *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-   *   implementation of the service using the specified {@code ClassLoader}.
-   *   If {@code classLoader} is null, the {@linkplain
-   *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism} will apply:
-   *   That is, the service-provider loading facility will use the {@linkplain
-   *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-   *   to attempt to load the service. If the context class
-   *   loader is null, the {@linkplain
-   *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-   * </li>
-   * <li>
-   *   Otherwise, throws a {@link FactoryConfigurationError}.
-   * </li>
-   * </ul>
-   *
-   * @apiNote The parameter factoryId defined here is inconsistent with that
-   * of other JAXP factories where the first parameter is fully qualified
-   * factory class name that provides implementation of the factory.
-   *
-   * <p>
-   *   Note that this is a new method that replaces the deprecated
-   *   {@link #newInstance(java.lang.String, java.lang.ClassLoader)
-   *   newInstance(String factoryId, ClassLoader classLoader)} method.
-   *   The original method was incorrectly defined to return XMLInputFactory.
-   * </p>
-   *
-   * @param factoryId             Name of the factory to find, same as
-   *                              a property name
-   * @param classLoader           classLoader to use
-   * @return the factory implementation
-   * @throws FactoryConfigurationError in case of {@linkplain
-   *   java.util.ServiceConfigurationError service configuration error} or if
-   *   the implementation is not available or cannot be instantiated.
-   */
-  public static XMLOutputFactory newFactory(String factoryId,
-          ClassLoader classLoader)
-          throws FactoryConfigurationError {
-      //do not fallback if given classloader can't find the class, throw exception
-      return FactoryFinder.find(XMLOutputFactory.class, factoryId, classLoader, null);
-  }
-
-  /**
-   * Create a new XMLStreamWriter that writes to a writer
-   * @param stream the writer to write to
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamWriter createXMLStreamWriter(java.io.Writer stream) throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamWriter that writes to a stream
-   * @param stream the stream to write to
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamWriter createXMLStreamWriter(java.io.OutputStream stream) throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamWriter that writes to a stream
-   * @param stream the stream to write to
-   * @param encoding the encoding to use
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamWriter createXMLStreamWriter(java.io.OutputStream stream,
-                                         String encoding) throws XMLStreamException;
-
-  /**
-   * Create a new XMLStreamWriter that writes to a JAXP result.  This method is optional.
-   * @param result the result to write to
-   * @throws UnsupportedOperationException if this method is not
-   * supported by this XMLOutputFactory
-   * @throws XMLStreamException
-   */
-  public abstract XMLStreamWriter createXMLStreamWriter(Result result) throws XMLStreamException;
-
-
-  /**
-   * Create a new XMLEventWriter that writes to a JAXP result.  This method is optional.
-   * @param result the result to write to
-   * @throws UnsupportedOperationException if this method is not
-   * supported by this XMLOutputFactory
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventWriter createXMLEventWriter(Result result) throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventWriter that writes to a stream
-   * @param stream the stream to write to
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventWriter createXMLEventWriter(java.io.OutputStream stream) throws XMLStreamException;
-
-
-
-  /**
-   * Create a new XMLEventWriter that writes to a stream
-   * @param stream the stream to write to
-   * @param encoding the encoding to use
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventWriter createXMLEventWriter(java.io.OutputStream stream,
-                                                     String encoding) throws XMLStreamException;
-
-  /**
-   * Create a new XMLEventWriter that writes to a writer
-   * @param stream the stream to write to
-   * @throws XMLStreamException
-   */
-  public abstract XMLEventWriter createXMLEventWriter(java.io.Writer stream) throws XMLStreamException;
-
-  /**
-   * Allows the user to set specific features/properties on the underlying implementation.
-   * @param name The name of the property
-   * @param value The value of the property
-   * @throws java.lang.IllegalArgumentException if the property is not supported
-   */
-  public abstract void setProperty(java.lang.String name,
-                                    Object value)
-    throws IllegalArgumentException;
-
-  /**
-   * Get a feature/property on the underlying implementation
-   * @param name The name of the property
-   * @return The value of the property
-   * @throws java.lang.IllegalArgumentException if the property is not supported
-   */
-  public abstract Object getProperty(java.lang.String name)
-    throws IllegalArgumentException;
-
-  /**
-   * Query the set of properties that this factory supports.
-   *
-   * @param name The name of the property (may not be null)
-   * @return true if the property is supported and false otherwise
-   */
-  public abstract boolean isPropertySupported(String name);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamConstants.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamConstants.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamConstants.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamConstants.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,139 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.stream;
-
-import javax.xml.stream.events.Attribute;
-import javax.xml.stream.events.Characters;
-import javax.xml.stream.events.Comment;
-import javax.xml.stream.events.EndDocument;
-import javax.xml.stream.events.EndElement;
-import javax.xml.stream.events.EntityReference;
-import javax.xml.stream.events.Namespace;
-import javax.xml.stream.events.NotationDeclaration;
-import javax.xml.stream.events.ProcessingInstruction;
-import javax.xml.stream.events.StartDocument;
-import javax.xml.stream.events.StartElement;
-
-/**
- * This interface declares the constants used in this API.
- * Numbers in the range 0 to 256 are reserved for the specification,
- * user defined events must use event codes outside that range.
- *
- * @since 1.6
- */
-
-public interface XMLStreamConstants {
-  /**
-   * Indicates an event is a start element
-   * @see StartElement
-   */
-  public static final int START_ELEMENT=1;
-  /**
-   * Indicates an event is an end element
-   * @see EndElement
-   */
-  public static final int END_ELEMENT=2;
-  /**
-   * Indicates an event is a processing instruction
-   * @see ProcessingInstruction
-   */
-  public static final int PROCESSING_INSTRUCTION=3;
-
-  /**
-   * Indicates an event is characters
-   * @see Characters
-   */
-  public static final int CHARACTERS=4;
-
-  /**
-   * Indicates an event is a comment
-   * @see Comment
-   */
-  public static final int COMMENT=5;
-
-  /**
-   * The characters are white space
-   * (see [XML], 2.10 "White Space Handling").
-   * Events are only reported as SPACE if they are ignorable white
-   * space.  Otherwise they are reported as CHARACTERS.
-   * @see Characters
-   */
-  public static final int SPACE=6;
-
-  /**
-   * Indicates an event is a start document
-   * @see StartDocument
-   */
-  public static final int START_DOCUMENT=7;
-
-  /**
-   * Indicates an event is an end document
-   * @see EndDocument
-   */
-  public static final int END_DOCUMENT=8;
-
-  /**
-   * Indicates an event is an entity reference
-   * @see EntityReference
-   */
-  public static final int ENTITY_REFERENCE=9;
-
-  /**
-   * Indicates an event is an attribute
-   * @see Attribute
-   */
-  public static final int ATTRIBUTE=10;
-
-  /**
-   * Indicates an event is a DTD
-   * @see javax.xml.stream.events.DTD
-   */
-  public static final int DTD=11;
-
-  /**
-   * Indicates an event is a CDATA section
-   * @see Characters
-   */
-  public static final int CDATA=12;
-
-  /**
-   * Indicates the event is a namespace declaration
-   *
-   * @see Namespace
-   */
-  public static final int NAMESPACE=13;
-
-  /**
-   * Indicates a Notation
-   * @see NotationDeclaration
-   */
-  public static final int NOTATION_DECLARATION=14;
-
-  /**
-   * Indicates a Entity Declaration
-   * @see NotationDeclaration
-   */
-  public static final int ENTITY_DECLARATION=15;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamException.java b/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/XMLStreamException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,130 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-/**
- * The base exception for unexpected processing errors.  This Exception
- * class is used to report well-formedness errors as well as unexpected
- * processing conditions.
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-
-public class XMLStreamException extends Exception {
-
-  protected Throwable nested;
-  protected Location location;
-
-  /**
-   * Default constructor
-   */
-  public XMLStreamException(){
-    super();
-  }
-
-  /**
-   * Construct an exception with the assocated message.
-   *
-   * @param msg the message to report
-   */
-  public XMLStreamException(String msg) {
-    super(msg);
-  }
-
-  /**
-   * Construct an exception with the assocated exception
-   *
-   * @param th a nested exception
-   */
-  public XMLStreamException(Throwable th) {
-      super(th);
-    nested = th;
-  }
-
-  /**
-   * Construct an exception with the assocated message and exception
-   *
-   * @param th a nested exception
-   * @param msg the message to report
-   */
-  public XMLStreamException(String msg, Throwable th) {
-    super(msg, th);
-    nested = th;
-  }
-
-  /**
-   * Construct an exception with the assocated message, exception and location.
-   *
-   * @param th a nested exception
-   * @param msg the message to report
-   * @param location the location of the error
-   */
-  public XMLStreamException(String msg, Location location, Throwable th) {
-    super("ParseError at [row,col]:["+location.getLineNumber()+","+
-          location.getColumnNumber()+"]\n"+
-          "Message: "+msg);
-    nested = th;
-    this.location = location;
-  }
-
-  /**
-   * Construct an exception with the assocated message, exception and location.
-   *
-   * @param msg the message to report
-   * @param location the location of the error
-   */
-  public XMLStreamException(String msg,
-                            Location location) {
-    super("ParseError at [row,col]:["+location.getLineNumber()+","+
-          location.getColumnNumber()+"]\n"+
-          "Message: "+msg);
-    this.location = location;
-  }
-
-
-  /**
-   * Gets the nested exception.
-   *
-   * @return Nested exception
-   */
-  public Throwable getNestedException() {
-    return nested;
-  }
-
-  /**
-   * Gets the location of the exception
-   *
-   * @return the location of the exception, may be null if none is available
-   */
-  public Location getLocation() {
-    return location;
-  }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/stream/FactoryConfigurationError.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/stream/FactoryConfigurationError.java b/Build/src/main/java/org/openjdk/javax/xml/stream/FactoryConfigurationError.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/stream/FactoryConfigurationError.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,125 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- */
-
-package javax.xml.stream;
-
-/**
- * An error class for reporting factory configuration errors.
- *
- * @version 1.0
- * @author Copyright (c) 2009 by Oracle Corporation. All Rights Reserved.
- * @since 1.6
- */
-public class FactoryConfigurationError extends Error {
-    private static final long serialVersionUID = -2994412584589975744L;
-
-  Exception nested;
-
-  /**
-   * Default constructor
-   */
-  public FactoryConfigurationError(){}
-
-  /**
-   * Construct an exception with a nested inner exception
-   *
-   * @param e the exception to nest
-   */
-  public FactoryConfigurationError(java.lang.Exception e){
-    nested = e;
-  }
-
-  /**
-   * Construct an exception with a nested inner exception
-   * and a message
-   *
-   * @param e the exception to nest
-   * @param msg the message to report
-   */
-  public FactoryConfigurationError(java.lang.Exception e, java.lang.String msg){
-    super(msg);
-    nested = e;
-  }
-
-  /**
-   * Construct an exception with a nested inner exception
-   * and a message
-   *
-   * @param msg the message to report
-   * @param e the exception to nest
-   */
-  public FactoryConfigurationError(java.lang.String msg, java.lang.Exception e){
-    super(msg);
-    nested = e;
-  }
-
-  /**
-   * Construct an exception with associated message
-   *
-   * @param msg the message to report
-   */
-  public FactoryConfigurationError(java.lang.String msg) {
-    super(msg);
-  }
-
-  /**
-   * Return the nested exception (if any)
-   *
-   * @return the nested exception or null
-   */
-  public Exception getException() {
-    return nested;
-  }
-    /**
-     * use the exception chaining mechanism of JDK1.4
-    */
-    @Override
-    public Throwable getCause() {
-        return nested;
-    }
-
-  /**
-   * Report the message associated with this error
-   *
-   * @return the string value of the message
-   */
-  public String getMessage() {
-    String msg = super.getMessage();
-    if(msg != null)
-      return msg;
-    if(nested != null){
-      msg = nested.getMessage();
-      if(msg == null)
-        msg = nested.getClass().toString();
-    }
-    return msg;
-  }
-
-
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/package.html b/Build/src/main/java/org/openjdk/javax/xml/parsers/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>javax.xml.parsers</title>
-
-  <meta name="CVS"
-        content="$Id: package.html,v 1.2 2005/06/10 03:50:29 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-<body>
-	<p>
-		Provides classes allowing the processing of XML documents. Two types
-		of plugable parsers are supported:
-	</p>
-	<ul>
-		<li>SAX (Simple API for XML)</li>
-		<li>DOM (Document Object Model)</li>
-	</ul>
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParser.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParser.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParser.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParser.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,556 +0,0 @@
-/*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-
-import javax.xml.validation.Schema;
-
-import javax.xml.XMLConstants;
-import org.xml.sax.HandlerBase;
-import org.xml.sax.InputSource;
-import org.xml.sax.Parser;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXNotSupportedException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.DefaultHandler;
-
-
-/**
- * Defines the API that wraps an {@link org.xml.sax.XMLReader}
- * implementation class. In JAXP 1.0, this class wrapped the
- * {@link org.xml.sax.Parser} interface, however this interface was
- * replaced by the {@link org.xml.sax.XMLReader}. For ease
- * of transition, this class continues to support the same name
- * and interface as well as supporting new methods.
- *
- * An instance of this class can be obtained from the
- * {@link javax.xml.parsers.SAXParserFactory#newSAXParser()} method.
- * Once an instance of this class is obtained, XML can be parsed from
- * a variety of input sources. These input sources are InputStreams,
- * Files, URLs, and SAX InputSources.<p>
- *
- * This static method creates a new factory instance based
- * on a system property setting or uses the platform default
- * if no property has been defined.<p>
- *
- * The system property that controls which Factory implementation
- * to create is named <code>&quot;javax.xml.parsers.SAXParserFactory&quot;</code>.
- * This property names a class that is a concrete subclass of this
- * abstract class. If no property is defined, a platform default
- * will be used.</p>
- *
- * As the content is parsed by the underlying parser, methods of the
- * given {@link org.xml.sax.HandlerBase} or the
- * {@link org.xml.sax.helpers.DefaultHandler} are called.<p>
- *
- * Implementors of this class which wrap an underlaying implementation
- * can consider using the {@link org.xml.sax.helpers.ParserAdapter}
- * class to initially adapt their SAX1 implementation to work under
- * this revised class.
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public abstract class SAXParser {
-
-    /**
-     * <p>Protected constructor to prevent instaniation.
-     * Use {@link javax.xml.parsers.SAXParserFactory#newSAXParser()}.</p>
-     */
-    protected SAXParser () {
-
-    }
-
-        /**
-         * <p>Reset this <code>SAXParser</code> to its original configuration.</p>
-         *
-         * <p><code>SAXParser</code> is reset to the same state as when it was created with
-         * {@link javax.xml.parsers.SAXParserFactory#newSAXParser()}.
-         * <code>reset()</code> is designed to allow the reuse of existing <code>SAXParser</code>s
-         * thus saving resources associated with the creation of new <code>SAXParser</code>s.</p>
-         *
-         * <p>The reset <code>SAXParser</code> is not guaranteed to have the same {@link Schema}
-         * <code>Object</code>, e.g. {@link Object#equals(Object obj)}.  It is guaranteed to have a functionally equal
-         * <code>Schema</code>.</p>
-     *
-     * @throws UnsupportedOperationException When Implementations do not
-     *   override this method
-         *
-         * @since 1.5
-         */
-        public void reset() {
-
-                // implementors should override this method
-                throw new UnsupportedOperationException(
-                        "This SAXParser, \"" + this.getClass().getName() + "\", does not support the reset functionality."
-                        + "  Specification \"" + this.getClass().getPackage().getSpecificationTitle() + "\""
-                        + " version \"" + this.getClass().getPackage().getSpecificationVersion() + "\""
-                        );
-        }
-
-    /**
-     * <p>Parse the content of the given {@link java.io.InputStream}
-     * instance as XML using the specified {@link org.xml.sax.HandlerBase}.
-     * <i> Use of the DefaultHandler version of this method is recommended as
-     * the HandlerBase class has been deprecated in SAX 2.0</i>.</p>
-     *
-     * @param is InputStream containing the content to be parsed.
-     * @param hb The SAX HandlerBase to use.
-     *
-     * @throws IllegalArgumentException If the given InputStream is null.
-     * @throws SAXException If parse produces a SAX error.
-     * @throws IOException If an IO error occurs interacting with the
-     *   <code>InputStream</code>.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(InputStream is, HandlerBase hb)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputStream cannot be null");
-        }
-
-        InputSource input = new InputSource(is);
-        this.parse(input, hb);
-    }
-
-    /**
-     * <p>Parse the content of the given {@link java.io.InputStream}
-     * instance as XML using the specified {@link org.xml.sax.HandlerBase}.
-     * <i> Use of the DefaultHandler version of this method is recommended as
-     * the HandlerBase class has been deprecated in SAX 2.0</i>.</p>
-     *
-     * @param is InputStream containing the content to be parsed.
-     * @param hb The SAX HandlerBase to use.
-     * @param systemId The systemId which is needed for resolving relative URIs.
-     *
-     * @throws IllegalArgumentException If the given <code>InputStream</code> is
-     *   <code>null</code>.
-     * @throws IOException If any IO error occurs interacting with the
-     *   <code>InputStream</code>.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler version of this method instead.
-     */
-    public void parse(
-        InputStream is,
-        HandlerBase hb,
-        String systemId)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputStream cannot be null");
-        }
-
-        InputSource input = new InputSource(is);
-        input.setSystemId(systemId);
-        this.parse(input, hb);
-    }
-
-    /**
-     * Parse the content of the given {@link java.io.InputStream}
-     * instance as XML using the specified
-     * {@link org.xml.sax.helpers.DefaultHandler}.
-     *
-     * @param is InputStream containing the content to be parsed.
-     * @param dh The SAX DefaultHandler to use.
-     *
-     * @throws IllegalArgumentException If the given InputStream is null.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(InputStream is, DefaultHandler dh)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputStream cannot be null");
-        }
-
-        InputSource input = new InputSource(is);
-        this.parse(input, dh);
-    }
-
-    /**
-     * Parse the content of the given {@link java.io.InputStream}
-     * instance as XML using the specified
-     * {@link org.xml.sax.helpers.DefaultHandler}.
-     *
-     * @param is InputStream containing the content to be parsed.
-     * @param dh The SAX DefaultHandler to use.
-     * @param systemId The systemId which is needed for resolving relative URIs.
-     *
-     * @throws IllegalArgumentException If the given InputStream is null.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler version of this method instead.
-     */
-    public void parse(
-        InputStream is,
-        DefaultHandler dh,
-        String systemId)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputStream cannot be null");
-        }
-
-        InputSource input = new InputSource(is);
-        input.setSystemId(systemId);
-        this.parse(input, dh);
-    }
-
-    /**
-     * Parse the content described by the giving Uniform Resource
-     * Identifier (URI) as XML using the specified
-     * {@link org.xml.sax.HandlerBase}.
-     * <i> Use of the DefaultHandler version of this method is recommended as
-     * the <code>HandlerBase</code> class has been deprecated in SAX 2.0</i>
-     *
-     * @param uri The location of the content to be parsed.
-     * @param hb The SAX HandlerBase to use.
-     *
-     * @throws IllegalArgumentException If the uri is null.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(String uri, HandlerBase hb)
-        throws SAXException, IOException {
-        if (uri == null) {
-            throw new IllegalArgumentException("uri cannot be null");
-        }
-
-        InputSource input = new InputSource(uri);
-        this.parse(input, hb);
-    }
-
-    /**
-     * Parse the content described by the giving Uniform Resource
-     * Identifier (URI) as XML using the specified
-     * {@link org.xml.sax.helpers.DefaultHandler}.
-     *
-     * @param uri The location of the content to be parsed.
-     * @param dh The SAX DefaultHandler to use.
-     *
-     * @throws IllegalArgumentException If the uri is null.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(String uri, DefaultHandler dh)
-        throws SAXException, IOException {
-        if (uri == null) {
-            throw new IllegalArgumentException("uri cannot be null");
-        }
-
-        InputSource input = new InputSource(uri);
-        this.parse(input, dh);
-    }
-
-    /**
-     * Parse the content of the file specified as XML using the
-     * specified {@link org.xml.sax.HandlerBase}.
-     * <i> Use of the DefaultHandler version of this method is recommended as
-     * the HandlerBase class has been deprecated in SAX 2.0</i>
-     *
-     * @param f The file containing the XML to parse
-     * @param hb The SAX HandlerBase to use.
-     *
-     * @throws IllegalArgumentException If the File object is null.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(File f, HandlerBase hb)
-        throws SAXException, IOException {
-        if (f == null) {
-            throw new IllegalArgumentException("File cannot be null");
-        }
-
-        //convert file to appropriate URI, f.toURI().toASCIIString()
-        //converts the URI to string as per rule specified in
-        //RFC 2396,
-        InputSource input = new InputSource(f.toURI().toASCIIString());
-        this.parse(input, hb);
-    }
-
-    /**
-     * Parse the content of the file specified as XML using the
-     * specified {@link org.xml.sax.helpers.DefaultHandler}.
-     *
-     * @param f The file containing the XML to parse
-     * @param dh The SAX DefaultHandler to use.
-     *
-     * @throws IllegalArgumentException If the File object is null.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(File f, DefaultHandler dh)
-        throws SAXException, IOException {
-        if (f == null) {
-            throw new IllegalArgumentException("File cannot be null");
-        }
-
-        //convert file to appropriate URI, f.toURI().toASCIIString()
-        //converts the URI to string as per rule specified in
-        //RFC 2396,
-        InputSource input = new InputSource(f.toURI().toASCIIString());
-        this.parse(input, dh);
-    }
-
-    /**
-     * Parse the content given {@link org.xml.sax.InputSource}
-     * as XML using the specified
-     * {@link org.xml.sax.HandlerBase}.
-     * <i> Use of the DefaultHandler version of this method is recommended as
-     * the HandlerBase class has been deprecated in SAX 2.0</i>
-     *
-     * @param is The InputSource containing the content to be parsed.
-     * @param hb The SAX HandlerBase to use.
-     *
-     * @throws IllegalArgumentException If the <code>InputSource</code> object
-     *   is <code>null</code>.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(InputSource is, HandlerBase hb)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputSource cannot be null");
-        }
-
-        Parser parser = this.getParser();
-        if (hb != null) {
-            parser.setDocumentHandler(hb);
-            parser.setEntityResolver(hb);
-            parser.setErrorHandler(hb);
-            parser.setDTDHandler(hb);
-        }
-        parser.parse(is);
-    }
-
-    /**
-     * Parse the content given {@link org.xml.sax.InputSource}
-     * as XML using the specified
-     * {@link org.xml.sax.helpers.DefaultHandler}.
-     *
-     * @param is The InputSource containing the content to be parsed.
-     * @param dh The SAX DefaultHandler to use.
-     *
-     * @throws IllegalArgumentException If the <code>InputSource</code> object
-     *   is <code>null</code>.
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any SAX errors occur during processing.
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-    public void parse(InputSource is, DefaultHandler dh)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputSource cannot be null");
-        }
-
-        XMLReader reader = this.getXMLReader();
-        if (dh != null) {
-            reader.setContentHandler(dh);
-            reader.setEntityResolver(dh);
-            reader.setErrorHandler(dh);
-            reader.setDTDHandler(dh);
-        }
-        reader.parse(is);
-    }
-
-    /**
-     * Returns the SAX parser that is encapsultated by the
-     * implementation of this class.
-     *
-     * @return The SAX parser that is encapsultated by the
-     *         implementation of this class.
-     *
-     * @throws SAXException If any SAX errors occur during processing.
-     */
-    public abstract org.xml.sax.Parser getParser() throws SAXException;
-
-    /**
-     * Returns the {@link org.xml.sax.XMLReader} that is encapsulated by the
-     * implementation of this class.
-     *
-     * @return The XMLReader that is encapsulated by the
-     *         implementation of this class.
-     *
-     * @throws SAXException If any SAX errors occur during processing.
-     */
-
-    public abstract org.xml.sax.XMLReader getXMLReader() throws SAXException;
-
-    /**
-     * Indicates whether or not this parser is configured to
-     * understand namespaces.
-     *
-     * @return true if this parser is configured to
-     *         understand namespaces; false otherwise.
-     */
-
-    public abstract boolean isNamespaceAware();
-
-    /**
-     * Indicates whether or not this parser is configured to
-     * validate XML documents.
-     *
-     * @return true if this parser is configured to
-     *         validate XML documents; false otherwise.
-     */
-
-    public abstract boolean isValidating();
-
-    /**
-     * <p>Sets the particular property in the underlying implementation of
-     * {@link org.xml.sax.XMLReader}.
-     * A list of the core features and properties can be found at
-     * <a href="http://sax.sourceforge.net/?selected=get-set">
-     * http://sax.sourceforge.net/?selected=get-set</a>.</p>
-     * <p>
-     * All implementations that implement JAXP 1.5 or newer are required to
-     * support the {@link XMLConstants#ACCESS_EXTERNAL_DTD} and
-     * {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} properties.
-     * </p>
-     * <ul>
-     *   <li>
-     *      <p>
-     *      Setting the {@link XMLConstants#ACCESS_EXTERNAL_DTD} property
-     *      restricts the access to external DTDs, external Entity References to
-     *      the protocols specified by the property.  If access is denied during parsing
-     *      due to the restriction of this property, {@link org.xml.sax.SAXException}
-     *      will be thrown by the parse methods defined by {@link SAXParser}.
-     *      </p>
-     *      <p>
-     *      Setting the {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} property
-     *      restricts the access to external Schema set by the schemaLocation attribute to
-     *      the protocols specified by the property.  If access is denied during parsing
-     *      due to the restriction of this property, {@link org.xml.sax.SAXException}
-     *      will be thrown by the parse methods defined by the {@link SAXParser}.
-     *      </p>
-     *   </li>
-     * </ul>
-     *
-     * @param name The name of the property to be set.
-     * @param value The value of the property to be set.
-     *
-     * @throws SAXNotRecognizedException When the underlying XMLReader does
-     *   not recognize the property name.
-     * @throws SAXNotSupportedException When the underlying XMLReader
-     *  recognizes the property name but doesn't support the property.
-     *
-     * @see org.xml.sax.XMLReader#setProperty
-     */
-    public abstract void setProperty(String name, Object value)
-        throws SAXNotRecognizedException, SAXNotSupportedException;
-
-    /**
-     * <p>Returns the particular property requested for in the underlying
-     * implementation of {@link org.xml.sax.XMLReader}.</p>
-     *
-     * @param name The name of the property to be retrieved.
-     * @return Value of the requested property.
-     *
-     * @throws SAXNotRecognizedException When the underlying XMLReader does
-     *    not recognize the property name.
-     * @throws SAXNotSupportedException When the underlying XMLReader
-     *  recognizes the property name but doesn't support the property.
-     *
-     * @see org.xml.sax.XMLReader#getProperty
-     */
-    public abstract Object getProperty(String name)
-        throws SAXNotRecognizedException, SAXNotSupportedException;
-
-    /** <p>Get current state of canonicalization.</p>
-     *
-     * @return current state canonicalization control
-     */
-    /*
-    public boolean getCanonicalization() {
-        return canonicalState;
-    }
-    */
-
-    /** <p>Get a reference to the the {@link Schema} being used by
-     * the XML processor.</p>
-     *
-     * <p>If no schema is being used, <code>null</code> is returned.</p>
-     *
-     * @return {@link Schema} being used or <code>null</code>
-     *  if none in use
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @since 1.5
-     */
-    public Schema getSchema() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-
-    /**
-     * <p>Get the XInclude processing mode for this parser.</p>
-     *
-     * @return
-     *      the return value of
-     *      the {@link javax.xml.parsers.SAXParserFactory#isXIncludeAware()}
-     *      when this parser was created from factory.
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @since 1.5
-     *
-     * @see SAXParserFactory#setXIncludeAware(boolean)
-     */
-    public boolean isXIncludeAware() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryFinder.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryFinder.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryFinder.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryFinder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,316 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-import java.io.File;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Iterator;
-import java.util.Properties;
-import java.util.ServiceConfigurationError;
-import java.util.ServiceLoader;
-
-/**
- * <p>Implements pluggable Parsers.</p>
- *
- * <p>This class is duplicated for each JAXP subpackage so keep it in
- * sync.  It is package private for secure class loading.</p>
- *
- * @author Santiago.PericasGeertsen@sun.com
- * @author Huizhe.Wang@oracle.com
- */
-class FactoryFinder {
-    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xerces.internal";
-    /**
-     * Internal debug flag.
-     */
-    private static boolean debug = false;
-
-    /**
-     * Cache for properties in java.home/lib/jaxp.properties
-     */
-    private static final Properties cacheProps = new Properties();
-
-    /**
-     * Flag indicating if properties from java.home/lib/jaxp.properties
-     * have been cached.
-     */
-    static volatile boolean firstTime = true;
-
-    /**
-     * Security support class use to check access control before
-     * getting certain system resources.
-     */
-    private static final SecuritySupport ss = new SecuritySupport();
-
-    // Define system property "jaxp.debug" to get output
-    static {
-        // Use try/catch block to support applets, which throws
-        // SecurityException out of this code.
-        try {
-            String val = ss.getSystemProperty("jaxp.debug");
-            // Allow simply setting the prop to turn on debug
-            debug = val != null && !"false".equals(val);
-        }
-        catch (SecurityException se) {
-            debug = false;
-        }
-    }
-
-    private static void dPrint(String msg) {
-        if (debug) {
-            System.err.println("JAXP: " + msg);
-        }
-    }
-
-    /**
-     * Attempt to load a class using the class loader supplied. If that fails
-     * and fall back is enabled, the current (i.e. bootstrap) class loader is
-     * tried.
-     *
-     * If the class loader supplied is <code>null</code>, first try using the
-     * context class loader followed by the current (i.e. bootstrap) class
-     * loader.
-     *
-     * Use bootstrap classLoader if cl = null and useBSClsLoader is true
-     */
-    static private Class<?> getProviderClass(String className, ClassLoader cl,
-            boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException
-    {
-        try {
-            if (cl == null) {
-                if (useBSClsLoader) {
-                    return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-                } else {
-                    cl = ss.getContextClassLoader();
-                    if (cl == null) {
-                        throw new ClassNotFoundException();
-                    }
-                    else {
-                        return Class.forName(className, false, cl);
-                    }
-                }
-            }
-            else {
-                return Class.forName(className, false, cl);
-            }
-        }
-        catch (ClassNotFoundException e1) {
-            if (doFallback) {
-                // Use current class loader - should always be bootstrap CL
-                return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-            }
-            else {
-                throw e1;
-            }
-        }
-    }
-
-    /**
-     * Create an instance of a class. Delegates to method
-     * <code>getProviderClass()</code> in order to load the class.
-     *
-     * @param type Base class / Service interface  of the factory to
-     *             instantiate.
-     *
-     * @param className Name of the concrete class corresponding to the
-     * service provider
-     *
-     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     * current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @param doFallback True if the current ClassLoader should be tried as
-     * a fallback if the class is not found using cl
-     */
-    static <T> T newInstance(Class<T> type, String className, ClassLoader cl,
-                             boolean doFallback)
-        throws javax.xml.parsers.FactoryConfigurationError
-    {
-        return newInstance(type, className, cl, doFallback, false);
-    }
-
-    /**
-     * Create an instance of a class. Delegates to method
-     * <code>getProviderClass()</code> in order to load the class.
-     *
-     * @param type Base class / Service interface  of the factory to
-     *             instantiate.
-     *
-     * @param className Name of the concrete class corresponding to the
-     * service provider
-     *
-     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     * current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @param doFallback True if the current ClassLoader should be tried as
-     * a fallback if the class is not found using cl
-     *
-     * @param useBSClsLoader True if cl=null actually meant bootstrap classLoader. This parameter
-     * is needed since DocumentBuilderFactory/SAXParserFactory defined null as context classLoader.
-     */
-    static <T> T newInstance(Class<T> type, String className, ClassLoader cl,
-                             boolean doFallback, boolean useBSClsLoader)
-        throws javax.xml.parsers.FactoryConfigurationError
-    {
-        assert type != null;
-        // make sure we have access to restricted packages
-        if (System.getSecurityManager() != null) {
-            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
-                cl = null;
-                useBSClsLoader = true;
-            }
-        }
-
-        try {
-            Class<?> providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
-            if (!type.isAssignableFrom(providerClass)) {
-                throw new ClassCastException(className + " cannot be cast to " + type.getName());
-            }
-            Object instance = providerClass.newInstance();
-            if (debug) {    // Extra check to avoid computing cl strings
-                dPrint("created new instance of " + providerClass +
-                       " using ClassLoader: " + cl);
-            }
-            return type.cast(instance);
-        }
-        catch (ClassNotFoundException x) {
-            throw new javax.xml.parsers.FactoryConfigurationError(x,
-                "Provider " + className + " not found");
-        }
-        catch (Exception x) {
-            throw new javax.xml.parsers.FactoryConfigurationError(x,
-                "Provider " + className + " could not be instantiated: " + x);
-        }
-    }
-
-    /**
-     * Finds the implementation Class object in the specified order.  Main
-     * entry point.
-     * @return Class object of factory, never null
-     *
-     * @param type                  Base class / Service interface  of the
-     *                              factory to find.
-     * @param fallbackClassName     Implementation class name, if nothing else
-     *                              is found.  Use null to mean no fallback.
-     *
-     * Package private so this code can be shared.
-     */
-    static <T> T find(Class<T> type, String fallbackClassName)
-        throws javax.xml.parsers.FactoryConfigurationError
-    {
-        final String factoryId = type.getName();
-        dPrint("find factoryId =" + factoryId);
-
-        // Use the system property first
-        try {
-            String systemProp = ss.getSystemProperty(factoryId);
-            if (systemProp != null) {
-                dPrint("found system property, value=" + systemProp);
-                return newInstance(type, systemProp, null, true);
-            }
-        }
-        catch (SecurityException se) {
-            if (debug) se.printStackTrace();
-        }
-
-        // try to read from $java.home/lib/jaxp.properties
-        try {
-            if (firstTime) {
-                synchronized (cacheProps) {
-                    if (firstTime) {
-                        String configFile = ss.getSystemProperty("java.home") + File.separator +
-                            "lib" + File.separator + "jaxp.properties";
-                        File f = new File(configFile);
-                        firstTime = false;
-                        if (ss.doesFileExist(f)) {
-                            dPrint("Read properties file "+f);
-                            cacheProps.load(ss.getFileInputStream(f));
-                        }
-                    }
-                }
-            }
-            final String factoryClassName = cacheProps.getProperty(factoryId);
-
-            if (factoryClassName != null) {
-                dPrint("found in $java.home/jaxp.properties, value=" + factoryClassName);
-                return newInstance(type, factoryClassName, null, true);
-            }
-        }
-        catch (Exception ex) {
-            if (debug) ex.printStackTrace();
-        }
-
-        // Try Jar Service Provider Mechanism
-        T provider = findServiceProvider(type);
-        if (provider != null) {
-            return provider;
-        }
-        if (fallbackClassName == null) {
-            throw new javax.xml.parsers.FactoryConfigurationError(
-                "Provider for " + factoryId + " cannot be found");
-        }
-
-        dPrint("loaded from fallback value: " + fallbackClassName);
-        return newInstance(type, fallbackClassName, null, true);
-    }
-
-    /*
-     * Try to find provider using the ServiceLoader API
-     *
-     * @param type Base class / Service interface  of the factory to find.
-     *
-     * @return instance of provider class if found or null
-     */
-    private static <T> T findServiceProvider(final Class<T> type) {
-        try {
-            return AccessController.doPrivileged(new PrivilegedAction<T>() {
-                public T run() {
-                    final ServiceLoader<T> serviceLoader = ServiceLoader.load(type);
-                    final Iterator<T> iterator = serviceLoader.iterator();
-                    if (iterator.hasNext()) {
-                        return iterator.next();
-                    } else {
-                        return null;
-                    }
-                 }
-            });
-        } catch(ServiceConfigurationError e) {
-            // It is not possible to wrap an error directly in
-            // FactoryConfigurationError - so we need to wrap the
-            // ServiceConfigurationError in a RuntimeException.
-            // The alternative would be to modify the logic in
-            // FactoryConfigurationError to allow setting a
-            // Throwable as the cause, but that could cause
-            // compatibility issues down the road.
-            final RuntimeException x = new RuntimeException(
-                    "Provider for " + type + " cannot be created", e);
-            final javax.xml.parsers.FactoryConfigurationError error =
-                    new FactoryConfigurationError(x, x.getMessage());
-            throw error;
-        }
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilder.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilder.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilder.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,348 +0,0 @@
-/*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-
-import javax.xml.validation.Schema;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.DOMImplementation;
-
-import org.xml.sax.EntityResolver;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-/**
- * Defines the API to obtain DOM Document instances from an XML
- * document. Using this class, an application programmer can obtain a
- * {@link Document} from XML.<p>
- *
- * An instance of this class can be obtained from the
- * {@link javax.xml.parsers.DocumentBuilderFactory#newDocumentBuilder()} method. Once
- * an instance of this class is obtained, XML can be parsed from a
- * variety of input sources. These input sources are InputStreams,
- * Files, URLs, and SAX InputSources.<p>
- *
- * Note that this class reuses several classes from the SAX API. This
- * does not require that the implementor of the underlying DOM
- * implementation use a SAX parser to parse XML document into a
- * <code>Document</code>. It merely requires that the implementation
- * communicate with the application using these existing APIs.
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-
-public abstract class DocumentBuilder {
-
-
-    /** Protected constructor */
-    protected DocumentBuilder () {
-    }
-
-    /**
-     * <p>Reset this <code>DocumentBuilder</code> to its original configuration.</p>
-     *
-     * <p><code>DocumentBuilder</code> is reset to the same state as when it was created with
-     * {@link javax.xml.parsers.DocumentBuilderFactory#newDocumentBuilder()}.
-     * <code>reset()</code> is designed to allow the reuse of existing <code>DocumentBuilder</code>s
-     * thus saving resources associated with the creation of new <code>DocumentBuilder</code>s.</p>
-     *
-     * <p>The reset <code>DocumentBuilder</code> is not guaranteed to have the same {@link EntityResolver} or {@link ErrorHandler}
-     * <code>Object</code>s, e.g. {@link Object#equals(Object obj)}.  It is guaranteed to have a functionally equal
-     * <code>EntityResolver</code> and <code>ErrorHandler</code>.</p>
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method.
-     *
-     * @since 1.5
-     */
-    public void reset() {
-
-        // implementors should override this method
-        throw new UnsupportedOperationException(
-                "This DocumentBuilder, \"" + this.getClass().getName() + "\", does not support the reset functionality."
-                + "  Specification \"" + this.getClass().getPackage().getSpecificationTitle() + "\""
-                + " version \"" + this.getClass().getPackage().getSpecificationVersion() + "\""
-                );
-    }
-
-    /**
-     * Parse the content of the given <code>InputStream</code> as an XML
-     * document and return a new DOM {@link Document} object.
-     * An <code>IllegalArgumentException</code> is thrown if the
-     * <code>InputStream</code> is null.
-     *
-     * @param is InputStream containing the content to be parsed.
-     *
-     * @return <code>Document</code> result of parsing the
-     *  <code>InputStream</code>
-     *
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any parse errors occur.
-     * @throws IllegalArgumentException When <code>is</code> is <code>null</code>
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-
-    public Document parse(InputStream is)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputStream cannot be null");
-        }
-
-        InputSource in = new InputSource(is);
-        return parse(in);
-    }
-
-    /**
-     * Parse the content of the given <code>InputStream</code> as an
-     * XML document and return a new DOM {@link Document} object.
-     * An <code>IllegalArgumentException</code> is thrown if the
-     * <code>InputStream</code> is null.
-     *
-     * @param is InputStream containing the content to be parsed.
-     * @param systemId Provide a base for resolving relative URIs.
-     *
-     * @return A new DOM Document object.
-     *
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any parse errors occur.
-     * @throws IllegalArgumentException When <code>is</code> is <code>null</code>
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-
-    public Document parse(InputStream is, String systemId)
-        throws SAXException, IOException {
-        if (is == null) {
-            throw new IllegalArgumentException("InputStream cannot be null");
-        }
-
-        InputSource in = new InputSource(is);
-        in.setSystemId(systemId);
-        return parse(in);
-    }
-
-    /**
-     * Parse the content of the given URI as an XML document
-     * and return a new DOM {@link Document} object.
-     * An <code>IllegalArgumentException</code> is thrown if the
-     * URI is <code>null</code> null.
-     *
-     * @param uri The location of the content to be parsed.
-     *
-     * @return A new DOM Document object.
-     *
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any parse errors occur.
-     * @throws IllegalArgumentException When <code>uri</code> is <code>null</code>
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-
-    public Document parse(String uri)
-        throws SAXException, IOException {
-        if (uri == null) {
-            throw new IllegalArgumentException("URI cannot be null");
-        }
-
-        InputSource in = new InputSource(uri);
-        return parse(in);
-    }
-
-    /**
-     * Parse the content of the given file as an XML document
-     * and return a new DOM {@link Document} object.
-     * An <code>IllegalArgumentException</code> is thrown if the
-     * <code>File</code> is <code>null</code> null.
-     *
-     * @param f The file containing the XML to parse.
-     *
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any parse errors occur.
-     * @throws IllegalArgumentException When <code>f</code> is <code>null</code>
-     *
-     * @see org.xml.sax.DocumentHandler
-     * @return A new DOM Document object.
-     */
-
-    public Document parse(File f) throws SAXException, IOException {
-        if (f == null) {
-            throw new IllegalArgumentException("File cannot be null");
-        }
-
-        //convert file to appropriate URI, f.toURI().toASCIIString()
-        //converts the URI to string as per rule specified in
-        //RFC 2396,
-        InputSource in = new InputSource(f.toURI().toASCIIString());
-        return parse(in);
-    }
-
-    /**
-     * Parse the content of the given input source as an XML document
-     * and return a new DOM {@link Document} object.
-     * An <code>IllegalArgumentException</code> is thrown if the
-     * <code>InputSource</code> is <code>null</code> null.
-     *
-     * @param is InputSource containing the content to be parsed.
-     *
-     * @return A new DOM Document object.
-     *
-     * @throws IOException If any IO errors occur.
-     * @throws SAXException If any parse errors occur.
-     * @throws IllegalArgumentException When <code>is</code> is <code>null</code>
-     *
-     * @see org.xml.sax.DocumentHandler
-     */
-
-    public abstract Document parse(InputSource is)
-        throws SAXException, IOException;
-
-
-    /**
-     * Indicates whether or not this parser is configured to
-     * understand namespaces.
-     *
-     * @return true if this parser is configured to understand
-     *         namespaces; false otherwise.
-     */
-
-    public abstract boolean isNamespaceAware();
-
-    /**
-     * Indicates whether or not this parser is configured to
-     * validate XML documents.
-     *
-     * @return true if this parser is configured to validate
-     *         XML documents; false otherwise.
-     */
-
-    public abstract boolean isValidating();
-
-    /**
-     * Specify the {@link EntityResolver} to be used to resolve
-     * entities present in the XML document to be parsed. Setting
-     * this to <code>null</code> will result in the underlying
-     * implementation using it's own default implementation and
-     * behavior.
-     *
-     * @param er The <code>EntityResolver</code> to be used to resolve entities
-     *           present in the XML document to be parsed.
-     */
-
-    public abstract void setEntityResolver(EntityResolver er);
-
-    /**
-     * Specify the {@link ErrorHandler} to be used by the parser.
-     * Setting this to <code>null</code> will result in the underlying
-     * implementation using it's own default implementation and
-     * behavior.
-     *
-     * @param eh The <code>ErrorHandler</code> to be used by the parser.
-     */
-
-    public abstract void setErrorHandler(ErrorHandler eh);
-
-    /**
-     * Obtain a new instance of a DOM {@link Document} object
-     * to build a DOM tree with.
-     *
-     * @return A new instance of a DOM Document object.
-     */
-
-    public abstract Document newDocument();
-
-    /**
-     * Obtain an instance of a {@link DOMImplementation} object.
-     *
-     * @return A new instance of a <code>DOMImplementation</code>.
-     */
-
-    public abstract DOMImplementation getDOMImplementation();
-
-    /** <p>Get current state of canonicalization.</p>
-     *
-     * @return current state canonicalization control
-     */
-    /*
-    public boolean getCanonicalization() {
-        return canonicalState;
-    }
-    */
-
-    /** <p>Get a reference to the the {@link Schema} being used by
-     * the XML processor.</p>
-     *
-     * <p>If no schema is being used, <code>null</code> is returned.</p>
-     *
-     * @return {@link Schema} being used or <code>null</code>
-     *  if none in use
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @since 1.5
-     */
-    public Schema getSchema() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-
-
-    /**
-     * <p>Get the XInclude processing mode for this parser.</p>
-     *
-     * @return
-     *      the return value of
-     *      the {@link javax.xml.parsers.DocumentBuilderFactory#isXIncludeAware()}
-     *      when this parser was created from factory.
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @since 1.5
-     *
-     * @see DocumentBuilderFactory#setXIncludeAware(boolean)
-     */
-    public boolean isXIncludeAware() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/SecuritySupport.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/SecuritySupport.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/SecuritySupport.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/SecuritySupport.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2004, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-import java.security.*;
-import java.net.*;
-import java.io.*;
-import java.util.*;
-
-/**
- * This class is duplicated for each JAXP subpackage so keep it in sync.
- * It is package private and therefore is not exposed as part of the JAXP
- * API.
- *
- * Security related methods that only work on J2SE 1.2 and newer.
- */
-class SecuritySupport  {
-
-
-    ClassLoader getContextClassLoader() throws SecurityException{
-        return (ClassLoader)
-                AccessController.doPrivileged(new PrivilegedAction() {
-            public Object run() {
-                ClassLoader cl = null;
-                //try {
-                cl = Thread.currentThread().getContextClassLoader();
-                //} catch (SecurityException ex) { }
-
-                if (cl == null)
-                    cl = ClassLoader.getSystemClassLoader();
-
-                return cl;
-            }
-        });
-    }
-
-    String getSystemProperty(final String propName) {
-        return (String)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(propName);
-                }
-            });
-    }
-
-    FileInputStream getFileInputStream(final File file)
-        throws FileNotFoundException
-    {
-        try {
-            return (FileInputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws FileNotFoundException {
-                        return new FileInputStream(file);
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (FileNotFoundException)e.getException();
-        }
-    }
-
-    InputStream getResourceAsStream(final ClassLoader cl,
-                                           final String name)
-    {
-        return (InputStream)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    InputStream ris;
-                    if (cl == null) {
-                        ris = Object.class.getResourceAsStream(name);
-                    } else {
-                        ris = cl.getResourceAsStream(name);
-                    }
-                    return ris;
-                }
-            });
-    }
-
-    boolean doesFileExist(final File f) {
-    return ((Boolean)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return new Boolean(f.exists());
-                }
-            })).booleanValue();
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParserFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParserFactory.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParserFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/SAXParserFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,445 +0,0 @@
-/*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-import javax.xml.validation.Schema;
-
-import javax.xml.XMLConstants;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXNotSupportedException;
-
-/**
- * Defines a factory API that enables applications to configure and
- * obtain a SAX based parser to parse XML documents.
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @author <a href="mailto:Neeraj.Bajaj@sun.com">Neeraj Bajaj</a>
- *
- * @version $Revision: 1.9 $, $Date: 2010/05/25 16:19:44 $
- *
- */
-public abstract class SAXParserFactory {
-
-    /**
-     * <p>Should Parsers be validating?</p>
-     */
-    private boolean validating = false;
-
-    /**
-     * <p>Should Parsers be namespace aware?</p>
-     */
-    private boolean namespaceAware = false;
-
-    /**
-     * <p>Protected constructor to force use of {@link #newInstance()}.</p>
-     */
-    protected SAXParserFactory () {
-
-    }
-
-    /**
-     * Obtain a new instance of a <code>SAXParserFactory</code>. This
-     * static method creates a new factory instance
-     * This method uses the following ordered lookup procedure to determine
-     * the <code>SAXParserFactory</code> implementation class to
-     * load:
-     * <ul>
-     * <li>
-     * Use the <code>javax.xml.parsers.SAXParserFactory</code> system
-     * property.
-     * </li>
-     * <li>
-     * Use the properties file "lib/jaxp.properties" in the JRE directory.
-     * This configuration file is in standard <code>java.util.Properties
-     * </code> format and contains the fully qualified name of the
-     * implementation class with the key being the system property defined
-     * above.
-     *
-     * The jaxp.properties file is read only once by the JAXP implementation
-     * and it's values are then cached for future use.  If the file does not exist
-     * when the first attempt is made to read from it, no further attempts are
-     * made to check for its existence.  It is not possible to change the value
-     * of any property in jaxp.properties after it has been read for the first time.
-     * </li>
-     * <li>
-     * Use the service-provider loading facilities, defined by the
-     * {@link java.util.ServiceLoader} class, to attempt to locate and load an
-     * implementation of the service using the {@linkplain
-     * java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-     * the service-provider loading facility will use the {@linkplain
-     * java.lang.Thread#getContextClassLoader() current thread's context class loader}
-     * to attempt to load the service. If the context class
-     * loader is null, the {@linkplain
-     * ClassLoader#getSystemClassLoader() system class loader} will be used.
-     * </li>
-     * <li>
-     * Otherwise the system-default implementation is returned.
-     * </li>
-     * </ul>
-     *
-     * Once an application has obtained a reference to a
-     * <code>SAXParserFactory</code> it can use the factory to
-     * configure and obtain parser instances.
-     *
-     *
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems loading {@link javax.xml.parsers.SAXParser}s, try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     *
-     * @return A new instance of a SAXParserFactory.
-     *
-     * @throws javax.xml.parsers.FactoryConfigurationError in case of {@linkplain
-     * java.util.ServiceConfigurationError service configuration error} or if
-     * the implementation is not available or cannot be instantiated.
-     */
-
-    public static SAXParserFactory newInstance() {
-        return FactoryFinder.find(
-                /* The default property name according to the JAXP spec */
-                SAXParserFactory.class,
-                /* The fallback implementation class name */
-                "com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl");
-    }
-
-    /**
-     * <p>Obtain a new instance of a <code>SAXParserFactory</code> from class name.
-     * This function is useful when there are multiple providers in the classpath.
-     * It gives more control to the application as it can specify which provider
-     * should be loaded.</p>
-     *
-     * <p>Once an application has obtained a reference to a <code>SAXParserFactory</code>
-     * it can use the factory to configure and obtain parser instances.</p>
-     *
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems, try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     * @param factoryClassName fully qualified factory class name that provides implementation of <code>javax.xml.parsers.SAXParserFactory</code>.
-     *
-     * @param classLoader <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     *                     current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @return New instance of a <code>SAXParserFactory</code>
-     *
-     * @throws FactoryConfigurationError if <code>factoryClassName</code> is <code>null</code>, or
-     *                                   the factory class cannot be loaded, instantiated.
-     *
-     * @see #newInstance()
-     *
-     * @since 1.6
-     */
-    public static SAXParserFactory newInstance(String factoryClassName, ClassLoader classLoader){
-            //do not fallback if given classloader can't find the class, throw exception
-            return FactoryFinder.newInstance(SAXParserFactory.class,
-                    factoryClassName, classLoader, false);
-    }
-
-    /**
-     * <p>Creates a new instance of a SAXParser using the currently
-     * configured factory parameters.</p>
-     *
-     * @return A new instance of a SAXParser.
-     *
-     * @throws javax.xml.parsers.ParserConfigurationException if a parser cannot
-     *   be created which satisfies the requested configuration.
-     * @throws SAXException for SAX errors.
-     */
-
-    public abstract javax.xml.parsers.SAXParser newSAXParser()
-        throws javax.xml.parsers.ParserConfigurationException, SAXException;
-
-
-    /**
-     * Specifies that the parser produced by this code will
-     * provide support for XML namespaces. By default the value of this is set
-     * to <code>false</code>.
-     *
-     * @param awareness true if the parser produced by this code will
-     *                  provide support for XML namespaces; false otherwise.
-     */
-
-    public void setNamespaceAware(boolean awareness) {
-        this.namespaceAware = awareness;
-    }
-
-    /**
-     * Specifies that the parser produced by this code will
-     * validate documents as they are parsed. By default the value of this is
-     * set to <code>false</code>.
-     *
-     * <p>
-     * Note that "the validation" here means
-     * <a href="http://www.w3.org/TR/REC-xml#proc-types">a validating
-     * parser</a> as defined in the XML recommendation.
-     * In other words, it essentially just controls the DTD validation.
-     * (except the legacy two properties defined in JAXP 1.2.)
-     * </p>
-     *
-     * <p>
-     * To use modern schema languages such as W3C XML Schema or
-     * RELAX NG instead of DTD, you can configure your parser to be
-     * a non-validating parser by leaving the {@link #setValidating(boolean)}
-     * method <code>false</code>, then use the {@link #setSchema(Schema)}
-     * method to associate a schema to a parser.
-     * </p>
-     *
-     * @param validating true if the parser produced by this code will
-     *                   validate documents as they are parsed; false otherwise.
-     */
-
-    public void setValidating(boolean validating) {
-        this.validating = validating;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which are namespace aware.
-     *
-     * @return true if the factory is configured to produce
-     *         parsers which are namespace aware; false otherwise.
-     */
-
-    public boolean isNamespaceAware() {
-        return namespaceAware;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which validate the XML content during parse.
-     *
-     * @return true if the factory is configured to produce parsers which validate
-     *         the XML content during parse; false otherwise.
-     */
-
-    public boolean isValidating() {
-        return validating;
-    }
-
-    /**
-     *
-     * <p>Sets the particular feature in the underlying implementation of
-     * org.xml.sax.XMLReader.
-     * A list of the core features and properties can be found at
-     * <a href="http://www.saxproject.org/">http://www.saxproject.org/</a></p>
-     *
-     * <p>All implementations are required to support the {@link XMLConstants#FEATURE_SECURE_PROCESSING} feature.
-     * When the feature is</p>
-     * <ul>
-     *   <li>
-     *     <code>true</code>: the implementation will limit XML processing to conform to implementation limits.
-     *     Examples include entity expansion limits and XML Schema constructs that would consume large amounts of resources.
-     *     If XML processing is limited for security reasons, it will be reported via a call to the registered
-     *     {@link org.xml.sax.ErrorHandler#fatalError(SAXParseException exception)}.
-     *     See {@link javax.xml.parsers.SAXParser} <code>parse</code> methods for handler specification.
-     *   </li>
-     *   <li>
-     *     When the feature is <code>false</code>, the implementation will processing XML according to the XML specifications without
-     *     regard to possible implementation limits.
-     *   </li>
-     * </ul>
-     *
-     * @param name The name of the feature to be set.
-     * @param value The value of the feature to be set.
-     *
-     * @throws javax.xml.parsers.ParserConfigurationException if a parser cannot
-     *     be created which satisfies the requested configuration.
-     * @throws SAXNotRecognizedException When the underlying XMLReader does
-     *            not recognize the property name.
-     * @throws SAXNotSupportedException When the underlying XMLReader
-     *            recognizes the property name but doesn't support the
-     *            property.
-     * @throws NullPointerException If the <code>name</code> parameter is null.
-     *
-     * @see org.xml.sax.XMLReader#setFeature
-     */
-    public abstract void setFeature(String name, boolean value)
-        throws javax.xml.parsers.ParserConfigurationException, SAXNotRecognizedException,
-                SAXNotSupportedException;
-
-    /**
-     *
-     * <p>Returns the particular property requested for in the underlying
-     * implementation of org.xml.sax.XMLReader.</p>
-     *
-     * @param name The name of the property to be retrieved.
-     *
-     * @return Value of the requested property.
-     *
-     * @throws javax.xml.parsers.ParserConfigurationException if a parser cannot be created which satisfies the requested configuration.
-     * @throws SAXNotRecognizedException When the underlying XMLReader does not recognize the property name.
-     * @throws SAXNotSupportedException When the underlying XMLReader recognizes the property name but doesn't support the property.
-     *
-     * @see org.xml.sax.XMLReader#getProperty
-     */
-    public abstract boolean getFeature(String name)
-        throws ParserConfigurationException, SAXNotRecognizedException,
-                SAXNotSupportedException;
-
-
-    /**
-     * Gets the {@link Schema} object specified through
-     * the {@link #setSchema(Schema schema)} method.
-     *
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @return
-     *      the {@link Schema} object that was last set through
-     *      the {@link #setSchema(Schema)} method, or null
-     *      if the method was not invoked since a {@link SAXParserFactory}
-     *      is created.
-     *
-     * @since 1.5
-     */
-    public Schema getSchema() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-
-    /**
-     * <p>Set the {@link Schema} to be used by parsers created
-     * from this factory.</p>
-     *
-     * <p>When a {@link Schema} is non-null, a parser will use a validator
-     * created from it to validate documents before it passes information
-     * down to the application.</p>
-     *
-     * <p>When warnings/errors/fatal errors are found by the validator, the parser must
-     * handle them as if those errors were found by the parser itself.
-     * In other words, if the user-specified {@link org.xml.sax.ErrorHandler}
-     * is set, it must receive those errors, and if not, they must be
-     * treated according to the implementation specific
-     * default error handling rules.
-     *
-     * <p>A validator may modify the SAX event stream (for example by
-     * adding default values that were missing in documents), and a parser
-     * is responsible to make sure that the application will receive
-     * those modified event stream.</p>
-     *
-     * <p>Initialy, <code>null</code> is set as the {@link Schema}.</p>
-     *
-     * <p>This processing will take effect even if
-     * the {@link #isValidating()} method returns <code>false</code>.
-     *
-     * <p>It is an error to use
-     * the <code>http://java.sun.com/xml/jaxp/properties/schemaSource</code>
-     * property and/or the <code>http://java.sun.com/xml/jaxp/properties/schemaLanguage</code>
-     * property in conjunction with a non-null {@link Schema} object.
-     * Such configuration will cause a {@link SAXException}
-     * exception when those properties are set on a {@link SAXParser}.</p>
-     *
-     * <h4>Note for implementors</h4>
-     * <p>
-     * A parser must be able to work with any {@link Schema}
-     * implementation. However, parsers and schemas are allowed
-     * to use implementation-specific custom mechanisms
-     * as long as they yield the result described in the specification.
-     * </p>
-     *
-     * @param schema <code>Schema</code> to use, <code>null</code> to remove a schema.
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @since 1.5
-     */
-    public void setSchema(Schema schema) {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-
-    /**
-     * <p>Set state of XInclude processing.</p>
-     *
-     * <p>If XInclude markup is found in the document instance, should it be
-     * processed as specified in <a href="http://www.w3.org/TR/xinclude/">
-     * XML Inclusions (XInclude) Version 1.0</a>.</p>
-     *
-     * <p>XInclude processing defaults to <code>false</code>.</p>
-     *
-     * @param state Set XInclude processing to <code>true</code> or
-     *   <code>false</code>
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @since 1.5
-     */
-    public void setXIncludeAware(final boolean state) {
-        if (state) {
-            throw new UnsupportedOperationException(" setXIncludeAware " +
-                "is not supported on this JAXP"  +
-                " implementation or earlier: " + this.getClass());
-        }
-    }
-
-    /**
-     * <p>Get state of XInclude processing.</p>
-     *
-     * @return current state of XInclude processing
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method
-     *
-     * @since 1.5
-     */
-    public boolean isXIncludeAware() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilderFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilderFactory.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilderFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/DocumentBuilderFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,619 +0,0 @@
-/*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-import javax.xml.XMLConstants;
-
-import javax.xml.validation.Schema;
-
-/**
- * Defines a factory API that enables applications to obtain a
- * parser that produces DOM object trees from XML documents.
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @author <a href="mailto:Neeraj.Bajaj@sun.com">Neeraj Bajaj</a>
- *
- * @version $Revision: 1.9 $, $Date: 2010/05/25 16:19:44 $
-
- */
-
-public abstract class DocumentBuilderFactory {
-
-    private boolean validating = false;
-    private boolean namespaceAware = false;
-    private boolean whitespace = false;
-    private boolean expandEntityRef = true;
-    private boolean ignoreComments = false;
-    private boolean coalescing = false;
-
-    /**
-     * <p>Protected constructor to prevent instantiation.
-     * Use {@link #newInstance()}.</p>
-     */
-    protected DocumentBuilderFactory () {
-    }
-
-    /**
-     * Obtain a new instance of a
-     * <code>DocumentBuilderFactory</code>. This static method creates
-     * a new factory instance.
-     * This method uses the following ordered lookup procedure to determine
-     * the <code>DocumentBuilderFactory</code> implementation class to
-     * load:
-     * <ul>
-     * <li>
-     * Use the <code>javax.xml.parsers.DocumentBuilderFactory</code> system
-     * property.
-     * </li>
-     * <li>
-     * Use the properties file "lib/jaxp.properties" in the JRE directory.
-     * This configuration file is in standard <code>java.util.Properties
-     * </code> format and contains the fully qualified name of the
-     * implementation class with the key being the system property defined
-     * above.
-     *
-     * The jaxp.properties file is read only once by the JAXP implementation
-     * and it's values are then cached for future use.  If the file does not exist
-     * when the first attempt is made to read from it, no further attempts are
-     * made to check for its existence.  It is not possible to change the value
-     * of any property in jaxp.properties after it has been read for the first time.
-     * </li>
-     * <li>
-     * Uses the service-provider loading facilities, defined by the
-     * {@link java.util.ServiceLoader} class, to attempt to locate and load an
-     * implementation of the service using the {@linkplain
-     * java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-     * the service-provider loading facility will use the {@linkplain
-     * java.lang.Thread#getContextClassLoader() current thread's context class loader}
-     * to attempt to load the service. If the context class
-     * loader is null, the {@linkplain
-     * ClassLoader#getSystemClassLoader() system class loader} will be used.
-     * </li>
-     * <li>
-     * Otherwise, the system-default implementation is returned.
-     * </li>
-     * </ul>
-     *
-     * Once an application has obtained a reference to a
-     * <code>DocumentBuilderFactory</code> it can use the factory to
-     * configure and obtain parser instances.
-     *
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems loading {@link javax.xml.parsers.DocumentBuilder}s, try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     * @return New instance of a <code>DocumentBuilderFactory</code>
-     *
-     * @throws javax.xml.parsers.FactoryConfigurationError in case of {@linkplain
-     * java.util.ServiceConfigurationError service configuration error} or if
-     * the implementation is not available or cannot be instantiated.
-     */
-    public static DocumentBuilderFactory newInstance() {
-
-        String factory = System.getProperty("javax.xml.parsers.DocumentBuilderFactory");
-        if (factory != null) {
-            try {
-                return (DocumentBuilderFactory) Class.forName(factory).newInstance();
-            } catch (Exception ignored) {
-
-            }
-        }
-        return FactoryFinder.find(
-                /* The default property name according to the JAXP spec */
-                DocumentBuilderFactory.class, // "javax.xml.parsers.DocumentBuilderFactory"
-                /* The fallback implementation class name */
-                "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");
-
-    }
-
-    /**
-     * <p>Obtain a new instance of a <code>DocumentBuilderFactory</code> from class name.
-     * This function is useful when there are multiple providers in the classpath.
-     * It gives more control to the application as it can specify which provider
-     * should be loaded.</p>
-     *
-     * <p>Once an application has obtained a reference to a <code>DocumentBuilderFactory</code>
-     * it can use the factory to configure and obtain parser instances.</p>
-     *
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     * @param factoryClassName fully qualified factory class name that provides implementation of <code>javax.xml.parsers.DocumentBuilderFactory</code>.
-     *
-     * @param classLoader <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     *                     current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @return New instance of a <code>DocumentBuilderFactory</code>
-     *
-     * @throws FactoryConfigurationError if <code>factoryClassName</code> is <code>null</code>, or
-     *                                   the factory class cannot be loaded, instantiated.
-     *
-     * @see #newInstance()
-     *
-     * @since 1.6
-     */
-    public static DocumentBuilderFactory newInstance(String factoryClassName, ClassLoader classLoader){
-            //do not fallback if given classloader can't find the class, throw exception
-            return FactoryFinder.newInstance(DocumentBuilderFactory.class,
-                        factoryClassName, classLoader, false);
-    }
-
-    /**
-     * Creates a new instance of a {@link javax.xml.parsers.DocumentBuilder}
-     * using the currently configured parameters.
-     *
-     * @return A new instance of a DocumentBuilder.
-     *
-     * @throws javax.xml.parsers.ParserConfigurationException if a DocumentBuilder
-     *   cannot be created which satisfies the configuration requested.
-     */
-
-    public abstract javax.xml.parsers.DocumentBuilder newDocumentBuilder()
-        throws javax.xml.parsers.ParserConfigurationException;
-
-
-    /**
-     * Specifies that the parser produced by this code will
-     * provide support for XML namespaces. By default the value of this is set
-     * to <code>false</code>
-     *
-     * @param awareness true if the parser produced will provide support
-     *                  for XML namespaces; false otherwise.
-     */
-
-    public void setNamespaceAware(boolean awareness) {
-        this.namespaceAware = awareness;
-    }
-
-    /**
-     * Specifies that the parser produced by this code will
-     * validate documents as they are parsed. By default the value of this
-     * is set to <code>false</code>.
-     *
-     * <p>
-     * Note that "the validation" here means
-     * <a href="http://www.w3.org/TR/REC-xml#proc-types">a validating
-     * parser</a> as defined in the XML recommendation.
-     * In other words, it essentially just controls the DTD validation.
-     * (except the legacy two properties defined in JAXP 1.2.)
-     * </p>
-     *
-     * <p>
-     * To use modern schema languages such as W3C XML Schema or
-     * RELAX NG instead of DTD, you can configure your parser to be
-     * a non-validating parser by leaving the {@link #setValidating(boolean)}
-     * method <code>false</code>, then use the {@link #setSchema(Schema)}
-     * method to associate a schema to a parser.
-     * </p>
-     *
-     * @param validating true if the parser produced will validate documents
-     *                   as they are parsed; false otherwise.
-     */
-
-    public void setValidating(boolean validating) {
-        this.validating = validating;
-    }
-
-    /**
-     * Specifies that the parsers created by this  factory must eliminate
-     * whitespace in element content (sometimes known loosely as
-     * 'ignorable whitespace') when parsing XML documents (see XML Rec
-     * 2.10). Note that only whitespace which is directly contained within
-     * element content that has an element only content model (see XML
-     * Rec 3.2.1) will be eliminated. Due to reliance on the content model
-     * this setting requires the parser to be in validating mode. By default
-     * the value of this is set to <code>false</code>.
-     *
-     * @param whitespace true if the parser created must eliminate whitespace
-     *                   in the element content when parsing XML documents;
-     *                   false otherwise.
-     */
-
-    public void setIgnoringElementContentWhitespace(boolean whitespace) {
-        this.whitespace = whitespace;
-    }
-
-    /**
-     * Specifies that the parser produced by this code will
-     * expand entity reference nodes. By default the value of this is set to
-     * <code>true</code>
-     *
-     * @param expandEntityRef true if the parser produced will expand entity
-     *                        reference nodes; false otherwise.
-     */
-
-    public void setExpandEntityReferences(boolean expandEntityRef) {
-        this.expandEntityRef = expandEntityRef;
-    }
-
-    /**
-     * <p>Specifies that the parser produced by this code will
-     * ignore comments. By default the value of this is set to <code>false
-     * </code>.</p>
-     *
-     * @param ignoreComments <code>boolean</code> value to ignore comments during processing
-     */
-
-    public void setIgnoringComments(boolean ignoreComments) {
-        this.ignoreComments = ignoreComments;
-    }
-
-    /**
-     * Specifies that the parser produced by this code will
-     * convert CDATA nodes to Text nodes and append it to the
-     * adjacent (if any) text node. By default the value of this is set to
-     * <code>false</code>
-     *
-     * @param coalescing  true if the parser produced will convert CDATA nodes
-     *                    to Text nodes and append it to the adjacent (if any)
-     *                    text node; false otherwise.
-     */
-
-    public void setCoalescing(boolean coalescing) {
-        this.coalescing = coalescing;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which are namespace aware.
-     *
-     * @return  true if the factory is configured to produce parsers which
-     *          are namespace aware; false otherwise.
-     */
-
-    public boolean isNamespaceAware() {
-        return namespaceAware;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which validate the XML content during parse.
-     *
-     * @return  true if the factory is configured to produce parsers
-     *          which validate the XML content during parse; false otherwise.
-     */
-
-    public boolean isValidating() {
-        return validating;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which ignore ignorable whitespace in element content.
-     *
-     * @return  true if the factory is configured to produce parsers
-     *          which ignore ignorable whitespace in element content;
-     *          false otherwise.
-     */
-
-    public boolean isIgnoringElementContentWhitespace() {
-        return whitespace;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which expand entity reference nodes.
-     *
-     * @return  true if the factory is configured to produce parsers
-     *          which expand entity reference nodes; false otherwise.
-     */
-
-    public boolean isExpandEntityReferences() {
-        return expandEntityRef;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which ignores comments.
-     *
-     * @return  true if the factory is configured to produce parsers
-     *          which ignores comments; false otherwise.
-     */
-
-    public boolean isIgnoringComments() {
-        return ignoreComments;
-    }
-
-    /**
-     * Indicates whether or not the factory is configured to produce
-     * parsers which converts CDATA nodes to Text nodes and appends it to
-     * the adjacent (if any) Text node.
-     *
-     * @return  true if the factory is configured to produce parsers
-     *          which converts CDATA nodes to Text nodes and appends it to
-     *          the adjacent (if any) Text node; false otherwise.
-     */
-
-    public boolean isCoalescing() {
-        return coalescing;
-    }
-
-    /**
-     * Allows the user to set specific attributes on the underlying
-     * implementation.
-     * <p>
-     * All implementations that implement JAXP 1.5 or newer are required to
-     * support the {@link XMLConstants#ACCESS_EXTERNAL_DTD} and
-     * {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} properties.
-     * </p>
-     * <ul>
-     *   <li>
-     *      <p>
-     *      Setting the {@link XMLConstants#ACCESS_EXTERNAL_DTD} property
-     *      restricts the access to external DTDs, external Entity References to the
-     *      protocols specified by the property.
-     *      If access is denied during parsing due to the restriction of this property,
-     *      {@link org.xml.sax.SAXException} will be thrown by the parse methods defined by
-     *      {@link javax.xml.parsers.DocumentBuilder}.
-     *      </p>
-     *      <p>
-     *      Setting the {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} property
-     *      restricts the access to external Schema set by the schemaLocation attribute to
-     *      the protocols specified by the property.  If access is denied during parsing
-     *      due to the restriction of this property, {@link org.xml.sax.SAXException}
-     *      will be thrown by the parse methods defined by
-     *      {@link javax.xml.parsers.DocumentBuilder}.
-     *      </p>
-     *   </li>
-     * </ul>
-     *
-     * @param name The name of the attribute.
-     * @param value The value of the attribute.
-     *
-     * @throws IllegalArgumentException thrown if the underlying
-     *   implementation doesn't recognize the attribute.
-     */
-    public abstract void setAttribute(String name, Object value)
-                throws IllegalArgumentException;
-
-    /**
-     * Allows the user to retrieve specific attributes on the underlying
-     * implementation.
-     *
-     * @param name The name of the attribute.
-     *
-     * @return value The value of the attribute.
-     *
-     * @throws IllegalArgumentException thrown if the underlying
-     *   implementation doesn't recognize the attribute.
-     */
-    public abstract Object getAttribute(String name)
-                throws IllegalArgumentException;
-
-    /**
-     * <p>Set a feature for this <code>DocumentBuilderFactory</code> and <code>DocumentBuilder</code>s created by this factory.</p>
-     *
-     * <p>
-     * Feature names are fully qualified {@link java.net.URI}s.
-     * Implementations may define their own features.
-     * A {@link javax.xml.parsers.ParserConfigurationException} is thrown if this <code>DocumentBuilderFactory</code> or the
-     * <code>DocumentBuilder</code>s it creates cannot support the feature.
-     * It is possible for a <code>DocumentBuilderFactory</code> to expose a feature value but be unable to change its state.
-     * </p>
-     *
-     * <p>
-     * All implementations are required to support the {@link XMLConstants#FEATURE_SECURE_PROCESSING} feature.
-     * When the feature is:</p>
-     * <ul>
-     *   <li>
-     *     <code>true</code>: the implementation will limit XML processing to conform to implementation limits.
-     *     Examples include enity expansion limits and XML Schema constructs that would consume large amounts of resources.
-     *     If XML processing is limited for security reasons, it will be reported via a call to the registered
-     *    {@link org.xml.sax.ErrorHandler#fatalError(SAXParseException exception)}.
-     *     See {@link  DocumentBuilder#setErrorHandler(org.xml.sax.ErrorHandler errorHandler)}.
-     *   </li>
-     *   <li>
-     *     <code>false</code>: the implementation will processing XML according to the XML specifications without
-     *     regard to possible implementation limits.
-     *   </li>
-     * </ul>
-     *
-     * @param name Feature name.
-     * @param value Is feature state <code>true</code> or <code>false</code>.
-     *
-     * @throws javax.xml.parsers.ParserConfigurationException if this <code>DocumentBuilderFactory</code> or the <code>DocumentBuilder</code>s
-     *   it creates cannot support this feature.
-     * @throws NullPointerException If the <code>name</code> parameter is null.
-     */
-    public abstract void setFeature(String name, boolean value)
-            throws javax.xml.parsers.ParserConfigurationException;
-
-    /**
-     * <p>Get the state of the named feature.</p>
-     *
-     * <p>
-     * Feature names are fully qualified {@link java.net.URI}s.
-     * Implementations may define their own features.
-     * An {@link javax.xml.parsers.ParserConfigurationException} is thrown if this <code>DocumentBuilderFactory</code> or the
-     * <code>DocumentBuilder</code>s it creates cannot support the feature.
-     * It is possible for an <code>DocumentBuilderFactory</code> to expose a feature value but be unable to change its state.
-     * </p>
-     *
-     * @param name Feature name.
-     *
-     * @return State of the named feature.
-     *
-     * @throws javax.xml.parsers.ParserConfigurationException if this <code>DocumentBuilderFactory</code>
-     *   or the <code>DocumentBuilder</code>s it creates cannot support this feature.
-     */
-    public abstract boolean getFeature(String name)
-            throws javax.xml.parsers.ParserConfigurationException;
-
-
-    /**
-     * Gets the {@link Schema} object specified through
-     * the {@link #setSchema(Schema schema)} method.
-     *
-     * @return
-     *      the {@link Schema} object that was last set through
-     *      the {@link #setSchema(Schema)} method, or null
-     *      if the method was not invoked since a {@link DocumentBuilderFactory}
-     *      is created.
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method.
-     *
-     * @since 1.5
-     */
-    public Schema getSchema() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-
-    }
-
-    /**
-     * <p>Set the {@link Schema} to be used by parsers created
-     * from this factory.
-     *
-     * <p>
-     * When a {@link Schema} is non-null, a parser will use a validator
-     * created from it to validate documents before it passes information
-     * down to the application.
-     *
-     * <p>When errors are found by the validator, the parser is responsible
-     * to report them to the user-specified {@link org.xml.sax.ErrorHandler}
-     * (or if the error handler is not set, ignore them or throw them), just
-     * like any other errors found by the parser itself.
-     * In other words, if the user-specified {@link org.xml.sax.ErrorHandler}
-     * is set, it must receive those errors, and if not, they must be
-     * treated according to the implementation specific
-     * default error handling rules.
-     *
-     * <p>
-     * A validator may modify the outcome of a parse (for example by
-     * adding default values that were missing in documents), and a parser
-     * is responsible to make sure that the application will receive
-     * modified DOM trees.
-     *
-     * <p>
-     * Initialy, null is set as the {@link Schema}.
-     *
-     * <p>
-     * This processing will take effect even if
-     * the {@link #isValidating()} method returns <code>false</code>.
-     *
-     * <p>It is an error to use
-     * the <code>http://java.sun.com/xml/jaxp/properties/schemaSource</code>
-     * property and/or the <code>http://java.sun.com/xml/jaxp/properties/schemaLanguage</code>
-     * property in conjunction with a {@link Schema} object.
-     * Such configuration will cause a {@link ParserConfigurationException}
-     * exception when the {@link #newDocumentBuilder()} is invoked.</p>
-     *
-     *
-     * <h4>Note for implmentors</h4>
-     *
-     * <p>
-     * A parser must be able to work with any {@link Schema}
-     * implementation. However, parsers and schemas are allowed
-     * to use implementation-specific custom mechanisms
-     * as long as they yield the result described in the specification.
-     * </p>
-     *
-     * @param schema <code>Schema</code> to use or <code>null</code>
-     *   to remove a schema.
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method.
-     *
-     * @since 1.5
-     */
-    public void setSchema(Schema schema) {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-
-
-
-    /**
-     * <p>Set state of XInclude processing.</p>
-     *
-     * <p>If XInclude markup is found in the document instance, should it be
-     * processed as specified in <a href="http://www.w3.org/TR/xinclude/">
-     * XML Inclusions (XInclude) Version 1.0</a>.</p>
-     *
-     * <p>XInclude processing defaults to <code>false</code>.</p>
-     *
-     * @param state Set XInclude processing to <code>true</code> or
-     *   <code>false</code>
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method.
-     *
-     * @since 1.5
-     */
-    public void setXIncludeAware(final boolean state) {
-        if (state) {
-            throw new UnsupportedOperationException(" setXIncludeAware " +
-                "is not supported on this JAXP" +
-                " implementation or earlier: " + this.getClass());
-        }
-    }
-
-    /**
-     * <p>Get state of XInclude processing.</p>
-     *
-     * @return current state of XInclude processing
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method.
-     *
-     * @since 1.5
-     */
-    public boolean isXIncludeAware() {
-        throw new UnsupportedOperationException(
-            "This parser does not support specification \""
-            + this.getClass().getPackage().getSpecificationTitle()
-            + "\" version \""
-            + this.getClass().getPackage().getSpecificationVersion()
-            + "\""
-            );
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryConfigurationError.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryConfigurationError.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryConfigurationError.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/FactoryConfigurationError.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,135 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-/**
- * Thrown when a problem with configuration with the Parser Factories
- * exists. This error will typically be thrown when the class of a
- * parser factory specified in the system properties cannot be found
- * or instantiated.
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @version $Revision: 1.7 $, $Date: 2010-11-01 04:36:09 $
- */
-
-public class FactoryConfigurationError extends Error {
-    private static final long serialVersionUID = -827108682472263355L;
-
-    /**
-     *<code>Exception</code> that represents the error.
-     */
-    private Exception exception;
-
-    /**
-     * Create a new <code>FactoryConfigurationError</code> with no
-     * detail mesage.
-     */
-
-    public FactoryConfigurationError() {
-        super();
-        this.exception = null;
-    }
-
-    /**
-     * Create a new <code>FactoryConfigurationError</code> with
-     * the <code>String </code> specified as an error message.
-     *
-     * @param msg The error message for the exception.
-     */
-
-    public FactoryConfigurationError(String msg) {
-        super(msg);
-        this.exception = null;
-    }
-
-
-    /**
-     * Create a new <code>FactoryConfigurationError</code> with a
-     * given <code>Exception</code> base cause of the error.
-     *
-     * @param e The exception to be encapsulated in a
-     * FactoryConfigurationError.
-     */
-
-    public FactoryConfigurationError(Exception e) {
-        super(e.toString());
-        this.exception = e;
-    }
-
-    /**
-     * Create a new <code>FactoryConfigurationError</code> with the
-     * given <code>Exception</code> base cause and detail message.
-     *
-     * @param e The exception to be encapsulated in a
-     * FactoryConfigurationError
-     * @param msg The detail message.
-     */
-
-    public FactoryConfigurationError(Exception e, String msg) {
-        super(msg);
-        this.exception = e;
-    }
-
-
-    /**
-     * Return the message (if any) for this error . If there is no
-     * message for the exception and there is an encapsulated
-     * exception then the message of that exception, if it exists will be
-     * returned. Else the name of the encapsulated exception will be
-     * returned.
-     *
-     * @return The error message.
-     */
-
-    public String getMessage () {
-        String message = super.getMessage ();
-
-        if (message == null && exception != null) {
-            return exception.getMessage();
-        }
-
-        return message;
-    }
-
-    /**
-     * Return the actual exception (if any) that caused this exception to
-     * be raised.
-     *
-     * @return The encapsulated exception, or null if there is none.
-     */
-
-    public Exception getException () {
-        return exception;
-    }
-
-    /**
-     * use the exception chaining mechanism of JDK1.4
-    */
-    @Override
-    public Throwable getCause() {
-        return exception;
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/parsers/ParserConfigurationException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/parsers/ParserConfigurationException.java b/Build/src/main/java/org/openjdk/javax/xml/parsers/ParserConfigurationException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/parsers/ParserConfigurationException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.parsers;
-
-/**
- * Indicates a serious configuration error.
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-
-public class ParserConfigurationException extends Exception {
-
-    /**
-     * Create a new <code>ParserConfigurationException</code> with no
-     * detail mesage.
-     */
-
-    public ParserConfigurationException() {
-        super();
-    }
-
-    /**
-     * Create a new <code>ParserConfigurationException</code> with
-     * the <code>String</code> specified as an error message.
-     *
-     * @param msg The error message for the exception.
-     */
-
-    public ParserConfigurationException(String msg) {
-        super(msg);
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/package.html b/Build/src/main/java/org/openjdk/javax/xml/datatype/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,170 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2004, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-	<head>
-		<title>javax.xml.xpath</title>
-
-		<meta name="@author" content="mailto:Jeff.Suttor@Sun.com" />
-		<meta name="@version" content="$Revision: 1.2 $, $Date: 2005/06/10 03:50:27 $" />
-		<meta name="@see" content='<a href="http://www.w3.org/TR/xmlschema-2/#dateTime">W3C XML Schema 1.0 Part 2, Section 3.2.7-14</a>' />
-		<meta name="@see" content='<a href="http://www.w3.org/TR/xpath-datamodel#dt-dayTimeDuration">XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a>' />
-		<meta name="@see" content='<a href="http://www.w3.org/TR/xpath-datamodel#dt-yearMonthDuration">XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration</a>' />
-		<meta name="@since" content="1.5" />
-	</head>
-
-	<body>
-
-		<p>XML/Java Type Mappings.</p>
-		
-		<p><code>javax.xml.datatype</code>API provides XML/Java type mappings.</p>
-		
-		<p>The following XML standards apply:</p>
-		<ul>
-			<li><a href="http://www.w3.org/TR/xmlschema-2/#dateTime">W3C XML Schema 1.0 Part 2, Section 3.2.7-14</a></li>
-			<li><a href="http://www.w3.org/TR/xpath-datamodel#dt-dayTimeDuration">XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a></li>
-			<li><a href="http://www.w3.org/TR/xpath-datamodel#dt-yearMonthDuration">XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration</a></li>
-		</ul>
-
-		<hr />
-		
-		<table border="1" cellpadding="2">
-			<thead>
-				<tr>
-					<th>W3C XML Schema Data Type</th>
-					<th>Java Data Type</th>
-				</tr>
-			</thead>
-			
-			<tbody>
-				<tr>
-					<td>xs:date</td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				<tr>
-					<td>xs:dateTime</td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				<tr>
-					<td>xs:duration</td>
-					<td>{@link javax.xml.datatype.Duration}</td>
-				</tr>
-				<tr>
-					<td>xs:gDay</td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				<tr>
-					<td>xs:gMonth </td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				<tr>
-					<td>xs:gMonthDay</td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				<tr>
-					<td>xs:gYear</td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				<tr>
-					<td>xs:gYearMonth</td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				<tr>
-					<td>xs:time</td>
-					<td>{@link javax.xml.datatype.XMLGregorianCalendar}</td>
-				</tr>
-				
-			</tbody>
-		</table>
-		
-		<hr />
-		
-		
-		<table border="1" cellpadding="2">
-			<thead>
-				<tr>
-					<th>XQuery 1.0 and XPath 2.0 Data Model</th>
-					<th>Java Data Type</th>
-				</tr>
-			</thead>
-			
-			<tbody>
-				<tr>
-					<td>xdt:dayTimeDuration</td>
-					<td>{@link javax.xml.datatype.Duration}</td>
-				</tr>
-				<tr>
-					<td>xdt:yearMonthDuration</td>
-					<td>{@link javax.xml.datatype.Duration}</td>
-				</tr>
-			</tbody>
-		</table>
-		
-		<hr />
-		
-		<p>
-			W3C XML Schema data types that have a "<em>natural</em>" mapping to Java types are defined by
-			JSR 31: Java&trade; Architecture for XML Binding (JAXB) Specification, Binding XML Schema to Java Representations.
-			JAXB defined mappings for XML Schema built-in data types include:
-		</p>
-		<ul>
-			<li>xs:anySimpleType</li>
-			<li>xs:base64Binary</li>
-			<li>xs:boolean</li>
-			<li>xs:byte</li>
-			<li>xs:decimal</li>
-			<li>xs:double</li>
-			<li>xs:float</li>
-			<li>xs:hexBinary</li>
-			<li>xs:int</li>
-			<li>xs:integer</li>
-			<li>xs:long</li>
-			<li>xs:QName</li>
-			<li>xs:short</li>
-			<li>xs:string</li>
-			<li>xs:unsignedByte</li>
-			<li>xs:unsignedInt</li>
-			<li>xs:unsignedShort</li>
-		</ul>
-		
-		<hr />
-		
-
-		<ul>
-			<li>Author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a></li>
-			<li>See <a href="http://www.w3.org/TR/xmlschema-2/#dateTime">W3C XML Schema 1.0 Part 2, Section 3.2.7-14</a></li>
-			<li>See <a href="http://www.w3.org/TR/xpath-datamodel#dt-dayTimeDuration">XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a></li>
-			<li>See <a href="http://www.w3.org/TR/xpath-datamodel#dt-yearMonthDuration">XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration</a></li>
-			<li>Since 1.5</li>
-		</ul>
-		
-		<hr />
-		
-
-	</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/Duration.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/Duration.java b/Build/src/main/java/org/openjdk/javax/xml/datatype/Duration.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/Duration.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,988 +0,0 @@
-/*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.datatype;
-
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-
-import javax.xml.namespace.QName;
-
-/**
- * <p>Immutable representation of a time span as defined in
- * the W3C XML Schema 1.0 specification.</p>
- *
- * <p>A Duration object represents a period of Gregorian time,
- * which consists of six fields (years, months, days, hours,
- * minutes, and seconds) plus a sign (+/-) field.</p>
- *
- * <p>The first five fields have non-negative (>=0) integers or null
- * (which represents that the field is not set),
- * and the seconds field has a non-negative decimal or null.
- * A negative sign indicates a negative duration.</p>
- *
- * <p>This class provides a number of methods that make it easy
- * to use for the duration datatype of XML Schema 1.0 with
- * the errata.</p>
- *
- * <h2>Order relationship</h2>
- * <p>Duration objects only have partial order, where two values A and B
- * maybe either:</p>
- * <ol>
- *  <li>A&lt;B (A is shorter than B)
- *  <li>A&gt;B (A is longer than B)
- *  <li>A==B   (A and B are of the same duration)
- *  <li>A&lt;>B (Comparison between A and B is indeterminate)
- * </ol>
- *
- * <p>For example, 30 days cannot be meaningfully compared to one month.
- * The {@link #compare(Duration duration)} method implements this
- * relationship.</p>
- *
- * <p>See the {@link #isLongerThan(Duration)} method for details about
- * the order relationship among <code>Duration</code> objects.</p>
- *
- * <h2>Operations over Duration</h2>
- * <p>This class provides a set of basic arithmetic operations, such
- * as addition, subtraction and multiplication.
- * Because durations don't have total order, an operation could
- * fail for some combinations of operations. For example, you cannot
- * subtract 15 days from 1 month. See the javadoc of those methods
- * for detailed conditions where this could happen.</p>
- *
- * <p>Also, division of a duration by a number is not provided because
- * the <code>Duration</code> class can only deal with finite precision
- * decimal numbers. For example, one cannot represent 1 sec divided by 3.</p>
- *
- * <p>However, you could substitute a division by 3 with multiplying
- * by numbers such as 0.3 or 0.333.</p>
- *
- * <h2>Range of allowed values</h2>
- * <p>
- * Because some operations of <code>Duration</code> rely on {@link Calendar}
- * even though {@link Duration} can hold very large or very small values,
- * some of the methods may not work correctly on such <code>Duration</code>s.
- * The impacted methods document their dependency on {@link Calendar}.
- *
- * @author <a href="mailto:Joseph.Fialli@Sun.COM">Joseph Fialli</a>
- * @author <a href="mailto:Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @author <a href="mailto:Sunitha.Reddy@Sun.com">Sunitha Reddy</a>
- * @see javax.xml.datatype.XMLGregorianCalendar#add(Duration)
- * @since 1.5
- */
-public abstract class Duration {
-
-    /**
-     * <p>Debugging <code>true</code> or <code>false</code>.</p>
-     */
-    private static final boolean DEBUG = true;
-
-    /**
-     * Default no-arg constructor.
-     *
-     * <p>Note: Always use the {@link javax.xml.datatype.DatatypeFactory} to
-     * construct an instance of <code>Duration</code>.
-     * The constructor on this class cannot be guaranteed to
-     * produce an object with a consistent state and may be
-     * removed in the future.</p>
-     */
-    public Duration() {
-    }
-
-    /**
-     * <p>Return the name of the XML Schema date/time type that this instance
-     * maps to. Type is computed based on fields that are set,
-     * i.e. {@link #isSet(javax.xml.datatype.DatatypeConstants.Field field)} == <code>true</code>.</p>
-     *
-     * <table border="2" rules="all" cellpadding="2">
-     *   <thead>
-     *     <tr>
-     *       <th align="center" colspan="7">
-     *         Required fields for XML Schema 1.0 Date/Time Datatypes.<br/>
-     *         <i>(timezone is optional for all date/time datatypes)</i>
-     *       </th>
-     *     </tr>
-     *   </thead>
-     *   <tbody>
-     *     <tr>
-     *       <td>Datatype</td>
-     *       <td>year</td>
-     *       <td>month</td>
-     *       <td>day</td>
-     *       <td>hour</td>
-     *       <td>minute</td>
-     *       <td>second</td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#DURATION}</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#DURATION_DAYTIME}</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#DURATION_YEARMONTH}</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *     </tr>
-     *   </tbody>
-     * </table>
-     *
-     * @return one of the following constants:
-     *   {@link javax.xml.datatype.DatatypeConstants#DURATION},
-     *   {@link javax.xml.datatype.DatatypeConstants#DURATION_DAYTIME} or
-     *   {@link javax.xml.datatype.DatatypeConstants#DURATION_YEARMONTH}.
-     *
-     * @throws IllegalStateException If the combination of set fields does not match one of the XML Schema date/time datatypes.
-     */
-    public QName getXMLSchemaType() {
-
-        boolean yearSet = isSet(javax.xml.datatype.DatatypeConstants.YEARS);
-        boolean monthSet = isSet(javax.xml.datatype.DatatypeConstants.MONTHS);
-        boolean daySet = isSet(javax.xml.datatype.DatatypeConstants.DAYS);
-        boolean hourSet = isSet(javax.xml.datatype.DatatypeConstants.HOURS);
-        boolean minuteSet = isSet(javax.xml.datatype.DatatypeConstants.MINUTES);
-        boolean secondSet = isSet(javax.xml.datatype.DatatypeConstants.SECONDS);
-
-        // DURATION
-        if (yearSet
-            && monthSet
-            && daySet
-            && hourSet
-            && minuteSet
-            && secondSet) {
-            return javax.xml.datatype.DatatypeConstants.DURATION;
-        }
-
-        // DURATION_DAYTIME
-        if (!yearSet
-            && !monthSet
-            && daySet
-            && hourSet
-            && minuteSet
-            && secondSet) {
-            return javax.xml.datatype.DatatypeConstants.DURATION_DAYTIME;
-        }
-
-        // DURATION_YEARMONTH
-        if (yearSet
-            && monthSet
-            && !daySet
-            && !hourSet
-            && !minuteSet
-            && !secondSet) {
-            return javax.xml.datatype.DatatypeConstants.DURATION_YEARMONTH;
-        }
-
-        // nothing matches
-        throw new IllegalStateException(
-                "javax.xml.datatype.Duration#getXMLSchemaType():"
-                + " this Duration does not match one of the XML Schema date/time datatypes:"
-                + " year set = " + yearSet
-                + " month set = " + monthSet
-                + " day set = " + daySet
-                + " hour set = " + hourSet
-                + " minute set = " + minuteSet
-                + " second set = " + secondSet
-        );
-    }
-
-    /**
-     * Returns the sign of this duration in -1,0, or 1.
-     *
-     * @return
-     *      -1 if this duration is negative, 0 if the duration is zero,
-     *      and 1 if the duration is positive.
-     */
-    public abstract int getSign();
-
-    /**
-     * <p>Get the years value of this <code>Duration</code> as an <code>int</code> or <code>0</code> if not present.</p>
-     *
-     * <p><code>getYears()</code> is a convenience method for
-     * {@link #getField(javax.xml.datatype.DatatypeConstants.Field field) getField(DatatypeConstants.YEARS)}.</p>
-     *
-     * <p>As the return value is an <code>int</code>, an incorrect value will be returned for <code>Duration</code>s
-     * with years that go beyond the range of an <code>int</code>.
-     * Use {@link #getField(javax.xml.datatype.DatatypeConstants.Field field) getField(DatatypeConstants.YEARS)} to avoid possible loss of precision.</p>
-     *
-     * @return If the years field is present, return its value as an <code>int</code>, else return <code>0</code>.
-     */
-    public int getYears() {
-        return getField(javax.xml.datatype.DatatypeConstants.YEARS).intValue();
-    }
-
-    /**
-     * Obtains the value of the MONTHS field as an integer value,
-     * or 0 if not present.
-     *
-     * This method works just like {@link #getYears()} except
-     * that this method works on the MONTHS field.
-     *
-     * @return Months of this <code>Duration</code>.
-     */
-    public int getMonths() {
-        return getField(javax.xml.datatype.DatatypeConstants.MONTHS).intValue();
-    }
-
-    /**
-     * Obtains the value of the DAYS field as an integer value,
-     * or 0 if not present.
-     *
-     * This method works just like {@link #getYears()} except
-     * that this method works on the DAYS field.
-     *
-     * @return Days of this <code>Duration</code>.
-     */
-    public int getDays() {
-        return getField(javax.xml.datatype.DatatypeConstants.DAYS).intValue();
-    }
-
-    /**
-     * Obtains the value of the HOURS field as an integer value,
-     * or 0 if not present.
-     *
-     * This method works just like {@link #getYears()} except
-     * that this method works on the HOURS field.
-     *
-     * @return Hours of this <code>Duration</code>.
-     *
-     */
-    public int getHours() {
-        return getField(javax.xml.datatype.DatatypeConstants.HOURS).intValue();
-    }
-
-    /**
-     * Obtains the value of the MINUTES field as an integer value,
-     * or 0 if not present.
-     *
-     * This method works just like {@link #getYears()} except
-     * that this method works on the MINUTES field.
-     *
-     * @return Minutes of this <code>Duration</code>.
-     *
-     */
-    public int getMinutes() {
-        return getField(javax.xml.datatype.DatatypeConstants.MINUTES).intValue();
-    }
-
-    /**
-     * Obtains the value of the SECONDS field as an integer value,
-     * or 0 if not present.
-     *
-     * This method works just like {@link #getYears()} except
-     * that this method works on the SECONDS field.
-     *
-     * @return seconds in the integer value. The fraction of seconds
-     *   will be discarded (for example, if the actual value is 2.5,
-     *   this method returns 2)
-     */
-    public int getSeconds() {
-        return getField(javax.xml.datatype.DatatypeConstants.SECONDS).intValue();
-    }
-
-    /**
-     * <p>Returns the length of the duration in milli-seconds.</p>
-     *
-     * <p>If the seconds field carries more digits than milli-second order,
-     * those will be simply discarded (or in other words, rounded to zero.)
-     * For example, for any Calendar value <code>x</code>,</p>
-     * <pre>
-     * <code>new Duration("PT10.00099S").getTimeInMills(x) == 10000</code>.
-     * <code>new Duration("-PT10.00099S").getTimeInMills(x) == -10000</code>.
-     * </pre>
-     *
-     * <p>
-     * Note that this method uses the {@link #addTo(Calendar)} method,
-     * which may work incorrectly with <code>Duration</code> objects with
-     * very large values in its fields. See the {@link #addTo(Calendar)}
-     * method for details.
-     *
-     * @param startInstant
-     *      The length of a month/year varies. The <code>startInstant</code> is
-     *      used to disambiguate this variance. Specifically, this method
-     *      returns the difference between <code>startInstant</code> and
-     *      <code>startInstant+duration</code>
-     *
-     * @return milliseconds between <code>startInstant</code> and
-     *   <code>startInstant</code> plus this <code>Duration</code>
-     *
-     * @throws NullPointerException if <code>startInstant</code> parameter
-     * is null.
-     *
-     */
-    public long getTimeInMillis(final Calendar startInstant) {
-        Calendar cal = (Calendar) startInstant.clone();
-        addTo(cal);
-        return getCalendarTimeInMillis(cal)
-                    - getCalendarTimeInMillis(startInstant);
-    }
-
-    /**
-     * <p>Returns the length of the duration in milli-seconds.</p>
-     *
-     * <p>If the seconds field carries more digits than milli-second order,
-     * those will be simply discarded (or in other words, rounded to zero.)
-     * For example, for any <code>Date</code> value <code>x</code>,</p>
-     * <pre>
-     * <code>new Duration("PT10.00099S").getTimeInMills(x) == 10000</code>.
-     * <code>new Duration("-PT10.00099S").getTimeInMills(x) == -10000</code>.
-     * </pre>
-     *
-     * <p>
-     * Note that this method uses the {@link #addTo(Date)} method,
-     * which may work incorrectly with <code>Duration</code> objects with
-     * very large values in its fields. See the {@link #addTo(Date)}
-     * method for details.
-     *
-     * @param startInstant
-     *      The length of a month/year varies. The <code>startInstant</code> is
-     *      used to disambiguate this variance. Specifically, this method
-     *      returns the difference between <code>startInstant</code> and
-     *      <code>startInstant+duration</code>.
-     *
-     * @throws NullPointerException
-     *      If the startInstant parameter is null.
-     *
-     * @return milliseconds between <code>startInstant</code> and
-     *   <code>startInstant</code> plus this <code>Duration</code>
-     *
-     * @see #getTimeInMillis(Calendar)
-     */
-    public long getTimeInMillis(final Date startInstant) {
-        Calendar cal = new GregorianCalendar();
-        cal.setTime(startInstant);
-        this.addTo(cal);
-        return getCalendarTimeInMillis(cal) - startInstant.getTime();
-    }
-
-    /**
-     * Gets the value of a field.
-     *
-     * Fields of a duration object may contain arbitrary large value.
-     * Therefore this method is designed to return a {@link Number} object.
-     *
-     * In case of YEARS, MONTHS, DAYS, HOURS, and MINUTES, the returned
-     * number will be a non-negative integer. In case of seconds,
-     * the returned number may be a non-negative decimal value.
-     *
-     * @param field
-     *      one of the six Field constants (YEARS,MONTHS,DAYS,HOURS,
-     *      MINUTES, or SECONDS.)
-     * @return
-     *      If the specified field is present, this method returns
-     *      a non-null non-negative {@link Number} object that
-     *      represents its value. If it is not present, return null.
-     *      For YEARS, MONTHS, DAYS, HOURS, and MINUTES, this method
-     *      returns a {@link java.math.BigInteger} object. For SECONDS, this
-     *      method returns a {@link java.math.BigDecimal}.
-     *
-     * @throws NullPointerException If the <code>field</code> is <code>null</code>.
-     */
-    public abstract Number getField(final javax.xml.datatype.DatatypeConstants.Field field);
-
-    /**
-     * Checks if a field is set.
-     *
-     * A field of a duration object may or may not be present.
-     * This method can be used to test if a field is present.
-     *
-     * @param field
-     *      one of the six Field constants (YEARS,MONTHS,DAYS,HOURS,
-     *      MINUTES, or SECONDS.)
-     * @return
-     *      true if the field is present. false if not.
-     *
-     * @throws NullPointerException
-     *      If the field parameter is null.
-     */
-    public abstract boolean isSet(final javax.xml.datatype.DatatypeConstants.Field field);
-
-    /**
-     * <p>Computes a new duration whose value is <code>this+rhs</code>.</p>
-     *
-     * <p>For example,</p>
-     * <pre>
-     * "1 day" + "-3 days" = "-2 days"
-     * "1 year" + "1 day" = "1 year and 1 day"
-     * "-(1 hour,50 minutes)" + "-20 minutes" = "-(1 hours,70 minutes)"
-     * "15 hours" + "-3 days" = "-(2 days,9 hours)"
-     * "1 year" + "-1 day" = IllegalStateException
-     * </pre>
-     *
-     * <p>Since there's no way to meaningfully subtract 1 day from 1 month,
-     * there are cases where the operation fails in
-     * {@link IllegalStateException}.</p>
-     *
-     * <p>
-     * Formally, the computation is defined as follows.</p>
-     * <p>
-     * Firstly, we can assume that two <code>Duration</code>s to be added
-     * are both positive without losing generality (i.e.,
-     * <code>(-X)+Y=Y-X</code>, <code>X+(-Y)=X-Y</code>,
-     * <code>(-X)+(-Y)=-(X+Y)</code>)
-     *
-     * <p>
-     * Addition of two positive <code>Duration</code>s are simply defined as
-     * field by field addition where missing fields are treated as 0.
-     * <p>
-     * A field of the resulting <code>Duration</code> will be unset if and
-     * only if respective fields of two input <code>Duration</code>s are unset.
-     * <p>
-     * Note that <code>lhs.add(rhs)</code> will be always successful if
-     * <code>lhs.signum()*rhs.signum()!=-1</code> or both of them are
-     * normalized.</p>
-     *
-     * @param rhs <code>Duration</code> to add to this <code>Duration</code>
-     *
-     * @return
-     *      non-null valid Duration object.
-     *
-     * @throws NullPointerException
-     *      If the rhs parameter is null.
-     * @throws IllegalStateException
-     *      If two durations cannot be meaningfully added. For
-     *      example, adding negative one day to one month causes
-     *      this exception.
-     *
-     *
-     * @see #subtract(Duration)
-     */
-    public abstract Duration add(final Duration rhs);
-
-    /**
-     * Adds this duration to a {@link Calendar} object.
-     *
-     * <p>
-     * Calls {@link java.util.Calendar#add(int,int)} in the
-     * order of YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, and MILLISECONDS
-     * if those fields are present. Because the {@link Calendar} class
-     * uses int to hold values, there are cases where this method
-     * won't work correctly (for example if values of fields
-     * exceed the range of int.)
-     * </p>
-     *
-     * <p>
-     * Also, since this duration class is a Gregorian duration, this
-     * method will not work correctly if the given {@link Calendar}
-     * object is based on some other calendar systems.
-     * </p>
-     *
-     * <p>
-     * Any fractional parts of this <code>Duration</code> object
-     * beyond milliseconds will be simply ignored. For example, if
-     * this duration is "P1.23456S", then 1 is added to SECONDS,
-     * 234 is added to MILLISECONDS, and the rest will be unused.
-     * </p>
-     *
-     * <p>
-     * Note that because {@link Calendar#add(int, int)} is using
-     * <code>int</code>, <code>Duration</code> with values beyond the
-     * range of <code>int</code> in its fields
-     * will cause overflow/underflow to the given {@link Calendar}.
-     * {@link XMLGregorianCalendar#add(Duration)} provides the same
-     * basic operation as this method while avoiding
-     * the overflow/underflow issues.
-     *
-     * @param calendar
-     *      A calendar object whose value will be modified.
-     * @throws NullPointerException
-     *      if the calendar parameter is null.
-     */
-    public abstract void addTo(Calendar calendar);
-
-    /**
-     * Adds this duration to a {@link Date} object.
-     *
-     * <p>
-     * The given date is first converted into
-     * a {@link java.util.GregorianCalendar}, then the duration
-     * is added exactly like the {@link #addTo(Calendar)} method.
-     *
-     * <p>
-     * The updated time instant is then converted back into a
-     * {@link Date} object and used to update the given {@link Date} object.
-     *
-     * <p>
-     * This somewhat redundant computation is necessary to unambiguously
-     * determine the duration of months and years.
-     *
-     * @param date
-     *      A date object whose value will be modified.
-     * @throws NullPointerException
-     *      if the date parameter is null.
-     */
-    public void addTo(Date date) {
-
-        // check data parameter
-        if (date == null) {
-            throw new NullPointerException(
-                "Cannot call "
-                + this.getClass().getName()
-                + "#addTo(Date date) with date == null."
-            );
-        }
-
-        Calendar cal = new GregorianCalendar();
-        cal.setTime(date);
-        this.addTo(cal);
-        date.setTime(getCalendarTimeInMillis(cal));
-    }
-
-    /**
-     * <p>Computes a new duration whose value is <code>this-rhs</code>.</p>
-     *
-     * <p>For example:</p>
-     * <pre>
-     * "1 day" - "-3 days" = "4 days"
-     * "1 year" - "1 day" = IllegalStateException
-     * "-(1 hour,50 minutes)" - "-20 minutes" = "-(1hours,30 minutes)"
-     * "15 hours" - "-3 days" = "3 days and 15 hours"
-     * "1 year" - "-1 day" = "1 year and 1 day"
-     * </pre>
-     *
-     * <p>Since there's no way to meaningfully subtract 1 day from 1 month,
-     * there are cases where the operation fails in {@link IllegalStateException}.</p>
-     *
-     * <p>Formally the computation is defined as follows.
-     * First, we can assume that two <code>Duration</code>s are both positive
-     * without losing generality.  (i.e.,
-     * <code>(-X)-Y=-(X+Y)</code>, <code>X-(-Y)=X+Y</code>,
-     * <code>(-X)-(-Y)=-(X-Y)</code>)</p>
-     *
-     * <p>Then two durations are subtracted field by field.
-     * If the sign of any non-zero field <code>F</code> is different from
-     * the sign of the most significant field,
-     * 1 (if <code>F</code> is negative) or -1 (otherwise)
-     * will be borrowed from the next bigger unit of <code>F</code>.</p>
-     *
-     * <p>This process is repeated until all the non-zero fields have
-     * the same sign.</p>
-     *
-     * <p>If a borrow occurs in the days field (in other words, if
-     * the computation needs to borrow 1 or -1 month to compensate
-     * days), then the computation fails by throwing an
-     * {@link IllegalStateException}.</p>
-     *
-     * @param rhs <code>Duration</code> to subtract from this <code>Duration</code>.
-     *
-     * @return New <code>Duration</code> created from subtracting <code>rhs</code> from this <code>Duration</code>.
-     *
-     * @throws IllegalStateException
-     *      If two durations cannot be meaningfully subtracted. For
-     *      example, subtracting one day from one month causes
-     *      this exception.
-     *
-     * @throws NullPointerException
-     *      If the rhs parameter is null.
-     *
-     * @see #add(Duration)
-     */
-    public Duration subtract(final Duration rhs) {
-        return add(rhs.negate());
-    }
-
-    /**
-     * <p>Computes a new duration whose value is <code>factor</code> times
-     * longer than the value of this duration.</p>
-     *
-     * <p>This method is provided for the convenience.
-     * It is functionally equivalent to the following code:</p>
-     * <pre>
-     * multiply(new BigDecimal(String.valueOf(factor)))
-     * </pre>
-     *
-     * @param factor Factor times longer of new <code>Duration</code> to create.
-     *
-     * @return New <code>Duration</code> that is <code>factor</code>times longer than this <code>Duration</code>.
-     *
-     * @see #multiply(BigDecimal)
-     */
-    public Duration multiply(int factor) {
-        return multiply(new BigDecimal(String.valueOf(factor)));
-    }
-
-    /**
-     * Computes a new duration whose value is <code>factor</code> times
-     * longer than the value of this duration.
-     *
-     * <p>
-     * For example,
-     * <pre>
-     * "P1M" (1 month) * "12" = "P12M" (12 months)
-     * "PT1M" (1 min) * "0.3" = "PT18S" (18 seconds)
-     * "P1M" (1 month) * "1.5" = IllegalStateException
-     * </pre>
-     *
-     * <p>
-     * Since the <code>Duration</code> class is immutable, this method
-     * doesn't change the value of this object. It simply computes
-     * a new Duration object and returns it.
-     *
-     * <p>
-     * The operation will be performed field by field with the precision
-     * of {@link BigDecimal}. Since all the fields except seconds are
-     * restricted to hold integers,
-     * any fraction produced by the computation will be
-     * carried down toward the next lower unit. For example,
-     * if you multiply "P1D" (1 day) with "0.5", then it will be 0.5 day,
-     * which will be carried down to "PT12H" (12 hours).
-     * When fractions of month cannot be meaningfully carried down
-     * to days, or year to months, this will cause an
-     * {@link IllegalStateException} to be thrown.
-     * For example if you multiple one month by 0.5.</p>
-     *
-     * <p>
-     * To avoid {@link IllegalStateException}, use
-     * the {@link #normalizeWith(Calendar)} method to remove the years
-     * and months fields.
-     *
-     * @param factor to multiply by
-     *
-     * @return
-     *      returns a non-null valid <code>Duration</code> object
-     *
-     * @throws IllegalStateException if operation produces fraction in
-     * the months field.
-     *
-     * @throws NullPointerException if the <code>factor</code> parameter is
-     * <code>null</code>.
-     *
-     */
-    public abstract Duration multiply(final BigDecimal factor);
-
-    /**
-     * Returns a new <code>Duration</code> object whose
-     * value is <code>-this</code>.
-     *
-     * <p>
-     * Since the <code>Duration</code> class is immutable, this method
-     * doesn't change the value of this object. It simply computes
-     * a new Duration object and returns it.
-     *
-     * @return
-     *      always return a non-null valid <code>Duration</code> object.
-     */
-    public abstract Duration negate();
-
-    /**
-     * <p>Converts the years and months fields into the days field
-     * by using a specific time instant as the reference point.</p>
-     *
-     * <p>For example, duration of one month normalizes to 31 days
-     * given the start time instance "July 8th 2003, 17:40:32".</p>
-     *
-     * <p>Formally, the computation is done as follows:</p>
-     * <ol>
-     *  <li>the given Calendar object is cloned</li>
-     *  <li>the years, months and days fields will be added to the {@link Calendar} object
-     *      by using the {@link Calendar#add(int,int)} method</li>
-     *  <li>the difference between the two Calendars in computed in milliseconds and converted to days,
-     *     if a remainder occurs due to Daylight Savings Time, it is discarded</li>
-     *  <li>the computed days, along with the hours, minutes and seconds
-     *      fields of this duration object is used to construct a new
-     *      Duration object.</li>
-     * </ol>
-     *
-     * <p>Note that since the Calendar class uses <code>int</code> to
-     * hold the value of year and month, this method may produce
-     * an unexpected result if this duration object holds
-     * a very large value in the years or months fields.</p>
-     *
-     * @param startTimeInstant <code>Calendar</code> reference point.
-     *
-     * @return <code>Duration</code> of years and months of this <code>Duration</code> as days.
-     *
-     * @throws NullPointerException If the startTimeInstant parameter is null.
-     */
-    public abstract Duration normalizeWith(final Calendar startTimeInstant);
-
-    /**
-     * <p>Partial order relation comparison with this <code>Duration</code> instance.</p>
-     *
-     * <p>Comparison result must be in accordance with
-     * <a href="http://www.w3.org/TR/xmlschema-2/#duration-order">W3C XML Schema 1.0 Part 2, Section 3.2.7.6.2,
-     * <i>Order relation on duration</i></a>.</p>
-     *
-     * <p>Return:</p>
-     * <ul>
-     *   <li>{@link javax.xml.datatype.DatatypeConstants#LESSER} if this <code>Duration</code> is shorter than <code>duration</code> parameter</li>
-     *   <li>{@link javax.xml.datatype.DatatypeConstants#EQUAL} if this <code>Duration</code> is equal to <code>duration</code> parameter</li>
-     *   <li>{@link javax.xml.datatype.DatatypeConstants#GREATER} if this <code>Duration</code> is longer than <code>duration</code> parameter</li>
-     *   <li>{@link javax.xml.datatype.DatatypeConstants#INDETERMINATE} if a conclusive partial order relation cannot be determined</li>
-     * </ul>
-     *
-     * @param duration to compare
-     *
-     * @return the relationship between <code>this</code> <code>Duration</code>and <code>duration</code> parameter as
-     *   {@link javax.xml.datatype.DatatypeConstants#LESSER}, {@link javax.xml.datatype.DatatypeConstants#EQUAL}, {@link javax.xml.datatype.DatatypeConstants#GREATER}
-     *   or {@link javax.xml.datatype.DatatypeConstants#INDETERMINATE}.
-     *
-     * @throws UnsupportedOperationException If the underlying implementation
-     *   cannot reasonably process the request, e.g. W3C XML Schema allows for
-     *   arbitrarily large/small/precise values, the request may be beyond the
-     *   implementations capability.
-     * @throws NullPointerException if <code>duration</code> is <code>null</code>.
-     *
-     * @see #isShorterThan(Duration)
-     * @see #isLongerThan(Duration)
-     */
-    public abstract int compare(final Duration duration);
-
-    /**
-     * <p>Checks if this duration object is strictly longer than
-     * another <code>Duration</code> object.</p>
-     *
-     * <p>Duration X is "longer" than Y if and only if X>Y
-     * as defined in the section 3.2.6.2 of the XML Schema 1.0
-     * specification.</p>
-     *
-     * <p>For example, "P1D" (one day) > "PT12H" (12 hours) and
-     * "P2Y" (two years) > "P23M" (23 months).</p>
-     *
-     * @param duration <code>Duration</code> to test this <code>Duration</code> against.
-     *
-     * @throws UnsupportedOperationException If the underlying implementation
-     *   cannot reasonably process the request, e.g. W3C XML Schema allows for
-     *   arbitrarily large/small/precise values, the request may be beyond the
-     *   implementations capability.
-     * @throws NullPointerException If <code>duration</code> is null.
-     *
-     * @return
-     *      true if the duration represented by this object
-     *      is longer than the given duration. false otherwise.
-     *
-     * @see #isShorterThan(Duration)
-     * @see #compare(Duration duration)
-     */
-    public boolean isLongerThan(final Duration duration) {
-        return compare(duration) == javax.xml.datatype.DatatypeConstants.GREATER;
-    }
-
-    /**
-     * <p>Checks if this duration object is strictly shorter than
-     * another <code>Duration</code> object.</p>
-     *
-     * @param duration <code>Duration</code> to test this <code>Duration</code> against.
-     *
-     * @return <code>true</code> if <code>duration</code> parameter is shorter than this <code>Duration</code>,
-     *   else <code>false</code>.
-     *
-     * @throws UnsupportedOperationException If the underlying implementation
-     *   cannot reasonably process the request, e.g. W3C XML Schema allows for
-     *   arbitrarily large/small/precise values, the request may be beyond the
-     *   implementations capability.
-     * @throws NullPointerException if <code>duration</code> is null.
-     *
-     * @see #isLongerThan(Duration duration)
-     * @see #compare(Duration duration)
-     */
-    public boolean isShorterThan(final Duration duration) {
-        return compare(duration) == javax.xml.datatype.DatatypeConstants.LESSER;
-    }
-
-    /**
-     * <p>Checks if this duration object has the same duration
-     * as another <code>Duration</code> object.</p>
-     *
-     * <p>For example, "P1D" (1 day) is equal to "PT24H" (24 hours).</p>
-     *
-     * <p>Duration X is equal to Y if and only if time instant
-     * t+X and t+Y are the same for all the test time instants
-     * specified in the section 3.2.6.2 of the XML Schema 1.0
-     * specification.</p>
-     *
-     * <p>Note that there are cases where two <code>Duration</code>s are
-     * "incomparable" to each other, like one month and 30 days.
-     * For example,</p>
-     * <pre>
-     * !new Duration("P1M").isShorterThan(new Duration("P30D"))
-     * !new Duration("P1M").isLongerThan(new Duration("P30D"))
-     * !new Duration("P1M").equals(new Duration("P30D"))
-     * </pre>
-     *
-     * @param duration
-     *      The object to compare this <code>Duration</code> against.
-     *
-     * @return
-     *      <code>true</code> if this duration is the same length as
-     *         <code>duration</code>.
-     *      <code>false</code> if <code>duration</code> is <code>null</code>,
-     *         is not a
-     *         <code>Duration</code> object,
-     *         or its length is different from this duration.
-     *
-     * @throws UnsupportedOperationException If the underlying implementation
-     *   cannot reasonably process the request, e.g. W3C XML Schema allows for
-     *   arbitrarily large/small/precise values, the request may be beyond the
-     *   implementations capability.
-     *
-     * @see #compare(Duration duration)
-     */
-    public boolean equals(final Object duration) {
-
-        if (duration == null || !(duration instanceof Duration)) {
-            return false;
-        }
-
-        return compare((Duration) duration) == javax.xml.datatype.DatatypeConstants.EQUAL;
-    }
-
-    /**
-     * Returns a hash code consistent with the definition of the equals method.
-     *
-     * @see Object#hashCode()
-     */
-    public abstract int hashCode();
-
-    /**
-     * <p>Returns a <code>String</code> representation of this <code>Duration</code> <code>Object</code>.</p>
-     *
-     * <p>The result is formatted according to the XML Schema 1.0 spec and can be always parsed back later into the
-     * equivalent <code>Duration</code> <code>Object</code> by {@link DatatypeFactory#newDuration(String  lexicalRepresentation)}.</p>
-     *
-     * <p>Formally, the following holds for any <code>Duration</code>
-     * <code>Object</code> x:</p>
-     * <pre>
-     * new Duration(x.toString()).equals(x)
-     * </pre>
-     *
-     * @return A non-<code>null</code> valid <code>String</code> representation of this <code>Duration</code>.
-     */
-    public String toString() {
-
-        StringBuffer buf = new StringBuffer();
-
-        if (getSign() < 0) {
-            buf.append('-');
-        }
-        buf.append('P');
-
-        BigInteger years = (BigInteger) getField(javax.xml.datatype.DatatypeConstants.YEARS);
-        if (years != null) {
-            buf.append(years + "Y");
-        }
-
-        BigInteger months = (BigInteger) getField(javax.xml.datatype.DatatypeConstants.MONTHS);
-        if (months != null) {
-            buf.append(months + "M");
-        }
-
-        BigInteger days = (BigInteger) getField(javax.xml.datatype.DatatypeConstants.DAYS);
-        if (days != null) {
-            buf.append(days + "D");
-        }
-
-        BigInteger hours = (BigInteger) getField(javax.xml.datatype.DatatypeConstants.HOURS);
-        BigInteger minutes = (BigInteger) getField(javax.xml.datatype.DatatypeConstants.MINUTES);
-        BigDecimal seconds = (BigDecimal) getField(DatatypeConstants.SECONDS);
-        if (hours != null || minutes != null || seconds != null) {
-            buf.append('T');
-            if (hours != null) {
-                buf.append(hours + "H");
-            }
-            if (minutes != null) {
-                buf.append(minutes + "M");
-            }
-            if (seconds != null) {
-                buf.append(toString(seconds) + "S");
-            }
-        }
-
-        return buf.toString();
-    }
-
-    /**
-     * <p>Turns {@link BigDecimal} to a string representation.</p>
-     *
-     * <p>Due to a behavior change in the {@link BigDecimal#toString()}
-     * method in JDK1.5, this had to be implemented here.</p>
-     *
-     * @param bd <code>BigDecimal</code> to format as a <code>String</code>
-     *
-     * @return  <code>String</code> representation of <code>BigDecimal</code>
-     */
-    private String toString(BigDecimal bd) {
-        String intString = bd.unscaledValue().toString();
-        int scale = bd.scale();
-
-        if (scale == 0) {
-            return intString;
-        }
-
-        /* Insert decimal point */
-        StringBuffer buf;
-        int insertionPoint = intString.length() - scale;
-        if (insertionPoint == 0) { /* Point goes right before intVal */
-            return "0." + intString;
-        } else if (insertionPoint > 0) { /* Point goes inside intVal */
-            buf = new StringBuffer(intString);
-            buf.insert(insertionPoint, '.');
-        } else { /* We must insert zeros between point and intVal */
-            buf = new StringBuffer(3 - insertionPoint + intString.length());
-            buf.append("0.");
-            for (int i = 0; i < -insertionPoint; i++) {
-                buf.append('0');
-            }
-            buf.append(intString);
-        }
-        return buf.toString();
-    }
-
-
-    /**
-     * <p>Calls the {@link Calendar#getTimeInMillis} method.
-     * Prior to JDK1.4, this method was protected and therefore
-     * cannot be invoked directly.</p>
-     *
-     * <p>TODO: In future, this should be replaced by <code>cal.getTimeInMillis()</code>.</p>
-     *
-     * @param cal <code>Calendar</code> to get time in milliseconds.
-     *
-     * @return Milliseconds of <code>cal</code>.
-     */
-    private static long getCalendarTimeInMillis(final Calendar cal) {
-        return cal.getTime().getTime();
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/FactoryFinder.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/FactoryFinder.java b/Build/src/main/java/org/openjdk/javax/xml/datatype/FactoryFinder.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/FactoryFinder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,311 +0,0 @@
-/*
- * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.datatype;
-
-import java.io.File;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Iterator;
-import java.util.Properties;
-import java.util.ServiceConfigurationError;
-import java.util.ServiceLoader;
-
-/**
- * <p>Implements pluggable Datatypes.</p>
- *
- * <p>This class is duplicated for each JAXP subpackage so keep it in
- * sync.  It is package private for secure class loading.</p>
- *
- * @author Santiago.PericasGeertsen@sun.com
- */
-class FactoryFinder {
-    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xerces.internal";
-
-    /**
-     * Internal debug flag.
-     */
-    private static boolean debug = false;
-
-    /**
-     * Cache for properties in java.home/lib/jaxp.properties
-     */
-    private final static Properties cacheProps = new Properties();
-
-    /**
-     * Flag indicating if properties from java.home/lib/jaxp.properties
-     * have been cached.
-     */
-    private static volatile boolean firstTime = true;
-
-    /**
-     * Security support class use to check access control before
-     * getting certain system resources.
-     */
-    private final static SecuritySupport ss = new SecuritySupport();
-
-    // Define system property "jaxp.debug" to get output
-    static {
-        // Use try/catch block to support applets, which throws
-        // SecurityException out of this code.
-        try {
-            String val = ss.getSystemProperty("jaxp.debug");
-            // Allow simply setting the prop to turn on debug
-            debug = val != null && !"false".equals(val);
-        }
-        catch (SecurityException se) {
-            debug = false;
-        }
-    }
-
-    private static void dPrint(String msg) {
-        if (debug) {
-            System.err.println("JAXP: " + msg);
-        }
-    }
-
-    /**
-     * Attempt to load a class using the class loader supplied. If that fails
-     * and fall back is enabled, the current (i.e. bootstrap) class loader is
-     * tried.
-     *
-     * If the class loader supplied is <code>null</code>, first try using the
-     * context class loader followed by the current (i.e. bootstrap) class
-     * loader.
-     *
-     * Use bootstrap classLoader if cl = null and useBSClsLoader is true
-     */
-    static private Class<?> getProviderClass(String className, ClassLoader cl,
-            boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException
-    {
-        try {
-            if (cl == null) {
-                if (useBSClsLoader) {
-                    return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-                } else {
-                    cl = ss.getContextClassLoader();
-                    if (cl == null) {
-                        throw new ClassNotFoundException();
-                    }
-                    else {
-                        return Class.forName(className, false, cl);
-                    }
-                }
-            }
-            else {
-                return Class.forName(className, false, cl);
-            }
-        }
-        catch (ClassNotFoundException e1) {
-            if (doFallback) {
-                // Use current class loader - should always be bootstrap CL
-                return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-            }
-            else {
-                throw e1;
-            }
-        }
-    }
-
-    /**
-     * Create an instance of a class. Delegates to method
-     * <code>getProviderClass()</code> in order to load the class.
-     *
-     * @param type Base class / Service interface  of the factory to
-     *             instantiate.
-     *
-     * @param className Name of the concrete class corresponding to the
-     * service provider
-     *
-     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     * current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @param doFallback True if the current ClassLoader should be tried as
-     * a fallback if the class is not found using cl
-     */
-    static <T> T newInstance(Class<T> type, String className, ClassLoader cl, boolean doFallback)
-        throws javax.xml.datatype.DatatypeConfigurationException
-    {
-        return newInstance(type, className, cl, doFallback, false);
-    }
-
-    /**
-     * Create an instance of a class. Delegates to method
-     * <code>getProviderClass()</code> in order to load the class.
-     *
-     * @param type Base class / Service interface  of the factory to
-     *             instantiate.
-     *
-     * @param className Name of the concrete class corresponding to the
-     * service provider
-     *
-     * @param cl ClassLoader to use to load the class, null means to use
-     * the bootstrap ClassLoader
-     *
-     * @param doFallback True if the current ClassLoader should be tried as
-     * a fallback if the class is not found using cl
-     *
-     * @param useBSClsLoader True if cl=null actually meant bootstrap classLoader. This parameter
-     * is needed since DocumentBuilderFactory/SAXParserFactory defined null as context classLoader.
-     */
-    static <T> T newInstance(Class<T> type, String className, ClassLoader cl,
-            boolean doFallback, boolean useBSClsLoader)
-        throws javax.xml.datatype.DatatypeConfigurationException
-    {
-        assert type != null;
-
-        // make sure we have access to restricted packages
-        if (System.getSecurityManager() != null) {
-            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
-                cl = null;
-                useBSClsLoader = true;
-            }
-        }
-
-        try {
-            Class<?> providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
-            if (!type.isAssignableFrom(providerClass)) {
-                throw new ClassCastException(className + " cannot be cast to " + type.getName());
-            }
-            Object instance = providerClass.newInstance();
-            if (debug) {    // Extra check to avoid computing cl strings
-                dPrint("created new instance of " + providerClass +
-                       " using ClassLoader: " + cl);
-            }
-            return type.cast(instance);
-        }
-        catch (ClassNotFoundException x) {
-            throw new javax.xml.datatype.DatatypeConfigurationException(
-                "Provider " + className + " not found", x);
-        }
-        catch (Exception x) {
-            throw new javax.xml.datatype.DatatypeConfigurationException(
-                "Provider " + className + " could not be instantiated: " + x,
-                x);
-        }
-    }
-
-    /**
-     * Finds the implementation Class object in the specified order.  Main
-     * entry point.
-     * @return Class object of factory, never null
-     *
-     * @param type                  Base class / Service interface  of the
-     *                              factory to find.
-     * @param fallbackClassName     Implementation class name, if nothing else
-     *                              is found.  Use null to mean no fallback.
-     *
-     * Package private so this code can be shared.
-     */
-    static <T> T find(Class<T> type, String fallbackClassName)
-        throws javax.xml.datatype.DatatypeConfigurationException
-    {
-        final String factoryId = type.getName();
-        dPrint("find factoryId =" + factoryId);
-
-        // Use the system property first
-        try {
-            String systemProp = ss.getSystemProperty(factoryId);
-            if (systemProp != null) {
-                dPrint("found system property, value=" + systemProp);
-                return newInstance(type, systemProp, null, true);
-            }
-        }
-        catch (SecurityException se) {
-            if (debug) se.printStackTrace();
-        }
-
-        // try to read from $java.home/lib/jaxp.properties
-        try {
-            if (firstTime) {
-                synchronized (cacheProps) {
-                    if (firstTime) {
-                        String configFile = ss.getSystemProperty("java.home") + File.separator +
-                            "lib" + File.separator + "jaxp.properties";
-                        File f = new File(configFile);
-                        firstTime = false;
-                        if (ss.doesFileExist(f)) {
-                            dPrint("Read properties file "+f);
-                            cacheProps.load(ss.getFileInputStream(f));
-                        }
-                    }
-                }
-            }
-            final String factoryClassName = cacheProps.getProperty(factoryId);
-
-            if (factoryClassName != null) {
-                dPrint("found in $java.home/jaxp.properties, value=" + factoryClassName);
-                return newInstance(type, factoryClassName, null, true);
-            }
-        }
-        catch (Exception ex) {
-            if (debug) ex.printStackTrace();
-        }
-
-        // Try Jar Service Provider Mechanism
-        final T provider = findServiceProvider(type);
-        if (provider != null) {
-            return provider;
-        }
-        if (fallbackClassName == null) {
-            throw new javax.xml.datatype.DatatypeConfigurationException(
-                "Provider for " + factoryId + " cannot be found");
-        }
-
-        dPrint("loaded from fallback value: " + fallbackClassName);
-        return newInstance(type, fallbackClassName, null, true);
-    }
-
-    /*
-     * Try to find provider using the ServiceLoader API
-     *
-     * @param type Base class / Service interface  of the factory to find.
-     *
-     * @return instance of provider class if found or null
-     */
-    private static <T> T findServiceProvider(final Class<T> type)
-            throws javax.xml.datatype.DatatypeConfigurationException
-    {
-        try {
-            return AccessController.doPrivileged(new PrivilegedAction<T>() {
-                public T run() {
-                    final ServiceLoader<T> serviceLoader = ServiceLoader.load(type);
-                    final Iterator<T> iterator = serviceLoader.iterator();
-                    if (iterator.hasNext()) {
-                        return iterator.next();
-                    } else {
-                        return null;
-                    }
-                }
-            });
-        } catch(ServiceConfigurationError e) {
-            final javax.xml.datatype.DatatypeConfigurationException error =
-                    new DatatypeConfigurationException(
-                        "Provider for " + type + " cannot be found", e);
-            throw error;
-        }
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeFactory.java b/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1076 +0,0 @@
-/*
- * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.datatype;
-
-import javax.xml.XMLConstants;
-
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.GregorianCalendar;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * <p>Factory that creates new <code>javax.xml.datatype</code> <code>Object</code>s that map XML to/from Java <code>Object</code>s.</p>
- *
- * <p>A new instance of the <code>DatatypeFactory</code> is created through the {@link #newInstance()} method
- * that uses the following implementation resolution mechanisms to determine an implementation:</p>
- * <ol>
- *    <li>
- *      If the system property specified by {@link #DATATYPEFACTORY_PROPERTY}, "<code>javax.xml.datatype.DatatypeFactory</code>",
- *      exists, a class with the name of the property value is instantiated.
- *      Any Exception thrown during the instantiation process is wrapped as a {@link javax.xml.datatype.DatatypeConfigurationException}.
- *    </li>
- *    <li>
- *      If the file ${JAVA_HOME}/lib/jaxp.properties exists, it is loaded in a {@link java.util.Properties} <code>Object</code>.
- *      The <code>Properties</code> <code>Object </code> is then queried for the property as documented in the prior step
- *      and processed as documented in the prior step.
- *    </li>
- *    <li>
- *     Uses the service-provider loading facilities, defined by the {@link java.util.ServiceLoader} class, to attempt
- *     to locate and load an implementation of the service using the {@linkplain
- *     java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
- *     the service-provider loading facility will use the {@linkplain
- *     java.lang.Thread#getContextClassLoader() current thread's context class loader}
- *     to attempt to load the service. If the context class
- *     loader is null, the {@linkplain
- *     ClassLoader#getSystemClassLoader() system class loader} will be used.
- *     <br>
- *     In case of {@link java.util.ServiceConfigurationError service
- *     configuration error} a {@link javax.xml.datatype.DatatypeConfigurationException}
- *     will be thrown.
- *    </li>
- *    <li>
- *      The final mechanism is to attempt to instantiate the <code>Class</code> specified by
- *      {@link #DATATYPEFACTORY_IMPLEMENTATION_CLASS}.
- *      Any Exception thrown during the instantiation process is wrapped as a {@link javax.xml.datatype.DatatypeConfigurationException}.
- *    </li>
- * </ol>
- *
- * @author <a href="mailto:Joseph.Fialli@Sun.COM">Joseph Fialli</a>
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @author <a href="mailto:Neeraj.Bajaj@sun.com">Neeraj Bajaj</a>
- *
- * @version $Revision: 1.13 $, $Date: 2010/03/11 23:10:53 $
- * @since 1.5
- */
-public abstract class DatatypeFactory {
-
-    /**
-     * <p>Default property name as defined in JSR 206: Java(TM) API for XML Processing (JAXP) 1.3.</p>
-     *
-     * <p>Default value is <code>javax.xml.datatype.DatatypeFactory</code>.</p>
-     */
-    public static final String DATATYPEFACTORY_PROPERTY =
-            // We use a String constant here, rather than calling
-            // DatatypeFactory.class.getName() - in order to make javadoc
-            // generate a See Also: Constant Field Value link.
-            "javax.xml.datatype.DatatypeFactory";
-
-    /**
-     * <p>Default implementation class name as defined in
-     * <em>JSR 206: Java(TM) API for XML Processing (JAXP) 1.3</em>.</p>
-     *
-     * <p>Implementers should specify the name of an appropriate class
-     * to be instantiated if no other implementation resolution mechanism
-     * succeeds.</p>
-     *
-     * <p>Users should not refer to this field; it is intended only to
-     * document a factory implementation detail.
-     * </p>
-     */
-    public static final String DATATYPEFACTORY_IMPLEMENTATION_CLASS =
-        // We use new String() here to prevent javadoc from generating
-        // a See Also: Constant Field Value link.
-        new String("com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl");
-
-    /**
-     * http://www.w3.org/TR/xpath-datamodel/#xdtschema defines two regexps
-     * to constrain the value space of dayTimeDuration ([^YM]*[DT].*)
-     * and yearMonthDuration ([^DT]*). Note that these expressions rely on
-     * the fact that the value must be an xs:Duration, they simply exclude
-     * some Durations.
-     */
-    private static final Pattern XDTSCHEMA_YMD =
-        Pattern.compile("[^DT]*");
-
-    private static final Pattern XDTSCHEMA_DTD =
-        Pattern.compile("[^YM]*[DT].*");
-
-    /**
-     * <p>Protected constructor to prevent instaniation outside of package.</p>
-     *
-     * <p>Use {@link #newInstance()} to create a <code>DatatypeFactory</code>.</p>
-     */
-    protected DatatypeFactory() {
-    }
-
-    /**
-     * <p>Obtain a new instance of a <code>DatatypeFactory</code>.</p>
-     *
-     * <p>The implementation resolution mechanisms are <a href="#DatatypeFactory.newInstance">defined</a> in this
-     * <code>Class</code>'s documentation.</p>
-     *
-     * @return New instance of a <code>DatatypeFactory</code>
-     *
-     * @throws javax.xml.datatype.DatatypeConfigurationException If the implementation is not
-     *   available or cannot be instantiated.
-     *
-     * @see #newInstance(String factoryClassName, ClassLoader classLoader)
-     */
-    public static DatatypeFactory newInstance()
-            throws javax.xml.datatype.DatatypeConfigurationException {
-
-            return FactoryFinder.find(
-                    /* The default property name according to the JAXP spec */
-                    DatatypeFactory.class,
-                    /* The fallback implementation class name */
-                    DATATYPEFACTORY_IMPLEMENTATION_CLASS);
-    }
-
-    /**
-     * <p>Obtain a new instance of a <code>DatatypeFactory</code> from class name.
-     * This function is useful when there are multiple providers in the classpath.
-     * It gives more control to the application as it can specify which provider
-     * should be loaded.</p>
-     *
-     * <p>Once an application has obtained a reference to a <code>DatatypeFactory</code>
-     * it can use the factory to configure and obtain datatype instances.</P>
-     *
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     * @param factoryClassName fully qualified factory class name that provides implementation of <code>javax.xml.datatype.DatatypeFactory</code>.
-     *
-     * @param classLoader <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     *                     current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @return New instance of a <code>DatatypeFactory</code>
-     *
-     * @throws javax.xml.datatype.DatatypeConfigurationException if <code>factoryClassName</code> is <code>null</code>, or
-     *                                   the factory class cannot be loaded, instantiated.
-     *
-     * @see #newInstance()
-     *
-     * @since 1.6
-     */
-    public static DatatypeFactory newInstance(String factoryClassName, ClassLoader classLoader)
-        throws DatatypeConfigurationException {
-        return FactoryFinder.newInstance(DatatypeFactory.class,
-                    factoryClassName, classLoader, false);
-     }
-
-    /**
-     * <p>Obtain a new instance of a <code>Duration</code>
-     * specifying the <code>Duration</code> as its string representation, "PnYnMnDTnHnMnS",
-     * as defined in XML Schema 1.0 section 3.2.6.1.</p>
-     *
-     * <p>XML Schema Part 2: Datatypes, 3.2.6 duration, defines <code>duration</code> as:</p>
-     * <blockquote>
-     * duration represents a duration of time.
-     * The value space of duration is a six-dimensional space where the coordinates designate the
-     * Gregorian year, month, day, hour, minute, and second components defined in Section 5.5.3.2 of [ISO 8601], respectively.
-     * These components are ordered in their significance by their order of appearance i.e. as
-     * year, month, day, hour, minute, and second.
-     * </blockquote>
-     * <p>All six values are set and available from the created {@link javax.xml.datatype.Duration}</p>
-     *
-     * <p>The XML Schema specification states that values can be of an arbitrary size.
-     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.
-     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits
-     * if implementation capacities are exceeded.</p>
-     *
-     * @param lexicalRepresentation <code>String</code> representation of a <code>Duration</code>.
-     *
-     * @return New <code>Duration</code> created from parsing the <code>lexicalRepresentation</code>.
-     *
-     * @throws IllegalArgumentException If <code>lexicalRepresentation</code> is not a valid representation of a <code>Duration</code>.
-     * @throws UnsupportedOperationException If implementation cannot support requested values.
-     * @throws NullPointerException if <code>lexicalRepresentation</code> is <code>null</code>.
-     */
-    public abstract javax.xml.datatype.Duration newDuration(final String lexicalRepresentation);
-
-    /**
-     * <p>Obtain a new instance of a <code>Duration</code>
-     * specifying the <code>Duration</code> as milliseconds.</p>
-     *
-     * <p>XML Schema Part 2: Datatypes, 3.2.6 duration, defines <code>duration</code> as:</p>
-     * <blockquote>
-     * duration represents a duration of time.
-     * The value space of duration is a six-dimensional space where the coordinates designate the
-     * Gregorian year, month, day, hour, minute, and second components defined in Section 5.5.3.2 of [ISO 8601], respectively.
-     * These components are ordered in their significance by their order of appearance i.e. as
-     * year, month, day, hour, minute, and second.
-     * </blockquote>
-     * <p>All six values are set by computing their values from the specified milliseconds
-     * and are available using the <code>get</code> methods of  the created {@link javax.xml.datatype.Duration}.
-     * The values conform to and are defined by:</p>
-     * <ul>
-     *   <li>ISO 8601:2000(E) Section 5.5.3.2 Alternative format</li>
-     *   <li><a href="http://www.w3.org/TR/xmlschema-2/#isoformats">
-     *     W3C XML Schema 1.0 Part 2, Appendix D, ISO 8601 Date and Time Formats</a>
-     *   </li>
-     *   <li>{@link javax.xml.datatype.XMLGregorianCalendar}  Date/Time Datatype Field Mapping Between XML Schema 1.0 and Java Representation</li>
-     * </ul>
-     *
-     * <p>The default start instance is defined by {@link GregorianCalendar}'s use of the start of the epoch: i.e.,
-     * {@link java.util.Calendar#YEAR} = 1970,
-     * {@link java.util.Calendar#MONTH} = {@link java.util.Calendar#JANUARY},
-     * {@link java.util.Calendar#DATE} = 1, etc.
-     * This is important as there are variations in the Gregorian Calendar,
-     * e.g. leap years have different days in the month = {@link java.util.Calendar#FEBRUARY}
-     * so the result of {@link javax.xml.datatype.Duration#getMonths()} and {@link javax.xml.datatype.Duration#getDays()} can be influenced.</p>
-     *
-     * @param durationInMilliSeconds Duration in milliseconds to create.
-     *
-     * @return New <code>Duration</code> representing <code>durationInMilliSeconds</code>.
-     */
-    public abstract javax.xml.datatype.Duration newDuration(final long durationInMilliSeconds);
-
-    /**
-     * <p>Obtain a new instance of a <code>Duration</code>
-     * specifying the <code>Duration</code> as isPositive, years, months, days, hours, minutes, seconds.</p>
-     *
-     * <p>The XML Schema specification states that values can be of an arbitrary size.
-     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.
-     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits
-     * if implementation capacities are exceeded.</p>
-     *
-     * <p>A <code>null</code> value indicates that field is not set.</p>
-     *
-     * @param isPositive Set to <code>false</code> to create a negative duration. When the length
-     *   of the duration is zero, this parameter will be ignored.
-     * @param years of this <code>Duration</code>
-     * @param months of this <code>Duration</code>
-     * @param days of this <code>Duration</code>
-     * @param hours of this <code>Duration</code>
-     * @param minutes of this <code>Duration</code>
-     * @param seconds of this <code>Duration</code>
-     *
-     * @return New <code>Duration</code> created from the specified values.
-     *
-     * @throws IllegalArgumentException If the values are not a valid representation of a
-     * <code>Duration</code>: if all the fields (years, months, ...) are null or
-     * if any of the fields is negative.
-     * @throws UnsupportedOperationException If implementation cannot support requested values.
-     */
-    public abstract javax.xml.datatype.Duration newDuration(
-            final boolean isPositive,
-            final BigInteger years,
-            final BigInteger months,
-            final BigInteger days,
-            final BigInteger hours,
-            final BigInteger minutes,
-            final BigDecimal seconds);
-
-    /**
-     * <p>Obtain a new instance of a <code>Duration</code>
-     * specifying the <code>Duration</code> as isPositive, years, months, days, hours, minutes, seconds.</p>
-     *
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param isPositive Set to <code>false</code> to create a negative duration. When the length
-     *   of the duration is zero, this parameter will be ignored.
-     * @param years of this <code>Duration</code>
-     * @param months of this <code>Duration</code>
-     * @param days of this <code>Duration</code>
-     * @param hours of this <code>Duration</code>
-     * @param minutes of this <code>Duration</code>
-     * @param seconds of this <code>Duration</code>
-     *
-     * @return New <code>Duration</code> created from the specified values.
-     *
-     * @throws IllegalArgumentException If the values are not a valid representation of a
-     * <code>Duration</code>: if any of the fields is negative.
-     *
-     * @see #newDuration(
-     *   boolean isPositive,
-     *   BigInteger years,
-     *   BigInteger months,
-     *   BigInteger days,
-     *   BigInteger hours,
-     *   BigInteger minutes,
-     *   BigDecimal seconds)
-     */
-    public javax.xml.datatype.Duration newDuration(
-            final boolean isPositive,
-            final int years,
-            final int months,
-            final int days,
-            final int hours,
-            final int minutes,
-            final int seconds) {
-
-            // years may not be set
-            BigInteger realYears = (years != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) ? BigInteger.valueOf((long) years) : null;
-
-            // months may not be set
-            BigInteger realMonths = (months != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) ? BigInteger.valueOf((long) months) : null;
-
-            // days may not be set
-            BigInteger realDays = (days != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) ? BigInteger.valueOf((long) days) : null;
-
-            // hours may not be set
-            BigInteger realHours = (hours != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) ? BigInteger.valueOf((long) hours) : null;
-
-            // minutes may not be set
-            BigInteger realMinutes = (minutes != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) ? BigInteger.valueOf((long) minutes) : null;
-
-            // seconds may not be set
-            BigDecimal realSeconds = (seconds != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) ? BigDecimal.valueOf((long) seconds) : null;
-
-                    return newDuration(
-                            isPositive,
-                            realYears,
-                            realMonths,
-                            realDays,
-                            realHours,
-                            realMinutes,
-                            realSeconds
-                    );
-            }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> by parsing its <code>String</code> representation,
-     * "<em>PnDTnHnMnS</em>", <a href="http://www.w3.org/TR/xpath-datamodel#dayTimeDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a>.</p>
-     *
-     * <p>The datatype <code>xdt:dayTimeDuration</code> is a subtype of <code>xs:duration</code>
-     * whose lexical representation contains only day, hour, minute, and second components.
-     * This datatype resides in the namespace <code>http://www.w3.org/2003/11/xpath-datatypes</code>.</p>
-     *
-     * <p>All four values are set and available from the created {@link javax.xml.datatype.Duration}</p>
-     *
-     * <p>The XML Schema specification states that values can be of an arbitrary size.
-     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.
-     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits
-     * if implementation capacities are exceeded.</p>
-     *
-     * @param lexicalRepresentation Lexical representation of a duration.
-     *
-     * @return New <code>Duration</code> created using the specified <code>lexicalRepresentation</code>.
-     *
-     * @throws IllegalArgumentException If <code>lexicalRepresentation</code> is not a valid representation of a <code>Duration</code> expressed only in terms of days and time.
-     * @throws UnsupportedOperationException If implementation cannot support requested values.
-     * @throws NullPointerException If <code>lexicalRepresentation</code> is <code>null</code>.
-     */
-    public javax.xml.datatype.Duration newDurationDayTime(final String lexicalRepresentation) {
-        // lexicalRepresentation must be non-null
-        if (lexicalRepresentation == null) {
-            throw new NullPointerException(
-                "Trying to create an xdt:dayTimeDuration with an invalid"
-                + " lexical representation of \"null\"");
-        }
-
-        // test lexicalRepresentation against spec regex
-        Matcher matcher = XDTSCHEMA_DTD.matcher(lexicalRepresentation);
-        if (!matcher.matches()) {
-            throw new IllegalArgumentException(
-                "Trying to create an xdt:dayTimeDuration with an invalid"
-                + " lexical representation of \"" + lexicalRepresentation
-                + "\", data model requires years and months only.");
-        }
-
-        return newDuration(lexicalRepresentation);
-    }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> using the specified milliseconds as defined in
-     * <a href="http://www.w3.org/TR/xpath-datamodel#dayTimeDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a>.</p>
-     *
-     * <p>The datatype <code>xdt:dayTimeDuration</code> is a subtype of <code>xs:duration</code>
-     * whose lexical representation contains only day, hour, minute, and second components.
-     * This datatype resides in the namespace <code>http://www.w3.org/2003/11/xpath-datatypes</code>.</p>
-     *
-     * <p>All four values are set by computing their values from the specified milliseconds
-     * and are available using the <code>get</code> methods of  the created {@link javax.xml.datatype.Duration}.
-     * The values conform to and are defined by:</p>
-     * <ul>
-     *   <li>ISO 8601:2000(E) Section 5.5.3.2 Alternative format</li>
-     *   <li><a href="http://www.w3.org/TR/xmlschema-2/#isoformats">
-     *     W3C XML Schema 1.0 Part 2, Appendix D, ISO 8601 Date and Time Formats</a>
-     *   </li>
-     *   <li>{@link javax.xml.datatype.XMLGregorianCalendar}  Date/Time Datatype Field Mapping Between XML Schema 1.0 and Java Representation</li>
-     * </ul>
-     *
-     * <p>The default start instance is defined by {@link GregorianCalendar}'s use of the start of the epoch: i.e.,
-     * {@link java.util.Calendar#YEAR} = 1970,
-     * {@link java.util.Calendar#MONTH} = {@link java.util.Calendar#JANUARY},
-     * {@link java.util.Calendar#DATE} = 1, etc.
-     * This is important as there are variations in the Gregorian Calendar,
-     * e.g. leap years have different days in the month = {@link java.util.Calendar#FEBRUARY}
-     * so the result of {@link javax.xml.datatype.Duration#getDays()} can be influenced.</p>
-     *
-     * <p>Any remaining milliseconds after determining the day, hour, minute and second are discarded.</p>
-     *
-     * @param durationInMilliseconds Milliseconds of <code>Duration</code> to create.
-     *
-     * @return New <code>Duration</code> created with the specified <code>durationInMilliseconds</code>.
-     *
-     * @see <a href="http://www.w3.org/TR/xpath-datamodel#dayTimeDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a>
-     */
-    public javax.xml.datatype.Duration newDurationDayTime(final long durationInMilliseconds) {
-
-            return newDuration(durationInMilliseconds);
-    }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> using the specified
-     * <code>day</code>, <code>hour</code>, <code>minute</code> and <code>second</code> as defined in
-     * <a href="http://www.w3.org/TR/xpath-datamodel#dayTimeDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a>.</p>
-     *
-     * <p>The datatype <code>xdt:dayTimeDuration</code> is a subtype of <code>xs:duration</code>
-     * whose lexical representation contains only day, hour, minute, and second components.
-     * This datatype resides in the namespace <code>http://www.w3.org/2003/11/xpath-datatypes</code>.</p>
-     *
-     * <p>The XML Schema specification states that values can be of an arbitrary size.
-     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.
-     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits
-     * if implementation capacities are exceeded.</p>
-     *
-     * <p>A <code>null</code> value indicates that field is not set.</p>
-     *
-     * @param isPositive Set to <code>false</code> to create a negative duration. When the length
-     *   of the duration is zero, this parameter will be ignored.
-     * @param day Day of <code>Duration</code>.
-     * @param hour Hour of <code>Duration</code>.
-     * @param minute Minute of <code>Duration</code>.
-     * @param second Second of <code>Duration</code>.
-     *
-     * @return New <code>Duration</code> created with the specified <code>day</code>, <code>hour</code>, <code>minute</code>
-     * and <code>second</code>.
-     *
-     * @throws IllegalArgumentException If the values are not a valid representation of a
-     * <code>Duration</code>: if all the fields (day, hour, ...) are null or
-     * if any of the fields is negative.
-     * @throws UnsupportedOperationException If implementation cannot support requested values.
-     */
-    public javax.xml.datatype.Duration newDurationDayTime(
-            final boolean isPositive,
-            final BigInteger day,
-            final BigInteger hour,
-            final BigInteger minute,
-            final BigInteger second) {
-
-            return newDuration(
-                    isPositive,
-                    null,  // years
-                    null, // months
-                    day,
-                    hour,
-                    minute,
-                    (second != null)? new BigDecimal(second):null
-            );
-    }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> using the specified
-     * <code>day</code>, <code>hour</code>, <code>minute</code> and <code>second</code> as defined in
-     * <a href="http://www.w3.org/TR/xpath-datamodel#dayTimeDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration</a>.</p>
-     *
-     * <p>The datatype <code>xdt:dayTimeDuration</code> is a subtype of <code>xs:duration</code>
-     * whose lexical representation contains only day, hour, minute, and second components.
-     * This datatype resides in the namespace <code>http://www.w3.org/2003/11/xpath-datatypes</code>.</p>
-     *
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param isPositive Set to <code>false</code> to create a negative duration. When the length
-     *   of the duration is zero, this parameter will be ignored.
-     * @param day Day of <code>Duration</code>.
-     * @param hour Hour of <code>Duration</code>.
-     * @param minute Minute of <code>Duration</code>.
-     * @param second Second of <code>Duration</code>.
-     *
-     * @return New <code>Duration</code> created with the specified <code>day</code>, <code>hour</code>, <code>minute</code>
-     * and <code>second</code>.
-     *
-     * @throws IllegalArgumentException If the values are not a valid representation of a
-     * <code>Duration</code>: if any of the fields (day, hour, ...) is negative.
-     */
-    public javax.xml.datatype.Duration newDurationDayTime(
-            final boolean isPositive,
-            final int day,
-            final int hour,
-            final int minute,
-            final int second) {
-
-                    return newDurationDayTime(
-                            isPositive,
-                            BigInteger.valueOf((long) day),
-                            BigInteger.valueOf((long) hour),
-                            BigInteger.valueOf((long) minute),
-                            BigInteger.valueOf((long) second)
-                            );
-            }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> by parsing its <code>String</code> representation,
-     * "<em>PnYnM</em>", <a href="http://www.w3.org/TR/xpath-datamodel#yearMonthDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration</a>.</p>
-     *
-     * <p>The datatype <code>xdt:yearMonthDuration</code> is a subtype of <code>xs:duration</code>
-     * whose lexical representation contains only year and month components.
-     * This datatype resides in the namespace {@link XMLConstants#W3C_XPATH_DATATYPE_NS_URI}.</p>
-     *
-     * <p>Both values are set and available from the created {@link javax.xml.datatype.Duration}</p>
-     *
-     * <p>The XML Schema specification states that values can be of an arbitrary size.
-     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.
-     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits
-     * if implementation capacities are exceeded.</p>
-     *
-     * @param lexicalRepresentation Lexical representation of a duration.
-     *
-     * @return New <code>Duration</code> created using the specified <code>lexicalRepresentation</code>.
-     *
-     * @throws IllegalArgumentException If <code>lexicalRepresentation</code> is not a valid representation of a <code>Duration</code> expressed only in terms of years and months.
-     * @throws UnsupportedOperationException If implementation cannot support requested values.
-     * @throws NullPointerException If <code>lexicalRepresentation</code> is <code>null</code>.
-     */
-    public javax.xml.datatype.Duration newDurationYearMonth(
-            final String lexicalRepresentation) {
-
-        // lexicalRepresentation must be non-null
-        if (lexicalRepresentation == null) {
-            throw new NullPointerException(
-                    "Trying to create an xdt:yearMonthDuration with an invalid"
-                    + " lexical representation of \"null\"");
-        }
-
-        // test lexicalRepresentation against spec regex
-        Matcher matcher = XDTSCHEMA_YMD.matcher(lexicalRepresentation);
-        if (!matcher.matches()) {
-            throw new IllegalArgumentException(
-                    "Trying to create an xdt:yearMonthDuration with an invalid"
-                    + " lexical representation of \"" + lexicalRepresentation
-                    + "\", data model requires days and times only.");
-        }
-
-        return newDuration(lexicalRepresentation);
-    }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> using the specified milliseconds as defined in
-     * <a href="http://www.w3.org/TR/xpath-datamodel#yearMonthDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration</a>.</p>
-     *
-     * <p>The datatype <code>xdt:yearMonthDuration</code> is a subtype of <code>xs:duration</code>
-     * whose lexical representation contains only year and month components.
-     * This datatype resides in the namespace {@link XMLConstants#W3C_XPATH_DATATYPE_NS_URI}.</p>
-     *
-     * <p>Both values are set by computing their values from the specified milliseconds
-     * and are available using the <code>get</code> methods of  the created {@link javax.xml.datatype.Duration}.
-     * The values conform to and are defined by:</p>
-     * <ul>
-     *   <li>ISO 8601:2000(E) Section 5.5.3.2 Alternative format</li>
-     *   <li><a href="http://www.w3.org/TR/xmlschema-2/#isoformats">
-     *     W3C XML Schema 1.0 Part 2, Appendix D, ISO 8601 Date and Time Formats</a>
-     *   </li>
-     *   <li>{@link javax.xml.datatype.XMLGregorianCalendar}  Date/Time Datatype Field Mapping Between XML Schema 1.0 and Java Representation</li>
-     * </ul>
-     *
-     * <p>The default start instance is defined by {@link GregorianCalendar}'s use of the start of the epoch: i.e.,
-     * {@link java.util.Calendar#YEAR} = 1970,
-     * {@link java.util.Calendar#MONTH} = {@link java.util.Calendar#JANUARY},
-     * {@link java.util.Calendar#DATE} = 1, etc.
-     * This is important as there are variations in the Gregorian Calendar,
-     * e.g. leap years have different days in the month = {@link java.util.Calendar#FEBRUARY}
-     * so the result of {@link javax.xml.datatype.Duration#getMonths()} can be influenced.</p>
-     *
-     * <p>Any remaining milliseconds after determining the year and month are discarded.</p>
-     *
-     * @param durationInMilliseconds Milliseconds of <code>Duration</code> to create.
-     *
-     * @return New <code>Duration</code> created using the specified <code>durationInMilliseconds</code>.
-     */
-    public javax.xml.datatype.Duration newDurationYearMonth(
-            final long durationInMilliseconds) {
-
-        // create a Duration that only has sign, year & month
-        // Duration is immutable, so need to create a new Duration
-        // implementations may override this method in a more efficient way
-        javax.xml.datatype.Duration fullDuration = newDuration(durationInMilliseconds);
-        boolean isPositive = (fullDuration.getSign() == -1) ? false : true;
-        BigInteger years =
-            (BigInteger) fullDuration.getField(javax.xml.datatype.DatatypeConstants.YEARS);
-        if (years == null) { years = BigInteger.ZERO; }
-        BigInteger months =
-            (BigInteger) fullDuration.getField(javax.xml.datatype.DatatypeConstants.MONTHS);
-        if (months == null) { months = BigInteger.ZERO; }
-
-        return newDurationYearMonth(isPositive, years, months);
-    }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> using the specified
-     * <code>year</code> and <code>month</code> as defined in
-     * <a href="http://www.w3.org/TR/xpath-datamodel#yearMonthDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration</a>.</p>
-     *
-     * <p>The XML Schema specification states that values can be of an arbitrary size.
-     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.
-     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits
-     * if implementation capacities are exceeded.</p>
-     *
-     * <p>A <code>null</code> value indicates that field is not set.</p>
-     *
-     * @param isPositive Set to <code>false</code> to create a negative duration. When the length
-     *   of the duration is zero, this parameter will be ignored.
-     * @param year Year of <code>Duration</code>.
-     * @param month Month of <code>Duration</code>.
-     *
-     * @return New <code>Duration</code> created using the specified <code>year</code> and <code>month</code>.
-     *
-     * @throws IllegalArgumentException If the values are not a valid representation of a
-     * <code>Duration</code>: if all of the fields (year, month) are null or
-     * if any of the fields is negative.
-     * @throws UnsupportedOperationException If implementation cannot support requested values.
-     */
-    public javax.xml.datatype.Duration newDurationYearMonth(
-            final boolean isPositive,
-            final BigInteger year,
-            final BigInteger month) {
-
-            return newDuration(
-                    isPositive,
-                    year,
-                    month,
-                    null, // days
-                    null, // hours
-                    null, // minutes
-                    null  // seconds
-            );
-    }
-
-    /**
-     * <p>Create a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> using the specified
-     * <code>year</code> and <code>month</code> as defined in
-     * <a href="http://www.w3.org/TR/xpath-datamodel#yearMonthDuration">
-     *   XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration</a>.</p>
-     *
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param isPositive Set to <code>false</code> to create a negative duration. When the length
-     *   of the duration is zero, this parameter will be ignored.
-     * @param year Year of <code>Duration</code>.
-     * @param month Month of <code>Duration</code>.
-     *
-     * @return New <code>Duration</code> created using the specified <code>year</code> and <code>month</code>.
-     *
-     * @throws IllegalArgumentException If the values are not a valid representation of a
-     * <code>Duration</code>: if any of the fields (year, month) is negative.
-     */
-    public Duration newDurationYearMonth(
-            final boolean isPositive,
-            final int year,
-            final int month) {
-
-            return newDurationYearMonth(
-                    isPositive,
-                    BigInteger.valueOf((long) year),
-                    BigInteger.valueOf((long) month));
-            }
-
-    /**
-     * <p>Create a new instance of an <code>XMLGregorianCalendar</code>.</p>
-     *
-     * <p>All date/time datatype fields set to {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} or null.</p>
-     *
-     * @return New <code>XMLGregorianCalendar</code> with all date/time datatype fields set to
-     *   {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} or null.
-     */
-    public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar();
-
-    /**
-     * <p>Create a new XMLGregorianCalendar by parsing the String as a lexical representation.</p>
-     *
-     * <p>Parsing the lexical string representation is defined in
-     * <a href="http://www.w3.org/TR/xmlschema-2/#dateTime-order">XML Schema 1.0 Part 2, Section 3.2.[7-14].1,
-     * <em>Lexical Representation</em>.</a></p>
-     *
-     * <p>The string representation may not have any leading and trailing whitespaces.</p>
-     *
-     * <p>The parsing is done field by field so that
-     * the following holds for any lexically correct String x:</p>
-     * <pre>
-     * newXMLGregorianCalendar(x).toXMLFormat().equals(x)
-     * </pre>
-     * <p>Except for the noted lexical/canonical representation mismatches
-     * listed in <a href="http://www.w3.org/2001/05/xmlschema-errata#e2-45">
-     * XML Schema 1.0 errata, Section 3.2.7.2</a>.</p>
-     *
-     * @param lexicalRepresentation Lexical representation of one the eight XML Schema date/time datatypes.
-     *
-     * @return <code>XMLGregorianCalendar</code> created from the <code>lexicalRepresentation</code>.
-     *
-     * @throws IllegalArgumentException If the <code>lexicalRepresentation</code> is not a valid <code>XMLGregorianCalendar</code>.
-     * @throws NullPointerException If <code>lexicalRepresentation</code> is <code>null</code>.
-     */
-    public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(final String lexicalRepresentation);
-
-    /**
-     * <p>Create an <code>XMLGregorianCalendar</code> from a {@link GregorianCalendar}.</p>
-     *
-     * <table border="2" rules="all" cellpadding="2">
-     *   <thead>
-     *     <tr>
-     *       <th align="center" colspan="2">
-     *          Field by Field Conversion from
-     *          {@link GregorianCalendar} to an {@link javax.xml.datatype.XMLGregorianCalendar}
-     *       </th>
-     *     </tr>
-     *     <tr>
-     *        <th><code>java.util.GregorianCalendar</code> field</th>
-     *        <th><code>javax.xml.datatype.XMLGregorianCalendar</code> field</th>
-     *     </tr>
-     *   </thead>
-     *   <tbody>
-     *     <tr>
-     *       <td><code>ERA == GregorianCalendar.BC ? -YEAR : YEAR</code></td>
-     *       <td>{@link javax.xml.datatype.XMLGregorianCalendar#setYear(int year)}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>MONTH + 1</code></td>
-     *       <td>{@link javax.xml.datatype.XMLGregorianCalendar#setMonth(int month)}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>DAY_OF_MONTH</code></td>
-     *       <td>{@link javax.xml.datatype.XMLGregorianCalendar#setDay(int day)}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND</code></td>
-     *       <td>{@link javax.xml.datatype.XMLGregorianCalendar#setTime(int hour, int minute, int second, BigDecimal fractional)}</td>
-     *     </tr>
-     *     <tr>
-     *       <td>
-     *         <code>(ZONE_OFFSET + DST_OFFSET) / (60*1000)</code><br/>
-     *         <em>(in minutes)</em>
-     *       </td>
-     *       <td>{@link javax.xml.datatype.XMLGregorianCalendar#setTimezone(int offset)}<sup><em>*</em></sup>
-     *       </td>
-     *     </tr>
-     *   </tbody>
-     * </table>
-     * <p><em>*</em>conversion loss of information. It is not possible to represent
-     * a <code>java.util.GregorianCalendar</code> daylight savings timezone id in the
-     * XML Schema 1.0 date/time datatype representation.</p>
-     *
-     * <p>To compute the return value's <code>TimeZone</code> field,
-     * <ul>
-     * <li>when <code>this.getTimezone() != FIELD_UNDEFINED</code>,
-     * create a <code>java.util.TimeZone</code> with a custom timezone id
-     * using the <code>this.getTimezone()</code>.</li>
-     * <li>else use the <code>GregorianCalendar</code> default timezone value
-     * for the host is defined as specified by
-     * <code>java.util.TimeZone.getDefault()</code>.</li></p>
-     *
-     * @param cal <code>java.util.GregorianCalendar</code> used to create <code>XMLGregorianCalendar</code>
-     *
-     * @return <code>XMLGregorianCalendar</code> created from <code>java.util.GregorianCalendar</code>
-     *
-     * @throws NullPointerException If <code>cal</code> is <code>null</code>.
-     */
-    public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(final GregorianCalendar cal);
-
-    /**
-     * <p>Constructor allowing for complete value spaces allowed by
-     * W3C XML Schema 1.0 recommendation for xsd:dateTime and related
-     * builtin datatypes. Note that <code>year</code> parameter supports
-     * arbitrarily large numbers and fractionalSecond has infinite
-     * precision.</p>
-     *
-     * <p>A <code>null</code> value indicates that field is not set.</p>
-     *
-     * @param year of <code>XMLGregorianCalendar</code> to be created.
-     * @param month of <code>XMLGregorianCalendar</code> to be created.
-     * @param day of <code>XMLGregorianCalendar</code> to be created.
-     * @param hour of <code>XMLGregorianCalendar</code> to be created.
-     * @param minute of <code>XMLGregorianCalendar</code> to be created.
-     * @param second of <code>XMLGregorianCalendar</code> to be created.
-     * @param fractionalSecond of <code>XMLGregorianCalendar</code> to be created.
-     * @param timezone of <code>XMLGregorianCalendar</code> to be created.
-     *
-     * @return <code>XMLGregorianCalendar</code> created from specified values.
-     *
-     * @throws IllegalArgumentException If any individual parameter's value is outside the maximum value constraint for the field
-     *   as determined by the Date/Time Data Mapping table in {@link javax.xml.datatype.XMLGregorianCalendar}
-     *   or if the composite values constitute an invalid <code>XMLGregorianCalendar</code> instance
-     *   as determined by {@link javax.xml.datatype.XMLGregorianCalendar#isValid()}.
-     */
-    public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(
-            final BigInteger year,
-            final int month,
-            final int day,
-            final int hour,
-            final int minute,
-            final int second,
-            final BigDecimal fractionalSecond,
-            final int timezone);
-
-    /**
-     * <p>Constructor of value spaces that a
-     * <code>java.util.GregorianCalendar</code> instance would need to convert to an
-     * <code>XMLGregorianCalendar</code> instance.</p>
-     *
-     * <p><code>XMLGregorianCalendar eon</code> and
-     * <code>fractionalSecond</code> are set to <code>null</code></p>
-     *
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param year of <code>XMLGregorianCalendar</code> to be created.
-     * @param month of <code>XMLGregorianCalendar</code> to be created.
-     * @param day of <code>XMLGregorianCalendar</code> to be created.
-     * @param hour of <code>XMLGregorianCalendar</code> to be created.
-     * @param minute of <code>XMLGregorianCalendar</code> to be created.
-     * @param second of <code>XMLGregorianCalendar</code> to be created.
-     * @param millisecond of <code>XMLGregorianCalendar</code> to be created.
-     * @param timezone of <code>XMLGregorianCalendar</code> to be created.
-     *
-     * @return <code>XMLGregorianCalendar</code> created from specified values.
-     *
-     * @throws IllegalArgumentException If any individual parameter's value is outside the maximum value constraint for the field
-     *   as determined by the Date/Time Data Mapping table in {@link javax.xml.datatype.XMLGregorianCalendar}
-     *   or if the composite values constitute an invalid <code>XMLGregorianCalendar</code> instance
-     *   as determined by {@link javax.xml.datatype.XMLGregorianCalendar#isValid()}.
-     */
-    public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(
-            final int year,
-            final int month,
-            final int day,
-            final int hour,
-            final int minute,
-            final int second,
-            final int millisecond,
-            final int timezone) {
-
-            // year may be undefined
-            BigInteger realYear = (year != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) ? BigInteger.valueOf((long) year) : null;
-
-            // millisecond may be undefined
-            // millisecond must be >= 0 millisecond <= 1000
-            BigDecimal realMillisecond = null; // undefined value
-            if (millisecond != javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) {
-                    if (millisecond < 0 || millisecond > 1000) {
-                            throw new IllegalArgumentException(
-                                                    "javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar("
-                                                    + "int year, int month, int day, int hour, int minute, int second, int millisecond, int timezone)"
-                                                    + "with invalid millisecond: " + millisecond
-                                                    );
-                    }
-
-                    realMillisecond = BigDecimal.valueOf((long) millisecond).movePointLeft(3);
-            }
-
-            return newXMLGregorianCalendar(
-                    realYear,
-                    month,
-                    day,
-                    hour,
-                    minute,
-                    second,
-                    realMillisecond,
-                    timezone
-            );
-    }
-
-    /**
-     * <p>Create a Java representation of XML Schema builtin datatype <code>date</code> or <code>g*</code>.</p>
-     *
-     * <p>For example, an instance of <code>gYear</code> can be created invoking this factory
-     * with <code>month</code> and <code>day</code> parameters set to
-     * {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-     *
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param year of <code>XMLGregorianCalendar</code> to be created.
-     * @param month of <code>XMLGregorianCalendar</code> to be created.
-     * @param day of <code>XMLGregorianCalendar</code> to be created.
-     * @param timezone offset in minutes. {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.
-     *
-     * @return <code>XMLGregorianCalendar</code> created from parameter values.
-     *
-     * @see javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED
-     *
-     * @throws IllegalArgumentException If any individual parameter's value is outside the maximum value constraint for the field
-     *   as determined by the Date/Time Data Mapping table in {@link javax.xml.datatype.XMLGregorianCalendar}
-     *   or if the composite values constitute an invalid <code>XMLGregorianCalendar</code> instance
-     *   as determined by {@link javax.xml.datatype.XMLGregorianCalendar#isValid()}.
-     */
-    public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendarDate(
-            final int year,
-            final int month,
-            final int day,
-            final int timezone) {
-
-            return newXMLGregorianCalendar(
-                    year,
-                    month,
-                    day,
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // hour
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // minute
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // second
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // millisecond
-                    timezone);
-            }
-
-    /**
-     * <p>Create a Java instance of XML Schema builtin datatype <code>time</code>.</p>
-     *
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param hours number of hours
-     * @param minutes number of minutes
-     * @param seconds number of seconds
-     * @param timezone offset in minutes. {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.
-     *
-     * @return <code>XMLGregorianCalendar</code> created from parameter values.
-     *
-     * @throws IllegalArgumentException If any individual parameter's value is outside the maximum value constraint for the field
-     *   as determined by the Date/Time Data Mapping table in {@link javax.xml.datatype.XMLGregorianCalendar}
-     *   or if the composite values constitute an invalid <code>XMLGregorianCalendar</code> instance
-     *   as determined by {@link javax.xml.datatype.XMLGregorianCalendar#isValid()}.
-     *
-     * @see javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED
-     */
-    public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendarTime(
-            final int hours,
-            final int minutes,
-            final int seconds,
-            final int timezone) {
-
-            return newXMLGregorianCalendar(
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // Year
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // Month
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // Day
-                    hours,
-                    minutes,
-                    seconds,
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, //Millisecond
-                    timezone);
-    }
-
-    /**
-     * <p>Create a Java instance of XML Schema builtin datatype time.</p>
-     *
-     * <p>A <code>null</code> value indicates that field is not set.</p>
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param hours number of hours
-     * @param minutes number of minutes
-     * @param seconds number of seconds
-     * @param fractionalSecond value of <code>null</code> indicates that this optional field is not set.
-     * @param timezone offset in minutes. {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.
-     *
-     * @return <code>XMLGregorianCalendar</code> created from parameter values.
-     *
-     * @see javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED
-     *
-     * @throws IllegalArgumentException If any individual parameter's value is outside the maximum value constraint for the field
-     *   as determined by the Date/Time Data Mapping table in {@link javax.xml.datatype.XMLGregorianCalendar}
-     *   or if the composite values constitute an invalid <code>XMLGregorianCalendar</code> instance
-     *   as determined by {@link javax.xml.datatype.XMLGregorianCalendar#isValid()}.
-     */
-    public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendarTime(
-            final int hours,
-            final int minutes,
-            final int seconds,
-            final BigDecimal fractionalSecond,
-            final int timezone) {
-
-            return newXMLGregorianCalendar(
-                    null, // year
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // month
-                    javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED, // day
-                    hours,
-                    minutes,
-                    seconds,
-                    fractionalSecond,
-                    timezone);
-            }
-
-    /**
-     * <p>Create a Java instance of XML Schema builtin datatype time.</p>
-     *
-     * <p>A {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} value indicates that field is not set.</p>
-     *
-     * @param hours number of hours
-     * @param minutes number of minutes
-     * @param seconds number of seconds
-     * @param milliseconds number of milliseconds
-     * @param timezone offset in minutes. {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.
-     *
-     * @return <code>XMLGregorianCalendar</code> created from parameter values.
-     *
-     * @see javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED
-     *
-     * @throws IllegalArgumentException If any individual parameter's value is outside the maximum value constraint for the field
-     *   as determined by the Date/Time Data Mapping table in {@link javax.xml.datatype.XMLGregorianCalendar}
-     *   or if the composite values constitute an invalid <code>XMLGregorianCalendar</code> instance
-     *   as determined by {@link javax.xml.datatype.XMLGregorianCalendar#isValid()}.
-     */
-    public XMLGregorianCalendar newXMLGregorianCalendarTime(
-            final int hours,
-            final int minutes,
-            final int seconds,
-            final int milliseconds,
-            final int timezone) {
-
-            // millisecond may be undefined
-            // millisecond must be >= 0 millisecond <= 1000
-            BigDecimal realMilliseconds = null; // undefined value
-            if (milliseconds != DatatypeConstants.FIELD_UNDEFINED) {
-                    if (milliseconds < 0 || milliseconds > 1000) {
-                            throw new IllegalArgumentException(
-                                                    "javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendarTime("
-                                                    + "int hours, int minutes, int seconds, int milliseconds, int timezone)"
-                                                    + "with invalid milliseconds: " + milliseconds
-                                                    );
-                    }
-
-                    realMilliseconds = BigDecimal.valueOf((long) milliseconds).movePointLeft(3);
-            }
-
-            return newXMLGregorianCalendarTime(
-                    hours,
-                    minutes,
-                    seconds,
-                    realMilliseconds,
-                    timezone
-            );
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/SecuritySupport.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/SecuritySupport.java b/Build/src/main/java/org/openjdk/javax/xml/datatype/SecuritySupport.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/SecuritySupport.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,106 +0,0 @@
-/*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.datatype;
-
-import java.security.*;
-import java.net.*;
-import java.io.*;
-import java.util.*;
-
-/**
- * This class is duplicated for each JAXP subpackage so keep it in sync.
- * It is package private and therefore is not exposed as part of the JAXP
- * API.
- *
- * Security related methods that only work on J2SE 1.2 and newer.
- */
-class SecuritySupport  {
-
-
-    ClassLoader getContextClassLoader() {
-        return (ClassLoader)
-                AccessController.doPrivileged(new PrivilegedAction() {
-            public Object run() {
-                ClassLoader cl = null;
-                try {
-                    cl = Thread.currentThread().getContextClassLoader();
-                } catch (SecurityException ex) { }
-                return cl;
-            }
-        });
-    }
-
-    String getSystemProperty(final String propName) {
-        return (String)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(propName);
-                }
-            });
-    }
-
-    FileInputStream getFileInputStream(final File file)
-        throws FileNotFoundException
-    {
-        try {
-            return (FileInputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws FileNotFoundException {
-                        return new FileInputStream(file);
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (FileNotFoundException)e.getException();
-        }
-    }
-
-    InputStream getResourceAsStream(final ClassLoader cl,
-                                           final String name)
-    {
-        return (InputStream)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    InputStream ris;
-                    if (cl == null) {
-                        ris = Object.class.getResourceAsStream(name);
-                    } else {
-                        ris = cl.getResourceAsStream(name);
-                    }
-                    return ris;
-                }
-            });
-    }
-
-    boolean doesFileExist(final File f) {
-    return ((Boolean)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return new Boolean(f.exists());
-                }
-            })).booleanValue();
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConstants.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConstants.java b/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConstants.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConstants.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,275 +0,0 @@
-/*
- * Copyright (c) 2004, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.datatype;
-
-import javax.xml.XMLConstants;
-
-import javax.xml.namespace.QName;
-
-/**
- * <p>Utility class to contain basic Datatype values as constants.</p>
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @since 1.5
- */
-
-public final class DatatypeConstants {
-
-    /**
-     * <p>Private constructor to prevent instantiation.</p>
-     */
-        private DatatypeConstants() {
-        }
-
-        /**
-         * Value for first month of year.
-         */
-        public static final int JANUARY  = 1;
-
-        /**
-         * Value for second month of year.
-         */
-        public static final int FEBRUARY = 2;
-
-        /**
-         * Value for third month of year.
-         */
-        public static final int MARCH    = 3;
-
-        /**
-         * Value for fourth month of year.
-         */
-        public static final int APRIL    = 4;
-
-        /**
-         * Value for fifth month of year.
-         */
-        public static final int MAY      = 5;
-
-        /**
-         * Value for sixth month of year.
-         */
-        public static final int JUNE     = 6;
-
-        /**
-         * Value for seventh month of year.
-         */
-        public static final int JULY     = 7;
-
-        /**
-         * Value for eighth month of year.
-         */
-        public static final int AUGUST   = 8;
-
-        /**
-         * Value for ninth month of year.
-         */
-        public static final int SEPTEMBER = 9;
-
-        /**
-         * Value for tenth month of year.
-         */
-        public static final int OCTOBER = 10;
-
-        /**
-         * Value for eleven month of year.
-         */
-        public static final int NOVEMBER = 11;
-
-        /**
-         * Value for twelve month of year.
-         */
-        public static final int DECEMBER = 12;
-
-        /**
-         * <p>Comparison result.</p>
-         */
-        public static final int LESSER = -1;
-
-        /**
-         * <p>Comparison result.</p>
-         */
-        public static final int EQUAL =  0;
-
-        /**
-         * <p>Comparison result.</p>
-         */
-        public static final int GREATER =  1;
-
-        /**
-         * <p>Comparison result.</p>
-         */
-        public static final int INDETERMINATE =  2;
-
-        /**
-         * Designation that an "int" field is not set.
-         */
-        public static final int FIELD_UNDEFINED = Integer.MIN_VALUE;
-
-        /**
-         * <p>A constant that represents the years field.</p>
-         */
-        public static final Field YEARS = new Field("YEARS", 0);
-
-        /**
-         * <p>A constant that represents the months field.</p>
-         */
-        public static final Field MONTHS = new Field("MONTHS", 1);
-
-        /**
-         * <p>A constant that represents the days field.</p>
-         */
-        public static final Field DAYS = new Field("DAYS", 2);
-
-        /**
-         * <p>A constant that represents the hours field.</p>
-         */
-        public static final Field HOURS = new Field("HOURS", 3);
-
-        /**
-         * <p>A constant that represents the minutes field.</p>
-         */
-        public static final Field MINUTES = new Field("MINUTES", 4);
-
-        /**
-         * <p>A constant that represents the seconds field.</p>
-         */
-        public static final Field SECONDS = new Field("SECONDS", 5);
-
-        /**
-         * Type-safe enum class that represents six fields
-         * of the {@link javax.xml.datatype.Duration} class.
-         * @since 1.5
-         */
-        public static final class Field {
-
-                /**
-                 * <p><code>String</code> representation of <code>Field</code>.</p>
-                 */
-                private final String str;
-                /**
-                 * <p>Unique id of the field.</p>
-                 *
-                 * <p>This value allows the {@link Duration} class to use switch
-                 * statements to process fields.</p>
-                 */
-                private final int id;
-
-                /**
-                 * <p>Construct a <code>Field</code> with specified values.</p>
-                 * @param str <code>String</code> representation of <code>Field</code>
-                 * @param id  <code>int</code> representation of <code>Field</code>
-                 */
-                private Field(final String str, final int id) {
-                        this.str = str;
-                        this.id = id;
-                }
-                /**
-                 * Returns a field name in English. This method
-                 * is intended to be used for debugging/diagnosis
-                 * and not for display to end-users.
-                 *
-                 * @return
-                 *      a non-null valid String constant.
-                 */
-                public String toString() { return str; }
-
-                /**
-                 * <p>Get id of this Field.</p>
-                 *
-                 * @return Id of field.
-                 */
-                public int getId() {
-                        return id;
-                }
-        }
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>dateTime</code>.</p>
-         */
-        public static final QName DATETIME = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "dateTime");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>time</code>.</p>
-         */
-        public static final QName TIME = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "time");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>date</code>.</p>
-         */
-        public static final QName DATE = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "date");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>gYearMonth</code>.</p>
-         */
-        public static final QName GYEARMONTH = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "gYearMonth");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>gMonthDay</code>.</p>
-         */
-        public static final QName GMONTHDAY = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "gMonthDay");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>gYear</code>.</p>
-         */
-        public static final QName GYEAR = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "gYear");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>gMonth</code>.</p>
-         */
-        public static final QName GMONTH = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "gMonth");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema 1.0 datatype <code>gDay</code>.</p>
-         */
-        public static final QName GDAY = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "gDay");
-
-        /**
-         * <p>Fully qualified name for W3C XML Schema datatype <code>duration</code>.</p>
-         */
-        public static final QName DURATION = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, "duration");
-
-        /**
-         * <p>Fully qualified name for XQuery 1.0 and XPath 2.0 datatype <code>dayTimeDuration</code>.</p>
-         */
-        public static final QName DURATION_DAYTIME = new QName(XMLConstants.W3C_XPATH_DATATYPE_NS_URI, "dayTimeDuration");
-
-        /**
-         * <p>Fully qualified name for XQuery 1.0 and XPath 2.0 datatype <code>yearMonthDuration</code>.</p>
-         */
-        public static final QName DURATION_YEARMONTH = new QName(XMLConstants.W3C_XPATH_DATATYPE_NS_URI, "yearMonthDuration");
-
-        /**
-         * W3C XML Schema max timezone offset is -14:00. Zone offset is in minutes.
-         */
-        public static final int MAX_TIMEZONE_OFFSET = -14 * 60;
-
-        /**
-         * W3C XML Schema min timezone offset is +14:00. Zone offset is in minutes.
-         */
-        public static final int MIN_TIMEZONE_OFFSET = 14 * 60;
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/XMLGregorianCalendar.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/XMLGregorianCalendar.java b/Build/src/main/java/org/openjdk/javax/xml/datatype/XMLGregorianCalendar.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/XMLGregorianCalendar.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1062 +0,0 @@
-/*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.datatype;
-
-import javax.xml.namespace.QName;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.TimeZone;
-import java.util.GregorianCalendar;
-
-/**
- * <p>Representation for W3C XML Schema 1.0 date/time datatypes.
- * Specifically, these date/time datatypes are
- * {@link javax.xml.datatype.DatatypeConstants#DATETIME},
- * {@link javax.xml.datatype.DatatypeConstants#TIME},
- * {@link javax.xml.datatype.DatatypeConstants#DATE},
- * {@link javax.xml.datatype.DatatypeConstants#GYEARMONTH},
- * {@link javax.xml.datatype.DatatypeConstants#GMONTHDAY},
- * {@link javax.xml.datatype.DatatypeConstants#GYEAR},
- * {@link javax.xml.datatype.DatatypeConstants#GMONTH}, and
- * {@link javax.xml.datatype.DatatypeConstants#GDAY}
- * defined in the XML Namespace
- * <code>"http://www.w3.org/2001/XMLSchema"</code>.
- * These datatypes are normatively defined in
- * <a href="http://www.w3.org/TR/xmlschema-2/#dateTime">W3C XML Schema 1.0 Part 2, Section 3.2.7-14</a>.</p>
- *
- * <p>The table below defines the mapping between XML Schema 1.0
- * date/time datatype fields and this class' fields. It also summarizes
- * the value constraints for the date and time fields defined in
- * <a href="http://www.w3.org/TR/xmlschema-2/#isoformats">W3C XML Schema 1.0 Part 2, Appendix D,
- * <i>ISO 8601 Date and Time Formats</i></a>.</p>
- *
- * <a name="datetimefieldmapping"/>
- * <table border="2" rules="all" cellpadding="2">
- *   <thead>
- *     <tr>
- *       <th align="center" colspan="3">
- *         Date/Time Datatype Field Mapping Between XML Schema 1.0 and Java Representation
- *       </th>
- *     </tr>
- *   </thead>
- *   <tbody>
- *     <tr>
- *       <th>XML Schema 1.0<br/>
- *           datatype<br/>
- *            field</th>
- *       <th>Related<br/>XMLGregorianCalendar<br/>Accessor(s)</th>
- *       <th>Value Range</th>
- *     </tr>
- *     <tr>
- *       <td><a name="datetimefield-year"/>year</td>
- *       <td> {@link #getYear()} + {@link #getEon()} or<br/>
- *            {@link #getEonAndYear}
- *       </td>
- *       <td> <code>getYear()</code> is a value between -(10^9-1) to (10^9)-1
- *            or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.<br/>
- *            {@link #getEon()} is high order year value in billion of years.<br/>
- *            <code>getEon()</code> has values greater than or equal to (10^9) or less than or equal to -(10^9).
- *            A value of null indicates field is undefined.</br>
- *            Given that <a href="http://www.w3.org/2001/05/xmlschema-errata#e2-63">XML Schema 1.0 errata</a> states that the year zero
- *            will be a valid lexical value in a future version of XML Schema,
- *            this class allows the year field to be set to zero. Otherwise,
- *            the year field value is handled exactly as described
- *            in the errata and [ISO-8601-1988]. Note that W3C XML Schema 1.0
- *            validation does not allow for the year field to have a value of zero.
- *            </td>
- *     </tr>
- *     <tr>
- *       <td><a name="datetimefield-month"/>month</td>
- *       <td> {@link #getMonth()} </td>
- *       <td> 1 to 12 or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} </td>
- *     </tr>
- *     <tr>
- *       <td><a name="datetimefield-day"/>day</td>
- *       <td> {@link #getDay()} </td>
- *       <td> Independent of month, max range is 1 to 31 or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.<br/>
- *            The normative value constraint stated relative to month
- *            field's value is in <a href="http://www.w3.org/TR/xmlschema-2/#isoformats">W3C XML Schema 1.0 Part 2, Appendix D</a>.
- *       </td>
- *     </tr>
- *     <tr>
- *       <td><a name="datetimefield-hour"/>hour</td>
- *       <td>{@link #getHour()}</td>
- *       <td>
- *         0 to 23 or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.
- *         An hour value of 24 is allowed to be set in the lexical space provided the minute and second
- *         field values are zero. However, an hour value of 24 is not allowed in value space and will be
- *         transformed to represent the value of the first instance of the following day as per
- *         <a href="http://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes">
- *         XML Schema Part 2: Datatypes Second Edition, 3.2 Primitive datatypes</a>.
- *       </td>
- *     </tr>
- *     <tr>
- *       <td><a name="datetimefield-minute"/>minute</td>
- *       <td> {@link #getMinute()} </td>
- *       <td> 0 to 59 or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} </td>
- *     </tr>
- *     <tr>
- *       <td><a name="datetimefield-second"/>second</td>
- *       <td>
- *         {@link #getSecond()} + {@link #getMillisecond()}/1000 or<br/>
- *         {@link #getSecond()} + {@link #getFractionalSecond()}
- *       </td>
- *       <td>
- *         {@link #getSecond()} from 0 to 60 or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.<br/>
- *         <i>(Note: 60 only allowable for leap second.)</i><br/>
- *         {@link #getFractionalSecond()} allows for infinite precision over the range from 0.0 to 1.0 when
- *         the {@link #getSecond()} is defined.<br/>
- *         <code>FractionalSecond</code> is optional and has a value of <code>null</code> when it is undefined.<br />
- *            {@link #getMillisecond()} is the convenience
- *            millisecond precision of value of {@link #getFractionalSecond()}.
- *       </td>
- *     </tr>
- *     <tr>
- *       <td><a name="datetimefield-timezone"/>timezone</td>
- *       <td> {@link #getTimezone()} </td>
- *       <td> Number of minutes or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.
- *         Value range from -14 hours (-14 * 60 minutes) to 14 hours (14 * 60 minutes).
- *       </td>
- *     </tr>
- *   </tbody>
- *  </table>
- *
- * <p>All maximum value space constraints listed for the fields in the table
- * above are checked by factory methods, @{link DatatypeFactory},
- * setter methods and parse methods of
- * this class. <code>IllegalArgumentException</code> is thrown when a
- * parameter's value is outside the value constraint for the field or
- * if the composite
- * values constitute an invalid XMLGregorianCalendar instance (for example, if
- * the 31st of June is specified).
- * </p>
- *
- * <p>The following operations are defined for this class:
- * <ul>
- *   <li>accessors/mutators for independent date/time fields</li>
- *   <li>conversion between this class and W3C XML Schema 1.0 lexical representation,
- *     {@link #toString()}, {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar(String lexicalRepresentation)}</li>
- *   <li>conversion between this class and {@link GregorianCalendar},
- *     {@link #toGregorianCalendar(java.util.TimeZone timezone, java.util.Locale aLocale, XMLGregorianCalendar defaults)},
- *     {@link javax.xml.datatype.DatatypeFactory}</li>
- *   <li>partial order relation comparator method, {@link #compare(XMLGregorianCalendar xmlGregorianCalendar)}</li>
- *   <li>{@link #equals(Object)} defined relative to {@link #compare(XMLGregorianCalendar xmlGregorianCalendar)}.</li>
- *   <li>addition operation with {@link javax.xml.datatype.Duration}
- *      instance as defined in <a href="http://www.w3.org/TR/xmlschema-2/#adding-durations-to-dateTimes">
- *      W3C XML Schema 1.0 Part 2, Appendix E, <i>Adding durations to dateTimes</i></a>.
- *   </li>
- * </ul>
- * </p>
- *
- * @author <a href="mailto:Joseph.Fialli@Sun.com">Joseph Fialli</a>
- * @author <a href="mailto:Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @author <a href="mailto:Sunitha.Reddy@Sun.com">Sunitha Reddy</a>
- * @see javax.xml.datatype.Duration
- * @see javax.xml.datatype.DatatypeFactory
- * @since 1.5
- */
-
-public abstract class XMLGregorianCalendar
-        implements Cloneable {
-
-        /**
-         * Default no-arg constructor.
-         *
-         * <p>Note: Always use the {@link javax.xml.datatype.DatatypeFactory} to
-         * construct an instance of <code>XMLGregorianCalendar</code>.
-         * The constructor on this class cannot be guaranteed to
-         * produce an object with a consistent state and may be
-         * removed in the future.</p>
-         */
-         public XMLGregorianCalendar() {
-         }
-
-        /**
-         * <p>Unset all fields to undefined.</p>
-         *
-         * <p>Set all int fields to {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} and reference fields
-         * to null.</p>
-         */
-        public abstract void clear();
-
-        /**
-         * <p>Reset this <code>XMLGregorianCalendar</code> to its original values.</p>
-         *
-         * <p><code>XMLGregorianCalendar</code> is reset to the same values as when it was created with
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar()},
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar(String lexicalRepresentation)},
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar(
-         *   BigInteger year,
-         *   int month,
-         *   int day,
-         *   int hour,
-         *   int minute,
-         *   int second,
-         *   BigDecimal fractionalSecond,
-         *   int timezone)},
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar(
-         *   int year,
-         *   int month,
-         *   int day,
-         *   int hour,
-         *   int minute,
-         *   int second,
-         *   int millisecond,
-         *   int timezone)},
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar(GregorianCalendar cal)},
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendarDate(
-         *   int year,
-         *   int month,
-         *   int day,
-         *   int timezone)},
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendarTime(
-         *   int hours,
-         *   int minutes,
-         *   int seconds,
-         *   int timezone)},
-         * {@link javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendarTime(
-         *   int hours,
-         *   int minutes,
-         *   int seconds,
-         *   BigDecimal fractionalSecond,
-         *   int timezone)} or
-         * {@link DatatypeFactory#newXMLGregorianCalendarTime(
-         *   int hours,
-         *   int minutes,
-         *   int seconds,
-         *   int milliseconds,
-         *   int timezone)}.
-         * </p>
-         *
-         * <p><code>reset()</code> is designed to allow the reuse of existing <code>XMLGregorianCalendar</code>s
-         * thus saving resources associated with the creation of new <code>XMLGregorianCalendar</code>s.</p>
-         */
-        public abstract void reset();
-
-    /**
-     * <p>Set low and high order component of XSD <code>dateTime</code> year field.</p>
-     *
-     * <p>Unset this field by invoking the setter with a parameter value of <code>null</code>.</p>
-     *
-     * @param year value constraints summarized in <a href="#datetimefield-year">year field of date/time field mapping table</a>.
-     *
-     * @throws IllegalArgumentException if <code>year</code> parameter is
-     * outside value constraints for the field as specified in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.
-     */
-    public abstract void setYear(BigInteger year);
-
-    /**
-     * <p>Set year of XSD <code>dateTime</code> year field.</p>
-     *
-     * <p>Unset this field by invoking the setter with a parameter value of
-     * {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-     *
-     * <p>Note: if the absolute value of the <code>year</code> parameter
-     * is less than 10^9, the eon component of the XSD year field is set to
-     * <code>null</code> by this method.</p>
-     *
-     * @param year value constraints are summarized in <a href="#datetimefield-year">year field of date/time field mapping table</a>.
-     *   If year is {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}, then eon is set to <code>null</code>.
-     */
-    public abstract void setYear(int year);
-
-    /**
-     * <p>Set month.</p>
-     *
-     * <p>Unset this field by invoking the setter with a parameter value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-     *
-     * @param month value constraints summarized in <a href="#datetimefield-month">month field of date/time field mapping table</a>.
-     *
-     * @throws IllegalArgumentException if <code>month</code> parameter is
-     * outside value constraints for the field as specified in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.
-     */
-    public abstract void setMonth(int month);
-
-    /**
-     * <p>Set days in month.</p>
-     *
-     * <p>Unset this field by invoking the setter with a parameter value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-     *
-     * @param day value constraints summarized in <a href="#datetimefield-day">day field of date/time field mapping table</a>.
-     *
-     * @throws IllegalArgumentException if <code>day</code> parameter is
-     * outside value constraints for the field as specified in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.
-     */
-    public abstract void setDay(int day);
-
-    /**
-     * <p>Set the number of minutes in the timezone offset.</p>
-     *
-     * <p>Unset this field by invoking the setter with a parameter value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-     *
-     * @param offset value constraints summarized in <a href="#datetimefield-timezone">
-     *   timezone field of date/time field mapping table</a>.
-     *
-     * @throws IllegalArgumentException if <code>offset</code> parameter is
-     * outside value constraints for the field as specified in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.
-     */
-    public abstract void setTimezone(int offset);
-
-    /**
-     * <p>Set time as one unit.</p>
-     *
-     * @param hour value constraints are summarized in
-     * <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.
-     * @param minute value constraints are summarized in
-     * <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.
-     * @param second value constraints are summarized in
-     * <a href="#datetimefield-second">second field of date/time field mapping table</a>.
-     *
-     * @see #setTime(int, int, int, BigDecimal)
-     *
-     * @throws IllegalArgumentException if any parameter is
-     * outside value constraints for the field as specified in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.
-     */
-    public void setTime(int hour, int minute, int second) {
-
-                setTime(
-                        hour,
-                        minute,
-                        second,
-                        null // fractional
-                );
-    }
-
-        /**
-         * <p>Set hours.</p>
-         *
-         * <p>Unset this field by invoking the setter with a parameter value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * @param hour value constraints summarized in <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.
-         *
-         * @throws IllegalArgumentException if <code>hour</code> parameter is outside value constraints for the field as specified in
-         *   <a href="#datetimefieldmapping">date/time field mapping table</a>.
-        */
-        public abstract void setHour(int hour);
-
-        /**
-         * <p>Set minutes.</p>
-         *
-         * <p>Unset this field by invoking the setter with a parameter value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * @param minute value constraints summarized in <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.
-         *
-         * @throws IllegalArgumentException if <code>minute</code> parameter is outside value constraints for the field as specified in
-         *   <a href="#datetimefieldmapping">date/time field mapping table</a>.
-        */
-        public abstract void setMinute(int minute);
-
-        /**
-         * <p>Set seconds.</p>
-         *
-         * <p>Unset this field by invoking the setter with a parameter value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * @param second value constraints summarized in <a href="#datetimefield-second">second field of date/time field mapping table</a>.
-         *
-         * @throws IllegalArgumentException if <code>second</code> parameter is outside value constraints for the field as specified in
-         *   <a href="#datetimefieldmapping">date/time field mapping table</a>.
-        */
-        public abstract void setSecond(int second);
-
-        /**
-         * <p>Set milliseconds.</p>
-         *
-         * <p>Unset this field by invoking the setter with a parameter value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * @param millisecond value constraints summarized in
-         *   <a href="#datetimefield-second">second field of date/time field mapping table</a>.
-         *
-         * @throws IllegalArgumentException if <code>millisecond</code> parameter is outside value constraints for the field as specified
-         *   in <a href="#datetimefieldmapping">date/time field mapping table</a>.
-        */
-        public abstract void setMillisecond(int millisecond);
-
-        /**
-         * <p>Set fractional seconds.</p>
-         *
-         * <p>Unset this field by invoking the setter with a parameter value of <code>null</code>.</p>
-         *
-         * @param fractional value constraints summarized in
-         *   <a href="#datetimefield-second">second field of date/time field mapping table</a>.
-         *
-         * @throws IllegalArgumentException if <code>fractional</code> parameter is outside value constraints for the field as specified
-         *   in <a href="#datetimefieldmapping">date/time field mapping table</a>.
-        */
-        public abstract void setFractionalSecond(BigDecimal fractional);
-
-
-    /**
-     * <p>Set time as one unit, including the optional infinite precision
-     * fractional seconds.</p>
-     *
-     * @param hour value constraints are summarized in
-     * <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.
-     * @param minute value constraints are summarized in
-     * <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.
-     * @param second value constraints are summarized in
-     * <a href="#datetimefield-second">second field of date/time field mapping table</a>.
-     * @param fractional value of <code>null</code> indicates this optional
-     *   field is not set.
-     *
-     * @throws IllegalArgumentException if any parameter is
-     * outside value constraints for the field as specified in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.
-     */
-    public void setTime(
-        int hour,
-        int minute,
-        int second,
-        BigDecimal fractional) {
-
-                setHour(hour);
-        setMinute(minute);
-        setSecond(second);
-        setFractionalSecond(fractional);
-    }
-
-
-    /**
-     * <p>Set time as one unit, including optional milliseconds.</p>
-     *
-     * @param hour value constraints are summarized in
-     * <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.
-     * @param minute value constraints are summarized in
-     * <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.
-     * @param second value constraints are summarized in
-     * <a href="#datetimefield-second">second field of date/time field mapping table</a>.
-     * @param millisecond value of {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} indicates this
-     *                    optional field is not set.
-     *
-     * @throws IllegalArgumentException if any parameter is
-     * outside value constraints for the field as specified in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.
-     */
-    public void setTime(int hour, int minute, int second, int millisecond) {
-
-        setHour(hour);
-        setMinute(minute);
-        setSecond(second);
-        setMillisecond(millisecond);
-    }
-
-        /**
-         * <p>Return high order component for XML Schema 1.0 dateTime datatype field for
-         * <code>year</code>.
-         * <code>null</code> if this optional part of the year field is not defined.</p>
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-year">year field of date/time field mapping table</a>.</p>
-         * @return eon of this <code>XMLGregorianCalendar</code>. The value
-         * returned is an integer multiple of 10^9.
-         *
-         * @see #getYear()
-         * @see #getEonAndYear()
-         */
-        public abstract BigInteger getEon();
-
-        /**
-         * <p>Return low order component for XML Schema 1.0 dateTime datatype field for
-         * <code>year</code> or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-year">year field of date/time field mapping table</a>.</p>
-         *
-         * @return year  of this <code>XMLGregorianCalendar</code>.
-         *
-         * @see #getEon()
-         * @see #getEonAndYear()
-         */
-        public abstract int getYear();
-
-        /**
-         * <p>Return XML Schema 1.0 dateTime datatype field for
-         * <code>year</code>.</p>
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-year">year field of date/time field mapping table</a>.</p>
-         *
-         * @return sum of <code>eon</code> and <code>BigInteger.valueOf(year)</code>
-         * when both fields are defined. When only <code>year</code> is defined,
-         * return it. When both <code>eon</code> and <code>year</code> are not
-         * defined, return <code>null</code>.
-         *
-         * @see #getEon()
-         * @see #getYear()
-         */
-        public abstract BigInteger getEonAndYear();
-
-        /**
-         * <p>Return number of month or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-month">month field of date/time field mapping table</a>.</p>
-         *
-         * @return year  of this <code>XMLGregorianCalendar</code>.
-         *
-         */
-        public abstract int getMonth();
-
-        /**
-         * Return day in month or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-day">day field of date/time field mapping table</a>.</p>
-         *
-         * @see #setDay(int)
-         */
-        public abstract int getDay();
-
-        /**
-         * Return timezone offset in minutes or
-         * {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} if this optional field is not defined.
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-timezone">timezone field of date/time field mapping table</a>.</p>
-         *
-         * @see #setTimezone(int)
-         */
-        public abstract int getTimezone();
-
-        /**
-         * Return hours or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.
-         * Returns {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} if this field is not defined.
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.</p>
-         * @see #setTime(int, int, int)
-         */
-        public abstract int getHour();
-
-        /**
-         * Return minutes or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         * Returns {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} if this field is not defined.
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.</p>
-         * @see #setTime(int, int, int)
-         */
-        public abstract int getMinute();
-
-        /**
-         * <p>Return seconds or {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * <p>Returns {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED} if this field is not defined.
-         * When this field is not defined, the optional xs:dateTime
-         * fractional seconds field, represented by
-         * {@link #getFractionalSecond()} and {@link #getMillisecond()},
-         * must not be defined.</p>
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-second">second field of date/time field mapping table</a>.</p>
-         *
-         * @return Second  of this <code>XMLGregorianCalendar</code>.
-         *
-         * @see #getFractionalSecond()
-         * @see #getMillisecond()
-         * @see #setTime(int, int, int)
-         */
-        public abstract int getSecond();
-
-        /**
-         * <p>Return millisecond precision of {@link #getFractionalSecond()}.</p>
-         *
-         * <p>This method represents a convenience accessor to infinite
-         * precision fractional second value returned by
-         * {@link #getFractionalSecond()}. The returned value is the rounded
-         * down to milliseconds value of
-         * {@link #getFractionalSecond()}. When {@link #getFractionalSecond()}
-         * returns <code>null</code>, this method must return
-         * {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * <p>Value constraints for this value are summarized in
-         * <a href="#datetimefield-second">second field of date/time field mapping table</a>.</p>
-         *
-         * @return Millisecond  of this <code>XMLGregorianCalendar</code>.
-         *
-         * @see #getFractionalSecond()
-         * @see #setTime(int, int, int)
-         */
-        public int getMillisecond() {
-
-                BigDecimal fractionalSeconds = getFractionalSecond();
-
-                // is field undefined?
-                if (fractionalSeconds == null) {
-                        return javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED;
-                }
-
-                return getFractionalSecond().movePointRight(3).intValue();
-        }
-
-        /**
-         * <p>Return fractional seconds.</p>
-         *
-         * <p><code>null</code> is returned when this optional field is not defined.</p>
-         *
-         * <p>Value constraints are detailed in
-         * <a href="#datetimefield-second">second field of date/time field mapping table</a>.</p>
-         *
-         * <p>This optional field can only have a defined value when the
-         * xs:dateTime second field, represented by {@link #getSecond()},
-         * does not return {@link javax.xml.datatype.DatatypeConstants#FIELD_UNDEFINED}.</p>
-         *
-         * @return fractional seconds  of this <code>XMLGregorianCalendar</code>.
-         *
-         * @see #getSecond()
-         * @see #setTime(int, int, int, BigDecimal)
-         */
-        public abstract BigDecimal getFractionalSecond();
-
-    // comparisons
-    /**
-     * <p>Compare two instances of W3C XML Schema 1.0 date/time datatypes
-     * according to partial order relation defined in
-     * <a href="http://www.w3.org/TR/xmlschema-2/#dateTime-order">W3C XML Schema 1.0 Part 2, Section 3.2.7.3,
-     * <i>Order relation on dateTime</i></a>.</p>
-     *
-     * <p><code>xsd:dateTime</code> datatype field mapping to accessors of
-     * this class are defined in
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>.</p>
-     *
-     * @param xmlGregorianCalendar Instance of <code>XMLGregorianCalendar</code> to compare
-     *
-     * @return The relationship between <code>this</code> <code>XMLGregorianCalendar</code> and
-     *   the specified <code>xmlGregorianCalendar</code> as
-     *   {@link javax.xml.datatype.DatatypeConstants#LESSER},
-     *   {@link javax.xml.datatype.DatatypeConstants#EQUAL},
-     *   {@link javax.xml.datatype.DatatypeConstants#GREATER} or
-     *   {@link javax.xml.datatype.DatatypeConstants#INDETERMINATE}.
-     *
-     * @throws NullPointerException if <code>xmlGregorianCalendar</code> is null.
-     */
-    public abstract int compare(XMLGregorianCalendar xmlGregorianCalendar);
-
-    /**
-     * <p>Normalize this instance to UTC.</p>
-     *
-     * <p>2000-03-04T23:00:00+03:00 normalizes to 2000-03-04T20:00:00Z</p>
-     * <p>Implements W3C XML Schema Part 2, Section 3.2.7.3 (A).</p>
-     *
-     * @return <code>this</code> <code>XMLGregorianCalendar</code> normalized to UTC.
-     */
-    public abstract XMLGregorianCalendar normalize();
-
-    /**
-     * <p>Compares this calendar to the specified object. The result is
-     * <code>true</code> if and only if the argument is not null and is an
-     * <code>XMLGregorianCalendar</code> object that represents the same
-     * instant in time as this object.</p>
-     *
-     * @param obj to compare.
-     *
-     * @return <code>true</code> when <code>obj</code> is an instance of
-     * <code>XMLGregorianCalendar</code> and
-     * {@link #compare(XMLGregorianCalendar obj)}
-     * returns {@link javax.xml.datatype.DatatypeConstants#EQUAL},
-     * otherwise <code>false</code>.
-     */
-    public boolean equals(Object obj) {
-
-        if (obj == null || !(obj instanceof XMLGregorianCalendar)) {
-               return false;
-        }
-        return compare((XMLGregorianCalendar) obj) == javax.xml.datatype.DatatypeConstants.EQUAL;
-    }
-
-    /**
-     * <p>Returns a hash code consistent with the definition of the equals method.</p>
-     *
-     * @return hash code of this object.
-     */
-    public int hashCode() {
-
-        // Following two dates compare to EQUALS since in different timezones.
-        // 2000-01-15T12:00:00-05:00 == 2000-01-15T13:00:00-04:00
-        //
-        // Must ensure both instances generate same hashcode by normalizing
-        // this to UTC timezone.
-        int timezone = getTimezone();
-        if (timezone == javax.xml.datatype.DatatypeConstants.FIELD_UNDEFINED) {
-            timezone = 0;
-        }
-        XMLGregorianCalendar gc = this;
-        if (timezone != 0) {
-            gc = this.normalize();
-        }
-        return gc.getYear()
-                + gc.getMonth()
-                + gc.getDay()
-                + gc.getHour()
-                + gc.getMinute()
-                + gc.getSecond();
-    }
-
-    /**
-     * <p>Return the lexical representation of <code>this</code> instance.
-     * The format is specified in
-     * <a href="http://www.w3.org/TR/xmlschema-2/#dateTime-order">XML Schema 1.0 Part 2, Section 3.2.[7-14].1,
-     * <i>Lexical Representation</i>".</a></p>
-     *
-     * <p>Specific target lexical representation format is determined by
-     * {@link #getXMLSchemaType()}.</p>
-     *
-     * @return XML, as <code>String</code>, representation of this <code>XMLGregorianCalendar</code>
-     *
-     * @throws IllegalStateException if the combination of set fields
-     *    does not match one of the eight defined XML Schema builtin date/time datatypes.
-     */
-    public abstract String toXMLFormat();
-
-    /**
-     * <p>Return the name of the XML Schema date/time type that this instance
-     * maps to. Type is computed based on fields that are set.</p>
-     *
-     * <table border="2" rules="all" cellpadding="2">
-     *   <thead>
-     *     <tr>
-     *       <th align="center" colspan="7">
-     *         Required fields for XML Schema 1.0 Date/Time Datatypes.<br/>
-     *         <i>(timezone is optional for all date/time datatypes)</i>
-     *       </th>
-     *     </tr>
-     *   </thead>
-     *   <tbody>
-     *     <tr>
-     *       <td>Datatype</td>
-     *       <td>year</td>
-     *       <td>month</td>
-     *       <td>day</td>
-     *       <td>hour</td>
-     *       <td>minute</td>
-     *       <td>second</td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#DATETIME}</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#DATE}</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#TIME}</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#GYEARMONTH}</td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#GMONTHDAY}</td>
-     *       <td></td>
-     *       <td>X</td>
-     *       <td>X</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#GYEAR}</td>
-     *       <td>X</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#GMONTH}</td>
-     *       <td></td>
-     *       <td>X</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *     </tr>
-     *     <tr>
-     *       <td>{@link javax.xml.datatype.DatatypeConstants#GDAY}</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td>X</td>
-     *       <td></td>
-     *       <td></td>
-     *       <td></td>
-     *     </tr>
-     *   </tbody>
-     * </table>
-     *
-     * @throws java.lang.IllegalStateException if the combination of set fields
-     *    does not match one of the eight defined XML Schema builtin
-     *    date/time datatypes.
-     * @return One of the following class constants:
-     *   {@link javax.xml.datatype.DatatypeConstants#DATETIME},
-     *   {@link javax.xml.datatype.DatatypeConstants#TIME},
-     *   {@link javax.xml.datatype.DatatypeConstants#DATE},
-     *   {@link javax.xml.datatype.DatatypeConstants#GYEARMONTH},
-     *   {@link javax.xml.datatype.DatatypeConstants#GMONTHDAY},
-     *   {@link javax.xml.datatype.DatatypeConstants#GYEAR},
-     *   {@link javax.xml.datatype.DatatypeConstants#GMONTH} or
-     *   {@link javax.xml.datatype.DatatypeConstants#GDAY}.
-     */
-    public abstract QName getXMLSchemaType();
-
-        /**
-         * <p>Returns a <code>String</code> representation of this <code>XMLGregorianCalendar</code> <code>Object</code>.</p>
-         *
-         * <p>The result is a lexical representation generated by {@link #toXMLFormat()}.</p>
-         *
-         * @return A non-<code>null</code> valid <code>String</code> representation of this <code>XMLGregorianCalendar</code>.
-         *
-     * @throws IllegalStateException if the combination of set fields
-     *    does not match one of the eight defined XML Schema builtin date/time datatypes.
-     *
-     * @see #toXMLFormat()
-         */
-    public String toString() {
-
-        return toXMLFormat();
-    }
-
-    /**
-     * Validate instance by <code>getXMLSchemaType()</code> constraints.
-     * @return true if data values are valid.
-     */
-    public abstract boolean isValid();
-
-    /**
-     * <p>Add <code>duration</code> to this instance.</p>
-     *
-     * <p>The computation is specified in
-     * <a href="http://www.w3.org/TR/xmlschema-2/#adding-durations-to-dateTimes">XML Schema 1.0 Part 2, Appendix E,
-     * <i>Adding durations to dateTimes</i>></a>.
-     * <a href="#datetimefieldmapping">date/time field mapping table</a>
-     * defines the mapping from XML Schema 1.0 <code>dateTime</code> fields
-     * to this class' representation of those fields.</p>
-     *
-     * @param duration Duration to add to this <code>XMLGregorianCalendar</code>.
-     *
-     * @throws NullPointerException  when <code>duration</code> parameter is <code>null</code>.
-     */
-    public abstract void add(Duration duration);
-
-    /**
-     * <p>Convert this <code>XMLGregorianCalendar</code> to a {@link GregorianCalendar}.</p>
-     *
-     * <p>When <code>this</code> instance has an undefined field, this
-     * conversion relies on the <code>java.util.GregorianCalendar</code> default
-     * for its corresponding field. A notable difference between
-     * XML Schema 1.0 date/time datatypes and <code>java.util.GregorianCalendar</code>
-     * is that Timezone value is optional for date/time datatypes and it is
-     * a required field for <code>java.util.GregorianCalendar</code>. See javadoc
-     * for <code>java.util.TimeZone.getDefault()</code> on how the default
-     * is determined. To explicitly specify the <code>TimeZone</code>
-     * instance, see
-     * {@link #toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar)}.</p>
-     *
-     * <table border="2" rules="all" cellpadding="2">
-     *   <thead>
-     *     <tr>
-     *       <th align="center" colspan="2">
-     *          Field by Field Conversion from this class to
-     *          <code>java.util.GregorianCalendar</code>
-     *       </th>
-     *     </tr>
-     *   </thead>
-     *   <tbody>
-     *     <tr>
-     *        <td><code>java.util.GregorianCalendar</code> field</td>
-     *        <td><code>javax.xml.datatype.XMLGregorianCalendar</code> field</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>ERA</code></td>
-     *       <td>{@link #getEonAndYear()}<code>.signum() < 0 ? GregorianCalendar.BC : GregorianCalendar.AD</code></td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>YEAR</code></td>
-     *       <td>{@link #getEonAndYear()}<code>.abs().intValue()</code><i>*</i></td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>MONTH</code></td>
-     *       <td>{@link #getMonth()} - {@link javax.xml.datatype.DatatypeConstants#JANUARY} + {@link GregorianCalendar#JANUARY}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>DAY_OF_MONTH</code></td>
-     *       <td>{@link #getDay()}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>HOUR_OF_DAY</code></td>
-     *       <td>{@link #getHour()}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>MINUTE</code></td>
-     *       <td>{@link #getMinute()}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>SECOND</code></td>
-     *       <td>{@link #getSecond()}</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>MILLISECOND</code></td>
-     *       <td>get millisecond order from {@link #getFractionalSecond()}<i>*</i> </td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>GregorianCalendar.setTimeZone(TimeZone)</code></td>
-     *       <td>{@link #getTimezone()} formatted into Custom timezone id</td>
-     *     </tr>
-     *   </tbody>
-     * </table>
-     * <i>*</i> designates possible loss of precision during the conversion due
-     * to source datatype having higher precision than target datatype.
-     *
-     * <p>To ensure consistency in conversion implementations, the new
-     * <code>GregorianCalendar</code> should be instantiated in following
-     * manner.
-     * <ul>
-     *   <li>Using <code>timeZone</code> value as defined above, create a new
-     * <code>java.util.GregorianCalendar(timeZone,Locale.getDefault())</code>.
-     *   </li>
-     *   <li>Initialize all GregorianCalendar fields by calling {@link java.util.GregorianCalendar#clear()}.</li>
-     *   <li>Obtain a pure Gregorian Calendar by invoking
-     *   <code>GregorianCalendar.setGregorianChange(
-     *   new Date(Long.MIN_VALUE))</code>.</li>
-     *   <li>Its fields ERA, YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY,
-     *       MINUTE, SECOND and MILLISECOND are set using the method
-     *       <code>Calendar.set(int,int)</code></li>
-     * </ul>
-     * </p>
-     *
-     * @see #toGregorianCalendar(java.util.TimeZone, java.util.Locale, XMLGregorianCalendar)
-     */
-    public abstract GregorianCalendar toGregorianCalendar();
-
-    /**
-     * <p>Convert this <code>XMLGregorianCalendar</code> along with provided parameters
-     * to a {@link GregorianCalendar} instance.</p>
-     *
-     * <p> Since XML Schema 1.0 date/time datetypes has no concept of
-     * timezone ids or daylight savings timezone ids, this conversion operation
-     * allows the user to explicitly specify one with
-     * <code>timezone</code> parameter.</p>
-     *
-     * <p>To compute the return value's <code>TimeZone</code> field,
-     * <ul>
-     * <li>when parameter <code>timeZone</code> is non-null,
-     * it is the timezone field.</li>
-     * <li>else when <code>this.getTimezone() != FIELD_UNDEFINED</code>,
-     * create a <code>java.util.TimeZone</code> with a custom timezone id
-     * using the <code>this.getTimezone()</code>.</li>
-     * <li>else when <code>defaults.getTimezone() != FIELD_UNDEFINED</code>,
-     * create a <code>java.util.TimeZone</code> with a custom timezone id
-     * using <code>defaults.getTimezone()</code>.</li>
-     * <li>else use the <code>GregorianCalendar</code> default timezone value
-     * for the host is defined as specified by
-     * <code>java.util.TimeZone.getDefault()</code>.</li></p>
-     *
-     * <p>To ensure consistency in conversion implementations, the new
-     * <code>GregorianCalendar</code> should be instantiated in following
-     * manner.
-     * <ul>
-     *   <li>Create a new <code>java.util.GregorianCalendar(TimeZone,
-     *       Locale)</code> with TimeZone set as specified above and the
-     *       <code>Locale</code> parameter.
-     *   </li>
-     *   <li>Initialize all GregorianCalendar fields by calling {@link GregorianCalendar#clear()}</li>
-     *   <li>Obtain a pure Gregorian Calendar by invoking
-     *   <code>GregorianCalendar.setGregorianChange(
-     *   new Date(Long.MIN_VALUE))</code>.</li>
-     *   <li>Its fields ERA, YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY,
-     *       MINUTE, SECOND and MILLISECOND are set using the method
-     *       <code>Calendar.set(int,int)</code></li>
-     * </ul>
-     *
-     * @param timezone provide Timezone. <code>null</code> is a legal value.
-     * @param aLocale  provide explicit Locale. Use default GregorianCalendar locale if
-     *                 value is <code>null</code>.
-     * @param defaults provide default field values to use when corresponding
-     *                 field for this instance is FIELD_UNDEFINED or null.
-     *                 If <code>defaults</code>is <code>null</code> or a field
-     *                 within the specified <code>defaults</code> is undefined,
-     *                 just use <code>java.util.GregorianCalendar</code> defaults.
-     * @return a java.util.GregorianCalendar conversion of this instance.
-     */
-    public abstract GregorianCalendar toGregorianCalendar(
-        java.util.TimeZone timezone,
-                java.util.Locale aLocale,
-                XMLGregorianCalendar defaults);
-
-    /**
-     * <p>Returns a <code>java.util.TimeZone</code> for this class.</p>
-     *
-     * <p>If timezone field is defined for this instance,
-     * returns TimeZone initialized with custom timezone id
-     * of zoneoffset. If timezone field is undefined,
-     * try the defaultZoneoffset that was passed in.
-     * If defaultZoneoffset is FIELD_UNDEFINED, return
-     * default timezone for this host.
-     * (Same default as java.util.GregorianCalendar).</p>
-     *
-     * @param defaultZoneoffset default zoneoffset if this zoneoffset is
-     * {@link DatatypeConstants#FIELD_UNDEFINED}.
-     *
-     * @return TimeZone for this.
-     */
-    public abstract TimeZone getTimeZone(int defaultZoneoffset);
-
-
-
-    /**
-     * <p>Creates and returns a copy of this object.</p>
-     *
-     * @return copy of this <code>Object</code>
-     */
-   public abstract Object clone();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConfigurationException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConfigurationException.java b/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConfigurationException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/datatype/DatatypeConfigurationException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,79 +0,0 @@
-/*
- * Copyright (c) 2004, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.datatype;
-
-/**
- * <p>Indicates a serious configuration error.</p>
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @since 1.5
- */
-
-public class DatatypeConfigurationException extends Exception {
-
-    /**
-     * <p>Create a new <code>DatatypeConfigurationException</code> with
-     * no specified detail mesage and cause.</p>
-     */
-
-    public DatatypeConfigurationException() {
-        super();
-    }
-
-    /**
-     * <p>Create a new <code>DatatypeConfigurationException</code> with
-         * the specified detail message.</p>
-     *
-         * @param message The detail message.
-     */
-
-    public DatatypeConfigurationException(String message) {
-        super(message);
-    }
-
-        /**
-         * <p>Create a new <code>DatatypeConfigurationException</code> with
-         * the specified detail message and cause.</p>
-         *
-         * @param message The detail message.
-         * @param cause The cause.  A <code>null</code> value is permitted, and indicates that the cause is nonexistent or unknown.
-         */
-
-        public DatatypeConfigurationException(String message, Throwable cause) {
-                super(message, cause);
-        }
-
-        /**
-         * <p>Create a new <code>DatatypeConfigurationException</code> with
-         * the specified cause.</p>
-         *
-         * @param cause The cause.  A <code>null</code> value is permitted, and indicates that the cause is nonexistent or unknown.
-         */
-
-        public DatatypeConfigurationException(Throwable cause) {
-                super(cause);
-        }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/namespace/QName.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/namespace/QName.java b/Build/src/main/java/org/openjdk/javax/xml/namespace/QName.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/namespace/QName.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,518 +0,0 @@
-/*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.namespace;
-
-import java.io.Serializable;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
-import javax.xml.XMLConstants;
-import javax.xml.transform.Source;
-import javax.xml.transform.Transformer;
-
-/**
- * <p><code>QName</code> represents a <strong>qualified name</strong>
- * as defined in the XML specifications: <a
- * href="http://www.w3.org/TR/xmlschema-2/#QName">XML Schema Part2:
- * Datatypes specification</a>, <a
- * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">Namespaces
- * in XML</a>, <a
- * href="http://www.w3.org/XML/xml-names-19990114-errata">Namespaces
- * in XML Errata</a>.</p>
- *
- * <p>The value of a <code>QName</code> contains a <strong>Namespace
- * URI</strong>, <strong>local part</strong> and
- * <strong>prefix</strong>.</p>
- *
- * <p>The prefix is included in <code>QName</code> to retain lexical
- * information <strong><em>when present</em></strong> in an {@link
- * Source XML input source}. The prefix is
- * <strong><em>NOT</em></strong> used in {@link #equals(Object)
- * QName.equals(Object)} or to compute the {@link #hashCode()
- * QName.hashCode()}.  Equality and the hash code are defined using
- * <strong><em>only</em></strong> the Namespace URI and local part.</p>
- *
- * <p>If not specified, the Namespace URI is set to {@link
- * XMLConstants#NULL_NS_URI XMLConstants.NULL_NS_URI}.
- * If not specified, the prefix is set to {@link
- * XMLConstants#DEFAULT_NS_PREFIX
- * XMLConstants.DEFAULT_NS_PREFIX}.</p>
- *
- * <p><code>QName</code> is immutable.</p>
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @version $Revision: 1.8 $, $Date: 2010/03/18 03:06:17 $
- * @see <a href="http://www.w3.org/TR/xmlschema-2/#QName">
- *   XML Schema Part2: Datatypes specification</a>
- * @see <a href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">
- *   Namespaces in XML</a>
- * @see <a href="http://www.w3.org/XML/xml-names-19990114-errata">
- *   Namespaces in XML Errata</a>
- * @since 1.5
- */
-
-public class QName implements Serializable {
-
-    /**
-     * <p>Stream Unique Identifier.</p>
-     *
-     * <p>Due to a historical defect, QName was released with multiple
-     * serialVersionUID values even though its serialization was the
-     * same.</p>
-     *
-     * <p>To workaround this issue, serialVersionUID is set with either
-     * a default value or a compatibility value.  To use the
-     * compatiblity value, set the system property:</p>
-     *
-     * <code>com.sun.xml.namespace.QName.useCompatibleSerialVersionUID=1.0</code>
-     *
-     * <p>This workaround was inspired by classes in the javax.management
-     * package, e.g. ObjectName, etc.
-     * See CR6267224 for original defect report.</p>
-     */
-    private static final long serialVersionUID;
-    /**
-     * <p>Default <code>serialVersionUID</code> value.</p>
-     */
-    private static final long defaultSerialVersionUID = -9120448754896609940L;
-    /**
-     * <p>Compatibility <code>serialVersionUID</code> value.</p>
-     */
-    private static final long compatibleSerialVersionUID = 4418622981026545151L;
-    /**
-     * <p>Flag to use default or campatible serialVersionUID.</p>
-     */
-    private static boolean useDefaultSerialVersionUID = true;
-    static {
-        try {
-            // use a privileged block as reading a system property
-            String valueUseCompatibleSerialVersionUID = (String) AccessController.doPrivileged(
-                    new PrivilegedAction() {
-                        public Object run() {
-                            return System.getProperty("com.sun.xml.namespace.QName.useCompatibleSerialVersionUID");
-                        }
-                    }
-            );
-            useDefaultSerialVersionUID = (valueUseCompatibleSerialVersionUID != null && valueUseCompatibleSerialVersionUID.equals("1.0")) ? false : true;
-        } catch (Exception exception) {
-            // use default if any Exceptions
-            useDefaultSerialVersionUID = true;
-        }
-
-        // set serialVersionUID to desired value
-        if (useDefaultSerialVersionUID) {
-            serialVersionUID = defaultSerialVersionUID;
-        } else {
-            serialVersionUID = compatibleSerialVersionUID;
-        }
-    }
-
-    /**
-     * <p>Namespace URI of this <code>QName</code>.</p>
-     */
-    private final String namespaceURI;
-
-    /**
-     * <p>local part of this <code>QName</code>.</p>
-     */
-    private final String localPart;
-
-    /**
-     * <p>prefix of this <code>QName</code>.</p>
-     */
-    private final String prefix;
-
-    /**
-     * <p><code>QName</code> constructor specifying the Namespace URI
-     * and local part.</p>
-     *
-     * <p>If the Namespace URI is <code>null</code>, it is set to
-     * {@link XMLConstants#NULL_NS_URI
-     * XMLConstants.NULL_NS_URI}.  This value represents no
-     * explicitly defined Namespace as defined by the <a
-     * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">Namespaces
-     * in XML</a> specification.  This action preserves compatible
-     * behavior with QName 1.0.  Explicitly providing the {@link
-     * XMLConstants#NULL_NS_URI
-     * XMLConstants.NULL_NS_URI} value is the preferred coding
-     * style.</p>
-     *
-     * <p>If the local part is <code>null</code> an
-     * <code>IllegalArgumentException</code> is thrown.
-     * A local part of "" is allowed to preserve
-     * compatible behavior with QName 1.0. </p>
-     *
-     * <p>When using this constructor, the prefix is set to {@link
-     * XMLConstants#DEFAULT_NS_PREFIX
-     * XMLConstants.DEFAULT_NS_PREFIX}.</p>
-     *
-     * <p>The Namespace URI is not validated as a
-     * <a href="http://www.ietf.org/rfc/rfc2396.txt">URI reference</a>.
-     * The local part is not validated as a
-     * <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a>
-     * as specified in <a href="http://www.w3.org/TR/REC-xml-names/">Namespaces
-     * in XML</a>.</p>
-     *
-     * @param namespaceURI Namespace URI of the <code>QName</code>
-     * @param localPart    local part of the <code>QName</code>
-     *
-     * @throws IllegalArgumentException When <code>localPart</code> is
-     *   <code>null</code>
-     *
-     * @see #QName(String namespaceURI, String localPart, String
-     * prefix) QName(String namespaceURI, String localPart, String
-     * prefix)
-     */
-    public QName(final String namespaceURI, final String localPart) {
-        this(namespaceURI, localPart, XMLConstants.DEFAULT_NS_PREFIX);
-    }
-
-    /**
-     * <p><code>QName</code> constructor specifying the Namespace URI,
-     * local part and prefix.</p>
-     *
-     * <p>If the Namespace URI is <code>null</code>, it is set to
-     * {@link XMLConstants#NULL_NS_URI
-     * XMLConstants.NULL_NS_URI}.  This value represents no
-     * explicitly defined Namespace as defined by the <a
-     * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">Namespaces
-     * in XML</a> specification.  This action preserves compatible
-     * behavior with QName 1.0.  Explicitly providing the {@link
-     * XMLConstants#NULL_NS_URI
-     * XMLConstants.NULL_NS_URI} value is the preferred coding
-     * style.</p>
-     *
-     * <p>If the local part is <code>null</code> an
-     * <code>IllegalArgumentException</code> is thrown.
-     * A local part of "" is allowed to preserve
-     * compatible behavior with QName 1.0. </p>
-     *
-     * <p>If the prefix is <code>null</code>, an
-     * <code>IllegalArgumentException</code> is thrown.  Use {@link
-     * XMLConstants#DEFAULT_NS_PREFIX
-     * XMLConstants.DEFAULT_NS_PREFIX} to explicitly indicate that no
-     * prefix is present or the prefix is not relevant.</p>
-     *
-     * <p>The Namespace URI is not validated as a
-     * <a href="http://www.ietf.org/rfc/rfc2396.txt">URI reference</a>.
-     * The local part and prefix are not validated as a
-     * <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a>
-     * as specified in <a href="http://www.w3.org/TR/REC-xml-names/">Namespaces
-     * in XML</a>.</p>
-     *
-     * @param namespaceURI Namespace URI of the <code>QName</code>
-     * @param localPart    local part of the <code>QName</code>
-     * @param prefix       prefix of the <code>QName</code>
-     *
-     * @throws IllegalArgumentException When <code>localPart</code>
-     *   or <code>prefix</code> is <code>null</code>
-     */
-    public QName(String namespaceURI, String localPart, String prefix) {
-
-        // map null Namespace URI to default
-        // to preserve compatibility with QName 1.0
-        if (namespaceURI == null) {
-            this.namespaceURI = XMLConstants.NULL_NS_URI;
-        } else {
-            this.namespaceURI = namespaceURI;
-        }
-
-        // local part is required.
-        // "" is allowed to preserve compatibility with QName 1.0
-        if (localPart == null) {
-            throw new IllegalArgumentException(
-                    "local part cannot be \"null\" when creating a QName");
-        }
-        this.localPart = localPart;
-
-        // prefix is required
-        if (prefix == null) {
-            throw new IllegalArgumentException(
-                    "prefix cannot be \"null\" when creating a QName");
-        }
-        this.prefix = prefix;
-    }
-
-    /**
-     * <p><code>QName</code> constructor specifying the local part.</p>
-     *
-     * <p>If the local part is <code>null</code> an
-     * <code>IllegalArgumentException</code> is thrown.
-     * A local part of "" is allowed to preserve
-     * compatible behavior with QName 1.0. </p>
-     *
-     * <p>When using this constructor, the Namespace URI is set to
-     * {@link XMLConstants#NULL_NS_URI
-     * XMLConstants.NULL_NS_URI} and the prefix is set to {@link
-     * XMLConstants#DEFAULT_NS_PREFIX
-     * XMLConstants.DEFAULT_NS_PREFIX}.</p>
-     *
-     * <p><em>In an XML context, all Element and Attribute names exist
-     * in the context of a Namespace.  Making this explicit during the
-     * construction of a <code>QName</code> helps prevent hard to
-     * diagnosis XML validity errors.  The constructors {@link
-     * #QName(String namespaceURI, String localPart) QName(String
-     * namespaceURI, String localPart)} and
-     * {@link #QName(String namespaceURI, String localPart, String prefix)}
-     * are preferred.</em></p>
-     *
-     * <p>The local part is not validated as a
-     * <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a>
-     * as specified in <a href="http://www.w3.org/TR/REC-xml-names/">Namespaces
-     * in XML</a>.</p>
-     *
-     * @param localPart local part of the <code>QName</code>
-     *
-     * @throws IllegalArgumentException When <code>localPart</code> is
-     *   <code>null</code>
-     *
-     * @see #QName(String namespaceURI, String localPart) QName(String
-     * namespaceURI, String localPart)
-     * @see #QName(String namespaceURI, String localPart, String
-     * prefix) QName(String namespaceURI, String localPart, String
-     * prefix)
-     */
-    public QName(String localPart) {
-        this(
-            XMLConstants.NULL_NS_URI,
-            localPart,
-            XMLConstants.DEFAULT_NS_PREFIX);
-    }
-
-    /**
-     * <p>Get the Namespace URI of this <code>QName</code>.</p>
-     *
-     * @return Namespace URI of this <code>QName</code>
-     */
-    public String getNamespaceURI() {
-        return namespaceURI;
-    }
-
-    /**
-     * <p>Get the local part of this <code>QName</code>.</p>
-     *
-     *  @return local part of this <code>QName</code>
-     */
-    public String getLocalPart() {
-        return localPart;
-    }
-
-    /**
-     * <p>Get the prefix of this <code>QName</code>.</p>
-     *
-     * <p>The prefix assigned to a <code>QName</code> might
-     * <strong><em>NOT</em></strong> be valid in a different
-     * context. For example, a <code>QName</code> may be assigned a
-     * prefix in the context of parsing a document but that prefix may
-     * be invalid in the context of a different document.</p>
-     *
-     *  @return prefix of this <code>QName</code>
-     */
-    public String getPrefix() {
-        return prefix;
-    }
-
-    /**
-     * <p>Test this <code>QName</code> for equality with another
-     * <code>Object</code>.</p>
-     *
-     * <p>If the <code>Object</code> to be tested is not a
-     * <code>QName</code> or is <code>null</code>, then this method
-     * returns <code>false</code>.</p>
-     *
-     * <p>Two <code>QName</code>s are considered equal if and only if
-     * both the Namespace URI and local part are equal. This method
-     * uses <code>String.equals()</code> to check equality of the
-     * Namespace URI and local part. The prefix is
-     * <strong><em>NOT</em></strong> used to determine equality.</p>
-     *
-     * <p>This method satisfies the general contract of {@link
-     * java.lang.Object#equals(Object) Object.equals(Object)}</p>
-     *
-     * @param objectToTest the <code>Object</code> to test for
-     * equality with this <code>QName</code>
-     * @return <code>true</code> if the given <code>Object</code> is
-     * equal to this <code>QName</code> else <code>false</code>
-     */
-    public final boolean equals(Object objectToTest) {
-        if (objectToTest == this) {
-            return true;
-        }
-
-        if (objectToTest == null || !(objectToTest instanceof QName)) {
-            return false;
-        }
-
-        QName qName = (QName) objectToTest;
-
-        return localPart.equals(qName.localPart)
-            && namespaceURI.equals(qName.namespaceURI);
-    }
-
-    /**
-     * <p>Generate the hash code for this <code>QName</code>.</p>
-     *
-     * <p>The hash code is calculated using both the Namespace URI and
-     * the local part of the <code>QName</code>.  The prefix is
-     * <strong><em>NOT</em></strong> used to calculate the hash
-     * code.</p>
-     *
-     * <p>This method satisfies the general contract of {@link
-     * java.lang.Object#hashCode() Object.hashCode()}.</p>
-     *
-     * @return hash code for this <code>QName</code> <code>Object</code>
-     */
-    public final int hashCode() {
-        return namespaceURI.hashCode() ^ localPart.hashCode();
-    }
-
-    /**
-     * <p><code>String</code> representation of this
-     * <code>QName</code>.</p>
-     *
-     * <p>The commonly accepted way of representing a <code>QName</code>
-     * as a <code>String</code> was
-     * <a href="http://jclark.com/xml/xmlns.htm">defined</a>
-     * by James Clark.  Although this is not a <em>standard</em>
-     * specification, it is in common use, e.g. {@link
-     * Transformer#setParameter(String name, Object value)}.
-     * This implementation represents a <code>QName</code> as:
-     * "{" + Namespace URI + "}" + local part.  If the Namespace URI
-     * <code>.equals(XMLConstants.NULL_NS_URI)</code>, only the
-     * local part is returned.  An appropriate use of this method is
-     * for debugging or logging for human consumption.</p>
-     *
-     * <p>Note the prefix value is <strong><em>NOT</em></strong>
-     * returned as part of the <code>String</code> representation.</p>
-     *
-     * <p>This method satisfies the general contract of {@link
-     * java.lang.Object#toString() Object.toString()}.</p>
-     *
-     *  @return <code>String</code> representation of this <code>QName</code>
-     */
-    public String toString() {
-        if (namespaceURI.equals(XMLConstants.NULL_NS_URI)) {
-            return localPart;
-        } else {
-            return "{" + namespaceURI + "}" + localPart;
-        }
-    }
-
-    /**
-     * <p><code>QName</code> derived from parsing the formatted
-     * <code>String</code>.</p>
-     *
-     * <p>If the <code>String</code> is <code>null</code> or does not conform to
-     * {@link #toString() QName.toString()} formatting, an
-     * <code>IllegalArgumentException</code> is thrown.</p>
-     *
-     * <p><em>The <code>String</code> <strong>MUST</strong> be in the
-     * form returned by {@link #toString() QName.toString()}.</em></p>
-     *
-     * <p>The commonly accepted way of representing a <code>QName</code>
-     * as a <code>String</code> was
-     * <a href="http://jclark.com/xml/xmlns.htm">defined</a>
-     * by James Clark.  Although this is not a <em>standard</em>
-     * specification, it is in common use, e.g. {@link
-     * Transformer#setParameter(String name, Object value)}.
-     * This implementation parses a <code>String</code> formatted
-     * as: "{" + Namespace URI + "}" + local part.  If the Namespace
-     * URI <code>.equals(XMLConstants.NULL_NS_URI)</code>, only the
-     * local part should be provided.</p>
-     *
-     * <p>The prefix value <strong><em>CANNOT</em></strong> be
-     * represented in the <code>String</code> and will be set to
-     * {@link XMLConstants#DEFAULT_NS_PREFIX
-     * XMLConstants.DEFAULT_NS_PREFIX}.</p>
-     *
-     * <p>This method does not do full validation of the resulting
-     * <code>QName</code>.
-     * <p>The Namespace URI is not validated as a
-     * <a href="http://www.ietf.org/rfc/rfc2396.txt">URI reference</a>.
-     * The local part is not validated as a
-     * <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a>
-     * as specified in
-     * <a href="http://www.w3.org/TR/REC-xml-names/">Namespaces in XML</a>.</p>
-     *
-     * @param qNameAsString <code>String</code> representation
-     * of the <code>QName</code>
-     *
-     * @throws IllegalArgumentException When <code>qNameAsString</code> is
-     *   <code>null</code> or malformed
-     *
-     * @return <code>QName</code> corresponding to the given <code>String</code>
-     * @see #toString() QName.toString()
-     */
-    public static QName valueOf(String qNameAsString) {
-
-        // null is not valid
-        if (qNameAsString == null) {
-            throw new IllegalArgumentException(
-                    "cannot create QName from \"null\" or \"\" String");
-        }
-
-        // "" local part is valid to preserve compatible behavior with QName 1.0
-        if (qNameAsString.length() == 0) {
-            return new QName(
-                XMLConstants.NULL_NS_URI,
-                qNameAsString,
-                XMLConstants.DEFAULT_NS_PREFIX);
-        }
-
-        // local part only?
-        if (qNameAsString.charAt(0) != '{') {
-            return new QName(
-                XMLConstants.NULL_NS_URI,
-                qNameAsString,
-                XMLConstants.DEFAULT_NS_PREFIX);
-        }
-
-        // Namespace URI improperly specified?
-        if (qNameAsString.startsWith("{" + XMLConstants.NULL_NS_URI + "}")) {
-            throw new IllegalArgumentException(
-                "Namespace URI .equals(XMLConstants.NULL_NS_URI), "
-                + ".equals(\"" + XMLConstants.NULL_NS_URI + "\"), "
-                + "only the local part, "
-                + "\""
-                + qNameAsString.substring(2 + XMLConstants.NULL_NS_URI.length())
-                + "\", "
-                + "should be provided.");
-        }
-
-        // Namespace URI and local part specified
-        int endOfNamespaceURI = qNameAsString.indexOf('}');
-        if (endOfNamespaceURI == -1) {
-            throw new IllegalArgumentException(
-                "cannot create QName from \""
-                    + qNameAsString
-                    + "\", missing closing \"}\"");
-        }
-        return new QName(
-            qNameAsString.substring(1, endOfNamespaceURI),
-            qNameAsString.substring(endOfNamespaceURI + 1),
-            XMLConstants.DEFAULT_NS_PREFIX);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/namespace/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/namespace/package.html b/Build/src/main/java/org/openjdk/javax/xml/namespace/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/namespace/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,54 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>javax.xml.namespace</title>
-
-  <meta name="CVS"
-        content="$Id: package.html,v 1.2 2005/06/10 03:50:28 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-
-<body>
-
-<p>XML Namespace processing.</p>
-
-<p>The following XML standards apply:</p>
-<ul>
-  <li><a href="http://www.w3.org/TR/xmlschema-2/#QName">XML Schema Part2: Datatypes specification</a></li>
-  <li><a href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">Namespaces in XML</a></li>
-  <li><a href="http://www.w3.org/XML/xml-names-19990114-errata">Namespaces in XML Errata</a></li>
-</ul>
-
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/namespace/NamespaceContext.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/namespace/NamespaceContext.java b/Build/src/main/java/org/openjdk/javax/xml/namespace/NamespaceContext.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/namespace/NamespaceContext.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,290 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.namespace;
-
-import javax.xml.XMLConstants;
-
-import java.util.Iterator;
-
-/**
- * <p>Interface for read only XML Namespace context processing.</p>
- *
- * <p>An XML Namespace has the properties:</p>
- * <ul>
- *   <li>Namespace URI:
- *       Namespace name expressed as a URI to which the prefix is bound</li>
- *   <li>prefix: syntactically, this is the part of the attribute name
- *       following the <code>XMLConstants.XMLNS_ATTRIBUTE</code>
- *       ("xmlns") in the Namespace declaration</li>
- * </ul>
- * <p>example:
- * <code>&lt;element xmlns:prefix="http://Namespace-name-URI"&gt;</code></p>
- *
- * <p>All <code>get*(*)</code> methods operate in the current scope
- * for Namespace URI and prefix resolution.</p>
- *
- * <p>Note that a Namespace URI can be bound to
- * <strong>multiple</strong> prefixes in the current scope.  This can
- * occur when multiple <code>XMLConstants.XMLNS_ATTRIBUTE</code>
- * ("xmlns") Namespace declarations occur in the same Start-Tag and
- * refer to the same Namespace URI. e.g.<br />
- * <pre>
- * &lt;element xmlns:prefix1="http://Namespace-name-URI"
- *          xmlns:prefix2="http://Namespace-name-URI"&gt;
- * </pre>
- * This can also occur when the same Namespace URI is used in multiple
- * <code>XMLConstants.XMLNS_ATTRIBUTE</code> ("xmlns") Namespace
- * declarations in the logical parent element hierarchy.  e.g.<br />
- * <pre>
- * &lt;parent xmlns:prefix1="http://Namespace-name-URI">
- *   &lt;child xmlns:prefix2="http://Namespace-name-URI"&gt;
- *     ...
- *   &lt;/child&gt;
- * &lt;/parent&gt;
- * </pre></p>
- *
- * <p>A prefix can only be bound to a <strong>single</strong>
- * Namespace URI in the current scope.</p>
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @see XMLConstants
- *   javax.xml.XMLConstants for declarations of common XML values
- * @see <a href="http://www.w3.org/TR/xmlschema-2/#QName">
- *   XML Schema Part2: Datatypes</a>
- * @see <a href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">
- *   Namespaces in XML</a>
- * @see <a href="http://www.w3.org/XML/xml-names-19990114-errata">
- *   Namespaces in XML Errata</a>
- * @since 1.5
- */
-
-public interface NamespaceContext {
-
-    /**
-     * <p>Get Namespace URI bound to a prefix in the current scope.</p>
-     *
-     * <p>When requesting a Namespace URI by prefix, the following
-     * table describes the returned Namespace URI value for all
-     * possible prefix values:</p>
-     *
-     * <table border="2" rules="all" cellpadding="4">
-     *   <thead>
-     *     <tr>
-     *       <td align="center" colspan="2">
-     *         <code>getNamespaceURI(prefix)</code>
-     *         return value for specified prefixes
-     *       </td>
-     *     </tr>
-     *     <tr>
-     *       <td>prefix parameter</td>
-     *       <td>Namespace URI return value</td>
-     *     </tr>
-     *   </thead>
-     *   <tbody>
-     *     <tr>
-     *       <td><code>DEFAULT_NS_PREFIX</code> ("")</td>
-     *       <td>default Namespace URI in the current scope or
-     *         <code>{@link
-     *         XMLConstants#NULL_NS_URI XMLConstants.NULL_NS_URI("")}
-     *         </code>
-     *         when there is no default Namespace URI in the current scope</td>
-     *     </tr>
-     *     <tr>
-     *       <td>bound prefix</td>
-     *       <td>Namespace URI bound to prefix in current scope</td>
-     *     </tr>
-     *     <tr>
-     *       <td>unbound prefix</td>
-     *       <td>
-     *         <code>{@link
-     *         XMLConstants#NULL_NS_URI XMLConstants.NULL_NS_URI("")}
-     *         </code>
-     *       </td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>XMLConstants.XML_NS_PREFIX</code> ("xml")</td>
-     *       <td><code>XMLConstants.XML_NS_URI</code>
-     *           ("http://www.w3.org/XML/1998/namespace")</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>XMLConstants.XMLNS_ATTRIBUTE</code> ("xmlns")</td>
-     *       <td><code>XMLConstants.XMLNS_ATTRIBUTE_NS_URI</code>
-     *         ("http://www.w3.org/2000/xmlns/")</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>null</code></td>
-     *       <td><code>IllegalArgumentException</code> is thrown</td>
-     *     </tr>
-     *    </tbody>
-     * </table>
-     *
-     * @param prefix prefix to look up
-     *
-     * @return Namespace URI bound to prefix in the current scope
-     *
-     * @throws IllegalArgumentException When <code>prefix</code> is
-     *   <code>null</code>
-     */
-    String getNamespaceURI(String prefix);
-
-    /**
-     * <p>Get prefix bound to Namespace URI in the current scope.</p>
-     *
-     * <p>To get all prefixes bound to a Namespace URI in the current
-     * scope, use {@link #getPrefixes(String namespaceURI)}.</p>
-     *
-     * <p>When requesting a prefix by Namespace URI, the following
-     * table describes the returned prefix value for all Namespace URI
-     * values:</p>
-     *
-     * <table border="2" rules="all" cellpadding="4">
-     *   <thead>
-     *     <tr>
-     *       <th align="center" colspan="2">
-     *         <code>getPrefix(namespaceURI)</code> return value for
-     *         specified Namespace URIs
-     *       </th>
-     *     </tr>
-     *     <tr>
-     *       <th>Namespace URI parameter</th>
-     *       <th>prefix value returned</th>
-     *     </tr>
-     *   </thead>
-     *   <tbody>
-     *     <tr>
-     *       <td>&lt;default Namespace URI&gt;</td>
-     *       <td><code>XMLConstants.DEFAULT_NS_PREFIX</code> ("")
-     *       </td>
-     *     </tr>
-     *     <tr>
-     *       <td>bound Namespace URI</td>
-     *       <td>prefix bound to Namespace URI in the current scope,
-     *           if multiple prefixes are bound to the Namespace URI in
-     *           the current scope, a single arbitrary prefix, whose
-     *           choice is implementation dependent, is returned</td>
-     *     </tr>
-     *     <tr>
-     *       <td>unbound Namespace URI</td>
-     *       <td><code>null</code></td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>XMLConstants.XML_NS_URI</code>
-     *           ("http://www.w3.org/XML/1998/namespace")</td>
-     *       <td><code>XMLConstants.XML_NS_PREFIX</code> ("xml")</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>XMLConstants.XMLNS_ATTRIBUTE_NS_URI</code>
-     *           ("http://www.w3.org/2000/xmlns/")</td>
-     *       <td><code>XMLConstants.XMLNS_ATTRIBUTE</code> ("xmlns")</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>null</code></td>
-     *       <td><code>IllegalArgumentException</code> is thrown</td>
-     *     </tr>
-     *   </tbody>
-     * </table>
-     *
-     * @param namespaceURI URI of Namespace to lookup
-     *
-     * @return prefix bound to Namespace URI in current context
-     *
-     * @throws IllegalArgumentException When <code>namespaceURI</code> is
-     *   <code>null</code>
-     */
-    String getPrefix(String namespaceURI);
-
-    /**
-     * <p>Get all prefixes bound to a Namespace URI in the current
-     * scope.</p>
-     *
-     * <p>An Iterator over String elements is returned in an arbitrary,
-     * <strong>implementation dependent</strong>, order.</p>
-     *
-     * <p><strong>The <code>Iterator</code> is
-     * <em>not</em> modifiable.  e.g. the
-     * <code>remove()</code> method will throw
-     * <code>UnsupportedOperationException</code>.</strong></p>
-     *
-     * <p>When requesting prefixes by Namespace URI, the following
-     * table describes the returned prefixes value for all Namespace
-     * URI values:</p>
-     *
-     * <table border="2" rules="all" cellpadding="4">
-     *   <thead>
-     *     <tr>
-     *       <th align="center" colspan="2"><code>
-     *         getPrefixes(namespaceURI)</code> return value for
-     *         specified Namespace URIs</th>
-     *     </tr>
-     *     <tr>
-     *       <th>Namespace URI parameter</th>
-     *       <th>prefixes value returned</th>
-     *     </tr>
-     *   </thead>
-     *   <tbody>
-     *     <tr>
-     *       <td>bound Namespace URI,
-     *         including the &lt;default Namespace URI&gt;</td>
-     *       <td>
-     *         <code>Iterator</code> over prefixes bound to Namespace URI in
-     *         the current scope in an arbitrary,
-     *         <strong>implementation dependent</strong>,
-     *         order
-     *       </td>
-     *     </tr>
-     *     <tr>
-     *       <td>unbound Namespace URI</td>
-     *       <td>empty <code>Iterator</code></td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>XMLConstants.XML_NS_URI</code>
-     *           ("http://www.w3.org/XML/1998/namespace")</td>
-     *       <td><code>Iterator</code> with one element set to
-     *         <code>XMLConstants.XML_NS_PREFIX</code> ("xml")</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>XMLConstants.XMLNS_ATTRIBUTE_NS_URI</code>
-     *           ("http://www.w3.org/2000/xmlns/")</td>
-     *       <td><code>Iterator</code> with one element set to
-     *         <code>XMLConstants.XMLNS_ATTRIBUTE</code> ("xmlns")</td>
-     *     </tr>
-     *     <tr>
-     *       <td><code>null</code></td>
-     *       <td><code>IllegalArgumentException</code> is thrown</td>
-     *     </tr>
-     *   </tbody>
-     * </table>
-     *
-     * @param namespaceURI URI of Namespace to lookup
-     *
-     * @return <code>Iterator</code> for all prefixes bound to the
-     *   Namespace URI in the current scope
-     *
-     * @throws IllegalArgumentException When <code>namespaceURI</code> is
-     *   <code>null</code>
-     */
-    Iterator getPrefixes(String namespaceURI);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/dom/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/package.html b/Build/src/main/java/org/openjdk/javax/xml/transform/dom/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,70 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>javax.xml.transform.dom</title>
-
-  <meta name="CVS"
-        content="$Id: package.html,v 1.2 2005/06/10 03:50:40 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-<body>
-<p>This package implements DOM-specific transformation APIs.</p>
-<p>The {@link javax.xml.transform.dom.DOMSource} class allows the
-client of the implementation of this API to specify a DOM
-{@link org.w3c.dom.Node} as the source of the input tree. The model of
-how the Transformer deals with the DOM tree in terms of mismatches with the
-<A href="http://www.w3.org/TR/xslt#data-model">XSLT data model</A> or
-other data models is beyond the scope of this document. Any of the nodes
-derived from {@link org.w3c.dom.Node} are legal input.</p>
-<p>The {@link javax.xml.transform.dom.DOMResult} class allows
-a {@link org.w3c.dom.Node} to be specified to which result DOM nodes will
-be appended. If an output node is not specified, the transformer will use
-{@link javax.xml.parsers.DocumentBuilder#newDocument} to create an
-output {@link org.w3c.dom.Document} node. If a node is specified, it
-should be one of the following: {@link org.w3c.dom.Document},
-{@link org.w3c.dom.Element}, or
-{@link org.w3c.dom.DocumentFragment}. Specification of any other node
-type is implementation dependent and undefined by this API. If the result is a
-{@link org.w3c.dom.Document}, the output of the transformation must have
-a single element root to set as the document element.</p>
-<p>The {@link javax.xml.transform.dom.DOMLocator} node may be passed
-to {@link javax.xml.transform.TransformerException} objects, and
-retrieved by trying to cast the result of the
-{@link javax.xml.transform.TransformerException#getLocator()} method.
-The implementation has no responsibility to use a DOMLocator instead of a
-{@link javax.xml.transform.SourceLocator} (though line numbers and the
-like do not make much sense for a DOM), so the result of getLocator must always
-be tested with an instanceof. </p>
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMResult.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMResult.java b/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMResult.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMResult.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,363 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.dom;
-
-import javax.xml.transform.Result;
-import javax.xml.transform.TransformerFactory;
-import org.w3c.dom.Node;
-
-/**
- * <p>Acts as a holder for a transformation result tree in the form of a Document Object Model (DOM) tree.</p>
- *
- * <p>If no output DOM source is set, the transformation will create a Document node as the holder for the result of the transformation,
- * which may be retrieved with {@link #getNode()}.</p>
- *
- * @author <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public class DOMResult implements Result {
-
-    /** <p>If {@link TransformerFactory#getFeature}
-     * returns <code>true</code> when passed this value as an argument,
-     * the <code>Transformer</code> supports <code>Result</code> output of this type.</p>
-     */
-    public static final String FEATURE = "http://javax.xml.transform.dom.DOMResult/feature";
-
-    /**
-     * <p>Zero-argument default constructor.</p>
-     *
-     * <p><code>node</code>,
-     * <code>siblingNode</code> and
-     * <code>systemId</code>
-     * will be set to <code>null</code>.</p>
-     */
-    public DOMResult() {
-        setNode(null);
-        setNextSibling(null);
-        setSystemId(null);
-    }
-
-    /**
-     * <p>Use a DOM node to create a new output target.</p>
-     *
-     * <p>In practice, the node should be
-     * a {@link org.w3c.dom.Document} node,
-     * a {@link org.w3c.dom.DocumentFragment} node, or
-     * a {@link org.w3c.dom.Element} node.
-     * In other words, a node that accepts children.</p>
-     *
-     * <p><code>siblingNode</code> and
-     * <code>systemId</code>
-     * will be set to <code>null</code>.</p>
-     *
-     * @param node The DOM node that will contain the result tree.
-     */
-    public DOMResult(Node node) {
-        setNode(node);
-        setNextSibling(null);
-        setSystemId(null);
-    }
-
-    /**
-     * <p>Use a DOM node to create a new output target with the specified System ID.<p>
-     *
-     * <p>In practice, the node should be
-     * a {@link org.w3c.dom.Document} node,
-     * a {@link org.w3c.dom.DocumentFragment} node, or
-     * a {@link org.w3c.dom.Element} node.
-     * In other words, a node that accepts children.</p>
-     *
-     * <p><code>siblingNode</code> will be set to <code>null</code>.</p>
-     *
-     * @param node The DOM node that will contain the result tree.
-     * @param systemId The system identifier which may be used in association with this node.
-     */
-    public DOMResult(Node node, String systemId) {
-        setNode(node);
-        setNextSibling(null);
-        setSystemId(systemId);
-    }
-
-    /**
-     * <p>Use a DOM node to create a new output target specifying the child node where the result nodes should be inserted before.</p>
-     *
-     * <p>In practice, <code>node</code> and <code>nextSibling</code> should be
-     * a {@link org.w3c.dom.Document} node,
-     * a {@link org.w3c.dom.DocumentFragment} node, or
-     * a {@link org.w3c.dom.Element} node.
-     * In other words, a node that accepts children.</p>
-     *
-     * <p>Use <code>nextSibling</code> to specify the child node
-     * where the result nodes should be inserted before.
-     * If <code>nextSibling</code> is not a sibling of <code>node</code>,
-     * then an <code>IllegalArgumentException</code> is thrown.
-     * If <code>node</code> is <code>null</code> and <code>nextSibling</code> is not <code>null</code>,
-     * then an <code>IllegalArgumentException</code> is thrown.
-     * If <code>nextSibling</code> is <code>null</code>,
-     * then the behavior is the same as calling {@link #DOMResult(Node node)},
-     * i.e. append the result nodes as the last child of the specified <code>node</code>.</p>
-     *
-     * <p><code>systemId</code> will be set to <code>null</code>.</p>
-     *
-     * @param node The DOM node that will contain the result tree.
-     * @param nextSibling The child node where the result nodes should be inserted before.
-     *
-     * @throws IllegalArgumentException If <code>nextSibling</code> is not a sibling of <code>node</code> or
-     *   <code>node</code> is <code>null</code> and <code>nextSibling</code>
-     *   is not <code>null</code>.
-     *
-     * @since 1.5
-     */
-    public DOMResult(Node node, Node nextSibling) {
-
-        // does the corrent parent/child relationship exist?
-        if (nextSibling != null) {
-            // cannot be a sibling of a null node
-            if (node == null) {
-                throw new IllegalArgumentException("Cannot create a DOMResult when the nextSibling is contained by the \"null\" node.");
-            }
-
-            // nextSibling contained by node?
-            if ((node.compareDocumentPosition(nextSibling)&Node.DOCUMENT_POSITION_CONTAINED_BY)==0) {
-                throw new IllegalArgumentException("Cannot create a DOMResult when the nextSibling is not contained by the node.");
-            }
-        }
-
-        setNode(node);
-        setNextSibling(nextSibling);
-        setSystemId(null);
-    }
-
-    /**
-     * <p>Use a DOM node to create a new output target specifying the child node where the result nodes should be inserted before and
-     * the specified System ID.</p>
-     *
-     * <p>In practice, <code>node</code> and <code>nextSibling</code> should be
-     * a {@link org.w3c.dom.Document} node,
-     * a {@link org.w3c.dom.DocumentFragment} node, or a
-     * {@link org.w3c.dom.Element} node.
-     * In other words, a node that accepts children.</p>
-     *
-     * <p>Use <code>nextSibling</code> to specify the child node
-     * where the result nodes should be inserted before.
-     * If <code>nextSibling</code> is not a sibling of <code>node</code>,
-     * then an <code>IllegalArgumentException</code> is thrown.
-     * If <code>node</code> is <code>null</code> and <code>nextSibling</code> is not <code>null</code>,
-     * then an <code>IllegalArgumentException</code> is thrown.
-     * If <code>nextSibling</code> is <code>null</code>,
-     * then the behavior is the same as calling {@link #DOMResult(Node node, String systemId)},
-     * i.e. append the result nodes as the last child of the specified node and use the specified System ID.</p>
-     *
-     * @param node The DOM node that will contain the result tree.
-     * @param nextSibling The child node where the result nodes should be inserted before.
-     * @param systemId The system identifier which may be used in association with this node.
-     *
-     * @throws IllegalArgumentException If <code>nextSibling</code> is not a
-     *   sibling of <code>node</code> or
-     *   <code>node</code> is <code>null</code> and <code>nextSibling</code>
-     *   is not <code>null</code>.
-     *
-     * @since 1.5
-     */
-    public DOMResult(Node node, Node nextSibling, String systemId) {
-
-        // does the corrent parent/child relationship exist?
-        if (nextSibling != null) {
-            // cannot be a sibling of a null node
-            if (node == null) {
-                throw new IllegalArgumentException("Cannot create a DOMResult when the nextSibling is contained by the \"null\" node.");
-            }
-
-            // nextSibling contained by node?
-            if ((node.compareDocumentPosition(nextSibling)&Node.DOCUMENT_POSITION_CONTAINED_BY)==0) {
-                throw new IllegalArgumentException("Cannot create a DOMResult when the nextSibling is not contained by the node.");
-            }
-        }
-
-        setNode(node);
-        setNextSibling(nextSibling);
-        setSystemId(systemId);
-    }
-
-    /**
-     * <p>Set the node that will contain the result DOM tree.<p>
-     *
-     * <p>In practice, the node should be
-     * a {@link org.w3c.dom.Document} node,
-     * a {@link org.w3c.dom.DocumentFragment} node, or
-     * a {@link org.w3c.dom.Element} node.
-     * In other words, a node that accepts children.</p>
-     *
-     * <p>An <code>IllegalStateException</code> is thrown if
-     * <code>nextSibling</code> is not <code>null</code> and
-     * <code>node</code> is not a parent of <code>nextSibling</code>.
-     * An <code>IllegalStateException</code> is thrown if <code>node</code> is <code>null</code> and
-     * <code>nextSibling</code> is not <code>null</code>.</p>
-     *
-     * @param node The node to which the transformation will be appended.
-     *
-     * @throws IllegalStateException If <code>nextSibling</code> is not
-     *   <code>null</code> and
-     *   <code>nextSibling</code> is not a child of <code>node</code> or
-     *   <code>node</code> is <code>null</code> and
-     *   <code>nextSibling</code> is not <code>null</code>.
-     */
-    public void setNode(Node node) {
-        // does the corrent parent/child relationship exist?
-        if (nextSibling != null) {
-            // cannot be a sibling of a null node
-            if (node == null) {
-                throw new IllegalStateException("Cannot create a DOMResult when the nextSibling is contained by the \"null\" node.");
-            }
-
-            // nextSibling contained by node?
-            if ((node.compareDocumentPosition(nextSibling)&Node.DOCUMENT_POSITION_CONTAINED_BY)==0) {
-                throw new IllegalArgumentException("Cannot create a DOMResult when the nextSibling is not contained by the node.");
-            }
-        }
-
-        this.node = node;
-    }
-
-    /**
-     * <p>Get the node that will contain the result DOM tree.</p>
-     *
-     * <p>If no node was set via
-     * {@link #DOMResult(Node node)},
-     * {@link #DOMResult(Node node, String systeId)},
-     * {@link #DOMResult(Node node, Node nextSibling)},
-     * {@link #DOMResult(Node node, Node nextSibling, String systemId)} or
-     * {@link #setNode(Node node)},
-     * then the node will be set by the transformation, and may be obtained from this method once the transformation is complete.
-     * Calling this method before the transformation will return <code>null</code>.</p>
-     *
-     * @return The node to which the transformation will be appended.
-     */
-    public Node getNode() {
-        return node;
-    }
-
-    /**
-     * <p>Set the child node before which the result nodes will be inserted.</p>
-     *
-     * <p>Use <code>nextSibling</code> to specify the child node
-     * before which the result nodes should be inserted.
-     * If <code>nextSibling</code> is not a descendant of <code>node</code>,
-     * then an <code>IllegalArgumentException</code> is thrown.
-     * If <code>node</code> is <code>null</code> and <code>nextSibling</code> is not <code>null</code>,
-     * then an <code>IllegalStateException</code> is thrown.
-     * If <code>nextSibling</code> is <code>null</code>,
-     * then the behavior is the same as calling {@link #DOMResult(Node node)},
-     * i.e. append the result nodes as the last child of the specified <code>node</code>.</p>
-     *
-     * @param nextSibling The child node before which the result nodes will be inserted.
-     *
-     * @throws IllegalArgumentException If <code>nextSibling</code> is not a
-     *   descendant of <code>node</code>.
-     * @throws IllegalStateException If <code>node</code> is <code>null</code>
-     *   and <code>nextSibling</code> is not <code>null</code>.
-     *
-     * @since 1.5
-     */
-    public void setNextSibling(Node nextSibling) {
-
-        // does the corrent parent/child relationship exist?
-        if (nextSibling != null) {
-            // cannot be a sibling of a null node
-            if (node == null) {
-                throw new IllegalStateException("Cannot create a DOMResult when the nextSibling is contained by the \"null\" node.");
-            }
-
-            // nextSibling contained by node?
-            if ((node.compareDocumentPosition(nextSibling)&Node.DOCUMENT_POSITION_CONTAINED_BY)==0) {
-                throw new IllegalArgumentException("Cannot create a DOMResult when the nextSibling is not contained by the node.");
-            }
-        }
-
-        this.nextSibling = nextSibling;
-    }
-
-    /**
-     * <p>Get the child node before which the result nodes will be inserted.</p>
-     *
-     * <p>If no node was set via
-     * {@link #DOMResult(Node node, Node nextSibling)},
-     * {@link #DOMResult(Node node, Node nextSibling, String systemId)} or
-     * {@link #setNextSibling(Node nextSibling)},
-     * then <code>null</code> will be returned.</p>
-     *
-     * @return The child node before which the result nodes will be inserted.
-     *
-     * @since 1.5
-     */
-    public Node getNextSibling() {
-        return nextSibling;
-    }
-
-    /**
-     * <p>Set the systemId that may be used in association with the node.</p>
-     *
-     * @param systemId The system identifier as a URI string.
-     */
-    public void setSystemId(String systemId) {
-        this.systemId = systemId;
-    }
-
-    /**
-     * <p>Get the System Identifier.</p>
-     *
-     * <p>If no System ID was set via
-     * {@link #DOMResult(Node node, String systemId)},
-     * {@link #DOMResult(Node node, Node nextSibling, String systemId)} or
-     * {@link #setSystemId(String systemId)},
-     * then <code>null</code> will be returned.</p>
-     *
-     * @return The system identifier.
-     */
-    public String getSystemId() {
-        return systemId;
-    }
-
-    //////////////////////////////////////////////////////////////////////
-    // Internal state.
-    //////////////////////////////////////////////////////////////////////
-
-    /**
-     * <p>The node to which the transformation will be appended.</p>
-     */
-    private Node node = null;
-
-    /**
-     * <p>The child node before which the result nodes will be inserted.</p>
-     *
-     * @since 1.5
-     */
-    private Node nextSibling = null;
-
-    /**
-     * <p>The System ID that may be used in association with the node.</p>
-     */
-    private String systemId = null;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMSource.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMSource.java b/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMSource.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMSource.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,141 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.dom;
-
-import javax.xml.transform.Source;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import org.w3c.dom.Node;
-
-/**
- * <p>Acts as a holder for a transformation Source tree in the
- * form of a Document Object Model (DOM) tree.</p>
- *
- * <p>Note that XSLT requires namespace support. Attempting to transform a DOM
- * that was not contructed with a namespace-aware parser may result in errors.
- * Parsers can be made namespace aware by calling
- * {@link DocumentBuilderFactory#setNamespaceAware(boolean awareness)}.</p>
- *
- * @author <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @see <a href="http://www.w3.org/TR/DOM-Level-2">Document Object Model (DOM) Level 2 Specification</a>
- */
-public class DOMSource implements Source {
-
-    /**
-     * <p><code>Node</code> to serve as DOM source.</p>
-     */
-    private Node node;
-
-    /**
-     * <p>The base ID (URL or system ID) from where URLs
-     * will be resolved.</p>
-     */
-    private String systemID;
-
-    /** If {@link TransformerFactory#getFeature}
-     * returns true when passed this value as an argument,
-     * the Transformer supports Source input of this type.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.dom.DOMSource/feature";
-
-    /**
-     * <p>Zero-argument default constructor.  If this constructor is used, and
-     * no DOM source is set using {@link #setNode(Node node)} , then the
-     * <code>Transformer</code> will
-     * create an empty source {@link org.w3c.dom.Document} using
-     * {@link DocumentBuilder#newDocument()}.</p>
-     *
-     * @see Transformer#transform(Source xmlSource, Result outputTarget)
-     */
-    public DOMSource() { }
-
-    /**
-     * Create a new input source with a DOM node.  The operation
-     * will be applied to the subtree rooted at this node.  In XSLT,
-     * a "/" pattern still means the root of the tree (not the subtree),
-     * and the evaluation of global variables and parameters is done
-     * from the root node also.
-     *
-     * @param n The DOM node that will contain the Source tree.
-     */
-    public DOMSource(Node n) {
-        setNode(n);
-    }
-
-    /**
-     * Create a new input source with a DOM node, and with the
-     * system ID also passed in as the base URI.
-     *
-     * @param node The DOM node that will contain the Source tree.
-     * @param systemID Specifies the base URI associated with node.
-     */
-    public DOMSource(Node node, String systemID) {
-        setNode(node);
-        setSystemId(systemID);
-    }
-
-    /**
-     * Set the node that will represents a Source DOM tree.
-     *
-     * @param node The node that is to be transformed.
-     */
-    public void setNode(Node node) {
-        this.node = node;
-    }
-
-    /**
-     * Get the node that represents a Source DOM tree.
-     *
-     * @return The node that is to be transformed.
-     */
-    public Node getNode() {
-        return node;
-    }
-
-    /**
-     * Set the base ID (URL or system ID) from where URLs
-     * will be resolved.
-     *
-     * @param systemID Base URL for this DOM tree.
-     */
-    public void setSystemId(String systemID) {
-        this.systemID = systemID;
-    }
-
-    /**
-     * Get the base ID (URL or system ID) from where URLs
-     * will be resolved.
-     *
-     * @return Base URL for this DOM tree.
-     */
-    public String getSystemId() {
-        return this.systemID;
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMLocator.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMLocator.java b/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMLocator.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/dom/DOMLocator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,50 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.dom;
-
-import javax.xml.transform.SourceLocator;
-
-import javax.xml.transform.Transformer;
-import org.w3c.dom.Node;
-
-
-/**
- * Indicates the position of a node in a source DOM, intended
- * primarily for error reporting.  To use a DOMLocator, the receiver of an
- * error must downcast the {@link SourceLocator}
- * object returned by an exception. A {@link Transformer}
- * may use this object for purposes other than error reporting, for instance,
- * to indicate the source node that originated a result node.
- */
-public interface DOMLocator extends SourceLocator {
-
-    /**
-     * Return the node where the event occurred.
-     *
-     * @return The node that is the location for the event.
-     */
-    public Node getOriginatingNode();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/sax/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/package.html b/Build/src/main/java/org/openjdk/javax/xml/transform/sax/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,104 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>javax.xml.transform.sax</title>
-
-  <meta name="CVS"
-        content="$Id: package.html,v 1.2 2005/06/10 03:50:41 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-
-<body>
-<p>This package implements SAX2-specific transformation APIs. It provides
-  classes which allow input from {@link org.xml.sax.ContentHandler}
-  events, and also classes that produce org.xml.sax.ContentHandler events. It
-  also provides methods to set the input source as an
-  {@link org.xml.sax.XMLReader}, or to use a
-  {@link org.xml.sax.InputSource} as the source. It also allows the
-  creation of a {@link org.xml.sax.XMLFilter}, which enables
-  transformations to "pull" from other transformations, and lets the transformer
-  to be used polymorphically as an {@link org.xml.sax.XMLReader}.</p>
-<p>The {@link javax.xml.transform.sax.SAXSource} class allows the
-  setting of an {@link org.xml.sax.XMLReader} to be used for "pulling"
-  parse events, and an {@link org.xml.sax.InputSource} that may be used to
-  specify the SAX source.</p>
-<p>The {@link javax.xml.transform.sax.SAXResult} class allows the
-  setting of a {@link org.xml.sax.ContentHandler} to be the receiver of
-  SAX2 events from the transformation. 
-<p>The {@link javax.xml.transform.sax.SAXTransformerFactory} extends
-  {@link javax.xml.transform.TransformerFactory} to provide factory
-  methods for creating {@link javax.xml.transform.sax.TemplatesHandler},
-  {@link javax.xml.transform.sax.TransformerHandler}, and
-  {@link org.xml.sax.XMLReader} instances.</p>
-<p>To obtain a {@link javax.xml.transform.sax.SAXTransformerFactory},
-  the caller must cast the {@link javax.xml.transform.TransformerFactory}
-  instance returned from
-  {@link javax.xml.transform.TransformerFactory#newInstance}.
-
-<p>The {@link javax.xml.transform.sax.TransformerHandler} interface
-  allows a transformation to be created from SAX2 parse events, which is a "push"
-  model rather than the "pull" model that normally occurs for a transformation.
-  Normal parse events are received through the
-  {@link org.xml.sax.ContentHandler} interface, lexical events such as
-  startCDATA and endCDATA are received through the
-  {@link org.xml.sax.ext.LexicalHandler} interface, and events that signal
-  the start or end of disabling output escaping are received via
-  {@link org.xml.sax.ContentHandler#processingInstruction}, with the
-  target parameter being
-  {@link javax.xml.transform.Result#PI_DISABLE_OUTPUT_ESCAPING} and
-  {@link javax.xml.transform.Result#PI_ENABLE_OUTPUT_ESCAPING}. If
-  parameters, output properties, or other features need to be set on the
-  Transformer handler, a {@link javax.xml.transform.Transformer} reference
-  will need to be obtained from
-  {@link javax.xml.transform.sax.TransformerHandler#getTransformer}, and
-  the methods invoked from that reference. 
-
-<p>The {@link javax.xml.transform.sax.TemplatesHandler} interface
-  allows the creation of {@link javax.xml.transform.Templates} objects
-  from SAX2 parse events. Once the {@link org.xml.sax.ContentHandler}
-  events are complete, the Templates object may be obtained from
-  {@link javax.xml.transform.sax.TemplatesHandler#getTemplates}. Note that
-  {@link javax.xml.transform.sax.TemplatesHandler#setSystemId} should
-  normally be called in order to establish a base system ID from which relative
-  URLs may be resolved. 
-<p>The
-  {@link javax.xml.transform.sax.SAXTransformerFactory#newXMLFilter}
-  method allows the creation of a {@link org.xml.sax.XMLFilter}, which
-  encapsulates the SAX2 notion of a "pull" transformation. The following
-  illustrates several transformations chained together. Each filter points to a
-  parent {@link org.xml.sax.XMLReader}, and the final transformation is
-  caused by invoking {@link org.xml.sax.XMLReader#parse} on the final
-  reader in the chain.</p>
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXResult.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXResult.java b/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXResult.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXResult.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,145 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.sax;
-
-import javax.xml.transform.Result;
-
-import javax.xml.transform.TransformerFactory;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.ext.LexicalHandler;
-
-/**
- * <p>Acts as an holder for a transformation Result.</p>
- *
- * @author <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public class SAXResult implements Result {
-
-    /**
-     * If {@link TransformerFactory#getFeature}
-     * returns true when passed this value as an argument,
-     * the Transformer supports Result output of this type.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.sax.SAXResult/feature";
-
-    /**
-     * Zero-argument default constructor.
-     */
-    public SAXResult() {
-    }
-
-    /**
-     * Create a SAXResult that targets a SAX2 {@link org.xml.sax.ContentHandler}.
-     *
-     * @param handler Must be a non-null ContentHandler reference.
-     */
-    public SAXResult(ContentHandler handler) {
-        setHandler(handler);
-    }
-
-    /**
-     * Set the target to be a SAX2 {@link org.xml.sax.ContentHandler}.
-     *
-     * @param handler Must be a non-null ContentHandler reference.
-     */
-    public void setHandler(ContentHandler handler) {
-        this.handler = handler;
-    }
-
-    /**
-     * Get the {@link org.xml.sax.ContentHandler} that is the Result.
-     *
-     * @return The ContentHandler that is to be transformation output.
-     */
-    public ContentHandler getHandler() {
-        return handler;
-    }
-
-    /**
-     * Set the SAX2 {@link org.xml.sax.ext.LexicalHandler} for the output.
-     *
-     * <p>This is needed to handle XML comments and the like.  If the
-     * lexical handler is not set, an attempt should be made by the
-     * transformer to cast the {@link org.xml.sax.ContentHandler} to a
-     * <code>LexicalHandler</code>.</p>
-     *
-     * @param handler A non-null <code>LexicalHandler</code> for
-     * handling lexical parse events.
-     */
-    public void setLexicalHandler(LexicalHandler handler) {
-        this.lexhandler = handler;
-    }
-
-    /**
-     * Get a SAX2 {@link org.xml.sax.ext.LexicalHandler} for the output.
-     *
-     * @return A <code>LexicalHandler</code>, or null.
-     */
-    public LexicalHandler getLexicalHandler() {
-        return lexhandler;
-    }
-
-    /**
-     * Method setSystemId Set the systemID that may be used in association
-     * with the {@link org.xml.sax.ContentHandler}.
-     *
-     * @param systemId The system identifier as a URI string.
-     */
-    public void setSystemId(String systemId) {
-        this.systemId = systemId;
-    }
-
-    /**
-     * Get the system identifier that was set with setSystemId.
-     *
-     * @return The system identifier that was set with setSystemId, or null
-     * if setSystemId was not called.
-     */
-    public String getSystemId() {
-        return systemId;
-    }
-
-    //////////////////////////////////////////////////////////////////////
-    // Internal state.
-    //////////////////////////////////////////////////////////////////////
-
-    /**
-     * The handler for parse events.
-     */
-    private ContentHandler handler;
-
-    /**
-     * The handler for lexical events.
-     */
-    private LexicalHandler lexhandler;
-
-    /**
-     * The systemID that may be used in association
-     * with the node.
-     */
-    private String systemId;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXSource.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXSource.java b/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXSource.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXSource.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,212 +0,0 @@
-/*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.sax;
-
-import javax.xml.transform.Source;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.stream.StreamSource;
-
-import javax.xml.parsers.SAXParserFactory;
-import org.xml.sax.InputSource;
-import org.xml.sax.XMLReader;
-
-/**
- * <p>Acts as an holder for SAX-style Source.</p>
- *
- * <p>Note that XSLT requires namespace support. Attempting to transform an
- * input source that is not
- * generated with a namespace-aware parser may result in errors.
- * Parsers can be made namespace aware by calling the
- * {@link SAXParserFactory#setNamespaceAware(boolean awareness)} method.</p>
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public class SAXSource implements Source {
-
-    /**
-     * If {@link TransformerFactory#getFeature}
-     * returns true when passed this value as an argument,
-     * the Transformer supports Source input of this type.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.sax.SAXSource/feature";
-
-    /**
-     * <p>Zero-argument default constructor.  If this constructor is used, and
-     * no SAX source is set using
-     * {@link #setInputSource(InputSource inputSource)} , then the
-     * <code>Transformer</code> will
-     * create an empty source {@link org.xml.sax.InputSource} using
-     * {@link org.xml.sax.InputSource#InputSource() new InputSource()}.</p>
-     *
-     * @see Transformer#transform(Source xmlSource, Result outputTarget)
-     */
-    public SAXSource() { }
-
-    /**
-     * Create a <code>SAXSource</code>, using an {@link org.xml.sax.XMLReader}
-     * and a SAX InputSource. The {@link Transformer}
-     * or {@link SAXTransformerFactory} will set itself
-     * to be the reader's {@link org.xml.sax.ContentHandler}, and then will call
-     * reader.parse(inputSource).
-     *
-     * @param reader An XMLReader to be used for the parse.
-     * @param inputSource A SAX input source reference that must be non-null
-     * and that will be passed to the reader parse method.
-     */
-    public SAXSource(XMLReader reader, InputSource inputSource) {
-        this.reader      = reader;
-        this.inputSource = inputSource;
-    }
-
-    /**
-     * Create a <code>SAXSource</code>, using a SAX <code>InputSource</code>.
-     * The {@link Transformer} or
-     * {@link SAXTransformerFactory} creates a
-     * reader via {@link org.xml.sax.helpers.XMLReaderFactory}
-     * (if setXMLReader is not used), sets itself as
-     * the reader's {@link org.xml.sax.ContentHandler}, and calls
-     * reader.parse(inputSource).
-     *
-     * @param inputSource An input source reference that must be non-null
-     * and that will be passed to the parse method of the reader.
-     */
-    public SAXSource(InputSource inputSource) {
-        this.inputSource = inputSource;
-    }
-
-    /**
-     * Set the XMLReader to be used for the Source.
-     *
-     * @param reader A valid XMLReader or XMLFilter reference.
-     */
-    public void setXMLReader(XMLReader reader) {
-        this.reader = reader;
-    }
-
-    /**
-     * Get the XMLReader to be used for the Source.
-     *
-     * @return A valid XMLReader or XMLFilter reference, or null.
-     */
-    public XMLReader getXMLReader() {
-        return reader;
-    }
-
-    /**
-     * Set the SAX InputSource to be used for the Source.
-     *
-     * @param inputSource A valid InputSource reference.
-     */
-    public void setInputSource(InputSource inputSource) {
-        this.inputSource = inputSource;
-    }
-
-    /**
-     * Get the SAX InputSource to be used for the Source.
-     *
-     * @return A valid InputSource reference, or null.
-     */
-    public InputSource getInputSource() {
-        return inputSource;
-    }
-
-    /**
-     * Set the system identifier for this Source.  If an input source
-     * has already been set, it will set the system ID or that
-     * input source, otherwise it will create a new input source.
-     *
-     * <p>The system identifier is optional if there is a byte stream
-     * or a character stream, but it is still useful to provide one,
-     * since the application can use it to resolve relative URIs
-     * and can include it in error messages and warnings (the parser
-     * will attempt to open a connection to the URI only if
-     * no byte stream or character stream is specified).</p>
-     *
-     * @param systemId The system identifier as a URI string.
-     */
-    public void setSystemId(String systemId) {
-
-        if (null == inputSource) {
-            inputSource = new InputSource(systemId);
-        } else {
-            inputSource.setSystemId(systemId);
-        }
-    }
-
-    /**
-     * <p>Get the base ID (URI or system ID) from where URIs
-     * will be resolved.</p>
-     *
-     * @return Base URL for the <code>Source</code>, or <code>null</code>.
-     */
-    public String getSystemId() {
-
-        if (inputSource == null) {
-            return null;
-        } else {
-            return inputSource.getSystemId();
-        }
-    }
-
-    /**
-     * The XMLReader to be used for the source tree input. May be null.
-     */
-    private XMLReader reader;
-
-    /**
-     * <p>The SAX InputSource to be used for the source tree input.
-     * Should not be <code>null</code>.</p>
-     */
-    private InputSource inputSource;
-
-    /**
-     * Attempt to obtain a SAX InputSource object from a Source
-     * object.
-     *
-     * @param source Must be a non-null Source reference.
-     *
-     * @return An InputSource, or null if Source can not be converted.
-     */
-    public static InputSource sourceToInputSource(Source source) {
-
-        if (source instanceof SAXSource) {
-            return ((SAXSource) source).getInputSource();
-        } else if (source instanceof StreamSource) {
-            StreamSource ss      = (StreamSource) source;
-            InputSource  isource = new InputSource(ss.getSystemId());
-
-            isource.setByteStream(ss.getInputStream());
-            isource.setCharacterStream(ss.getReader());
-            isource.setPublicId(ss.getPublicId());
-
-            return isource;
-        } else {
-            return null;
-        }
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/sax/TemplatesHandler.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/TemplatesHandler.java b/Build/src/main/java/org/openjdk/javax/xml/transform/sax/TemplatesHandler.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/TemplatesHandler.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.sax;
-
-import javax.xml.transform.Templates;
-import org.xml.sax.ContentHandler;
-
-/**
- * A SAX ContentHandler that may be used to process SAX
- * parse events (parsing transformation instructions) into a Templates object.
- *
- * <p>Note that TemplatesHandler does not need to implement LexicalHandler.</p>
- */
-public interface TemplatesHandler extends ContentHandler {
-
-    /**
-     * When a TemplatesHandler object is used as a ContentHandler
-     * for the parsing of transformation instructions, it creates a Templates object,
-     * which the caller can get once the SAX events have been completed.
-     *
-     * @return The Templates object that was created during
-     * the SAX event process, or null if no Templates object has
-     * been created.
-     *
-     */
-    public Templates getTemplates();
-
-    /**
-     * Set the base ID (URI or system ID) for the Templates object
-     * created by this builder.  This must be set in order to
-     * resolve relative URIs in the stylesheet.  This must be
-     * called before the startDocument event.
-     *
-     * @param systemID Base URI for this stylesheet.
-     */
-    public void setSystemId(String systemID);
-
-    /**
-     * Get the base ID (URI or system ID) from where relative
-     * URLs will be resolved.
-     * @return The systemID that was set with {@link #setSystemId}.
-     */
-    public String getSystemId();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/sax/TransformerHandler.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/TransformerHandler.java b/Build/src/main/java/org/openjdk/javax/xml/transform/sax/TransformerHandler.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/TransformerHandler.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,76 +0,0 @@
-/*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.sax;
-
-import javax.xml.transform.Result;
-import javax.xml.transform.Transformer;
-
-import org.xml.sax.ContentHandler;
-import org.xml.sax.DTDHandler;
-import org.xml.sax.ext.LexicalHandler;
-
-/**
- * A TransformerHandler
- * listens for SAX ContentHandler parse events and transforms
- * them to a Result.
- */
-public interface TransformerHandler
-    extends ContentHandler, LexicalHandler, DTDHandler {
-
-    /**
-     * <p>Set  the <code>Result</code> associated with this
-     * <code>TransformerHandler</code> to be used for the transformation.</p>
-     *
-     * @param result A <code>Result</code> instance, should not be
-     *   <code>null</code>.
-     *
-     * @throws IllegalArgumentException if result is invalid for some reason.
-     */
-    public void setResult(Result result) throws IllegalArgumentException;
-
-    /**
-     * Set the base ID (URI or system ID) from where relative
-     * URLs will be resolved.
-     * @param systemID Base URI for the source tree.
-     */
-    public void setSystemId(String systemID);
-
-    /**
-     * Get the base ID (URI or system ID) from where relative
-     * URLs will be resolved.
-     * @return The systemID that was set with {@link #setSystemId}.
-     */
-    public String getSystemId();
-
-    /**
-     * <p>Get the <code>Transformer</code> associated with this handler, which
-     * is needed in order to set parameters and output properties.</p>
-     *
-     * @return <code>Transformer</code> associated with this
-     *   <code>TransformerHandler</code>.
-     */
-    public Transformer getTransformer();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXTransformerFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXTransformerFactory.java b/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXTransformerFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/sax/SAXTransformerFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,149 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.sax;
-
-import javax.xml.transform.Source;
-import org.xml.sax.XMLFilter;
-
-/**
- * This class extends TransformerFactory to provide SAX-specific
- * factory methods.  It provides two types of ContentHandlers,
- * one for creating Transformers, the other for creating Templates
- * objects.
- *
- * <p>If an application wants to set the ErrorHandler or EntityResolver
- * for an XMLReader used during a transformation, it should use a URIResolver
- * to return the SAXSource which provides (with getXMLReader) a reference to
- * the XMLReader.</p>
- */
-public abstract class SAXTransformerFactory extends javax.xml.transform.TransformerFactory {
-
-    /** If {@link javax.xml.transform.TransformerFactory#getFeature}
-     * returns true when passed this value as an argument,
-     * the TransformerFactory returned from
-     * {@link javax.xml.transform.TransformerFactory#newInstance} may
-     * be safely cast to a SAXTransformerFactory.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.sax.SAXTransformerFactory/feature";
-
-    /** If {@link javax.xml.transform.TransformerFactory#getFeature}
-     * returns true when passed this value as an argument,
-     * the {@link #newXMLFilter(javax.xml.transform.Source src)}
-     * and {@link #newXMLFilter(javax.xml.transform.Templates templates)} methods are supported.
-     */
-    public static final String FEATURE_XMLFILTER =
-        "http://javax.xml.transform.sax.SAXTransformerFactory/feature/xmlfilter";
-
-    /**
-     * The default constructor is protected on purpose.
-     */
-    protected SAXTransformerFactory() {}
-
-    /**
-     * Get a TransformerHandler object that can process SAX
-     * ContentHandler events into a Result, based on the transformation
-     * instructions specified by the argument.
-     *
-     * @param src The Source of the transformation instructions.
-     *
-     * @return TransformerHandler ready to transform SAX events.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException If for some reason the
-     * TransformerHandler can not be created.
-     */
-    public abstract javax.xml.transform.sax.TransformerHandler newTransformerHandler(javax.xml.transform.Source src)
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * Get a TransformerHandler object that can process SAX
-     * ContentHandler events into a Result, based on the Templates argument.
-     *
-     * @param templates The compiled transformation instructions.
-     *
-     * @return TransformerHandler ready to transform SAX events.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException If for some reason the
-     * TransformerHandler can not be created.
-     */
-    public abstract javax.xml.transform.sax.TransformerHandler newTransformerHandler(
-        javax.xml.transform.Templates templates) throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * Get a TransformerHandler object that can process SAX
-     * ContentHandler events into a Result. The transformation
-     * is defined as an identity (or copy) transformation, for example
-     * to copy a series of SAX parse events into a DOM tree.
-     *
-     * @return A non-null reference to a TransformerHandler, that may
-     * be used as a ContentHandler for SAX parse events.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException If for some reason the
-     * TransformerHandler cannot be created.
-     */
-    public abstract TransformerHandler newTransformerHandler()
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * Get a TemplatesHandler object that can process SAX
-     * ContentHandler events into a Templates object.
-     *
-     * @return A non-null reference to a TransformerHandler, that may
-     * be used as a ContentHandler for SAX parse events.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException If for some reason the
-     * TemplatesHandler cannot be created.
-     */
-    public abstract TemplatesHandler newTemplatesHandler()
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * Create an XMLFilter that uses the given Source as the
-     * transformation instructions.
-     *
-     * @param src The Source of the transformation instructions.
-     *
-     * @return An XMLFilter object, or null if this feature is not supported.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException If for some reason the
-     * TemplatesHandler cannot be created.
-     */
-    public abstract XMLFilter newXMLFilter(Source src)
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * Create an XMLFilter, based on the Templates argument..
-     *
-     * @param templates The compiled transformation instructions.
-     *
-     * @return An XMLFilter object, or null if this feature is not supported.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException If for some reason the
-     * TemplatesHandler cannot be created.
-     */
-    public abstract XMLFilter newXMLFilter(javax.xml.transform.Templates templates)
-        throws javax.xml.transform.TransformerConfigurationException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/stax/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/stax/package.html b/Build/src/main/java/org/openjdk/javax/xml/transform/stax/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/stax/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,73 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
-
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>javax.xml.transform.stax</title>
-
-		<meta name="CVS"
-			content="$Id: package.html,v 1.2 2005/11/03 19:34:28 jeffsuttor Exp $" />
-		<meta name="AUTHOR"
-			content="Jeff.Suttor@Sun.com" />
-		<meta name="AUTHOR"
-			content="Neeraj.Bajaj@Sun.com" />
-	</head>
-	<body>
-		<p>
-			Provides for StAX-specific transformation APIs.
-			TODO: better description(s).
-		</p>
-
-		<h2>Package Specification</h2>
-		<ul>
-			<li><a href="http://jcp.org/en/jsr/detail?id=173">JSR 173: Streaming API for XML</a></li>
-		</ul>
-
-		<h2>Related Documentation</h2>
-
-		<p>For overviews, tutorials, examples, guides, and tool documentation, please see:</p>
-		<ul>
-			<li><a href="">TODO: Refer to non-spec documentation</a></li>
-		</ul>
-
-		<!-- Put @see and @since tags down here. -->
-		<ul>
-			<li>@see XMLStreamReader</li>
-			<li>@see XMLEventReader</li>
-		</ul>
-		
-		<p>
-			@since 1.6
-		</p>
-
-	</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXResult.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXResult.java b/Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXResult.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXResult.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,186 +0,0 @@
-/*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.stax;
-
-import javax.xml.stream.XMLEventWriter;
-import javax.xml.stream.XMLStreamWriter;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.Result;
-import javax.xml.validation.Validator;
-
-/**
- * <p>Acts as a holder for an XML {@link Result} in the
- * form of a StAX writer,i.e.
- * {@link XMLStreamWriter} or {@link XMLEventWriter}.
- * <code>StAXResult</code> can be used in all cases that accept
- * a <code>Result</code>, e.g. {@link Transformer},
- * {@link Validator} which accept
- * <code>Result</code> as input.
- *
- * @author <a href="mailto:Neeraj.Bajaj@Sun.com">Neeraj Bajaj</a>
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- *
- * @see <a href="http://jcp.org/en/jsr/detail?id=173">
- *  JSR 173: Streaming API for XML</a>
- * @see XMLStreamWriter
- * @see XMLEventWriter
- *
- * @since 1.6
- */
-public class StAXResult implements Result {
-    /** If {@link TransformerFactory#getFeature(String name)}
-     * returns true when passed this value as an argument,
-     * the Transformer supports Result output of this type.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.stax.StAXResult/feature";
-
-    /**
-     * <p><code>XMLEventWriter</code> to be used for
-     * <code>Result</code> output.</p>
-     */
-    private XMLEventWriter xmlEventWriter = null;
-
-    /**
-     * <p><code>XMLStreamWriter</code> to be used for
-     * <code>Result</code> output.</p>
-     */
-    private XMLStreamWriter xmlStreamWriter = null;
-
-    /** <p>System identifier for this <code>StAXResult</code>.<p> */
-    private String systemId = null;
-
-    /**
-     * <p>Creates a new instance of a <code>StAXResult</code>
-     * by supplying an {@link XMLEventWriter}.</p>
-     *
-     * <p><code>XMLEventWriter</code> must be a
-     * non-<code>null</code> reference.</p>
-     *
-     * @param xmlEventWriter <code>XMLEventWriter</code> used to create
-     *   this <code>StAXResult</code>.
-     *
-     * @throws IllegalArgumentException If <code>xmlEventWriter</code> ==
-     *   <code>null</code>.
-     */
-    public StAXResult(final XMLEventWriter xmlEventWriter) {
-
-        if (xmlEventWriter == null) {
-            throw new IllegalArgumentException(
-                    "StAXResult(XMLEventWriter) with XMLEventWriter == null");
-        }
-
-        this.xmlEventWriter = xmlEventWriter;
-    }
-
-    /**
-     * <p>Creates a new instance of a <code>StAXResult</code>
-     * by supplying an {@link XMLStreamWriter}.</p>
-     *
-     * <p><code>XMLStreamWriter</code> must be a
-     * non-<code>null</code> reference.</p>
-     *
-     * @param xmlStreamWriter <code>XMLStreamWriter</code> used to create
-     *   this <code>StAXResult</code>.
-     *
-     * @throws IllegalArgumentException If <code>xmlStreamWriter</code> ==
-     *   <code>null</code>.
-     */
-    public StAXResult(final XMLStreamWriter xmlStreamWriter) {
-
-        if (xmlStreamWriter == null) {
-            throw new IllegalArgumentException(
-                    "StAXResult(XMLStreamWriter) with XMLStreamWriter == null");
-        }
-
-        this.xmlStreamWriter = xmlStreamWriter;
-    }
-
-    /**
-     * <p>Get the <code>XMLEventWriter</code> used by this
-     * <code>StAXResult</code>.</p>
-     *
-     * <p><code>XMLEventWriter</code> will be <code>null</code>
-     * if this <code>StAXResult</code> was created with a
-     * <code>XMLStreamWriter</code>.</p>
-     *
-     * @return <code>XMLEventWriter</code> used by this
-     *   <code>StAXResult</code>.
-     */
-    public XMLEventWriter getXMLEventWriter() {
-
-        return xmlEventWriter;
-    }
-
-    /**
-     * <p>Get the <code>XMLStreamWriter</code> used by this
-     * <code>StAXResult</code>.</p>
-     *
-     * <p><code>XMLStreamWriter</code> will be <code>null</code>
-     * if this <code>StAXResult</code> was created with a
-     * <code>XMLEventWriter</code>.</p>
-     *
-     * @return <code>XMLStreamWriter</code> used by this
-     *   <code>StAXResult</code>.
-     */
-    public XMLStreamWriter getXMLStreamWriter() {
-
-        return xmlStreamWriter;
-    }
-
-    /**
-     * <p>In the context of a <code>StAXResult</code>, it is not appropriate
-     * to explicitly set the system identifier.
-     * The <code>XMLEventWriter</code> or <code>XMLStreamWriter</code>
-     * used to construct this <code>StAXResult</code> determines the
-     * system identifier of the XML result.</p>
-     *
-     * <p>An {@link UnsupportedOperationException} is <strong>always</strong>
-     * thrown by this method.</p>
-     *
-     * @param systemId Ignored.
-     *
-     * @throws UnsupportedOperationException Is <strong>always</strong>
-     *   thrown by this method.
-     */
-    public void setSystemId(final String systemId) {
-
-        throw new UnsupportedOperationException(
-                "StAXResult#setSystemId(systemId) cannot set the "
-                + "system identifier for a StAXResult");
-    }
-
-    /**
-     * <p>The returned system identifier is always <code>null</code>.</p>
-     *
-     * @return The returned system identifier is always <code>null</code>.
-     */
-    public String getSystemId() {
-
-        return null;
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXSource.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXSource.java b/Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXSource.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/stax/StAXSource.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,239 +0,0 @@
-/*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.stax;
-
-import javax.xml.stream.XMLEventReader;
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.events.XMLEvent;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.Source;
-import javax.xml.validation.Validator;
-
-/**
- * <p>Acts as a holder for an XML {@link Source} in the
- * form of a StAX reader,i.e.
- * {@link XMLStreamReader} or {@link XMLEventReader}.
- * <code>StAXSource</code> can be used in all cases that accept
- * a <code>Source</code>, e.g. {@link Transformer},
- * {@link Validator} which accept
- * <code>Source</code> as input.
- *
- * <p><code>StAXSource</code>s are consumed during processing
- * and are not reusable.</p>
- *
- * @author <a href="mailto:Neeraj.Bajaj@Sun.com">Neeraj Bajaj</a>
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- *
- * @see <a href="http://jcp.org/en/jsr/detail?id=173">
- *  JSR 173: Streaming API for XML</a>
- * @see XMLStreamReader
- * @see XMLEventReader
- *
- * @since 1.6
- */
-public class StAXSource implements Source {
-
-    /** If {@link TransformerFactory#getFeature(String name)}
-     * returns true when passed this value as an argument,
-     * the Transformer supports Source input of this type.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.stax.StAXSource/feature";
-
-    /** <p><code>XMLEventReader</code> to be used for source input.</p> */
-    private XMLEventReader xmlEventReader = null;
-
-    /** <p><code>XMLStreamReader</code> to be used for source input.</p> */
-    private XMLStreamReader xmlStreamReader = null;
-
-    /** <p>System identifier of source input.</p> */
-    private String systemId = null;
-
-    /**
-     * <p>Creates a new instance of a <code>StAXSource</code>
-     * by supplying an {@link XMLEventReader}.</p>
-     *
-     * <p><code>XMLEventReader</code> must be a
-     * non-<code>null</code> reference.</p>
-     *
-     * <p><code>XMLEventReader</code> must be in
-     * {@link XMLStreamConstants#START_DOCUMENT} or
-     * {@link XMLStreamConstants#START_ELEMENT} state.</p>
-     *
-     * @param xmlEventReader <code>XMLEventReader</code> used to create
-     *   this <code>StAXSource</code>.
-     *
-     * @throws XMLStreamException If <code>xmlEventReader</code> access
-     *   throws an <code>Exception</code>.
-     * @throws IllegalArgumentException If <code>xmlEventReader</code> ==
-     *   <code>null</code>.
-     * @throws IllegalStateException If <code>xmlEventReader</code>
-     *   is not in <code>XMLStreamConstants.START_DOCUMENT</code> or
-     *   <code>XMLStreamConstants.START_ELEMENT</code> state.
-     */
-    public StAXSource(final XMLEventReader xmlEventReader)
-        throws XMLStreamException {
-
-        if (xmlEventReader == null) {
-            throw new IllegalArgumentException(
-                    "StAXSource(XMLEventReader) with XMLEventReader == null");
-        }
-
-        // TODO: This is ugly ...
-        // there is no way to know the current position(event) of
-        // XMLEventReader.  peek() is the only way to know the next event.
-        // The next event on the input stream should be
-        // XMLStreamConstants.START_DOCUMENT or
-        // XMLStreamConstants.START_ELEMENT.
-        XMLEvent event = xmlEventReader.peek();
-        int eventType = event.getEventType();
-        if (eventType != XMLStreamConstants.START_DOCUMENT
-                && eventType != XMLStreamConstants.START_ELEMENT) {
-            throw new IllegalStateException(
-                "StAXSource(XMLEventReader) with XMLEventReader "
-                + "not in XMLStreamConstants.START_DOCUMENT or "
-                + "XMLStreamConstants.START_ELEMENT state");
-        }
-
-        this.xmlEventReader = xmlEventReader;
-        systemId = event.getLocation().getSystemId();
-    }
-
-    /**
-     * <p>Creates a new instance of a <code>StAXSource</code>
-     * by supplying an {@link XMLStreamReader}.</p>
-     *
-     * <p><code>XMLStreamReader</code> must be a
-     * non-<code>null</code> reference.</p>
-     *
-     * <p><code>XMLStreamReader</code> must be in
-     * {@link XMLStreamConstants#START_DOCUMENT} or
-     * {@link XMLStreamConstants#START_ELEMENT} state.</p>
-     *
-     * @param xmlStreamReader <code>XMLStreamReader</code> used to create
-     *   this <code>StAXSource</code>.
-     *
-     * @throws IllegalArgumentException If <code>xmlStreamReader</code> ==
-     *   <code>null</code>.
-     * @throws IllegalStateException If <code>xmlStreamReader</code>
-     *   is not in <code>XMLStreamConstants.START_DOCUMENT</code> or
-     *   <code>XMLStreamConstants.START_ELEMENT</code> state.
-     */
-    public StAXSource(final XMLStreamReader xmlStreamReader) {
-
-        if (xmlStreamReader == null) {
-            throw new IllegalArgumentException(
-                    "StAXSource(XMLStreamReader) with XMLStreamReader == null");
-        }
-
-        int eventType = xmlStreamReader.getEventType();
-        if (eventType != XMLStreamConstants.START_DOCUMENT
-                && eventType != XMLStreamConstants.START_ELEMENT) {
-            throw new IllegalStateException(
-                    "StAXSource(XMLStreamReader) with XMLStreamReader"
-                    + "not in XMLStreamConstants.START_DOCUMENT or "
-                    + "XMLStreamConstants.START_ELEMENT state");
-        }
-
-        this.xmlStreamReader = xmlStreamReader;
-        systemId = xmlStreamReader.getLocation().getSystemId();
-    }
-
-    /**
-     * <p>Get the <code>XMLEventReader</code> used by this
-     * <code>StAXSource</code>.</p>
-     *
-     * <p><code>XMLEventReader</code> will be <code>null</code>.
-     * if this <code>StAXSource</code> was created with a
-     * <code>XMLStreamReader</code>.</p>
-     *
-     * @return <code>XMLEventReader</code> used by this
-     *   <code>StAXSource</code>.
-     */
-    public XMLEventReader getXMLEventReader() {
-
-        return xmlEventReader;
-    }
-
-    /**
-     * <p>Get the <code>XMLStreamReader</code> used by this
-     * <code>StAXSource</code>.</p>
-     *
-     * <p><code>XMLStreamReader</code> will be <code>null</code>
-     * if this <code>StAXSource</code> was created with a
-     * <code>XMLEventReader</code>.</p>
-     *
-     * @return <code>XMLStreamReader</code> used by this
-     *   <code>StAXSource</code>.
-     */
-    public XMLStreamReader getXMLStreamReader() {
-
-        return xmlStreamReader;
-    }
-
-    /**
-     * <p>In the context of a <code>StAXSource</code>, it is not appropriate
-     * to explicitly set the system identifier.
-     * The <code>XMLStreamReader</code> or <code>XMLEventReader</code>
-     * used to construct this <code>StAXSource</code> determines the
-     * system identifier of the XML source.</p>
-     *
-     * <p>An {@link UnsupportedOperationException} is <strong>always</strong>
-     * thrown by this method.</p>
-     *
-     * @param systemId Ignored.
-     *
-     * @throws UnsupportedOperationException Is <strong>always</strong>
-     *   thrown by this method.
-     */
-    public void setSystemId(final String systemId) {
-
-        throw new UnsupportedOperationException(
-                "StAXSource#setSystemId(systemId) cannot set the "
-                + "system identifier for a StAXSource");
-    }
-
-    /**
-     * <p>Get the system identifier used by this
-     * <code>StAXSource</code>.</p>
-     *
-     * <p>The <code>XMLStreamReader</code> or <code>XMLEventReader</code>
-     * used to construct this <code>StAXSource</code> is queried to determine
-     * the system identifier of the XML source.</p>
-     *
-     * <p>The system identifier may be <code>null</code> or
-     * an empty <code>""</code> <code>String</code>.</p>
-     *
-     * @return System identifier used by this <code>StAXSource</code>.
-     */
-    public String getSystemId() {
-
-        return systemId;
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/stream/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/stream/package.html b/Build/src/main/java/org/openjdk/javax/xml/transform/stream/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/stream/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,64 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>javax.xml.transform.stream</title>
-
-  <meta name="CVS"
-        content="$Id: package.html,v 1.2 2005/06/10 03:50:42 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-<body>
-<p>This package implements stream- and URI- specific transformation APIs.
-	 </p>
-<p>The {@link javax.xml.transform.stream.StreamSource} class
-	 provides methods for specifying {@link java.io.InputStream} input,
-	 {@link java.io.Reader} input, and URL input in the form of strings. Even
-	 if an input stream or reader is specified as the source,
-	 {@link javax.xml.transform.stream.StreamSource#setSystemId} should still
-	 be called, so that the transformer can know from where it should resolve
-	 relative URIs. The public identifier is always optional: if the application
-	 writer includes one, it will be provided as part of the
-	 {@link javax.xml.transform.SourceLocator} information.</p>
-<p>The {@link javax.xml.transform.stream.StreamResult} class
-	 provides methods for specifying {@link java.io.OutputStream},
-	 {@link java.io.Writer}, or an output system ID, as the output of the
-	 transformation result.</p>
-<p>Normally streams should be used rather than readers or writers, for
-	 both the Source and Result, since readers and writers already have the encoding
-	 established to and from the internal Unicode format. However, there are times
-	 when it is useful to write to a character stream, such as when using a
-	 StringWriter in order to write to a String, or in the case of reading source
-	 XML from a StringReader.</p>
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamResult.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamResult.java b/Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamResult.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamResult.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,203 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.stream;
-
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.Result;
-
-import java.io.File;
-import java.io.OutputStream;
-import java.io.Writer;
-
-/**
- * <p>Acts as an holder for a transformation result,
- * which may be XML, plain Text, HTML, or some other form of markup.</p>
- *
- * @author <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public class StreamResult implements Result {
-
-    /** If {@link TransformerFactory#getFeature}
-     * returns true when passed this value as an argument,
-     * the Transformer supports Result output of this type.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.stream.StreamResult/feature";
-
-    /**
-     * Zero-argument default constructor.
-     */
-    public StreamResult() {
-    }
-
-    /**
-     * Construct a StreamResult from a byte stream.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the transformer may use instructions contained in the
-     * transformation instructions to control the encoding.
-     *
-     * @param outputStream A valid OutputStream reference.
-     */
-    public StreamResult(OutputStream outputStream) {
-        setOutputStream(outputStream);
-    }
-
-    /**
-     * Construct a StreamResult from a character stream.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the transformer may use instructions contained in the
-     * transformation instructions to control the encoding.  However,
-     * there are times when it is useful to write to a character
-     * stream, such as when using a StringWriter.
-     *
-     * @param writer  A valid Writer reference.
-     */
-    public StreamResult(Writer writer) {
-        setWriter(writer);
-    }
-
-    /**
-     * Construct a StreamResult from a URL.
-     *
-     * @param systemId Must be a String that conforms to the URI syntax.
-     */
-    public StreamResult(String systemId) {
-        this.systemId = systemId;
-    }
-
-    /**
-     * Construct a StreamResult from a File.
-     *
-     * @param f Must a non-null File reference.
-     */
-    public StreamResult(File f) {
-        //convert file to appropriate URI, f.toURI().toASCIIString()
-        //converts the URI to string as per rule specified in
-        //RFC 2396,
-        setSystemId(f.toURI().toASCIIString());
-    }
-
-    /**
-     * Set the ByteStream that is to be written to.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the transformer may use instructions contained in the
-     * transformation instructions to control the encoding.
-     *
-     * @param outputStream A valid OutputStream reference.
-     */
-    public void setOutputStream(OutputStream outputStream) {
-        this.outputStream = outputStream;
-    }
-
-    /**
-     * Get the byte stream that was set with setOutputStream.
-     *
-     * @return The byte stream that was set with setOutputStream, or null
-     * if setOutputStream or the ByteStream constructor was not called.
-     */
-    public OutputStream getOutputStream() {
-        return outputStream;
-    }
-
-    /**
-     * Set the writer that is to receive the result.  Normally,
-     * a stream should be used rather than a writer, so that
-     * the transformer may use instructions contained in the
-     * transformation instructions to control the encoding.  However,
-     * there are times when it is useful to write to a writer,
-     * such as when using a StringWriter.
-     *
-     * @param writer  A valid Writer reference.
-     */
-    public void setWriter(Writer writer) {
-        this.writer = writer;
-    }
-
-    /**
-     * Get the character stream that was set with setWriter.
-     *
-     * @return The character stream that was set with setWriter, or null
-     * if setWriter or the Writer constructor was not called.
-     */
-    public Writer getWriter() {
-        return writer;
-    }
-
-    /**
-     * Set the systemID that may be used in association
-     * with the byte or character stream, or, if neither is set, use
-     * this value as a writeable URI (probably a file name).
-     *
-     * @param systemId The system identifier as a URI string.
-     */
-    public void setSystemId(String systemId) {
-        this.systemId = systemId;
-    }
-
-    /**
-     * <p>Set the system ID from a <code>File</code> reference.</p>
-     *
-     *
-     * @param f Must a non-null File reference.
-     */
-    public void setSystemId(File f) {
-        //convert file to appropriate URI, f.toURI().toASCIIString()
-        //converts the URI to string as per rule specified in
-        //RFC 2396,
-        this.systemId = f.toURI().toASCIIString();
-    }
-
-    /**
-     * Get the system identifier that was set with setSystemId.
-     *
-     * @return The system identifier that was set with setSystemId, or null
-     * if setSystemId was not called.
-     */
-    public String getSystemId() {
-        return systemId;
-    }
-
-    //////////////////////////////////////////////////////////////////////
-    // Internal state.
-    //////////////////////////////////////////////////////////////////////
-
-    /**
-     * The systemID that may be used in association
-     * with the byte or character stream, or, if neither is set, use
-     * this value as a writeable URI (probably a file name).
-     */
-    private String systemId;
-
-    /**
-     * The byte stream that is to be written to.
-     */
-    private OutputStream outputStream;
-
-    /**
-     * The character stream that is to be written to.
-     */
-    private Writer writer;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamSource.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamSource.java b/Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamSource.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/stream/StreamSource.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,287 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform.stream;
-
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-
-import java.io.File;
-import java.io.InputStream;
-import java.io.Reader;
-
-import javax.xml.transform.Source;
-
-/**
- * <p>Acts as an holder for a transformation Source in the form
- * of a stream of XML markup.</p>
- *
- * <p><em>Note:</em> Due to their internal use of either a {@link Reader} or {@link InputStream} instance,
- * <code>StreamSource</code> instances may only be used once.</p>
- *
- * @author <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public class StreamSource implements Source {
-
-    /** If {@link TransformerFactory#getFeature}
-     * returns true when passed this value as an argument,
-     * the Transformer supports Source input of this type.
-     */
-    public static final String FEATURE =
-        "http://javax.xml.transform.stream.StreamSource/feature";
-
-    /**
-     * <p>Zero-argument default constructor.  If this constructor is used, and
-     * no Stream source is set using
-     * {@link #setInputStream(java.io.InputStream inputStream)} or
-     * {@link #setReader(java.io.Reader reader)}, then the
-     * <code>Transformer</code> will
-     * create an empty source {@link java.io.InputStream} using
-     * {@link java.io.InputStream#InputStream() new InputStream()}.</p>
-     *
-     * @see Transformer#transform(Source xmlSource, Result outputTarget)
-     */
-    public StreamSource() { }
-
-    /**
-     * Construct a StreamSource from a byte stream.  Normally,
-     * a stream should be used rather than a reader, so
-     * the XML parser can resolve character encoding specified
-     * by the XML declaration.
-     *
-     * <p>If this constructor is used to process a stylesheet, normally
-     * setSystemId should also be called, so that relative URI references
-     * can be resolved.</p>
-     *
-     * @param inputStream A valid InputStream reference to an XML stream.
-     */
-    public StreamSource(InputStream inputStream) {
-        setInputStream(inputStream);
-    }
-
-    /**
-     * Construct a StreamSource from a byte stream.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the XML parser can resolve character encoding specified
-     * by the XML declaration.
-     *
-     * <p>This constructor allows the systemID to be set in addition
-     * to the input stream, which allows relative URIs
-     * to be processed.</p>
-     *
-     * @param inputStream A valid InputStream reference to an XML stream.
-     * @param systemId Must be a String that conforms to the URI syntax.
-     */
-    public StreamSource(InputStream inputStream, String systemId) {
-        setInputStream(inputStream);
-        setSystemId(systemId);
-    }
-
-    /**
-     * Construct a StreamSource from a character reader.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the XML parser can resolve character encoding specified
-     * by the XML declaration.  However, in many cases the encoding
-     * of the input stream is already resolved, as in the case of
-     * reading XML from a StringReader.
-     *
-     * @param reader A valid Reader reference to an XML character stream.
-     */
-    public StreamSource(Reader reader) {
-        setReader(reader);
-    }
-
-    /**
-     * Construct a StreamSource from a character reader.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the XML parser may resolve character encoding specified
-     * by the XML declaration.  However, in many cases the encoding
-     * of the input stream is already resolved, as in the case of
-     * reading XML from a StringReader.
-     *
-     * @param reader A valid Reader reference to an XML character stream.
-     * @param systemId Must be a String that conforms to the URI syntax.
-     */
-    public StreamSource(Reader reader, String systemId) {
-        setReader(reader);
-        setSystemId(systemId);
-    }
-
-    /**
-     * Construct a StreamSource from a URL.
-     *
-     * @param systemId Must be a String that conforms to the URI syntax.
-     */
-    public StreamSource(String systemId) {
-        this.systemId = systemId;
-    }
-
-    /**
-     * Construct a StreamSource from a File.
-     *
-     * @param f Must a non-null File reference.
-     */
-    public StreamSource(File f) {
-        //convert file to appropriate URI, f.toURI().toASCIIString()
-        //converts the URI to string as per rule specified in
-        //RFC 2396,
-        setSystemId(f.toURI().toASCIIString());
-    }
-
-    /**
-     * Set the byte stream to be used as input.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the XML parser can resolve character encoding specified
-     * by the XML declaration.
-     *
-     * <p>If this Source object is used to process a stylesheet, normally
-     * setSystemId should also be called, so that relative URL references
-     * can be resolved.</p>
-     *
-     * @param inputStream A valid InputStream reference to an XML stream.
-     */
-    public void setInputStream(InputStream inputStream) {
-        this.inputStream = inputStream;
-    }
-
-    /**
-     * Get the byte stream that was set with setByteStream.
-     *
-     * @return The byte stream that was set with setByteStream, or null
-     * if setByteStream or the ByteStream constructor was not called.
-     */
-    public InputStream getInputStream() {
-        return inputStream;
-    }
-
-    /**
-     * Set the input to be a character reader.  Normally,
-     * a stream should be used rather than a reader, so that
-     * the XML parser can resolve character encoding specified
-     * by the XML declaration.  However, in many cases the encoding
-     * of the input stream is already resolved, as in the case of
-     * reading XML from a StringReader.
-     *
-     * @param reader A valid Reader reference to an XML CharacterStream.
-     */
-    public void setReader(Reader reader) {
-        this.reader = reader;
-    }
-
-    /**
-     * Get the character stream that was set with setReader.
-     *
-     * @return The character stream that was set with setReader, or null
-     * if setReader or the Reader constructor was not called.
-     */
-    public Reader getReader() {
-        return reader;
-    }
-
-    /**
-     * Set the public identifier for this Source.
-     *
-     * <p>The public identifier is always optional: if the application
-     * writer includes one, it will be provided as part of the
-     * location information.</p>
-     *
-     * @param publicId The public identifier as a string.
-     */
-    public void setPublicId(String publicId) {
-        this.publicId = publicId;
-    }
-
-    /**
-     * Get the public identifier that was set with setPublicId.
-     *
-     * @return The public identifier that was set with setPublicId, or null
-     * if setPublicId was not called.
-     */
-    public String getPublicId() {
-        return publicId;
-    }
-
-    /**
-     * Set the system identifier for this Source.
-     *
-     * <p>The system identifier is optional if there is a byte stream
-     * or a character stream, but it is still useful to provide one,
-     * since the application can use it to resolve relative URIs
-     * and can include it in error messages and warnings (the parser
-     * will attempt to open a connection to the URI only if
-     * there is no byte stream or character stream specified).</p>
-     *
-     * @param systemId The system identifier as a URL string.
-     */
-    public void setSystemId(String systemId) {
-        this.systemId = systemId;
-    }
-
-    /**
-     * Get the system identifier that was set with setSystemId.
-     *
-     * @return The system identifier that was set with setSystemId, or null
-     * if setSystemId was not called.
-     */
-    public String getSystemId() {
-        return systemId;
-    }
-
-    /**
-     * Set the system ID from a File reference.
-     *
-     * @param f Must a non-null File reference.
-     */
-    public void setSystemId(File f) {
-        //convert file to appropriate URI, f.toURI().toASCIIString()
-        //converts the URI to string as per rule specified in
-        //RFC 2396,
-        this.systemId = f.toURI().toASCIIString();
-    }
-
-    //////////////////////////////////////////////////////////////////////
-    // Internal state.
-    //////////////////////////////////////////////////////////////////////
-
-    /**
-     * The public identifier for this input source, or null.
-     */
-    private String publicId;
-
-    /**
-     * The system identifier as a URL string, or null.
-     */
-    private String systemId;
-
-    /**
-     * The byte stream for this Source, or null.
-     */
-    private InputStream inputStream;
-
-    /**
-     * The character stream for this Source, or null.
-     */
-    private Reader reader;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/Result.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/Result.java b/Build/src/main/java/org/openjdk/javax/xml/transform/Result.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/Result.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * <p>An object that implements this interface contains the information
- * needed to build a transformation result tree.</p>
- *
- * @author <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public interface Result {
-
-    /**
-     * The name of the processing instruction that is sent if the
-     * result tree disables output escaping.
-     *
-     * <p>Normally, result tree serialization escapes & and < (and
-     * possibly other characters) when outputting text nodes.
-     * This ensures that the output is well-formed XML. However,
-     * it is sometimes convenient to be able to produce output that is
-     * almost, but not quite well-formed XML; for example,
-     * the output may include ill-formed sections that will
-     * be transformed into well-formed XML by a subsequent non-XML aware
-     * process. If a processing instruction is sent with this name,
-     * serialization should be output without any escaping. </p>
-     *
-     * <p>Result DOM trees may also have PI_DISABLE_OUTPUT_ESCAPING and
-     * PI_ENABLE_OUTPUT_ESCAPING inserted into the tree.</p>
-     *
-     * @see <a href="http://www.w3.org/TR/xslt#disable-output-escaping">disable-output-escaping in XSLT Specification</a>
-     */
-    public static final String PI_DISABLE_OUTPUT_ESCAPING =
-        "javax.xml.transform.disable-output-escaping";
-
-    /**
-     * The name of the processing instruction that is sent
-     * if the result tree enables output escaping at some point after having
-     * received a PI_DISABLE_OUTPUT_ESCAPING processing instruction.
-     *
-     * @see <a href="http://www.w3.org/TR/xslt#disable-output-escaping">disable-output-escaping in XSLT Specification</a>
-     */
-    public static final String PI_ENABLE_OUTPUT_ESCAPING =
-        "javax.xml.transform.enable-output-escaping";
-
-    /**
-     * Set the system identifier for this Result.
-     *
-     * <p>If the Result is not to be written to a file, the system identifier is optional.
-     * The application may still want to provide one, however, for use in error messages
-     * and warnings, or to resolve relative output identifiers.</p>
-     *
-     * @param systemId The system identifier as a URI string.
-     */
-    public void setSystemId(String systemId);
-
-    /**
-     * Get the system identifier that was set with setSystemId.
-     *
-     * @return The system identifier that was set with setSystemId,
-     * or null if setSystemId was not called.
-     */
-    public String getSystemId();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/Source.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/Source.java b/Build/src/main/java/org/openjdk/javax/xml/transform/Source.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/Source.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,53 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * An object that implements this interface contains the information
- * needed to act as source input (XML source or transformation instructions).
- */
-public interface Source {
-
-    /**
-     * Set the system identifier for this Source.
-     *
-     * <p>The system identifier is optional if the source does not
-     * get its data from a URL, but it may still be useful to provide one.
-     * The application can use a system identifier, for example, to resolve
-     * relative URIs and to include in error messages and warnings.</p>
-     *
-     * @param systemId The system identifier as a URL string.
-     */
-    public void setSystemId(String systemId);
-
-    /**
-     * Get the system identifier that was set with setSystemId.
-     *
-     * @return The system identifier that was set with setSystemId, or null
-     * if setSystemId was not called.
-     */
-    public String getSystemId();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/package.html b/Build/src/main/java/org/openjdk/javax/xml/transform/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,233 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>javax.xml.transform</title>
-
-  <meta name="CVS"
-        content="$Id: package.html,v 1.2 2005/06/10 03:50:39 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-
-<body>
-<p>This package defines the generic APIs for processing transformation
-instructions, and performing a transformation from source to result. These
-interfaces have no dependencies on SAX or the DOM standard, and try to make as
-few assumptions as possible about the details of the source and result of a
-transformation. It achieves this by defining
-{@link javax.xml.transform.Source} and
-{@link javax.xml.transform.Result} interfaces.
-</p>
-
-<p>To define concrete classes for the user, the API defines specializations
-of the interfaces found at the root level. These interfaces are found in
-{@link javax.xml.transform.sax}, {@link javax.xml.transform.dom},
-and {@link javax.xml.transform.stream}.
-</p>
-
-
-<h3>Creating Objects</h3>
-
-<p>The API allows a concrete
-{@link javax.xml.transform.TransformerFactory} object to be created from
-the static function
-{@link javax.xml.transform.TransformerFactory#newInstance}.
-</p>
-
-
-<h3>Specification of Inputs and Outputs</h3>
-
-<p>This API defines two interface objects called
-{@link javax.xml.transform.Source} and
-{@link javax.xml.transform.Result}. In order to pass Source and Result
-objects to the interfaces, concrete classes must be used.
-Three concrete representations are defined for each of these
-objects:
-{@link javax.xml.transform.stream.StreamSource} and
-{@link javax.xml.transform.stream.StreamResult},
-{@link javax.xml.transform.sax.SAXSource} and
-{@link javax.xml.transform.sax.SAXResult}, and
-{@link javax.xml.transform.dom.DOMSource} and
-{@link javax.xml.transform.dom.DOMResult}. Each of these objects defines
-a FEATURE string (which is i the form of a URL), which can be passed into
-{@link javax.xml.transform.TransformerFactory#getFeature} to see if the
-given type of Source or Result object is supported. For instance, to test if a
-DOMSource and a StreamResult is supported, you can apply the following
-test.
-</p>
-
-<pre>
-<code>
-TransformerFactory tfactory = TransformerFactory.newInstance();
-if (tfactory.getFeature(DOMSource.FEATURE) &amp;&amp; tfactory.getFeature(StreamResult.FEATURE)) {
-...
-}
-</code>
-</pre>
-
-
-<h3>
-<a name="qname-delimiter">Qualified Name Representation</a>
-</h3>
-
-<p><a href="http://www.w3.org/TR/REC-xml-names">Namespaces</a>
-present something of a problem area when dealing with XML objects. Qualified
-Names appear in XML markup as prefixed names. But the prefixes themselves do
-not hold identity. Rather, it is the URIs that they contextually map to that
-hold the identity. Therefore, when passing a Qualified Name like "xyz:foo"
-among Java programs, one must provide a means to map "xyz" to a namespace.
-</p>
-
-<p>One solution has been to create a "QName" object that holds the
-namespace URI, as well as the prefix and local name, but this is not always an
-optimal solution, as when, for example, you want to use unique strings as keys
-in a dictionary object. Not having a string representation also makes it
-difficult to specify a namespaced identity outside the context of an XML
-document.
-</p>
-
-<p>In order to pass namespaced values to transformations,
-for 
-instance when setting a property or a parameter on a 
-{@link javax.xml.transform.Transformer} object,
-this specification defines that a
-String "qname" object parameter be passed as two-part string, the namespace URI
-enclosed in curly braces ({}), followed by the local name. If the qname has a
-null URI, then the String object only contains the local name. An application
-can safely check for a non-null URI by testing to see if the first character of
-the name is a '{' character.
-</p>
-
-<p>For example, if a URI and local name were obtained from an element
-defined with &lt;xyz:foo xmlns:xyz="http://xyz.foo.com/yada/baz.html"/&gt;,
-then the Qualified Name would be "{http://xyz.foo.com/yada/baz.html}foo".
-Note that the prefix is lost.
-</p>
-
-
-<h3>Result Tree Serialization</h3>
-
-<p>Serialization of the result tree to a stream can be controlled with
-the {@link javax.xml.transform.Transformer#setOutputProperties} and the
-{@link javax.xml.transform.Transformer#setOutputProperty} methods.
-These properties only apply to stream results, they have no effect when
-the result is a DOM tree or SAX event stream.</p>
-
-<p>Strings that match the <a href="http://www.w3.org/TR/xslt#output">XSLT
-specification for xsl:output attributes</a> can be referenced from the
-{@link javax.xml.transform.OutputKeys} class. Other strings can be
-specified as well.
-If the transformer does not recognize an output key, a
-{@link java.lang.IllegalArgumentException} is thrown, unless the
-key name is <a href="#qname-delimiter">namespace qualified</a>. Output key names
-that are namespace qualified are always allowed, although they may be
-ignored by some implementations.</p>
-
-<p>If all that is desired is the simple identity transformation of a
-source to a result, then {@link javax.xml.transform.TransformerFactory}
-provides a
-{@link javax.xml.transform.TransformerFactory#newTransformer()} method
-with no arguments. This method creates a Transformer that effectively copies
-the source to the result. This method may be used to create a DOM from SAX
-events or to create an XML or HTML stream from a DOM or SAX events.  </p>
-
-<h3>Exceptions and Error Reporting</h3>
-
-<p>The transformation API throw three types of specialized exceptions. A
-{@link javax.xml.transform.TransformerFactoryConfigurationError} is parallel to
-the {@link javax.xml.parsers.FactoryConfigurationError}, and is thrown
-when a configuration problem with the TransformerFactory exists. This error
-will typically be thrown when the transformation factory class specified with
-the "javax.xml.transform.TransformerFactory" system property cannot be found or
-instantiated.</p>
-
-<p>A {@link javax.xml.transform.TransformerConfigurationException}
-may be thrown if for any reason a Transformer can not be created. A
-TransformerConfigurationException may be thrown if there is a syntax error in
-the transformation instructions, for example when
-{@link javax.xml.transform.TransformerFactory#newTransformer} is
-called.</p>
-
-<p>{@link javax.xml.transform.TransformerException} is a general
-exception that occurs during the course of a transformation. A transformer
-exception may wrap another exception, and if any of the
-{@link javax.xml.transform.TransformerException#printStackTrace()}
-methods are called on it, it will produce a list of stack dumps, starting from
-the most recent. The transformer exception also provides a
-{@link javax.xml.transform.SourceLocator} object which indicates where
-in the source tree or transformation instructions the error occurred.
-{@link javax.xml.transform.TransformerException#getMessageAndLocation()}
-may be called to get an error message with location info, and
-{@link javax.xml.transform.TransformerException#getLocationAsString()}
-may be called to get just the location string.</p>
-
-<p>Transformation warnings and errors are sent to an
-{@link javax.xml.transform.ErrorListener}, at which point the
-application may decide to report the error or warning, and may decide to throw
-an <code>Exception</code> for a non-fatal error. The <code>ErrorListener</code> may be set via
-{@link javax.xml.transform.TransformerFactory#setErrorListener} for
-reporting errors that have to do with syntax errors in the transformation
-instructions, or via
-{@link javax.xml.transform.Transformer#setErrorListener} to report
-errors that occur during the transformation. The <code>ErrorListener</code> on both objects
-will always be valid and non-<code>null</code>, whether set by the application or a default
-implementation provided by the processor.
-The default implementation provided by the processor will report all warnings and errors to <code>System.err</code>
-and does not throw any <code>Exception</code>s.
-Applications are <em>strongly</em> encouraged to register and use
-<code>ErrorListener</code>s that insure proper behavior for warnings and
-errors.
-</p>
-
-
-<h3>Resolution of URIs within a transformation</h3>
-
-<p>The API provides a way for URIs referenced from within the stylesheet
-instructions or within the transformation to be resolved by the calling
-application. This can be done by creating a class that implements the
-{@link javax.xml.transform.URIResolver} interface, with its one method,
-{@link javax.xml.transform.URIResolver#resolve}, and use this class to
-set the URI resolution for the transformation instructions or transformation
-with {@link javax.xml.transform.TransformerFactory#setURIResolver} or
-{@link javax.xml.transform.Transformer#setURIResolver}. The
-<code>URIResolver.resolve</code> method takes two String arguments, the URI found in the
-stylesheet instructions or built as part of the transformation process, and the
-base URI 
-against which the first argument will be made absolute if the
-absolute URI is required.
-The returned {@link javax.xml.transform.Source} object must be usable by
-the transformer, as specified in its implemented features.</p>
-
-
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/transform/overview.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/overview.html b/Build/src/main/java/org/openjdk/javax/xml/transform/overview.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/overview.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,291 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>Transformation API For XML</title>
-
-  <meta name="CVS"
-        content="$Id: overview.html,v 1.2 2005/06/10 03:50:39 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-<body> 
-  
-<h2>Transformation API For XML</h2> 
-  
-  
-<h3>Introduction</h3> 
-  
-<p>This overview describes the set of APIs contained in
-	 javax.xml.transform. For the sake of brevity, these interfaces are referred to
-	 as TrAX (Transformations for XML). </p> 
-  
-<p>There is a broad need for Java applications to be able to transform XML
-	 and related tree-shaped data structures. In fact, XML is not normally very
-	 useful to an application without going through some sort of transformation,
-	 unless the semantic structure is used directly as data. Almost all XML-related
-	 applications need to perform transformations. Transformations may be described
-	 by Java code, Perl code, <A href="http://www.w3.org/TR/xslt">XSLT</A>
-	 Stylesheets, other types of script, or by proprietary formats. The inputs, one
-	 or multiple, to a transformation, may be a URL, XML stream, a DOM tree, SAX
-	 Events, or a proprietary format or data structure. The output types are the
-	 pretty much the same types as the inputs, but different inputs may need to be
-	 combined with different outputs.</p> 
-  
-<p>The great challenge of a transformation API is how to deal with all the
-	 possible combinations of inputs and outputs, without becoming specialized for
-	 any of the given types.</p> 
-  
-<p>The Java community will greatly benefit from a common API that will
-	 allow them to understand and apply a single model, write to consistent
-	 interfaces, and apply the transformations polymorphically. TrAX attempts to
-	 define a model that is clean and generic, yet fills general application
-	 requirements across a wide variety of uses. </p> 
-   
-	 
-<h3>General Terminology</h3> 
-	 
-<p>This section will explain some general terminology used in this
-		document. Technical terminology will be explained in the Model section. In many
-		cases, the general terminology overlaps with the technical terminology.</p> 
-	 
-<ul>
-<li>
-<p>
-<b>Tree</b>
-<br>This term, as used within this document, describes an
-			 abstract structure that consists of nodes or events that may be produced by
-			 XML. A Tree physically may be a DOM tree, a series of well balanced parse
-			 events (such as those coming from a SAX2 ContentHander), a series of requests
-			 (the result of which can describe a tree), or a stream of marked-up
-			 characters.</p>
-</li>
-<li>
-<p>
-<b>Source Tree(s)</b>
-<br>One or more trees that are the inputs to the
-			 transformation.</p>
-</li>
-<li>
-<p>
-<b>Result Tree(s)</b>
-<br>One or more trees that are the output of the
-			 transformation.</p>
-</li>
-<li>
-<p>
-<b>Transformation</b>
-<br>The processor of consuming a stream or tree to produce
-			 another stream or tree.</p>
-</li>
-<li>
-<p>
-<b>Identity (or Copy) Transformation</b>
-<br>The process of transformation from a source to a result,
-			 making as few structural changes as possible and no informational changes. The
-			 term is somewhat loosely used, as the process is really a copy. from one
-			 "format" (such as a DOM tree, stream, or set of SAX events) to
-			 another.</p>
-</li>
-<li>
-<p>
-<b>Serialization</b>
-<br>The process of taking a tree and turning it into a stream. In
-			 some sense, a serialization is a specialized transformation.</p>
-</li>
-<li>
-<p>
-<b>Parsing</b>
-<br>The process of taking a stream and turning it into a tree. In
-			 some sense, parsing is a specialized transformation.</p>
-</li>
-<li>
-<p>
-<b>Transformer</b>
-<br>A Transformer is the object that executes the transformation.
-			 </p>
-</li>
-<li>
-<p>
-<b>Transformation instructions</b>
-<br>Describes the transformation. A form of code, script, or
-			 simply a declaration or series of declarations.</p>
-</li>
-<li>
-<p>
-<b>Stylesheet</b>
-<br>The same as "transformation instructions," except it is
-			 likely to be used in conjunction with <A href="http://www.w3.org/TR/xslt">XSLT</A>.</p>
-</li>
-<li>
-<p>
-<b>Templates</b>
-<br>Another form of "transformation instructions." In the TrAX
-			 interface, this term is used to describe processed or compiled transformation
-			 instructions. The Source flows through a Templates object to be formed into the
-			 Result.</p>
-</li>
-<li>
-<p>
-<b>Processor</b>
-<br>A general term for the thing that may both process the
-			 transformation instructions, and perform the transformation.</p>
-</li>
-<li>
-<p>
-<b>DOM</b>
-<br>Document Object Model, specifically referring to the
-			 <A href="#http://www.w3.org/TR/DOM-Level-2%20">Document Object Model
-			 (DOM) Level 2 Specification</A>.</p>
-</li>
-<li>
-	<p>
-		<b>SAX</b><br>
-		Simple API for XML, specifically referring to the <a href="http://sax.sourceforge.net/">SAX 2.0.2 release</a>.
-	</p>
-</li>
-</ul> 
-   
-  
-  
-<h3>Model</h3> 
-  
-<p>The section defines the abstract model for TrAX, apart from the details
-	 of the interfaces.</p> 
-  
-<p>A TRaX <A href="#pattern-TransformerFactory">TransformerFactory</A> is an object
-	 that processes transformation instructions, and produces
-	 <A href="#pattern-Templates">Templates</A> (in the technical
-	 terminology). A <A href="#pattern-Templates">Templates</A>
-	 object provides a <A href="#pattern-Transformer">Transformer</A>, which transforms one or
-	 more <A href="#pattern-Source">Source</A>s into one or more
-	 <A href="#pattern-Result">Result</A>s.</p> 
-  
-<p>To use the TRaX interface, you create a
-	 <A href="#pattern-TransformerFactory">TransformerFactory</A>,
-	 which may directly provide a <A href="#pattern-Transformers">Transformers</A>, or which can provide
-	 <A href="#pattern-Templates">Templates</A> from a variety of
-	 <A href="#pattern-Source">Source</A>s. The
-	 <A href="#pattern-Templates">Templates</A> object is a processed
-	 or compiled representation of the transformation instructions, and provides a
-	 <A href="#pattern-Transformer">Transformer</A>. The
-	 <A href="#pattern-Transformer">Transformer</A> processes a
-	 <A href="#pattern-Transformer">Source</A> according to the
-	 instructions found in the <A href="#pattern-Templates">Templates</A>, and produces a
-	 <A href="#pattern-Result">Result</A>.</p> 
-  
-<p>The process of transformation from a tree, either in the form of an
-	 object model, or in the form of parse events, into a stream, is known as
-	 <code>serialization</code>. We believe this is the most suitable term for
-	 this process, despite the overlap with Java object serialization.</p>
-  
-<H3>TRaX Patterns</H3>
-<ul>
-<p>
-<b><a name="pattern-Processor">Processor</a></b>
-<br>
-<br>
-<i>Intent: </i>Generic concept for the
-  set of objects that implement the TrAX interfaces.<br>
-<i>Responsibilities: </i>Create compiled transformation instructions, transform
-  sources, and manage transformation parameters and
-  properties.<br>
-<i>Thread safety: </i>Only the Templates object can be
-  used concurrently in multiple threads. The rest of the processor does not do
-  synchronized blocking, and so may not be used to perform multiple concurrent
-  operations. Different Processors can be used concurrently by different
-  threads.</p>
-<p>
-<b><a name="pattern-TransformerFactory">TransformerFactory</a></b>
-<br>
-<br>
-<i>Intent: </i>Serve as a vendor-neutral Processor interface for
-  <A href="http://www.w3.org/TR/xslt">XSLT</A> and similar
-  processors.<br>
-<i>Responsibilities: </i>Serve as a factory for a concrete
-  implementation of an TransformerFactory, serve as a direct factory for
-  Transformer objects, serve as a factory for Templates objects, and manage
-  processor specific features.<br>
-<i>Thread safety: </i>A
-  TransformerFactory may not perform mulitple concurrent
-  operations.</p>
-<p>
-<b><a name="pattern-Templates">Templates</a></b>
-<br>
-<br>
-<i>Intent: </i>The
-  runtime representation of the transformation instructions.<br>
-<i>Responsibilities: </i>A data bag for transformation instructions; act as a factory
-  for Transformers.<br>
-<i>Thread safety: </i>Threadsafe for concurrent
-  usage over multiple threads once construction is complete.</p>
-<p>
-<b><a name="pattern-Transformer">Transformer</a></b>
-<br>
-<br>
-<i>Intent: </i>Act as a per-thread
-  execution context for transformations, act as an interface for performing the
-  transformation.<br>
-<i>Responsibilities: </i>Perform the
-  transformation.<br>
-<i>Thread safety: </i>Only one instance per thread
-  is safe.<br>
-<i>Notes: </i>The Transformer is bound to the Templates
-  object that created it.</p>
-<p>
-<b><a name="pattern-Source">Source</a></b>
-<br>
-<br>
-<i>Intent: </i>Serve as a
-  single vendor-neutral object for multiple types of input.<br>
-<i>Responsibilities: </i>Act as simple data holder for System IDs, DOM nodes, streams,
-  etc.<br>
-<i>Thread safety: </i>Threadsafe concurrently over multiple
-  threads for read-only operations; must be synchronized for edit
-  operations.</p>
-<p>
-<b><a name="pattern-Result">Result</a></b>
-<br>
-<br>
-<i>Potential alternate name: </i>ResultTarget<br>
-<i>Intent: </i>Serve
-  as a single object for multiple types of output, so there can be simple process
-  method signatures.<br>
-<i>Responsibilities: </i>Act as simple data holder for
-  output stream, DOM node, ContentHandler, etc.<br>
-<i>Thread safety: </i>Threadsafe concurrently over multiple threads for read-only,
-  must be synchronized for edit.</p>
-</ul> 
-  
-
-</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/transform/Templates.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/Templates.java b/Build/src/main/java/org/openjdk/javax/xml/transform/Templates.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/Templates.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-import java.util.Properties;
-
-
-/**
- * An object that implements this interface is the runtime representation of processed
- * transformation instructions.
- *
- * <p>Templates must be threadsafe for a given instance
- * over multiple threads running concurrently, and may
- * be used multiple times in a given session.</p>
- */
-public interface Templates {
-
-    /**
-     * Create a new transformation context for this Templates object.
-     *
-     * @return A valid non-null instance of a Transformer.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException if a Transformer can not be created.
-     */
-    Transformer newTransformer() throws TransformerConfigurationException;
-
-    /**
-     * Get the properties corresponding to the effective xsl:output element.
-     * The object returned will
-     * be a clone of the internal values. Accordingly, it can be mutated
-     * without mutating the Templates object, and then handed in to
-     * {@link javax.xml.transform.Transformer#setOutputProperties}.
-     *
-     * <p>The properties returned should contain properties set by the stylesheet,
-     * and these properties are "defaulted" by default properties specified by
-     * <a href="http://www.w3.org/TR/xslt#output">section 16 of the
-     * XSL Transformations (XSLT) W3C Recommendation</a>.  The properties that
-     * were specifically set by the stylesheet should be in the base
-     * Properties list, while the XSLT default properties that were not
-     * specifically set should be in the "default" Properties list.  Thus,
-     * getOutputProperties().getProperty(String key) will obtain any
-     * property in that was set by the stylesheet, <em>or</em> the default
-     * properties, while
-     * getOutputProperties().get(String key) will only retrieve properties
-     * that were explicitly set in the stylesheet.</p>
-     *
-     * <p>For XSLT,
-     * <a href="http://www.w3.org/TR/xslt#attribute-value-templates">Attribute
-     * Value Templates</a> attribute values will
-     * be returned unexpanded (since there is no context at this point).  The
-     * namespace prefixes inside Attribute Value Templates will be unexpanded,
-     * so that they remain valid XPath values.</p>
-     *
-     * @return A Properties object, never null.
-     */
-    Properties getOutputProperties();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/OutputKeys.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/OutputKeys.java b/Build/src/main/java/org/openjdk/javax/xml/transform/OutputKeys.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/OutputKeys.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,200 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * Provides string constants that can be used to set
- * output properties for a Transformer, or to retrieve
- * output properties from a Transformer or Templates object.
- * <p>All the fields in this class are read-only.</p>
- *
- * @see <a href="http://www.w3.org/TR/xslt#output">
- *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
- */
-public class OutputKeys {
-
-    /**
-     * Default constructor is private on purpose.  This class is
-     * only for static variable access, and should never be constructed.
-     */
-    private OutputKeys() { }
-
-    /**
-     * method = "xml" | "html" | "text" | <var>expanded name</var>.
-     *
-     * <p>The value of the method property identifies the overall method that
-     * should be used for outputting the result tree.  Other non-namespaced
-     * values may be used, such as "xhtml", but, if accepted, the handling
-     * of such values is implementation defined.  If any of the method values
-     * are not accepted and are not namespace qualified,
-     * then {@link Transformer#setOutputProperty}
-     * or {@link Transformer#setOutputProperties} will
-     * throw a {@link java.lang.IllegalArgumentException}.</p>
-     *
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String METHOD = "method";
-
-    /**
-     * version = <var>nmtoken</var>.
-     *
-     * <p><code>version</code> specifies the version of the output
-     * method.</p>
-     * <p>When the output method is "xml", the version value specifies the
-     * version of XML to be used for outputting the result tree. The default
-     * value for the xml output method is 1.0. When the output method is
-     * "html", the version value indicates the version of the HTML.
-     * The default value for the xml output method is 4.0, which specifies
-     * that the result should be output as HTML conforming to the HTML 4.0
-     * Recommendation [HTML].  If the output method is "text", the version
-     * property is ignored.</p>
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String VERSION = "version";
-
-    /**
-     * encoding = <var>string</var>.
-     *
-     * <p><code>encoding</code> specifies the preferred character
-     * encoding that the Transformer should use to encode sequences of
-     * characters as sequences of bytes. The value of the encoding property should be
-     * treated case-insensitively. The value must only contain characters in
-     * the range #x21 to #x7E (i.e., printable ASCII characters). The value
-     * should either be a <code>charset</code> registered with the Internet
-     * Assigned Numbers Authority <a href="http://www.iana.org/">[IANA]</a>,
-     * <a href="http://www.ietf.org/rfc/rfc2278.txt">[RFC2278]</a>
-     * or start with <code>X-</code>.</p>
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     * section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String ENCODING = "encoding";
-
-    /**
-     * omit-xml-declaration = "yes" | "no".
-     *
-     * <p><code>omit-xml-declaration</code> specifies whether the XSLT
-     * processor should output an XML declaration; the value must be
-     * <code>yes</code> or <code>no</code>.</p>
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String OMIT_XML_DECLARATION = "omit-xml-declaration";
-
-    /**
-     * standalone = "yes" | "no".
-     *
-     * <p><code>standalone</code> specifies whether the Transformer
-     * should output a standalone document declaration; the value must be
-     * <code>yes</code> or <code>no</code>.</p>
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String STANDALONE = "standalone";
-
-    /**
-     * doctype-public = <var>string</var>.
-     * <p>See the documentation for the {@link #DOCTYPE_SYSTEM} property
-     * for a description of what the value of the key should be.</p>
-     *
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String DOCTYPE_PUBLIC = "doctype-public";
-
-    /**
-     * doctype-system = <var>string</var>.
-     * <p><code>doctype-system</code> specifies the system identifier
-     * to be used in the document type declaration.</p>
-     * <p>If the doctype-system property is specified, the xml output method
-     * should output a document type declaration immediately before the first
-     * element. The name following &lt;!DOCTYPE should be the name of the first
-     * element. If doctype-public property is also specified, then the xml
-     * output method should output PUBLIC followed by the public identifier
-     * and then the system identifier; otherwise, it should output SYSTEM
-     * followed by the system identifier. The internal subset should be empty.
-     * The value of the doctype-public property should be ignored unless the doctype-system
-     * property is specified.</p>
-     * <p>If the doctype-public or doctype-system properties are specified,
-     * then the html output method should output a document type declaration
-     * immediately before the first element. The name following &lt;!DOCTYPE
-     * should be HTML or html. If the doctype-public property is specified,
-     * then the output method should output PUBLIC followed by the specified
-     * public identifier; if the doctype-system property is also specified,
-     * it should also output the specified system identifier following the
-     * public identifier. If the doctype-system property is specified but
-     * the doctype-public property is not specified, then the output method
-     * should output SYSTEM followed by the specified system identifier.</p>
-     *
-     * <p><code>doctype-system</code> specifies the system identifier
-     * to be used in the document type declaration.</p>
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String DOCTYPE_SYSTEM = "doctype-system";
-
-    /**
-     * cdata-section-elements = <var>expanded names</var>.
-     *
-     * <p><code>cdata-section-elements</code> specifies a whitespace delimited
-     * list of the names of elements whose text node children should be output
-     * using CDATA sections. Note that these names must use the format
-     * described in the section Qualfied Name Representation in
-     * {@link javax.xml.transform}.</p>
-     *
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation.</a>
-     */
-    public static final String CDATA_SECTION_ELEMENTS =
-        "cdata-section-elements";
-
-    /**
-     * indent = "yes" | "no".
-     *
-     * <p><code>indent</code> specifies whether the Transformer may
-     * add additional whitespace when outputting the result tree; the value
-     * must be <code>yes</code> or <code>no</code>.  </p>
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *  section 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String INDENT = "indent";
-
-    /**
-     * media-type = <var>string</var>.
-     *
-     * <p><code>media-type</code> specifies the media type (MIME
-     * content type) of the data that results from outputting the result
-     * tree. The <code>charset</code> parameter should not be specified
-     * explicitly; instead, when the top-level media type is
-     * <code>text</code>, a <code>charset</code> parameter should be added
-     * according to the character encoding actually used by the output
-     * method.  </p>
-     * @see <a href="http://www.w3.org/TR/xslt#output">s
-     * ection 16 of the XSL Transformations (XSLT) W3C Recommendation</a>
-     */
-    public static final String MEDIA_TYPE = "media-type";
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/Transformer.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/Transformer.java b/Build/src/main/java/org/openjdk/javax/xml/transform/Transformer.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/Transformer.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,341 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-import javax.xml.parsers.DocumentBuilder;
-
-import java.util.Properties;
-
-/**
- * An instance of this abstract class can transform a
- * source tree into a result tree.
- *
- * <p>An instance of this class can be obtained with the
- * {@link javax.xml.transform.TransformerFactory#newTransformer TransformerFactory.newTransformer}
- * method. This instance may then be used to process XML from a
- * variety of sources and write the transformation output to a
- * variety of sinks.</p>
- *
- * <p>An object of this class may not be used in multiple threads
- * running concurrently.  Different Transformers may be used
- * concurrently by different threads.</p>
- *
- * <p>A <code>Transformer</code> may be used multiple times.  Parameters and
- * output properties are preserved across transformations.</p>
- *
- * @author <a href="Jeff.Suttor@Sun.com">Jeff Suttor</a>
- */
-public abstract class Transformer {
-
-    /**
-     * Default constructor is protected on purpose.
-     */
-    protected Transformer() { }
-
-        /**
-         * <p>Reset this <code>Transformer</code> to its original configuration.</p>
-         *
-         * <p><code>Transformer</code> is reset to the same state as when it was created with
-         * {@link javax.xml.transform.TransformerFactory#newTransformer()},
-         * {@link TransformerFactory#newTransformer(javax.xml.transform.Source source)} or
-         * {@link Templates#newTransformer()}.
-         * <code>reset()</code> is designed to allow the reuse of existing <code>Transformer</code>s
-         * thus saving resources associated with the creation of new <code>Transformer</code>s.</p>
-         *
-         * <p>The reset <code>Transformer</code> is not guaranteed to have the same {@link javax.xml.transform.URIResolver}
-         * or {@link javax.xml.transform.ErrorListener} <code>Object</code>s, e.g. {@link Object#equals(Object obj)}.
-         * It is guaranteed to have a functionally equal <code>URIResolver</code>
-         * and <code>ErrorListener</code>.</p>
-     *
-     * @throws UnsupportedOperationException When implementation does not
-     *   override this method.
-         *
-         * @since 1.5
-         */
-        public void reset() {
-
-                // implementors should override this method
-                throw new UnsupportedOperationException(
-                        "This Transformer, \"" + this.getClass().getName() + "\", does not support the reset functionality."
-                        + "  Specification \"" + this.getClass().getPackage().getSpecificationTitle() + "\""
-                        + " version \"" + this.getClass().getPackage().getSpecificationVersion() + "\""
-                        );
-        }
-
-    /**
-     * <p>Transform the XML <code>Source</code> to a <code>Result</code>.
-     * Specific transformation behavior is determined by the settings of the
-     * <code>TransformerFactory</code> in effect when the
-     * <code>Transformer</code> was instantiated and any modifications made to
-     * the <code>Transformer</code> instance.</p>
-     *
-     * <p>An empty <code>Source</code> is represented as an empty document
-     * as constructed by {@link DocumentBuilder#newDocument()}.
-     * The result of transforming an empty <code>Source</code> depends on
-     * the transformation behavior; it is not always an empty
-     * <code>Result</code>.</p>
-     *
-     * @param xmlSource The XML input to transform.
-     * @param outputTarget The <code>Result</code> of transforming the
-     *   <code>xmlSource</code>.
-     *
-     * @throws javax.xml.transform.TransformerException If an unrecoverable error occurs
-     *   during the course of the transformation.
-     */
-    public abstract void transform(Source xmlSource, Result outputTarget)
-        throws TransformerException;
-
-    /**
-     * Add a parameter for the transformation.
-     *
-     * <p>Pass a qualified name as a two-part string, the namespace URI
-     * enclosed in curly braces ({}), followed by the local name. If the
-     * name has a null URL, the String only contain the local name. An
-     * application can safely check for a non-null URI by testing to see if the
-     * first character of the name is a '{' character.</p>
-     * <p>For example, if a URI and local name were obtained from an element
-     * defined with &lt;xyz:foo
-     * xmlns:xyz="http://xyz.foo.com/yada/baz.html"/&gt;,
-     * then the qualified name would be "{http://xyz.foo.com/yada/baz.html}foo".
-     * Note that no prefix is used.</p>
-     *
-     * @param name The name of the parameter, which may begin with a
-     * namespace URI in curly braces ({}).
-     * @param value The value object.  This can be any valid Java object. It is
-     * up to the processor to provide the proper object coersion or to simply
-     * pass the object on for use in an extension.
-     *
-     * @throws NullPointerException If value is null.
-     */
-     public abstract void setParameter(String name, Object value);
-
-    /**
-     * Get a parameter that was explicitly set with setParameter.
-     *
-     * <p>This method does not return a default parameter value, which
-     * cannot be determined until the node context is evaluated during
-     * the transformation process.
-     *
-     * @param name of <code>Object</code> to get
-     *
-     * @return A parameter that has been set with setParameter.
-     */
-    public abstract Object getParameter(String name);
-
-    /**
-     * <p>Set a list of parameters.</p>
-     *
-     * <p>Note that the list of parameters is specified as a
-     * <code>Properties</code> <code>Object</code> which limits the parameter
-     * values to <code>String</code>s.  Multiple calls to
-     * {@link #setParameter(String name, Object value)} should be used when the
-     * desired values are non-<code>String</code> <code>Object</code>s.
-     * The parameter names should conform as specified in
-     * {@link #setParameter(String name, Object value)}.
-     * An <code>IllegalArgumentException</code> is thrown if any names do not
-     * conform.</p>
-     *
-     * <p>New parameters in the list are added to any existing parameters.
-     * If the name of a new parameter is equal to the name of an existing
-     * parameter as determined by {@link java.lang.Object#equals(Object obj)},
-     *  the existing parameter is set to the new value.</p>
-     *
-     * @param params Parameters to set.
-     *
-     * @throws IllegalArgumentException If any parameter names do not conform
-     *   to the naming rules.
-     */
-
-    /**
-     * Clear all parameters set with setParameter.
-     */
-    public abstract void clearParameters();
-
-    /**
-     * Set an object that will be used to resolve URIs used in
-     * document().
-     *
-     * <p>If the resolver argument is null, the URIResolver value will
-     * be cleared and the transformer will no longer have a resolver.</p>
-     *
-     * @param resolver An object that implements the URIResolver interface,
-     * or null.
-     */
-    public abstract void setURIResolver(javax.xml.transform.URIResolver resolver);
-
-    /**
-     * Get an object that will be used to resolve URIs used in
-     * document().
-     *
-     * @return An object that implements the URIResolver interface,
-     * or null.
-     */
-    public abstract URIResolver getURIResolver();
-
-    /**
-     * Set the output properties for the transformation.  These
-     * properties will override properties set in the Templates
-     * with xsl:output.
-     *
-     * <p>If argument to this function is null, any properties
-     * previously set are removed, and the value will revert to the value
-     * defined in the templates object.</p>
-     *
-     * <p>Pass a qualified property key name as a two-part string, the namespace
-     * URI enclosed in curly braces ({}), followed by the local name. If the
-     * name has a null URL, the String only contain the local name. An
-     * application can safely check for a non-null URI by testing to see if the
-     * first character of the name is a '{' character.</p>
-     * <p>For example, if a URI and local name were obtained from an element
-     * defined with &lt;xyz:foo
-     * xmlns:xyz="http://xyz.foo.com/yada/baz.html"/&gt;,
-     * then the qualified name would be "{http://xyz.foo.com/yada/baz.html}foo".
-     * Note that no prefix is used.</p>
-     * An <code>IllegalArgumentException</code> is thrown  if any of the
-     * argument keys are not recognized and are not namespace qualified.
-     *
-     * @param oformat A set of output properties that will be
-     *   used to override any of the same properties in affect
-     *   for the transformation.
-     *
-     * @throws IllegalArgumentException When keys are not recognized and
-     *   are not namespace qualified.
-     *
-     * @see OutputKeys
-     * @see java.util.Properties
-     *
-     */
-    public abstract void setOutputProperties(Properties oformat);
-
-    /**
-     * <p>Get a copy of the output properties for the transformation.</p>
-     *
-     * <p>The properties returned should contain properties set by the user,
-     * and properties set by the stylesheet, and these properties
-     * are "defaulted" by default properties specified by
-     * <a href="http://www.w3.org/TR/xslt#output">section 16 of the
-     * XSL Transformations (XSLT) W3C Recommendation</a>.  The properties that
-     * were specifically set by the user or the stylesheet should be in the base
-     * Properties list, while the XSLT default properties that were not
-     * specifically set should be the default Properties list.  Thus,
-     * getOutputProperties().getProperty(String key) will obtain any
-     * property in that was set by {@link #setOutputProperty},
-     * {@link #setOutputProperties}, in the stylesheet, <em>or</em> the default
-     * properties, while
-     * getOutputProperties().get(String key) will only retrieve properties
-     * that were explicitly set by {@link #setOutputProperty},
-     * {@link #setOutputProperties}, or in the stylesheet.</p>
-     *
-     * <p>Note that mutation of the Properties object returned will not
-     * effect the properties that the transformer contains.</p>
-     *
-     * <p>If any of the argument keys are not recognized and are not
-     * namespace qualified, the property will be ignored and not returned.
-     * In other words the behaviour is not orthogonal with
-     * {@link #setOutputProperties setOutputProperties}.</p>
-     *
-     * @return A copy of the set of output properties in effect for
-     *   the next transformation.
-     *
-     * @see OutputKeys
-     * @see java.util.Properties
-     * @see <a href="http://www.w3.org/TR/xslt#output">
-     *   XSL Transformations (XSLT) Version 1.0</a>
-     */
-    public abstract Properties getOutputProperties();
-
-    /**
-     * Set an output property that will be in effect for the
-     * transformation.
-     *
-     * <p>Pass a qualified property name as a two-part string, the namespace URI
-     * enclosed in curly braces ({}), followed by the local name. If the
-     * name has a null URL, the String only contain the local name. An
-     * application can safely check for a non-null URI by testing to see if the
-     * first character of the name is a '{' character.</p>
-     * <p>For example, if a URI and local name were obtained from an element
-     * defined with &lt;xyz:foo
-     * xmlns:xyz="http://xyz.foo.com/yada/baz.html"/&gt;,
-     * then the qualified name would be "{http://xyz.foo.com/yada/baz.html}foo".
-     * Note that no prefix is used.</p>
-     *
-     * <p>The Properties object that was passed to {@link #setOutputProperties}
-     * won't be effected by calling this method.</p>
-     *
-     * @param name A non-null String that specifies an output
-     * property name, which may be namespace qualified.
-     * @param value The non-null string value of the output property.
-     *
-     * @throws IllegalArgumentException If the property is not supported, and is
-     * not qualified with a namespace.
-     *
-     * @see OutputKeys
-     */
-    public abstract void setOutputProperty(String name, String value)
-        throws IllegalArgumentException;
-
-    /**
-     * <p>Get an output property that is in effect for the transformer.</p>
-     *
-     * <p>If a property has been set using {@link #setOutputProperty},
-     * that value will be returned. Otherwise, if a property is explicitly
-     * specified in the stylesheet, that value will be returned. If
-     * the value of the property has been defaulted, that is, if no
-     * value has been set explicitly either with {@link #setOutputProperty} or
-     * in the stylesheet, the result may vary depending on
-     * implementation and input stylesheet.</p>
-     *
-     * @param name A non-null String that specifies an output
-     * property name, which may be namespace qualified.
-     *
-     * @return The string value of the output property, or null
-     * if no property was found.
-     *
-     * @throws IllegalArgumentException If the property is not supported.
-     *
-     * @see OutputKeys
-     */
-    public abstract String getOutputProperty(String name)
-        throws IllegalArgumentException;
-
-    /**
-     * Set the error event listener in effect for the transformation.
-     *
-     * @param listener The new error listener.
-     *
-     * @throws IllegalArgumentException if listener is null.
-     */
-    public abstract void setErrorListener(javax.xml.transform.ErrorListener listener)
-        throws IllegalArgumentException;
-
-    /**
-     * Get the error event handler in effect for the transformation.
-     * Implementations must provide a default error listener.
-     *
-     * @return The current error handler, which should never be null.
-     */
-    public abstract ErrorListener getErrorListener();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/URIResolver.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/URIResolver.java b/Build/src/main/java/org/openjdk/javax/xml/transform/URIResolver.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/URIResolver.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,50 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * <p>An object that implements this interface that can be called by the processor
- * to turn a URI used in document(), xsl:import, or xsl:include into a Source object.
- */
-public interface URIResolver {
-
-    /**
-     * Called by the processor when it encounters
-     * an xsl:include, xsl:import, or document() function.
-     *
-     * @param href An href attribute, which may be relative or absolute.
-     * @param base The base URI against which the first argument will be made
-     * absolute if the absolute URI is required.
-     *
-     * @return A Source object, or null if the href cannot be resolved,
-     * and the processor should try to resolve the URI itself.
-     *
-     * @throws javax.xml.transform.TransformerException if an error occurs when trying to
-     * resolve the URI.
-     */
-    public Source resolve(String href, String base)
-        throws TransformerException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/ErrorListener.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/ErrorListener.java b/Build/src/main/java/org/openjdk/javax/xml/transform/ErrorListener.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/ErrorListener.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,117 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * <p>To provide customized error handling, implement this interface and
- * use the <code>setErrorListener</code> method to register an instance of the
- * implmentation with the {@link Transformer}.  The
- * <code>Transformer</code> then reports all errors and warnings through this
- * interface.</p>
- *
- * <p>If an application does <em>not</em> register its own custom
- * <code>ErrorListener</code>, the default <code>ErrorListener</code>
- * is used which reports all warnings and errors to <code>System.err</code>
- * and does not throw any <code>Exception</code>s.
- * Applications are <em>strongly</em> encouraged to register and use
- * <code>ErrorListener</code>s that insure proper behavior for warnings and
- * errors.</p>
- *
- * <p>For transformation errors, a <code>Transformer</code> must use this
- * interface instead of throwing an <code>Exception</code>: it is up to the
- * application to decide whether to throw an <code>Exception</code> for
- * different types of errors and warnings.  Note however that the
- * <code>Transformer</code> is not required to continue with the transformation
- * after a call to {@link #fatalError(javax.xml.transform.TransformerException exception)}.</p>
- *
- * <p><code>Transformer</code>s may use this mechanism to report XML parsing
- * errors as well as transformation errors.</p>
- */
-public interface ErrorListener {
-
-    /**
-     * Receive notification of a warning.
-     *
-     * <p>{@link Transformer} can use this method to report
-     * conditions that are not errors or fatal errors.  The default behaviour
-     * is to take no action.</p>
-     *
-     * <p>After invoking this method, the Transformer must continue with
-     * the transformation. It should still be possible for the
-     * application to process the document through to the end.</p>
-     *
-     * @param exception The warning information encapsulated in a
-     *                  transformer exception.
-     *
-     * @throws javax.xml.transform.TransformerException if the application
-     * chooses to discontinue the transformation.
-     *
-     * @see javax.xml.transform.TransformerException
-     */
-    public abstract void warning(javax.xml.transform.TransformerException exception)
-        throws javax.xml.transform.TransformerException;
-
-    /**
-     * Receive notification of a recoverable error.
-     *
-     * <p>The transformer must continue to try and provide normal transformation
-     * after invoking this method.  It should still be possible for the
-     * application to process the document through to the end if no other errors
-     * are encountered.</p>
-     *
-     * @param exception The error information encapsulated in a
-     *                  transformer exception.
-     *
-     * @throws javax.xml.transform.TransformerException if the application
-     * chooses to discontinue the transformation.
-     *
-     * @see javax.xml.transform.TransformerException
-     */
-    public abstract void error(javax.xml.transform.TransformerException exception)
-        throws javax.xml.transform.TransformerException;
-
-    /**
-     * <p>Receive notification of a non-recoverable error.</p>
-     *
-     * <p>The processor may choose to continue, but will not normally
-     * proceed to a successful completion.</p>
-     *
-     * <p>The method should throw an exception if it is unable to
-     * process the error, or if it wishes execution to terminate
-     * immediately. The processor will not necessarily honor this
-     * request.</p>
-     *
-     * @param exception The error information encapsulated in a
-     *    <code>TransformerException</code>.
-     *
-     * @throws javax.xml.transform.TransformerException if the application
-     * chooses to discontinue the transformation.
-     *
-     * @see javax.xml.transform.TransformerException
-     */
-    public abstract void fatalError(javax.xml.transform.TransformerException exception)
-        throws TransformerException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/FactoryFinder.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/FactoryFinder.java b/Build/src/main/java/org/openjdk/javax/xml/transform/FactoryFinder.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/FactoryFinder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,349 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-import java.io.File;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Iterator;
-import java.util.Properties;
-import java.util.ServiceConfigurationError;
-import java.util.ServiceLoader;
-
-/**
- * <p>Implements pluggable Datatypes.</p>
- *
- * <p>This class is duplicated for each JAXP subpackage so keep it in
- * sync.  It is package private for secure class loading.</p>
- *
- * @author Santiago.PericasGeertsen@sun.com
- * @author Huizhe.Wang@oracle.com
- */
-class FactoryFinder {
-    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xalan.internal.";
-
-    /**
-     * Internal debug flag.
-     */
-    private static boolean debug = false;
-
-    /**
-     * Cache for properties in java.home/lib/jaxp.properties
-     */
-    private final static Properties cacheProps = new Properties();
-
-    /**
-     * Flag indicating if properties from java.home/lib/jaxp.properties
-     * have been cached.
-     */
-    static volatile boolean firstTime = true;
-
-    /**
-     * Security support class use to check access control before
-     * getting certain system resources.
-     */
-    private final static SecuritySupport ss = new SecuritySupport();
-
-    // Define system property "jaxp.debug" to get output
-    static {
-        // Use try/catch block to support applets, which throws
-        // SecurityException out of this code.
-        try {
-            String val = ss.getSystemProperty("jaxp.debug");
-            // Allow simply setting the prop to turn on debug
-            debug = val != null && !"false".equals(val);
-        }
-        catch (SecurityException se) {
-            debug = false;
-        }
-    }
-
-    private static void dPrint(String msg) {
-        if (debug) {
-            System.err.println("JAXP: " + msg);
-        }
-    }
-
-    /**
-     * Attempt to load a class using the class loader supplied. If that fails
-     * and fall back is enabled, the current (i.e. bootstrap) class loader is
-     * tried.
-     *
-     * If the class loader supplied is <code>null</code>, first try using the
-     * context class loader followed by the current (i.e. bootstrap) class
-     * loader.
-     *
-     * Use bootstrap classLoader if cl = null and useBSClsLoader is true
-     */
-    static private Class<?> getProviderClass(String className, ClassLoader cl,
-            boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException
-    {
-        try {
-            if (cl == null) {
-                if (useBSClsLoader) {
-                    return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-                } else {
-                    cl = ss.getContextClassLoader();
-                    if (cl == null) {
-                        throw new ClassNotFoundException();
-                    }
-                    else {
-                        return Class.forName(className, false, cl);
-                    }
-                }
-            }
-            else {
-                return Class.forName(className, false, cl);
-            }
-        }
-        catch (ClassNotFoundException e1) {
-            if (doFallback) {
-                // Use current class loader - should always be bootstrap CL
-                return Class.forName(className, false, FactoryFinder.class.getClassLoader());
-            }
-            else {
-                throw e1;
-            }
-        }
-    }
-
-    /**
-     * Create an instance of a class. Delegates to method
-     * <code>getProviderClass()</code> in order to load the class.
-     *
-     * @param type Base class / Service interface  of the factory to
-     *             instantiate.
-     *
-     * @param className Name of the concrete class corresponding to the
-     * service provider
-     *
-     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     * current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @param doFallback True if the current ClassLoader should be tried as
-     * a fallback if the class is not found using cl
-     *
-     * @param useServicesMechanism True use services mechanism
-     */
-    static <T> T newInstance(Class<T> type, String className, ClassLoader cl,
-                             boolean doFallback, boolean useServicesMechanism)
-        throws javax.xml.transform.TransformerFactoryConfigurationError
-    {
-        assert type != null;
-
-        boolean useBSClsLoader = false;
-        // make sure we have access to restricted packages
-        if (System.getSecurityManager() != null) {
-            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
-                cl = null;
-                useBSClsLoader = true;
-            }
-        }
-
-        try {
-            Class<?> providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
-            if (!type.isAssignableFrom(providerClass)) {
-                throw new ClassCastException(className + " cannot be cast to " + type.getName());
-            }
-            Object instance = null;
-            if (!useServicesMechanism) {
-                instance = newInstanceNoServiceLoader(type, providerClass);
-            }
-            if (instance == null) {
-                instance = providerClass.newInstance();
-            }
-            if (debug) {    // Extra check to avoid computing cl strings
-                dPrint("created new instance of " + providerClass +
-                       " using ClassLoader: " + cl);
-            }
-            return type.cast(instance);
-        }
-        catch (ClassNotFoundException x) {
-            throw new javax.xml.transform.TransformerFactoryConfigurationError(x,
-                "Provider " + className + " not found");
-        }
-        catch (Exception x) {
-            throw new javax.xml.transform.TransformerFactoryConfigurationError(x,
-                "Provider " + className + " could not be instantiated: " + x);
-        }
-    }
-
-    /**
-     * Try to construct using newTransformerFactoryNoServiceLoader
-     *   method if available.
-     */
-    private static <T> T newInstanceNoServiceLoader(Class<T> type, Class<?> providerClass) {
-        // Retain maximum compatibility if no security manager.
-        if (System.getSecurityManager() == null) {
-            return null;
-        }
-        try {
-            final Method creationMethod =
-                    providerClass.getDeclaredMethod(
-                        "newTransformerFactoryNoServiceLoader"
-                    );
-            final int modifiers = creationMethod.getModifiers();
-
-            // Do not call the method if it's not public static.
-            if (!Modifier.isPublic(modifiers) || !Modifier.isStatic(modifiers)) {
-                return null;
-            }
-
-            // Only call the method if it's declared to return an instance of
-            // TransformerFactory
-            final Class<?> returnType = creationMethod.getReturnType();
-            if (type.isAssignableFrom(returnType)) {
-                final Object result = creationMethod.invoke(null, (Object[])null);
-                return type.cast(result);
-            } else {
-                // This should not happen, as
-                // TransformerFactoryImpl.newTransformerFactoryNoServiceLoader is
-                // declared to return TransformerFactory.
-                throw new ClassCastException(returnType + " cannot be cast to " + type);
-            }
-        } catch (ClassCastException e) {
-            throw new javax.xml.transform.TransformerFactoryConfigurationError(e, e.getMessage());
-        } catch (NoSuchMethodException exc) {
-            return null;
-        } catch (Exception exc) {
-            return null;
-        }
-    }
-
-    /**
-     * Finds the implementation Class object in the specified order.  Main
-     * entry point.
-     * @return Class object of factory, never null
-     *
-     * @param type                  Base class / Service interface  of the
-     *                              factory to find.
-     *
-     * @param fallbackClassName     Implementation class name, if nothing else
-     *                              is found.  Use null to mean no fallback.
-     *
-     * Package private so this code can be shared.
-     */
-    static <T> T find(Class<T> type, String fallbackClassName)
-        throws javax.xml.transform.TransformerFactoryConfigurationError
-    {
-        assert type != null;
-
-        final String factoryId = type.getName();
-
-        dPrint("find factoryId =" + factoryId);
-        // Use the system property first
-        try {
-            String systemProp = ss.getSystemProperty(factoryId);
-            if (systemProp != null) {
-                dPrint("found system property, value=" + systemProp);
-                return newInstance(type, systemProp, null, true, true);
-            }
-        }
-        catch (SecurityException se) {
-            if (debug) se.printStackTrace();
-        }
-
-        // try to read from $java.home/lib/jaxp.properties
-        try {
-            if (firstTime) {
-                synchronized (cacheProps) {
-                    if (firstTime) {
-                        String configFile = ss.getSystemProperty("java.home") + File.separator +
-                            "lib" + File.separator + "jaxp.properties";
-                        File f = new File(configFile);
-                        firstTime = false;
-                        if (ss.doesFileExist(f)) {
-                            dPrint("Read properties file "+f);
-                            cacheProps.load(ss.getFileInputStream(f));
-                        }
-                    }
-                }
-            }
-            final String factoryClassName = cacheProps.getProperty(factoryId);
-
-            if (factoryClassName != null) {
-                dPrint("found in $java.home/jaxp.properties, value=" + factoryClassName);
-                return newInstance(type, factoryClassName, null, true, true);
-            }
-        }
-        catch (Exception ex) {
-            if (debug) ex.printStackTrace();
-        }
-
-        // Try Jar Service Provider Mechanism
-        T provider = findServiceProvider(type);
-        if (provider != null) {
-            return provider;
-        }
-        if (fallbackClassName == null) {
-            throw new javax.xml.transform.TransformerFactoryConfigurationError(null,
-                "Provider for " + factoryId + " cannot be found");
-        }
-
-        dPrint("loaded from fallback value: " + fallbackClassName);
-        return newInstance(type, fallbackClassName, null, true, true);
-    }
-
-    /*
-     * Try to find provider using the ServiceLoader.
-     *
-     * @param type Base class / Service interface  of the factory to find.
-     *
-     * @return instance of provider class if found or null
-     */
-    private static <T> T findServiceProvider(final Class<T> type)
-        throws javax.xml.transform.TransformerFactoryConfigurationError
-    {
-      try {
-            return AccessController.doPrivileged(new PrivilegedAction<T>() {
-                public T run() {
-                    final ServiceLoader<T> serviceLoader = ServiceLoader.load(type);
-                    final Iterator<T> iterator = serviceLoader.iterator();
-                    if (iterator.hasNext()) {
-                        return iterator.next();
-                    } else {
-                        return null;
-                    }
-                 }
-            });
-        } catch(ServiceConfigurationError e) {
-            // It is not possible to wrap an error directly in
-            // FactoryConfigurationError - so we need to wrap the
-            // ServiceConfigurationError in a RuntimeException.
-            // The alternative would be to modify the logic in
-            // FactoryConfigurationError to allow setting a
-            // Throwable as the cause, but that could cause
-            // compatibility issues down the road.
-            final RuntimeException x = new RuntimeException(
-                    "Provider for " + type + " cannot be created", e);
-            final javax.xml.transform.TransformerFactoryConfigurationError error =
-                    new TransformerFactoryConfigurationError(x, x.getMessage());
-            throw error;
-        }
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/SourceLocator.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/SourceLocator.java b/Build/src/main/java/org/openjdk/javax/xml/transform/SourceLocator.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/SourceLocator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,96 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * This interface is primarily for the purposes of reporting where
- * an error occurred in the XML source or transformation instructions.
- */
-public interface SourceLocator {
-
-    /**
-     * Return the public identifier for the current document event.
-     *
-     * <p>The return value is the public identifier of the document
-     * entity or of the external parsed entity in which the markup that
-     * triggered the event appears.</p>
-     *
-     * @return A string containing the public identifier, or
-     *         null if none is available.
-     * @see #getSystemId
-     */
-    public String getPublicId();
-
-    /**
-     * Return the system identifier for the current document event.
-     *
-     * <p>The return value is the system identifier of the document
-     * entity or of the external parsed entity in which the markup that
-     * triggered the event appears.</p>
-     *
-     * <p>If the system identifier is a URL, the parser must resolve it
-     * fully before passing it to the application.</p>
-     *
-     * @return A string containing the system identifier, or null
-     *         if none is available.
-     * @see #getPublicId
-     */
-    public String getSystemId();
-
-    /**
-     * Return the line number where the current document event ends.
-     *
-     * <p><strong>Warning:</strong> The return value from the method
-     * is intended only as an approximation for the sake of error
-     * reporting; it is not intended to provide sufficient information
-     * to edit the character content of the original XML document.</p>
-     *
-     * <p>The return value is an approximation of the line number
-     * in the document entity or external parsed entity where the
-     * markup that triggered the event appears.</p>
-     *
-     * @return The line number, or -1 if none is available.
-     * @see #getColumnNumber
-     */
-    public int getLineNumber();
-
-    /**
-     * Return the character position where the current document event ends.
-     *
-     * <p><strong>Warning:</strong> The return value from the method
-     * is intended only as an approximation for the sake of error
-     * reporting; it is not intended to provide sufficient information
-     * to edit the character content of the original XML document.</p>
-     *
-     * <p>The return value is an approximation of the column number
-     * in the document entity or external parsed entity where the
-     * markup that triggered the event appears.</p>
-     *
-     * @return The column number, or -1 if none is available.
-     * @see #getLineNumber
-     */
-    public int getColumnNumber();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/SecuritySupport.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/SecuritySupport.java b/Build/src/main/java/org/openjdk/javax/xml/transform/SecuritySupport.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/SecuritySupport.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,108 +0,0 @@
-/*
- * Copyright (c) 2004, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-import java.security.*;
-import java.net.*;
-import java.io.*;
-import java.util.*;
-
-/**
- * This class is duplicated for each JAXP subpackage so keep it in sync.
- * It is package private and therefore is not exposed as part of the JAXP
- * API.
- *
- * Security related methods that only work on J2SE 1.2 and newer.
- */
-class SecuritySupport  {
-
-
-    ClassLoader getContextClassLoader() throws SecurityException{
-        return (ClassLoader)
-        AccessController.doPrivileged(new PrivilegedAction() {
-            public Object run() {
-                ClassLoader cl = null;
-                //try {
-                cl = Thread.currentThread().getContextClassLoader();
-                //} catch (SecurityException ex) { }
-                if (cl == null)
-                    cl = ClassLoader.getSystemClassLoader();
-                return cl;
-            }
-        });
-    }
-
-    String getSystemProperty(final String propName) {
-        return (String)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(propName);
-                }
-            });
-    }
-
-    FileInputStream getFileInputStream(final File file)
-        throws FileNotFoundException
-    {
-        try {
-            return (FileInputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws FileNotFoundException {
-                        return new FileInputStream(file);
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (FileNotFoundException)e.getException();
-        }
-    }
-
-    InputStream getResourceAsStream(final ClassLoader cl,
-                                           final String name)
-    {
-        return (InputStream)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    InputStream ris;
-                    if (cl == null) {
-                        ris = Object.class.getResourceAsStream(name);
-                    } else {
-                        ris = cl.getResourceAsStream(name);
-                    }
-                    return ris;
-                }
-            });
-    }
-
-    boolean doesFileExist(final File f) {
-    return ((Boolean)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return new Boolean(f.exists());
-                }
-            })).booleanValue();
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactory.java b/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,424 +0,0 @@
-/*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-import javax.xml.XMLConstants;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.stream.StreamSource;
-
-/**
- * <p>A TransformerFactory instance can be used to create
- * {@link javax.xml.transform.Transformer} and
- * {@link javax.xml.transform.Templates} objects.</p>
- *
- * <p>The system property that determines which Factory implementation
- * to create is named <code>"javax.xml.transform.TransformerFactory"</code>.
- * This property names a concrete subclass of the
- * <code>TransformerFactory</code> abstract class. If the property is not
- * defined, a platform default is be used.</p>
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @author <a href="mailto:Neeraj.Bajaj@sun.com">Neeraj Bajaj</a>
- *
- * @since 1.5
- */
-public abstract class TransformerFactory {
-
-    /**
-     * Default constructor is protected on purpose.
-     */
-    protected TransformerFactory() { }
-
-
-
-    /**
-     * <p>Obtain a new instance of a <code>TransformerFactory</code>.
-     * This static method creates a new factory instance.</p>
-     * <p>This method uses the following ordered lookup procedure to determine
-     * the <code>TransformerFactory</code> implementation class to
-     * load:</p>
-     * <ul>
-     * <li>
-     * Use the <code>javax.xml.transform.TransformerFactory</code> system
-     * property.
-     * </li>
-     * <li>
-     * Use the properties file "lib/jaxp.properties" in the JRE directory.
-     * This configuration file is in standard <code>java.util.Properties
-     * </code> format and contains the fully qualified name of the
-     * implementation class with the key being the system property defined
-     * above.
-     * <br>
-     * The jaxp.properties file is read only once by the JAXP implementation
-     * and it's values are then cached for future use.  If the file does not exist
-     * when the first attempt is made to read from it, no further attempts are
-     * made to check for its existence.  It is not possible to change the value
-     * of any property in jaxp.properties after it has been read for the first time.
-     * </li>
-     * <li>
-     *   Use the service-provider loading facilities, defined by the
-     *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-     *   implementation of the service using the {@linkplain
-     *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-     *   the service-provider loading facility will use the {@linkplain
-     *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-     *   to attempt to load the service. If the context class
-     *   loader is null, the {@linkplain
-     *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-     * </li>
-     * <li>
-     *   Otherwise, the system-default implementation is returned.
-     * </li>
-     * </ul>
-     *
-     * <p>Once an application has obtained a reference to a <code>
-     * TransformerFactory</code> it can use the factory to configure
-     * and obtain transformer instances.</p>
-     *
-     * @return new TransformerFactory instance, never null.
-     *
-     * @throws javax.xml.transform.TransformerFactoryConfigurationError Thrown in case of {@linkplain
-     * java.util.ServiceConfigurationError service configuration error} or if
-     * the implementation is not available or cannot be instantiated.
-     */
-    public static TransformerFactory newInstance()
-        throws javax.xml.transform.TransformerFactoryConfigurationError {
-
-        return FactoryFinder.find(
-            /* The default property name according to the JAXP spec */
-            TransformerFactory.class,
-            /* The fallback implementation class name, XSLTC */
-            "org.openjdk.com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl");
-    }
-
-    /**
-     * <p>Obtain a new instance of a <code>TransformerFactory</code> from factory class name.
-     * This function is useful when there are multiple providers in the classpath.
-     * It gives more control to the application as it can specify which provider
-     * should be loaded.</p>
-     *
-     * <p>Once an application has obtained a reference to a <code>
-     * TransformerFactory</code> it can use the factory to configure
-     * and obtain transformer instances.</p>
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     * @param factoryClassName fully qualified factory class name that provides implementation of <code>javax.xml.transform.TransformerFactory</code>.
-     *
-     * @param classLoader <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     *                     current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @return new TransformerFactory instance, never null.
-     *
-     * @throws javax.xml.transform.TransformerFactoryConfigurationError
-     *                    if <code>factoryClassName</code> is <code>null</code>, or
-     *                   the factory class cannot be loaded, instantiated.
-     *
-     * @see #newInstance()
-     *
-     * @since 1.6
-     */
-    public static TransformerFactory newInstance(String factoryClassName, ClassLoader classLoader)
-        throws TransformerFactoryConfigurationError {
-
-        //do not fallback if given classloader can't find the class, throw exception
-        return  FactoryFinder.newInstance(TransformerFactory.class,
-                    factoryClassName, classLoader, false, false);
-    }
-    /**
-     * <p>Process the <code>Source</code> into a <code>Transformer</code>
-     * <code>Object</code>.  The <code>Source</code> is an XSLT document that
-     * conforms to <a href="http://www.w3.org/TR/xslt">
-     * XSL Transformations (XSLT) Version 1.0</a>.  Care must
-     * be taken not to use this <code>Transformer</code> in multiple
-     * <code>Thread</code>s running concurrently.
-     * Different <code>TransformerFactories</code> can be used concurrently by
-     * different <code>Thread</code>s.</p>
-     *
-     * @param source <code>Source </code> of XSLT document used to create
-     *   <code>Transformer</code>.
-     *   Examples of XML <code>Source</code>s include
-     *   {@link DOMSource DOMSource},
-     *   {@link SAXSource SAXSource}, and
-     *   {@link StreamSource StreamSource}.
-     *
-     * @return A <code>Transformer</code> object that may be used to perform
-     *   a transformation in a single <code>Thread</code>, never
-     *   <code>null</code>.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException Thrown if there are errors when
-     *    parsing the <code>Source</code> or it is not possible to create a
-     *   <code>Transformer</code> instance.
-     *
-     * @see <a href="http://www.w3.org/TR/xslt">
-     *   XSL Transformations (XSLT) Version 1.0</a>
-     */
-    public abstract javax.xml.transform.Transformer newTransformer(javax.xml.transform.Source source)
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * <p>Create a new <code>Transformer</code> that performs a copy
-     * of the <code>Source</code> to the <code>Result</code>.
-     * i.e. the "<em>identity transform</em>".</p>
-     *
-     * @return A Transformer object that may be used to perform a transformation
-     * in a single thread, never null.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException When it is not
-     *   possible to create a <code>Transformer</code> instance.
-     */
-    public abstract Transformer newTransformer()
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * Process the Source into a Templates object, which is a
-     * a compiled representation of the source. This Templates object
-     * may then be used concurrently across multiple threads.  Creating
-     * a Templates object allows the TransformerFactory to do detailed
-     * performance optimization of transformation instructions, without
-     * penalizing runtime transformation.
-     *
-     * @param source An object that holds a URL, input stream, etc.
-     *
-     * @return A Templates object capable of being used for transformation
-     *   purposes, never <code>null</code>.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException When parsing to
-     *   construct the Templates object fails.
-     */
-    public abstract Templates newTemplates(javax.xml.transform.Source source)
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * <p>Get the stylesheet specification(s) associated with the
-     * XML <code>Source</code> document via the
-     * <a href="http://www.w3.org/TR/xml-stylesheet/">
-     * xml-stylesheet processing instruction</a> that match the given criteria.
-     * Note that it is possible to return several stylesheets, in which case
-     * they are applied as if they were a list of imports or cascades in a
-     * single stylesheet.</p>
-     *
-     * @param source The XML source document.
-     * @param media The media attribute to be matched.  May be null, in which
-     *      case the prefered templates will be used (i.e. alternate = no).
-     * @param title The value of the title attribute to match.  May be null.
-     * @param charset The value of the charset attribute to match.  May be null.
-     *
-     * @return A <code>Source</code> <code>Object</code> suitable for passing
-     *   to the <code>TransformerFactory</code>.
-     *
-     * @throws javax.xml.transform.TransformerConfigurationException An <code>Exception</code>
-     *   is thrown if an error occurings during parsing of the
-     *   <code>source</code>.
-     *
-     * @see <a href="http://www.w3.org/TR/xml-stylesheet/">
-     *   Associating Style Sheets with XML documents Version 1.0</a>
-     */
-    public abstract javax.xml.transform.Source getAssociatedStylesheet(
-        javax.xml.transform.Source source,
-        String media,
-        String title,
-        String charset)
-        throws javax.xml.transform.TransformerConfigurationException;
-
-    /**
-     * Set an object that is used by default during the transformation
-     * to resolve URIs used in document(), xsl:import, or xsl:include.
-     *
-     * @param resolver An object that implements the URIResolver interface,
-     * or null.
-     */
-    public abstract void setURIResolver(javax.xml.transform.URIResolver resolver);
-
-    /**
-     * Get the object that is used by default during the transformation
-     * to resolve URIs used in document(), xsl:import, or xsl:include.
-     *
-     * @return The URIResolver that was set with setURIResolver.
-     */
-    public abstract URIResolver getURIResolver();
-
-    //======= CONFIGURATION METHODS =======
-
-        /**
-         * <p>Set a feature for this <code>TransformerFactory</code> and <code>Transformer</code>s
-         * or <code>Template</code>s created by this factory.</p>
-         *
-         * <p>
-         * Feature names are fully qualified {@link java.net.URI}s.
-         * Implementations may define their own features.
-         * An {@link javax.xml.transform.TransformerConfigurationException} is thrown if this <code>TransformerFactory</code> or the
-         * <code>Transformer</code>s or <code>Template</code>s it creates cannot support the feature.
-         * It is possible for an <code>TransformerFactory</code> to expose a feature value but be unable to change its state.
-         * </p>
-         *
-         * <p>All implementations are required to support the {@link XMLConstants#FEATURE_SECURE_PROCESSING} feature.
-         * When the feature is:</p>
-         * <ul>
-         *   <li>
-         *     <code>true</code>: the implementation will limit XML processing to conform to implementation limits
-         *     and behave in a secure fashion as defined by the implementation.
-         *     Examples include resolving user defined style sheets and functions.
-         *     If XML processing is limited for security reasons, it will be reported via a call to the registered
-         *     {@link javax.xml.transform.ErrorListener#fatalError(TransformerException exception)}.
-         *     See {@link  #setErrorListener(javax.xml.transform.ErrorListener listener)}.
-         *   </li>
-         *   <li>
-         *     <code>false</code>: the implementation will processing XML according to the XML specifications without
-         *     regard to possible implementation limits.
-         *   </li>
-         * </ul>
-         *
-         * @param name Feature name.
-         * @param value Is feature state <code>true</code> or <code>false</code>.
-         *
-         * @throws javax.xml.transform.TransformerConfigurationException if this <code>TransformerFactory</code>
-         *   or the <code>Transformer</code>s or <code>Template</code>s it creates cannot support this feature.
-     * @throws NullPointerException If the <code>name</code> parameter is null.
-         */
-        public abstract void setFeature(String name, boolean value)
-                throws TransformerConfigurationException;
-
-    /**
-     * Look up the value of a feature.
-     *
-         * <p>
-         * Feature names are fully qualified {@link java.net.URI}s.
-         * Implementations may define their own features.
-         * <code>false</code> is returned if this <code>TransformerFactory</code> or the
-         * <code>Transformer</code>s or <code>Template</code>s it creates cannot support the feature.
-         * It is possible for an <code>TransformerFactory</code> to expose a feature value but be unable to change its state.
-         * </p>
-         *
-         * @param name Feature name.
-         *
-     * @return The current state of the feature, <code>true</code> or <code>false</code>.
-     *
-     * @throws NullPointerException If the <code>name</code> parameter is null.
-     */
-    public abstract boolean getFeature(String name);
-
-    /**
-     * Allows the user to set specific attributes on the underlying
-     * implementation.  An attribute in this context is defined to
-     * be an option that the implementation provides.
-     * An <code>IllegalArgumentException</code> is thrown if the underlying
-     * implementation doesn't recognize the attribute.
-     * <p>
-     * All implementations that implement JAXP 1.5 or newer are required to
-     * support the {@link XMLConstants#ACCESS_EXTERNAL_DTD}  and
-     * {@link XMLConstants#ACCESS_EXTERNAL_STYLESHEET} properties.
-     * </p>
-     * <ul>
-     *   <li>
-     *      <p>
-     *      Access to external DTDs in the source file is restricted to the protocols
-     *      specified by the {@link XMLConstants#ACCESS_EXTERNAL_DTD} property.
-     *      If access is denied during transformation due to the restriction of this property,
-     *      {@link javax.xml.transform.TransformerException} will be thrown by
-     *      {@link javax.xml.transform.Transformer#transform(javax.xml.transform.Source, javax.xml.transform.Result)}.
-     *      </p>
-     *      <p>
-     *      Access to external DTDs in the stylesheet is restricted to the protocols
-     *      specified by the {@link XMLConstants#ACCESS_EXTERNAL_DTD} property.
-     *      If access is denied during the creation of a new transformer due to the
-     *      restriction of this property,
-     *      {@link javax.xml.transform.TransformerConfigurationException} will be thrown
-     *      by the {@link #newTransformer(javax.xml.transform.Source)} method.
-     *      </p>
-     *      <p>
-     *      Access to external reference set by the stylesheet processing instruction,
-     *      Import and Include element is restricted to the protocols specified by the
-     *      {@link XMLConstants#ACCESS_EXTERNAL_STYLESHEET} property.
-     *      If access is denied during the creation of a new transformer due to the
-     *      restriction of this property,
-     *      {@link javax.xml.transform.TransformerConfigurationException} will be thrown
-     *      by the {@link #newTransformer(javax.xml.transform.Source)} method.
-     *      </p>
-     *      <p>
-     *      Access to external document through XSLT document function is restricted
-     *      to the protocols specified by the property. If access is denied during
-     *      the transformation due to the restriction of this property,
-     *      {@link javax.xml.transform.TransformerException} will be thrown by the
-     *      {@link javax.xml.transform.Transformer#transform(Source, Result)} method.
-     *      </p>
-     *   </li>
-     * </ul>
-     *
-     * @param name The name of the attribute.
-     * @param value The value of the attribute.
-     *
-     * @throws IllegalArgumentException When implementation does not
-     *   recognize the attribute.
-     */
-    public abstract void setAttribute(String name, Object value);
-
-    /**
-     * Allows the user to retrieve specific attributes on the underlying
-     * implementation.
-     * An <code>IllegalArgumentException</code> is thrown if the underlying
-     * implementation doesn't recognize the attribute.
-     *
-     * @param name The name of the attribute.
-     *
-     * @return value The value of the attribute.
-     *
-     * @throws IllegalArgumentException When implementation does not
-     *   recognize the attribute.
-     */
-    public abstract Object getAttribute(String name);
-
-    /**
-     * Set the error event listener for the TransformerFactory, which
-     * is used for the processing of transformation instructions,
-     * and not for the transformation itself.
-     * An <code>IllegalArgumentException</code> is thrown if the
-     * <code>ErrorListener</code> listener is <code>null</code>.
-     *
-     * @param listener The new error listener.
-     *
-     * @throws IllegalArgumentException When <code>listener</code> is
-     *   <code>null</code>
-     */
-    public abstract void setErrorListener(javax.xml.transform.ErrorListener listener);
-
-    /**
-     * Get the error event handler for the TransformerFactory.
-     *
-     * @return The current error handler, which should never be null.
-     */
-    public abstract ErrorListener getErrorListener();
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/TransformerException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerException.java b/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,370 +0,0 @@
-/*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-
-/**
- * This class specifies an exceptional condition that occured
- * during the transformation process.
- */
-public class TransformerException extends Exception {
-
-    /** Field locator specifies where the error occured */
-    javax.xml.transform.SourceLocator locator;
-
-    /**
-     * Method getLocator retrieves an instance of a SourceLocator
-     * object that specifies where an error occured.
-     *
-     * @return A SourceLocator object, or null if none was specified.
-     */
-    public javax.xml.transform.SourceLocator getLocator() {
-        return locator;
-    }
-
-    /**
-     * Method setLocator sets an instance of a SourceLocator
-     * object that specifies where an error occured.
-     *
-     * @param location A SourceLocator object, or null to clear the location.
-     */
-    public void setLocator(javax.xml.transform.SourceLocator location) {
-        locator = location;
-    }
-
-    /** Field containedException specifies a wrapped exception.  May be null. */
-    Throwable containedException;
-
-    /**
-     * This method retrieves an exception that this exception wraps.
-     *
-     * @return An Throwable object, or null.
-     * @see #getCause
-     */
-    public Throwable getException() {
-        return containedException;
-    }
-
-    /**
-     * Returns the cause of this throwable or <code>null</code> if the
-     * cause is nonexistent or unknown.  (The cause is the throwable that
-     * caused this throwable to get thrown.)
-     */
-    public Throwable getCause() {
-
-        return ((containedException == this)
-                ? null
-                : containedException);
-    }
-
-    /**
-     * Initializes the <i>cause</i> of this throwable to the specified value.
-     * (The cause is the throwable that caused this throwable to get thrown.)
-     *
-     * <p>This method can be called at most once.  It is generally called from
-     * within the constructor, or immediately after creating the
-     * throwable.  If this throwable was created
-     * with {@link #TransformerException(Throwable)} or
-     * {@link #TransformerException(String,Throwable)}, this method cannot be called
-     * even once.
-     *
-     * @param  cause the cause (which is saved for later retrieval by the
-     *         {@link #getCause()} method).  (A <code>null</code> value is
-     *         permitted, and indicates that the cause is nonexistent or
-     *         unknown.)
-     * @return  a reference to this <code>Throwable</code> instance.
-     * @throws IllegalArgumentException if <code>cause</code> is this
-     *         throwable.  (A throwable cannot
-     *         be its own cause.)
-     * @throws IllegalStateException if this throwable was
-     *         created with {@link #TransformerException(Throwable)} or
-     *         {@link #TransformerException(String,Throwable)}, or this method has already
-     *         been called on this throwable.
-     */
-    public synchronized Throwable initCause(Throwable cause) {
-
-        if (this.containedException != null) {
-            throw new IllegalStateException("Can't overwrite cause");
-        }
-
-        if (cause == this) {
-            throw new IllegalArgumentException(
-                "Self-causation not permitted");
-        }
-
-        this.containedException = cause;
-
-        return this;
-    }
-
-    /**
-     * Create a new TransformerException.
-     *
-     * @param message The error or warning message.
-     */
-    public TransformerException(String message) {
-
-        super(message);
-
-        this.containedException = null;
-        this.locator            = null;
-    }
-
-    /**
-     * Create a new TransformerException wrapping an existing exception.
-     *
-     * @param e The exception to be wrapped.
-     */
-    public TransformerException(Throwable e) {
-
-        super(e.toString());
-
-        this.containedException = e;
-        this.locator            = null;
-    }
-
-    /**
-     * Wrap an existing exception in a TransformerException.
-     *
-     * <p>This is used for throwing processor exceptions before
-     * the processing has started.</p>
-     *
-     * @param message The error or warning message, or null to
-     *                use the message from the embedded exception.
-     * @param e Any exception
-     */
-    public TransformerException(String message, Throwable e) {
-
-        super(((message == null) || (message.length() == 0))
-              ? e.toString()
-              : message);
-
-        this.containedException = e;
-        this.locator            = null;
-    }
-
-    /**
-     * Create a new TransformerException from a message and a Locator.
-     *
-     * <p>This constructor is especially useful when an application is
-     * creating its own exception from within a DocumentHandler
-     * callback.</p>
-     *
-     * @param message The error or warning message.
-     * @param locator The locator object for the error or warning.
-     */
-    public TransformerException(String message, javax.xml.transform.SourceLocator locator) {
-
-        super(message);
-
-        this.containedException = null;
-        this.locator            = locator;
-    }
-
-    /**
-     * Wrap an existing exception in a TransformerException.
-     *
-     * @param message The error or warning message, or null to
-     *                use the message from the embedded exception.
-     * @param locator The locator object for the error or warning.
-     * @param e Any exception
-     */
-    public TransformerException(String message, SourceLocator locator,
-                                Throwable e) {
-
-        super(message);
-
-        this.containedException = e;
-        this.locator            = locator;
-    }
-
-    /**
-     * Get the error message with location information
-     * appended.
-     *
-     * @return A <code>String</code> representing the error message with
-     *         location information appended.
-     */
-    public String getMessageAndLocation() {
-
-        StringBuffer sbuffer = new StringBuffer();
-        String       message = super.getMessage();
-
-        if (null != message) {
-            sbuffer.append(message);
-        }
-
-        if (null != locator) {
-            String systemID = locator.getSystemId();
-            int    line     = locator.getLineNumber();
-            int    column   = locator.getColumnNumber();
-
-            if (null != systemID) {
-                sbuffer.append("; SystemID: ");
-                sbuffer.append(systemID);
-            }
-
-            if (0 != line) {
-                sbuffer.append("; Line#: ");
-                sbuffer.append(line);
-            }
-
-            if (0 != column) {
-                sbuffer.append("; Column#: ");
-                sbuffer.append(column);
-            }
-        }
-
-        return sbuffer.toString();
-    }
-
-    /**
-     * Get the location information as a string.
-     *
-     * @return A string with location info, or null
-     * if there is no location information.
-     */
-    public String getLocationAsString() {
-
-        if (null != locator) {
-            StringBuffer sbuffer  = new StringBuffer();
-            String       systemID = locator.getSystemId();
-            int          line     = locator.getLineNumber();
-            int          column   = locator.getColumnNumber();
-
-            if (null != systemID) {
-                sbuffer.append("; SystemID: ");
-                sbuffer.append(systemID);
-            }
-
-            if (0 != line) {
-                sbuffer.append("; Line#: ");
-                sbuffer.append(line);
-            }
-
-            if (0 != column) {
-                sbuffer.append("; Column#: ");
-                sbuffer.append(column);
-            }
-
-            return sbuffer.toString();
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Print the the trace of methods from where the error
-     * originated.  This will trace all nested exception
-     * objects, as well as this object.
-     */
-    public void printStackTrace() {
-        printStackTrace(new java.io.PrintWriter(System.err, true));
-    }
-
-    /**
-     * Print the the trace of methods from where the error
-     * originated.  This will trace all nested exception
-     * objects, as well as this object.
-     * @param s The stream where the dump will be sent to.
-     */
-    public void printStackTrace(java.io.PrintStream s) {
-        printStackTrace(new java.io.PrintWriter(s));
-    }
-
-    /**
-     * Print the the trace of methods from where the error
-     * originated.  This will trace all nested exception
-     * objects, as well as this object.
-     * @param s The writer where the dump will be sent to.
-     */
-    public void printStackTrace(java.io.PrintWriter s) {
-
-        if (s == null) {
-            s = new java.io.PrintWriter(System.err, true);
-        }
-
-        try {
-            String locInfo = getLocationAsString();
-
-            if (null != locInfo) {
-                s.println(locInfo);
-            }
-
-            super.printStackTrace(s);
-        } catch (Throwable e) {}
-
-        Throwable exception = getException();
-
-        for (int i = 0; (i < 10) && (null != exception); i++) {
-            s.println("---------");
-
-            try {
-                if (exception instanceof TransformerException) {
-                    String locInfo =
-                        ((TransformerException) exception)
-                            .getLocationAsString();
-
-                    if (null != locInfo) {
-                        s.println(locInfo);
-                    }
-                }
-
-                exception.printStackTrace(s);
-            } catch (Throwable e) {
-                s.println("Could not print stack trace...");
-            }
-
-            try {
-                Method meth =
-                    ((Object) exception).getClass().getMethod("getException",
-                        (Class[]) null);
-
-                if (null != meth) {
-                    Throwable prev = exception;
-
-                    exception = (Throwable) meth.invoke(exception, (Object[]) null);
-
-                    if (prev == exception) {
-                        break;
-                    }
-                } else {
-                    exception = null;
-                }
-            } catch (InvocationTargetException ite) {
-                exception = null;
-            } catch (IllegalAccessException iae) {
-                exception = null;
-            } catch (NoSuchMethodException nsme) {
-                exception = null;
-            }
-        }
-        // insure output is written
-        s.flush();
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/TransformerConfigurationException.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerConfigurationException.java b/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerConfigurationException.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerConfigurationException.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,102 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * Indicates a serious configuration error.
- */
-public class TransformerConfigurationException extends TransformerException {
-
-    /**
-     * Create a new <code>TransformerConfigurationException</code> with no
-     * detail mesage.
-     */
-    public TransformerConfigurationException() {
-        super("Configuration Error");
-    }
-
-    /**
-     * Create a new <code>TransformerConfigurationException</code> with
-     * the <code>String </code> specified as an error message.
-     *
-     * @param msg The error message for the exception.
-     */
-    public TransformerConfigurationException(String msg) {
-        super(msg);
-    }
-
-    /**
-     * Create a new <code>TransformerConfigurationException</code> with a
-     * given <code>Exception</code> base cause of the error.
-     *
-     * @param e The exception to be encapsulated in a
-     * TransformerConfigurationException.
-     */
-    public TransformerConfigurationException(Throwable e) {
-        super(e);
-    }
-
-    /**
-     * Create a new <code>TransformerConfigurationException</code> with the
-     * given <code>Exception</code> base cause and detail message.
-     *
-     * @param e The exception to be encapsulated in a
-     *      TransformerConfigurationException
-     * @param msg The detail message.
-     */
-    public TransformerConfigurationException(String msg, Throwable e) {
-        super(msg, e);
-    }
-
-    /**
-     * Create a new TransformerConfigurationException from a message and a Locator.
-     *
-     * <p>This constructor is especially useful when an application is
-     * creating its own exception from within a DocumentHandler
-     * callback.</p>
-     *
-     * @param message The error or warning message.
-     * @param locator The locator object for the error or warning.
-     */
-    public TransformerConfigurationException(String message,
-                                             javax.xml.transform.SourceLocator locator) {
-        super(message, locator);
-    }
-
-    /**
-     * Wrap an existing exception in a TransformerConfigurationException.
-     *
-     * @param message The error or warning message, or null to
-     *                use the message from the embedded exception.
-     * @param locator The locator object for the error or warning.
-     * @param e Any exception.
-     */
-    public TransformerConfigurationException(String message,
-                                             SourceLocator locator,
-                                             Throwable e) {
-        super(message, locator, e);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactoryConfigurationError.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactoryConfigurationError.java b/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactoryConfigurationError.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/transform/TransformerFactoryConfigurationError.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,130 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.transform;
-
-/**
- * Thrown when a problem with configuration with the Transformer Factories
- * exists. This error will typically be thrown when the class of a
- * transformation factory specified in the system properties cannot be found
- * or instantiated.
- */
-public class TransformerFactoryConfigurationError extends Error {
-    private static final long serialVersionUID = -6527718720676281516L;
-
-    /**
-     * <code>Exception</code> for the
-     *  <code>TransformerFactoryConfigurationError</code>.
-     */
-    private Exception exception;
-
-    /**
-     * Create a new <code>TransformerFactoryConfigurationError</code> with no
-     * detail mesage.
-     */
-    public TransformerFactoryConfigurationError() {
-
-        super();
-
-        this.exception = null;
-    }
-
-    /**
-     * Create a new <code>TransformerFactoryConfigurationError</code> with
-     * the <code>String</code> specified as an error message.
-     *
-     * @param msg The error message for the exception.
-     */
-    public TransformerFactoryConfigurationError(String msg) {
-
-        super(msg);
-
-        this.exception = null;
-    }
-
-    /**
-     * Create a new <code>TransformerFactoryConfigurationError</code> with a
-     * given <code>Exception</code> base cause of the error.
-     *
-     * @param e The exception to be encapsulated in a
-     * TransformerFactoryConfigurationError.
-     */
-    public TransformerFactoryConfigurationError(Exception e) {
-
-        super(e.toString());
-
-        this.exception = e;
-    }
-
-    /**
-     * Create a new <code>TransformerFactoryConfigurationError</code> with the
-     * given <code>Exception</code> base cause and detail message.
-     *
-     * @param e The exception to be encapsulated in a
-     * TransformerFactoryConfigurationError
-     * @param msg The detail message.
-     */
-    public TransformerFactoryConfigurationError(Exception e, String msg) {
-
-        super(msg);
-
-        this.exception = e;
-    }
-
-    /**
-     * Return the message (if any) for this error . If there is no
-     * message for the exception and there is an encapsulated
-     * exception then the message of that exception will be returned.
-     *
-     * @return The error message.
-     */
-    public String getMessage() {
-
-        String message = super.getMessage();
-
-        if ((message == null) && (exception != null)) {
-            return exception.getMessage();
-        }
-
-        return message;
-    }
-
-    /**
-     * Return the actual exception (if any) that caused this exception to
-     * be raised.
-     *
-     * @return The encapsulated exception, or null if there is none.
-     */
-    public Exception getException() {
-        return exception;
-    }
-    /**
-     * use the exception chaining mechanism of JDK1.4
-    */
-    @Override
-    public Throwable getCause() {
-        return exception;
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/Schema.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/Schema.java b/Build/src/main/java/org/openjdk/javax/xml/validation/Schema.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/Schema.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,104 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-/**
- * Immutable in-memory representation of grammar.
- *
- * <p>
- * This object represents a set of constraints that can be checked/
- * enforced against an XML document.
- *
- * <p>
- * A {@link Schema} object is thread safe and applications are
- * encouraged to share it across many parsers in many threads.
- *
- * <p>
- * A {@link Schema} object is immutable in the sense that it shouldn't
- * change the set of constraints once it is created. In other words,
- * if an application validates the same document twice against the same
- * {@link Schema}, it must always produce the same result.
- *
- * <p>
- * A {@link Schema} object is usually created from {@link javax.xml.validation.SchemaFactory}.
- *
- * <p>
- * Two kinds of validators can be created from a {@link Schema} object.
- * One is {@link javax.xml.validation.Validator}, which provides highly-level validation
- * operations that cover typical use cases. The other is
- * {@link javax.xml.validation.ValidatorHandler}, which works on top of SAX for better
- * modularity.
- *
- * <p>
- * This specification does not refine
- * the {@link java.lang.Object#equals(java.lang.Object)} method.
- * In other words, if you parse the same schema twice, you may
- * still get <code>!schemaA.equals(schemaB)</code>.
- *
- * @author <a href="mailto:Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @see <a href="http://www.w3.org/TR/xmlschema-1/">XML Schema Part 1: Structures</a>
- * @see <a href="http://www.w3.org/TR/xml11/">Extensible Markup Language (XML) 1.1</a>
- * @see <a href="http://www.w3.org/TR/REC-xml">Extensible Markup Language (XML) 1.0 (Second Edition)</a>
- * @since 1.5
- */
-public abstract class Schema {
-
-    /**
-     * Constructor for the derived class.
-     *
-     * <p>
-     * The constructor does nothing.
-     */
-    protected Schema() {
-    }
-
-    /**
-     * Creates a new {@link javax.xml.validation.Validator} for this {@link Schema}.
-     *
-     * <p>A validator enforces/checks the set of constraints this object
-     * represents.</p>
-     *
-     * <p>Implementors should assure that the properties set on the
-     * {@link javax.xml.validation.SchemaFactory} that created this {@link Schema} are also
-     * set on the {@link javax.xml.validation.Validator} constructed.</p>
-     *
-     * @return
-     *      Always return a non-null valid object.
-     */
-    public abstract Validator newValidator();
-
-    /**
-     * Creates a new {@link javax.xml.validation.ValidatorHandler} for this {@link Schema}.
-     *
-     * <p>Implementors should assure that the properties set on the
-     * {@link SchemaFactory} that created this {@link Schema} are also
-     * set on the {@link javax.xml.validation.ValidatorHandler} constructed.</p>
-     *
-     * @return
-     *      Always return a non-null valid object.
-     */
-    public abstract ValidatorHandler newValidatorHandler();
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/package.html
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/package.html b/Build/src/main/java/org/openjdk/javax/xml/validation/package.html
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/package.html	(date 0)
+++ /dev/null	(date 0)
@@ -1,124 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
-This code is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License version 2 only, as
-published by the Free Software Foundation.  Oracle designates this
-particular file as subject to the "Classpath" exception as provided
-by Oracle in the LICENSE file that accompanied this code.
-
-This code is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-version 2 for more details (a copy is included in the LICENSE file that
-accompanied this code).
-
-You should have received a copy of the GNU General Public License version
-2 along with this work; if not, write to the Free Software Foundation,
-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-or visit www.oracle.com if you need additional information or have any
-questions. 
--->
-
-<!DOCTYPE html
-     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml">
-
-<head>
-  <title>javax.xml.validation</title>
-
-  <meta name="CVS"
-        content="$Id: package.html,v 1.2 2005/06/10 03:50:43 jeffsuttor Exp $" />
-  <meta name="AUTHOR"
-        content="Jeff.Suttor@Sun.com" />
-</head>
-	<body>
-		<p>
-		    This package provides an API for validation of XML documents.  <em>Validation</em> is the process of verifying
-		    that an XML document is an instance of a specified XML <em>schema</em>.  An XML schema defines the
-		    content model (also called a <em>grammar</em> or <em>vocabulary</em>) that its instance documents
-		    will represent.
-        </p>
-        <p>
-            There are a number of popular technologies available for creating an XML schema. Some of the most
-            popular include:
-		</p>
-            <ul>
-                <li><strong>Document Type Definition (DTD)</strong> - XML's built-in schema language.</li>
-                <li><strong><a href="http://www.w3.org/XML/Schema">W3C XML Schema (WXS)</a></strong> - an object-oriented XML schema
-                    language. WXS also provides a type system for constraining the character data of an XML document.
-                    WXS is maintained by the <a href="http://www.w3.org">World Wide Web Consortium (W3C)</a> and is a W3C
-                    Recommendation (that is, a ratified W3C standard specification).</li>
-                <li><strong><a href="http://www.relaxng.org">RELAX NG (RNG)</a></strong> - a pattern-based,
-                    user-friendly XML schema language. RNG schemas may also use types to constrain XML character data.
-                    RNG is maintained by the <a href="http://www.oasis-open.org">Organization for the Advancement of
-                    Structured Information Standards (OASIS)</a> and is both an OASIS and an
-                    <a href="http://www.iso.org">ISO (International Organization for Standardization)</a> standard.</li>
-                <li><strong><a href="http://www.schematron.com/">Schematron</a></strong> - a rules-based XML schema
-                language. Whereas DTD, WXS, and RNG are designed to express the structure of a content model,
-                Schematron is designed to enforce individual rules that are difficult or impossible to express
-                with other schema languages. Schematron is intended to supplement a schema written in
-                structural schema language such as the aforementioned. Schematron is in the process
-                of becoming an ISO standard.</li>
-            </ul>
-        <p>
-		    Previous versions of JAXP supported validation as a feature of an XML parser, represented by
-		    either a {@link javax.xml.parsers.SAXParser} or {@link javax.xml.parsers.DocumentBuilder} instance.
-        </p>
-        <p>
-		    The JAXP validation API decouples the validation of an instance document from the parsing of an
-		    XML document. This is advantageous for several reasons, some of which are:
-		</p>
-		    <ul>
-		        <li><strong>Support for additional schema langauges.</strong> As of JDK 1.5, the two most
-		        popular JAXP parser implementations, Crimson and Xerces, only support a subset of the available
-		        XML schema languages. The Validation API provides a standard mechanism through which applications
-		        may take of advantage of specialization validation libraries which support additional schema
-		        languages.</li>
-		        <li><strong>Easy runtime coupling of an XML instance and schema.</strong> Specifying the location
-		        of a schema to use for validation with JAXP parsers can be confusing. The Validation API makes this
-		        process simple (see <a href="#example-1">example</a> below).</li>
-          </ul>
-		<p>
-            <a name="example-1"><strong>Usage example</strong>.</a> The following example demonstrates validating
-            an XML document with the Validation API (for readability, some exception handling is not shown):
-		</p>
-            <pre>
-            
-    // parse an XML document into a DOM tree
-    DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
-    Document document = parser.parse(new File("instance.xml"));
-
-    // create a SchemaFactory capable of understanding WXS schemas
-    SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
-
-    // load a WXS schema, represented by a Schema instance
-    Source schemaFile = new StreamSource(new File("mySchema.xsd"));
-    Schema schema = factory.newSchema(schemaFile);
-
-    // create a Validator instance, which can be used to validate an instance document
-    Validator validator = schema.newValidator();
-
-    // validate the DOM tree
-    try {
-        validator.validate(new DOMSource(document));
-    } catch (SAXException e) {
-        // instance document is invalid!
-    }
-</pre>
-		<p>
-		    The JAXP parsing API has been integrated with the Validation API. Applications may create a {@link javax.xml.validation.Schema} with the validation API
-		    and associate it with a {@link javax.xml.parsers.DocumentBuilderFactory} or a {@link javax.xml.parsers.SAXParserFactory} instance
-		    by using the {@link javax.xml.parsers.DocumentBuilderFactory#setSchema(Schema)} and {@link javax.xml.parsers.SAXParserFactory#setSchema(Schema)}
-		    methods. <strong>You should not</strong> both set a schema and call <code>setValidating(true)</code> on a parser factory. The former technique
-		    will cause parsers to use the new validation API; the latter will cause parsers to use their own internal validation
-		    facilities. <strong>Turning on both of these options simultaneously will cause either redundant behavior or error conditions.</strong>
-        </p>
-	</body>
-</html>
Index: Build/src/main/java/org/openjdk/javax/xml/validation/Validator.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/Validator.java b/Build/src/main/java/org/openjdk/javax/xml/validation/Validator.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/Validator.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,534 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-import java.io.IOException;
-
-import javax.xml.transform.Result;
-import javax.xml.transform.Source;
-
-import javax.xml.XMLConstants;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMResult;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.sax.SAXResult;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.stax.StAXResult;
-import javax.xml.transform.stax.StAXSource;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.transform.stream.StreamSource;
-import org.w3c.dom.ls.LSResourceResolver;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXNotSupportedException;
-
-/**
- * <p>A processor that checks an XML document against {@link javax.xml.validation.Schema}.</p>
- *
- * <p>
- * A validator object is not thread-safe and not reentrant.
- * In other words, it is the application's responsibility to make
- * sure that one {@link Validator} object is not used from
- * more than one thread at any given time, and while the <code>validate</code>
- * method is invoked, applications may not recursively call
- * the <code>validate</code> method.
- * <p>
- *
- *
- * @author  <a href="mailto:Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @since 1.5
- */
-public abstract class Validator {
-
-    /**
-     * Constructor for derived classes.
-     *
-     * <p>The constructor does nothing.</p>
-     *
-     * <p>Derived classes must create {@link Validator} objects that have
-     * <code>null</code> {@link ErrorHandler} and
-     * <code>null</code> {@link LSResourceResolver}.
-     * </p>
-     */
-    protected Validator() {
-    }
-
-        /**
-         * <p>Reset this <code>Validator</code> to its original configuration.</p>
-         *
-         * <p><code>Validator</code> is reset to the same state as when it was created with
-         * {@link Schema#newValidator()}.
-         * <code>reset()</code> is designed to allow the reuse of existing <code>Validator</code>s
-         * thus saving resources associated with the creation of new <code>Validator</code>s.</p>
-         *
-         * <p>The reset <code>Validator</code> is not guaranteed to have the same {@link LSResourceResolver} or {@link ErrorHandler}
-         * <code>Object</code>s, e.g. {@link Object#equals(Object obj)}.  It is guaranteed to have a functionally equal
-         * <code>LSResourceResolver</code> and <code>ErrorHandler</code>.</p>
-         */
-        public abstract void reset();
-
-    /**
-     * Validates the specified input.
-     *
-     * <p>This is just a convenience method for
-     * {@link #validate(Source source, Result result)}
-     * with <code>result</code> of <code>null</code>.</p>
-     *
-     * @param source
-     *      XML to be validated. Must be an XML document or
-     *      XML element and must not be null. For backwards compatibility,
-     *      the results of attempting to validate anything other than
-     *      a document or element are implementation-dependent.
-     *      Implementations must either recognize and process the input
-     *      or throw an IllegalArgumentException.
-     *
-     * @throws IllegalArgumentException
-     *      If the <code>Source</code>
-     *      is an XML artifact that the implementation cannot
-     *      validate (for example, a processing instruction).
-     *
-     * @throws SAXException
-     *      If the {@link ErrorHandler} throws a {@link SAXException} or
-     *      if a fatal error is found and the {@link ErrorHandler} returns
-     *      normally.
-     *
-     * @throws IOException
-     *      If the validator is processing a
-     *      {@link SAXSource} and the
-     *      underlying {@link org.xml.sax.XMLReader} throws an
-     *      {@link IOException}.
-     *
-     *
-     * @throws NullPointerException If <code>source</code> is
-     *   <code>null</code>.
-     *
-     * @see #validate(Source source, Result result)
-     */
-    public void validate(Source source)
-        throws SAXException, IOException {
-
-        validate(source, null);
-    }
-
-    /**
-     * <p>Validates the specified input and send the augmented validation
-     * result to the specified output.</p>
-     *
-     * <p>This method places the following restrictions on the types of
-     * the {@link Source}/{@link Result} accepted.</p>
-     *
-     * <table border=1>
-     * <thead>
-     *  <tr>
-     *   <th colspan="5"><code>Source</code> / <code>Result</code> Accepted</th>
-     *  </tr>
-     *  <tr>
-     *   <th></th>
-     *   <th>{@link StreamSource}</th>
-     *   <th>{@link SAXSource}</th>
-     *   <th>{@link DOMSource}</th>
-     *   <th>{@link StAXSource}</th>
-     *  </tr>
-     * </thead>
-     * <tbody align="center">
-     *  <tr>
-     *   <td><code>null</code></td>
-     *   <td>OK</td>
-     *   <td>OK</td>
-     *   <td>OK</td>
-     *   <td>OK</td>
-     *  </tr>
-     *  <tr>
-     *   <th>{@link StreamResult}</th>
-     *   <td>OK</td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *  </tr>
-     *  <tr>
-     *   <th>{@link SAXResult}</th>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td>OK</td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *  </tr>
-     *  <tr>
-     *   <th>{@link DOMResult}</th>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td>OK</td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *  </tr>
-     *  <tr>
-     *   <th>{@link StAXResult}</th>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td><code>IllegalArgumentException</code></td>
-     *   <td>OK</td>
-     *  </tr>
-     * </tbody>
-     * </table>
-     *
-     * <p>To validate one <code>Source</code> into another kind of
-     * <code>Result</code>, use the identity transformer (see
-     * {@link TransformerFactory#newTransformer()}).</p>
-     *
-     * <p>Errors found during the validation is sent to the specified
-     * {@link ErrorHandler}.</p>
-     *
-     * <p>If a document is valid, or if a document contains some errors
-     * but none of them were fatal and the <code>ErrorHandler</code> didn't
-     * throw any exception, then the method returns normally.</p>
-     *
-     * @param source
-     *      XML to be validated. Must be an XML document or
-     *      XML element and must not be null. For backwards compatibility,
-     *      the results of attempting to validate anything other than
-     *      a document or element are implementation-dependent.
-     *      Implementations must either recognize and process the input
-     *      or throw an IllegalArgumentException.
-     *
-     * @param result
-     *      The <code>Result</code> object that receives (possibly augmented)
-     *      XML. This parameter can be null if the caller is not interested
-     *      in it.
-     *
-     *      Note that when a <code>DOMResult</code> is used,
-     *      a validator might just pass the same DOM node from
-     *      <code>DOMSource</code> to <code>DOMResult</code>
-     *      (in which case <code>source.getNode()==result.getNode()</code>),
-     *      it might copy the entire DOM tree, or it might alter the
-     *      node given by the source.
-     *
-     * @throws IllegalArgumentException
-     *      If the <code>Result</code> type doesn't match the
-     *      <code>Source</code> type of if the <code>Source</code>
-     *      is an XML artifact that the implementation cannot
-     *      validate (for example, a processing instruction).
-     * @throws SAXException
-     *      If the <code>ErrorHandler</code> throws a
-     *      <code>SAXException</code> or
-     *      if a fatal error is found and the <code>ErrorHandler</code> returns
-     *      normally.
-     * @throws IOException
-     *      If the validator is processing a
-     *      <code>SAXSource</code> and the
-     *      underlying {@link org.xml.sax.XMLReader} throws an
-     *      <code>IOException</code>.
-     * @throws NullPointerException
-     *      If the <code>source</code> parameter is <code>null</code>.
-     *
-     * @see #validate(Source source)
-     */
-    public abstract void validate(Source source, Result result)
-        throws SAXException, IOException;
-
-    /**
-     * Sets the {@link ErrorHandler} to receive errors encountered
-     * during the <code>validate</code> method invocation.
-     *
-     * <p>
-     * Error handler can be used to customize the error handling process
-     * during a validation. When an {@link ErrorHandler} is set,
-     * errors found during the validation will be first sent
-     * to the {@link ErrorHandler}.
-     *
-     * <p>
-     * The error handler can abort further validation immediately
-     * by throwing {@link SAXException} from the handler. Or for example
-     * it can print an error to the screen and try to continue the
-     * validation by returning normally from the {@link ErrorHandler}
-     *
-     * <p>
-     * If any {@link Throwable} is thrown from an {@link ErrorHandler},
-     * the caller of the <code>validate</code> method will be thrown
-     * the same {@link Throwable} object.
-     *
-     * <p>
-     * {@link Validator} is not allowed to
-     * throw {@link SAXException} without first reporting it to
-     * {@link ErrorHandler}.
-     *
-     * <p>
-     * When the {@link ErrorHandler} is null, the implementation will
-     * behave as if the following {@link ErrorHandler} is set:
-     * <pre>
-     * class DraconianErrorHandler implements {@link ErrorHandler} {
-     *     public void fatalError( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {
-     *         throw e;
-     *     }
-     *     public void error( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {
-     *         throw e;
-     *     }
-     *     public void warning( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {
-     *         // noop
-     *     }
-     * }
-     * </pre>
-     *
-     * <p>
-     * When a new {@link Validator} object is created, initially
-     * this field is set to null.
-     *
-     * @param   errorHandler
-     *      A new error handler to be set. This parameter can be null.
-     */
-    public abstract void setErrorHandler(ErrorHandler errorHandler);
-
-    /**
-     * Gets the current {@link ErrorHandler} set to this {@link Validator}.
-     *
-     * @return
-     *      This method returns the object that was last set through
-     *      the {@link #setErrorHandler(ErrorHandler)} method, or null
-     *      if that method has never been called since this {@link Validator}
-     *      has created.
-     *
-     * @see #setErrorHandler(ErrorHandler)
-     */
-    public abstract ErrorHandler getErrorHandler();
-
-    /**
-     * Sets the {@link LSResourceResolver} to customize
-     * resource resolution while in a validation episode.
-     *
-     * <p>
-     * {@link Validator} uses a {@link LSResourceResolver}
-     * when it needs to locate external resources while a validation,
-     * although exactly what constitutes "locating external resources" is
-     * up to each schema language.
-     *
-     * <p>
-     * When the {@link LSResourceResolver} is null, the implementation will
-     * behave as if the following {@link LSResourceResolver} is set:
-     * <pre>
-     * class DumbLSResourceResolver implements {@link LSResourceResolver} {
-     *     public {@link org.w3c.dom.ls.LSInput} resolveResource(
-     *         String publicId, String systemId, String baseURI) {
-     *
-     *         return null; // always return null
-     *     }
-     * }
-     * </pre>
-     *
-     * <p>
-     * If a {@link LSResourceResolver} throws a {@link RuntimeException}
-     *  (or instances of its derived classes),
-     * then the {@link Validator} will abort the parsing and
-     * the caller of the <code>validate</code> method will receive
-     * the same {@link RuntimeException}.
-     *
-     * <p>
-     * When a new {@link Validator} object is created, initially
-     * this field is set to null.
-     *
-     * @param   resourceResolver
-     *      A new resource resolver to be set. This parameter can be null.
-     */
-    public abstract void setResourceResolver(LSResourceResolver resourceResolver);
-
-    /**
-     * Gets the current {@link LSResourceResolver} set to this {@link Validator}.
-     *
-     * @return
-     *      This method returns the object that was last set through
-     *      the {@link #setResourceResolver(LSResourceResolver)} method, or null
-     *      if that method has never been called since this {@link Validator}
-     *      has created.
-     *
-     * @see #setErrorHandler(ErrorHandler)
-     */
-    public abstract LSResourceResolver getResourceResolver();
-
-
-
-    /**
-     * Look up the value of a feature flag.
-     *
-     * <p>The feature name is any fully-qualified URI.  It is
-     * possible for a {@link Validator} to recognize a feature name but
-     * temporarily be unable to return its value.
-     * Some feature values may be available only in specific
-     * contexts, such as before, during, or after a validation.
-     *
-     * <p>Implementors are free (and encouraged) to invent their own features,
-     * using names built on their own URIs.</p>
-     *
-     * @param name The feature name, which is a non-null fully-qualified URI.
-     *
-     * @return The current value of the feature (true or false).
-     *
-     * @throws SAXNotRecognizedException If the feature
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link Validator} recognizes the feature name but
-     *   cannot determine its value at this time.
-     * @throws NullPointerException
-     *   When the name parameter is null.
-     *
-     * @see #setFeature(String, boolean)
-     */
-    public boolean getFeature(String name)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException("the name parameter is null");
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Set the value of a feature flag.
-     *
-     * <p>
-     * Feature can be used to control the way a {@link Validator}
-     * parses schemas, although {@link Validator}s are not required
-     * to recognize any specific feature names.</p>
-     *
-     * <p>The feature name is any fully-qualified URI.  It is
-     * possible for a {@link Validator} to expose a feature value but
-     * to be unable to change the current value.
-     * Some feature values may be immutable or mutable only
-     * in specific contexts, such as before, during, or after
-     * a validation.</p>
-     *
-     * @param name The feature name, which is a non-null fully-qualified URI.
-     * @param value The requested value of the feature (true or false).
-     *
-     * @throws SAXNotRecognizedException If the feature
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link Validator} recognizes the feature name but
-     *   cannot set the requested value.
-     * @throws NullPointerException
-     *   When the name parameter is null.
-     *
-     * @see #getFeature(String)
-     */
-    public void setFeature(String name, boolean value)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException("the name parameter is null");
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Set the value of a property.
-     *
-     * <p>The property name is any fully-qualified URI.  It is
-     * possible for a {@link Validator} to recognize a property name but
-     * to be unable to change the current value.
-     * Some property values may be immutable or mutable only
-     * in specific contexts, such as before, during, or after
-     * a validation.</p>
-     *
-     * <p>
-     * All implementations that implement JAXP 1.5 or newer are required to
-     * support the {@link XMLConstants#ACCESS_EXTERNAL_DTD} and
-     * {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} properties.
-     * </p>
-     * <ul>
-     *   <li>
-     *      <p>Access to external DTDs in source or Schema file is restricted to
-     *      the protocols specified by the {@link XMLConstants#ACCESS_EXTERNAL_DTD}
-     *      property.  If access is denied during validation due to the restriction
-     *      of this property, {@link org.xml.sax.SAXException} will be thrown by the
-     *      {@link #validate(Source)} method.</p>
-     *
-     *      <p>Access to external reference set by the schemaLocation attribute is
-     *      restricted to the protocols specified by the
-     *      {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} property.
-     *      If access is denied during validation due to the restriction of this property,
-     *      {@link org.xml.sax.SAXException} will be thrown by the
-     *      {@link #validate(Source)} method.</p>
-     *   </li>
-     * </ul>
-     *
-     * @param name The property name, which is a non-null fully-qualified URI.
-     * @param object The requested value for the property.
-     *
-     * @throws SAXNotRecognizedException If the property
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link Validator} recognizes the property name but
-     *   cannot set the requested value.
-     * @throws NullPointerException
-     *   When the name parameter is null.
-     */
-    public void setProperty(String name, Object object)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException("the name parameter is null");
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Look up the value of a property.
-     *
-     * <p>The property name is any fully-qualified URI.  It is
-     * possible for a {@link Validator} to recognize a property name but
-     * temporarily be unable to return its value.
-     * Some property values may be available only in specific
-     * contexts, such as before, during, or after a validation.</p>
-     *
-     * <p>{@link Validator}s are not required to recognize any specific
-     * property names.</p>
-     *
-     * <p>Implementors are free (and encouraged) to invent their own properties,
-     * using names built on their own URIs.</p>
-     *
-     * @param name The property name, which is a non-null fully-qualified URI.
-     *
-     * @return The current value of the property.
-     *
-     * @throws SAXNotRecognizedException If the property
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   XMLReader recognizes the property name but
-     *   cannot determine its value at this time.
-     * @throws NullPointerException
-     *   When the name parameter is null.
-     *
-     * @see #setProperty(String, Object)
-     */
-    public Object getProperty(String name)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException("the name parameter is null");
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactory.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactory.java b/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactory.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactory.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,805 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-import java.io.File;
-import java.net.URL;
-import javax.xml.transform.Source;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.stax.StAXSource;
-import javax.xml.transform.stream.StreamSource;
-
-import javax.xml.XMLConstants;
-import org.w3c.dom.ls.LSResourceResolver;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXNotSupportedException;
-import org.xml.sax.SAXParseException;
-
-/**
- * Factory that creates {@link javax.xml.validation.Schema} objects&#x2E; Entry-point to
- * the validation API.
- *
- * <p>
- * {@link SchemaFactory} is a schema compiler. It reads external
- * representations of schemas and prepares them for validation.
- *
- * <p>
- * The {@link SchemaFactory} class is not thread-safe. In other words,
- * it is the application's responsibility to ensure that at most
- * one thread is using a {@link SchemaFactory} object at any
- * given moment. Implementations are encouraged to mark methods
- * as <code>synchronized</code> to protect themselves from broken clients.
- *
- * <p>
- * {@link SchemaFactory} is not re-entrant. While one of the
- * <code>newSchema</code> methods is being invoked, applications
- * may not attempt to recursively invoke the <code>newSchema</code> method,
- * even from the same thread.
- *
- * <h2><a name="schemaLanguage"></a>Schema Language</h2>
- * <p>
- * This spec uses a namespace URI to designate a schema language.
- * The following table shows the values defined by this specification.
- * <p>
- * To be compliant with the spec, the implementation
- * is only required to support W3C XML Schema 1.0. However,
- * if it chooses to support other schema languages listed here,
- * it must conform to the relevant behaviors described in this spec.
- *
- * <p>
- * Schema languages not listed here are expected to
- * introduce their own URIs to represent themselves.
- * The {@link SchemaFactory} class is capable of locating other
- * implementations for other schema languages at run-time.
- *
- * <p>
- * Note that because the XML DTD is strongly tied to the parsing process
- * and has a significant effect on the parsing process, it is impossible
- * to define the DTD validation as a process independent from parsing.
- * For this reason, this specification does not define the semantics for
- * the XML DTD. This doesn't prohibit implementors from implementing it
- * in a way they see fit, but <em>users are warned that any DTD
- * validation implemented on this interface necessarily deviate from
- * the XML DTD semantics as defined in the XML 1.0</em>.
- *
- * <table border="1" cellpadding="2">
- *   <thead>
- *     <tr>
- *       <th>value</th>
- *       <th>language</th>
- *     </tr>
- *   </thead>
- *   <tbody>
- *     <tr>
- *       <td>{@link XMLConstants#W3C_XML_SCHEMA_NS_URI} ("<code>http://www.w3.org/2001/XMLSchema</code>")</td>
- *       <td><a href="http://www.w3.org/TR/xmlschema-1">W3C XML Schema 1.0</a></td>
- *     </tr>
- *     <tr>
- *       <td>{@link XMLConstants#RELAXNG_NS_URI} ("<code>http://relaxng.org/ns/structure/1.0</code>")</td>
- *       <td><a href="http://www.relaxng.org/">RELAX NG 1.0</a></td>
- *     </tr>
- *   </tbody>
- * </table>
- *
- * @author  <a href="mailto:Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @author  <a href="mailto:Neeraj.Bajaj@sun.com">Neeraj Bajaj</a>
- *
- * @since 1.5
- */
-public abstract class SchemaFactory {
-
-     private static SecuritySupport ss = new SecuritySupport();
-
-    /**
-     * <p>Constructor for derived classes.</p>
-     *
-     * <p>The constructor does nothing.</p>
-     *
-     * <p>Derived classes must create {@link SchemaFactory} objects that have
-     * <code>null</code> {@link ErrorHandler} and
-     * <code>null</code> {@link LSResourceResolver}.</p>
-     */
-    protected SchemaFactory() {
-    }
-
-    /**
-     * <p>Lookup an implementation of the <code>SchemaFactory</code> that supports the specified
-     * schema language and return it.</p>
-     *
-     * <p>To find a <code>SchemaFactory</code> object for a given schema language,
-     * this method looks the following places in the following order
-     * where "the class loader" refers to the context class loader:</p>
-     * <ol>
-     *  <li>
-     *     If the system property
-     *     <code>"javax.xml.validation.SchemaFactory:<i>schemaLanguage</i>"</code>
-     *     is present (where <i>schemaLanguage</i> is the parameter
-     *     to this method), then its value is read
-     *     as a class name. The method will try to
-     *     create a new instance of this class by using the class loader,
-     *     and returns it if it is successfully created.
-     *   </li>
-     *   <li>
-     *     <code>$java.home/lib/jaxp.properties</code> is read and
-     *     the value associated with the key being the system property above
-     *     is looked for. If present, the value is processed just like above.
-     *   </li>
-     *   <li>
-     *   Use the service-provider loading facilities, defined by the
-     *   {@link java.util.ServiceLoader} class, to attempt to locate and load an
-     *   implementation of the service using the {@linkplain
-     *   java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}:
-     *   the service-provider loading facility will use the {@linkplain
-     *   java.lang.Thread#getContextClassLoader() current thread's context class loader}
-     *   to attempt to load the service. If the context class
-     *   loader is null, the {@linkplain
-     *   ClassLoader#getSystemClassLoader() system class loader} will be used.
-     *   <br>
-     *   Each potential service provider is required to implement the method
-     *        {@link #isSchemaLanguageSupported(String schemaLanguage)}.
-     *   <br>
-     *   The first service provider found that supports the specified schema
-     *   language is returned.
-     *   <br>
-     *   In case of {@link java.util.ServiceConfigurationError} a
-     *   {@link SchemaFactoryConfigurationError} will be thrown.
-     *   </li>
-     *   <li>
-     *     Platform default <code>SchemaFactory</code> is located
-     *     in a implementation specific way. There must be a platform default
-     *     <code>SchemaFactory</code> for W3C XML Schema.
-     *   </li>
-     * </ol>
-     *
-     * <p>If everything fails, {@link IllegalArgumentException} will be thrown.</p>
-     *
-     * <p><strong>Tip for Trouble-shooting:</strong></p>
-     * <p>See {@link java.util.Properties#load(java.io.InputStream)} for
-     * exactly how a property file is parsed. In particular, colons ':'
-     * need to be escaped in a property file, so make sure schema language
-     * URIs are properly escaped in it. For example:</p>
-     * <pre>
-     * http\://www.w3.org/2001/XMLSchema=org.acme.foo.XSSchemaFactory
-     * </pre>
-     *
-     * @param schemaLanguage
-     *      Specifies the schema language which the returned
-     *      SchemaFactory will understand. See
-     *      <a href="#schemaLanguage">the list of available
-     *      schema languages</a> for the possible values.
-     *
-     * @return New instance of a <code>SchemaFactory</code>
-     *
-     * @throws IllegalArgumentException
-     *      If no implementation of the schema language is available.
-     * @throws NullPointerException
-     *      If the <code>schemaLanguage</code> parameter is null.
-     * @throws SchemaFactoryConfigurationError
-     *      If a configuration error is encountered.
-     *
-     * @see #newInstance(String schemaLanguage, String factoryClassName, ClassLoader classLoader)
-     */
-    public static SchemaFactory newInstance(String schemaLanguage) {
-        ClassLoader cl;
-        cl = ss.getContextClassLoader();
-
-        if (cl == null) {
-            //cl = ClassLoader.getSystemClassLoader();
-            //use the current class loader
-            cl = SchemaFactory.class.getClassLoader();
-        }
-
-        SchemaFactory f = new SchemaFactoryFinder(cl).newFactory(schemaLanguage);
-        if (f == null) {
-            throw new IllegalArgumentException(
-                    "No SchemaFactory"
-                    + " that implements the schema language specified by: " + schemaLanguage
-                    + " could be loaded");
-        }
-        return f;
-    }
-
-    /**
-     * <p>Obtain a new instance of a <code>SchemaFactory</code> from class name. <code>SchemaFactory</code>
-     * is returned if specified factory class name supports the specified schema language.
-     * This function is useful when there are multiple providers in the classpath.
-     * It gives more control to the application as it can specify which provider
-     * should be loaded.</p>
-     *
-     * <h2>Tip for Trouble-shooting</h2>
-     * <p>Setting the <code>jaxp.debug</code> system property will cause
-     * this method to print a lot of debug messages
-     * to <code>System.err</code> about what it is doing and where it is looking at.</p>
-     *
-     * <p> If you have problems try:</p>
-     * <pre>
-     * java -Djaxp.debug=1 YourProgram ....
-     * </pre>
-     *
-     * @param schemaLanguage Specifies the schema language which the returned
-     *                          <code>SchemaFactory</code> will understand. See
-     *                          <a href="#schemaLanguage">the list of available
-     *                          schema languages</a> for the possible values.
-     *
-     * @param factoryClassName fully qualified factory class name that provides implementation of <code>javax.xml.validation.SchemaFactory</code>.
-     *
-     * @param classLoader <code>ClassLoader</code> used to load the factory class. If <code>null</code>
-     *                     current <code>Thread</code>'s context classLoader is used to load the factory class.
-     *
-     * @return New instance of a <code>SchemaFactory</code>
-     *
-     * @throws IllegalArgumentException
-     *                   if <code>factoryClassName</code> is <code>null</code>, or
-     *                   the factory class cannot be loaded, instantiated or doesn't
-     *                   support the schema language specified in <code>schemLanguage</code>
-     *                   parameter.
-     *
-     * @throws NullPointerException
-     *      If the <code>schemaLanguage</code> parameter is null.
-     *
-     * @see #newInstance(String schemaLanguage)
-     *
-     * @since 1.6
-     */
-    public static SchemaFactory newInstance(String schemaLanguage, String factoryClassName, ClassLoader classLoader){
-        ClassLoader cl = classLoader;
-
-        if (cl == null) {
-            cl = ss.getContextClassLoader();
-        }
-
-        SchemaFactory f = new SchemaFactoryFinder(cl).createInstance(factoryClassName);
-        if (f == null) {
-            throw new IllegalArgumentException(
-                    "Factory " + factoryClassName
-                    + " could not be loaded to implement the schema language specified by: " + schemaLanguage);
-        }
-        //if this factory supports the given schemalanguage return this factory else thrown exception
-        if(f.isSchemaLanguageSupported(schemaLanguage)){
-            return f;
-        }else{
-            throw new IllegalArgumentException(
-                    "Factory " + f.getClass().getName()
-                    + " does not implement the schema language specified by: " + schemaLanguage);
-        }
-
-    }
-
-    /**
-     * <p>Is specified schema supported by this <code>SchemaFactory</code>?</p>
-     *
-     * @param schemaLanguage Specifies the schema language which the returned <code>SchemaFactory</code> will understand.
-     *    <code>schemaLanguage</code> must specify a <a href="#schemaLanguage">valid</a> schema language.
-     *
-     * @return <code>true</code> if <code>SchemaFactory</code> supports <code>schemaLanguage</code>, else <code>false</code>.
-     *
-     * @throws NullPointerException If <code>schemaLanguage</code> is <code>null</code>.
-     * @throws IllegalArgumentException If <code>schemaLanguage.length() == 0</code>
-     *   or <code>schemaLanguage</code> does not specify a <a href="#schemaLanguage">valid</a> schema language.
-     */
-    public abstract boolean isSchemaLanguageSupported(String schemaLanguage);
-
-    /**
-     * Look up the value of a feature flag.
-     *
-     * <p>The feature name is any fully-qualified URI.  It is
-     * possible for a {@link SchemaFactory} to recognize a feature name but
-     * temporarily be unable to return its value.
-     *
-     * <p>Implementors are free (and encouraged) to invent their own features,
-     * using names built on their own URIs.</p>
-     *
-     * @param name The feature name, which is a non-null fully-qualified URI.
-     *
-     * @return The current value of the feature (true or false).
-     *
-     * @throws SAXNotRecognizedException If the feature
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link SchemaFactory} recognizes the feature name but
-     *   cannot determine its value at this time.
-     * @throws NullPointerException If <code>name</code> is <code>null</code>.
-     *
-     * @see #setFeature(String, boolean)
-     */
-    public boolean getFeature(String name)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-                throw new NullPointerException("the name parameter is null");
-        }
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * <p>Set a feature for this <code>SchemaFactory</code>,
-     * {@link javax.xml.validation.Schema}s created by this factory, and by extension,
-     * {@link javax.xml.validation.Validator}s and {@link javax.xml.validation.ValidatorHandler}s created by
-     * those {@link javax.xml.validation.Schema}s.
-     * </p>
-     *
-     * <p>Implementors and developers should pay particular attention
-     * to how the special {@link javax.xml.validation.Schema} object returned by {@link
-     * #newSchema()} is processed. In some cases, for example, when the
-     * <code>SchemaFactory</code> and the class actually loading the
-     * schema come from different implementations, it may not be possible
-     * for <code>SchemaFactory</code> features to be inherited automatically.
-     * Developers should
-     * make sure that features, such as secure processing, are explicitly
-     * set in both places.</p>
-     *
-     * <p>The feature name is any fully-qualified URI. It is
-     * possible for a {@link SchemaFactory} to expose a feature value but
-     * to be unable to change the current value.</p>
-     *
-     * <p>All implementations are required to support the {@link XMLConstants#FEATURE_SECURE_PROCESSING} feature.
-     * When the feature is:</p>
-     * <ul>
-     *   <li>
-     *     <code>true</code>: the implementation will limit XML processing to conform to implementation limits.
-     *     Examples include enity expansion limits and XML Schema constructs that would consume large amounts of resources.
-     *     If XML processing is limited for security reasons, it will be reported via a call to the registered
-     *    {@link ErrorHandler#fatalError(SAXParseException exception)}.
-     *     See {@link #setErrorHandler(ErrorHandler errorHandler)}.
-     *   </li>
-     *   <li>
-     *     <code>false</code>: the implementation will processing XML according to the XML specifications without
-     *     regard to possible implementation limits.
-     *   </li>
-     * </ul>
-     *
-     * @param name The feature name, which is a non-null fully-qualified URI.
-     * @param value The requested value of the feature (true or false).
-     *
-     * @throws SAXNotRecognizedException If the feature
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link SchemaFactory} recognizes the feature name but
-     *   cannot set the requested value.
-     * @throws NullPointerException If <code>name</code> is <code>null</code>.
-     *
-     * @see #getFeature(String)
-     */
-    public void setFeature(String name, boolean value)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-                throw new NullPointerException("the name parameter is null");
-        }
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Set the value of a property.
-     *
-     * <p>The property name is any fully-qualified URI.  It is
-     * possible for a {@link SchemaFactory} to recognize a property name but
-     * to be unable to change the current value.</p>
-     *
-     * <p>
-     * All implementations that implement JAXP 1.5 or newer are required to
-     * support the {@link XMLConstants#ACCESS_EXTERNAL_DTD} and
-     * {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} properties.
-     * </p>
-     * <ul>
-     *   <li>
-     *      <p>Access to external DTDs in Schema files is restricted to the protocols
-     *      specified by the {@link XMLConstants#ACCESS_EXTERNAL_DTD} property.
-     *      If access is denied during the creation of new Schema due to the restriction
-     *      of this property, {@link org.xml.sax.SAXException} will be thrown by the
-     *      {@link #newSchema(Source)} or {@link #newSchema(File)}
-     *      or {@link #newSchema(URL)} or  or {@link #newSchema(Source[])} method.</p>
-     *
-     *      <p>Access to external DTDs in xml source files is restricted to the protocols
-     *      specified by the {@link XMLConstants#ACCESS_EXTERNAL_DTD} property.
-     *      If access is denied during validation due to the restriction
-     *      of this property, {@link org.xml.sax.SAXException} will be thrown by the
-     *      {@link javax.xml.validation.Validator#validate(Source)} or
-     *      {@link javax.xml.validation.Validator#validate(Source, Result)} method.</p>
-     *
-     *      <p>Access to external reference set by the schemaLocation attribute is
-     *      restricted to the protocols specified by the
-     *      {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} property.
-     *      If access is denied during validation due to the restriction of this property,
-     *      {@link org.xml.sax.SAXException} will be thrown by the
-     *      {@link javax.xml.validation.Validator#validate(Source)} or
-     *      {@link javax.xml.validation.Validator#validate(Source, Result)} method.</p>
-     *
-     *      <p>Access to external reference set by the Import
-     *      and Include element is restricted to the protocols specified by the
-     *      {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA} property.
-     *      If access is denied during the creation of new Schema due to the restriction
-     *      of this property, {@link org.xml.sax.SAXException} will be thrown by the
-     *      {@link #newSchema(Source)} or {@link #newSchema(File)}
-     *      or {@link #newSchema(URL)} or {@link #newSchema(Source[])} method.</p>
-     *   </li>
-     * </ul>
-     *
-     * @param name The property name, which is a non-null fully-qualified URI.
-     * @param object The requested value for the property.
-     *
-     * @throws SAXNotRecognizedException If the property
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link SchemaFactory} recognizes the property name but
-     *   cannot set the requested value.
-     * @throws NullPointerException If <code>name</code> is <code>null</code>.
-     */
-    public void setProperty(String name, Object object)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-                throw new NullPointerException("the name parameter is null");
-        }
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Look up the value of a property.
-     *
-     * <p>The property name is any fully-qualified URI.  It is
-     * possible for a {@link SchemaFactory} to recognize a property name but
-     * temporarily be unable to return its value.</p>
-     *
-     * <p>{@link SchemaFactory}s are not required to recognize any specific
-     * property names.</p>
-     *
-     * <p>Implementors are free (and encouraged) to invent their own properties,
-     * using names built on their own URIs.</p>
-     *
-     * @param name The property name, which is a non-null fully-qualified URI.
-     *
-     * @return The current value of the property.
-     *
-     * @throws SAXNotRecognizedException If the property
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   XMLReader recognizes the property name but
-     *   cannot determine its value at this time.
-     * @throws NullPointerException If <code>name</code> is <code>null</code>.
-     *
-     * @see #setProperty(String, Object)
-     */
-    public Object getProperty(String name)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-                throw new NullPointerException("the name parameter is null");
-        }
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Sets the {@link ErrorHandler} to receive errors encountered
-     * during the <code>newSchema</code> method invocation.
-     *
-     * <p>
-     * Error handler can be used to customize the error handling process
-     * during schema parsing. When an {@link ErrorHandler} is set,
-     * errors found during the parsing of schemas will be first sent
-     * to the {@link ErrorHandler}.
-     *
-     * <p>
-     * The error handler can abort the parsing of a schema immediately
-     * by throwing {@link SAXException} from the handler. Or for example
-     * it can print an error to the screen and try to continue the
-     * processing by returning normally from the {@link ErrorHandler}
-     *
-     * <p>
-     * If any {@link Throwable} (or instances of its derived classes)
-     * is thrown from an {@link ErrorHandler},
-     * the caller of the <code>newSchema</code> method will be thrown
-     * the same {@link Throwable} object.
-     *
-     * <p>
-     * {@link SchemaFactory} is not allowed to
-     * throw {@link SAXException} without first reporting it to
-     * {@link ErrorHandler}.
-     *
-     * <p>
-     * Applications can call this method even during a {@link javax.xml.validation.Schema}
-     * is being parsed.
-     *
-     * <p>
-     * When the {@link ErrorHandler} is null, the implementation will
-     * behave as if the following {@link ErrorHandler} is set:
-     * <pre>
-     * class DraconianErrorHandler implements {@link ErrorHandler} {
-     *     public void fatalError( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {
-     *         throw e;
-     *     }
-     *     public void error( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {
-     *         throw e;
-     *     }
-     *     public void warning( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {
-     *         // noop
-     *     }
-     * }
-     * </pre>
-     *
-     * <p>
-     * When a new {@link SchemaFactory} object is created, initially
-     * this field is set to null. This field will <em>NOT</em> be
-     * inherited to {@link javax.xml.validation.Schema}s, {@link javax.xml.validation.Validator}s, or
-     * {@link javax.xml.validation.ValidatorHandler}s that are created from this {@link SchemaFactory}.
-     *
-     * @param errorHandler A new error handler to be set.
-     *   This parameter can be <code>null</code>.
-     */
-    public abstract void setErrorHandler(ErrorHandler errorHandler);
-
-    /**
-     * Gets the current {@link ErrorHandler} set to this {@link SchemaFactory}.
-     *
-     * @return
-     *      This method returns the object that was last set through
-     *      the {@link #setErrorHandler(ErrorHandler)} method, or null
-     *      if that method has never been called since this {@link SchemaFactory}
-     *      has created.
-     *
-     * @see #setErrorHandler(ErrorHandler)
-     */
-    public abstract ErrorHandler getErrorHandler();
-
-    /**
-     * Sets the {@link LSResourceResolver} to customize
-     * resource resolution when parsing schemas.
-     *
-     * <p>
-     * {@link SchemaFactory} uses a {@link LSResourceResolver}
-     * when it needs to locate external resources while parsing schemas,
-     * although exactly what constitutes "locating external resources" is
-     * up to each schema language. For example, for W3C XML Schema,
-     * this includes files <code>&lt;include></code>d or <code>&lt;import></code>ed,
-     * and DTD referenced from schema files, etc.
-     *
-     * <p>
-     * Applications can call this method even during a {@link javax.xml.validation.Schema}
-     * is being parsed.
-     *
-     * <p>
-     * When the {@link LSResourceResolver} is null, the implementation will
-     * behave as if the following {@link LSResourceResolver} is set:
-     * <pre>
-     * class DumbDOMResourceResolver implements {@link LSResourceResolver} {
-     *     public {@link org.w3c.dom.ls.LSInput} resolveResource(
-     *         String publicId, String systemId, String baseURI) {
-     *
-     *         return null; // always return null
-     *     }
-     * }
-     * </pre>
-     *
-     * <p>
-     * If a {@link LSResourceResolver} throws a {@link RuntimeException}
-     *  (or instances of its derived classes),
-     * then the {@link SchemaFactory} will abort the parsing and
-     * the caller of the <code>newSchema</code> method will receive
-     * the same {@link RuntimeException}.
-     *
-     * <p>
-     * When a new {@link SchemaFactory} object is created, initially
-     * this field is set to null.  This field will <em>NOT</em> be
-     * inherited to {@link javax.xml.validation.Schema}s, {@link Validator}s, or
-     * {@link ValidatorHandler}s that are created from this {@link SchemaFactory}.
-     *
-     * @param   resourceResolver
-     *      A new resource resolver to be set. This parameter can be null.
-     */
-    public abstract void setResourceResolver(LSResourceResolver resourceResolver);
-
-    /**
-     * Gets the current {@link LSResourceResolver} set to this {@link SchemaFactory}.
-     *
-     * @return
-     *      This method returns the object that was last set through
-     *      the {@link #setResourceResolver(LSResourceResolver)} method, or null
-     *      if that method has never been called since this {@link SchemaFactory}
-     *      has created.
-     *
-     * @see #setErrorHandler(ErrorHandler)
-     */
-    public abstract LSResourceResolver getResourceResolver();
-
-    /**
-     * <p>Parses the specified source as a schema and returns it as a schema.</p>
-     *
-     * <p>This is a convenience method for {@link #newSchema(Source[] schemas)}.</p>
-     *
-     * @param schema Source that represents a schema.
-     *
-     * @return New <code>Schema</code> from parsing <code>schema</code>.
-     *
-     * @throws SAXException If a SAX error occurs during parsing.
-     * @throws NullPointerException if <code>schema</code> is null.
-     */
-    public javax.xml.validation.Schema newSchema(Source schema) throws SAXException {
-        return newSchema(new Source[]{schema});
-    }
-
-    /**
-     * <p>Parses the specified <code>File</code> as a schema and returns it as a <code>Schema</code>.</p>
-     *
-     * <p>This is a convenience method for {@link #newSchema(Source schema)}.</p>
-     *
-     * @param schema File that represents a schema.
-     *
-     * @return New <code>Schema</code> from parsing <code>schema</code>.
-     *
-     * @throws SAXException If a SAX error occurs during parsing.
-     * @throws NullPointerException if <code>schema</code> is null.
-     */
-    public javax.xml.validation.Schema newSchema(File schema) throws SAXException {
-        return newSchema(new StreamSource(schema));
-    }
-
-    /**
-     * <p>Parses the specified <code>URL</code> as a schema and returns it as a <code>Schema</code>.</p>
-     *
-     * <p>This is a convenience method for {@link #newSchema(Source schema)}.</p>
-     *
-     * @param schema <code>URL</code> that represents a schema.
-     *
-     * @return New <code>Schema</code> from parsing <code>schema</code>.
-     *
-     * @throws SAXException If a SAX error occurs during parsing.
-     * @throws NullPointerException if <code>schema</code> is null.
-     */
-    public javax.xml.validation.Schema newSchema(URL schema) throws SAXException {
-        return newSchema(new StreamSource(schema.toExternalForm()));
-    }
-
-    /**
-     * Parses the specified source(s) as a schema and returns it as a schema.
-     *
-     * <p>
-     * The callee will read all the {@link Source}s and combine them into a
-     * single schema. The exact semantics of the combination depends on the schema
-     * language that this {@link SchemaFactory} object is created for.
-     *
-     * <p>
-     * When an {@link ErrorHandler} is set, the callee will report all the errors
-     * found in sources to the handler. If the handler throws an exception, it will
-     * abort the schema compilation and the same exception will be thrown from
-     * this method. Also, after an error is reported to a handler, the callee is allowed
-     * to abort the further processing by throwing it. If an error handler is not set,
-     * the callee will throw the first error it finds in the sources.
-     *
-     * <h2>W3C XML Schema 1.0</h2>
-     * <p>
-     * The resulting schema contains components from the specified sources.
-     * The same result would be achieved if all these sources were
-     * imported, using appropriate values for schemaLocation and namespace,
-     * into a single schema document with a different targetNamespace
-     * and no components of its own, if the import elements were given
-     * in the same order as the sources.  Section 4.2.3 of the XML Schema
-     * recommendation describes the options processors have in this
-     * regard.  While a processor should be consistent in its treatment of
-     * JAXP schema sources and XML Schema imports, the behaviour between
-     * JAXP-compliant parsers may vary; in particular, parsers may choose
-     * to ignore all but the first &lt;import> for a given namespace,
-     * regardless of information provided in schemaLocation.
-     *
-     * <p>
-     * If the parsed set of schemas includes error(s) as
-     * specified in the section 5.1 of the XML Schema spec, then
-     * the error must be reported to the {@link ErrorHandler}.
-     *
-     * <h2>RELAX NG</h2>
-     *
-     * <p>For RELAX NG, this method must throw {@link UnsupportedOperationException}
-     * if <code>schemas.length!=1</code>.
-     *
-     *
-     * @param schemas
-     *      inputs to be parsed. {@link SchemaFactory} is required
-     *      to recognize {@link SAXSource},
-     *      {@link StreamSource},
-     *      {@link StAXSource},
-     *      and {@link DOMSource}.
-     *      Input schemas must be XML documents or
-     *      XML elements and must not be null. For backwards compatibility,
-     *      the results of passing anything other than
-     *      a document or element are implementation-dependent.
-     *      Implementations must either recognize and process the input
-     *      or thrown an IllegalArgumentException.
-     *
-     * @return
-     *      Always return a non-null valid {@link javax.xml.validation.Schema} object.
-     *      Note that when an error has been reported, there is no
-     *      guarantee that the returned {@link javax.xml.validation.Schema} object is
-     *      meaningful.
-     *
-     * @throws SAXException
-     *      If an error is found during processing the specified inputs.
-     *      When an {@link ErrorHandler} is set, errors are reported to
-     *      there first. See {@link #setErrorHandler(ErrorHandler)}.
-     * @throws NullPointerException
-     *      If the <code>schemas</code> parameter itself is null or
-     *      any item in the array is null.
-     * @throws IllegalArgumentException
-     *      If any item in the array is not recognized by this method.
-     * @throws UnsupportedOperationException
-     *      If the schema language doesn't support this operation.
-     */
-    public abstract javax.xml.validation.Schema newSchema(Source[] schemas) throws SAXException;
-
-    /**
-     * Creates a special {@link javax.xml.validation.Schema} object.
-     *
-     * <p>The exact semantics of the returned {@link javax.xml.validation.Schema} object
-     * depend on the schema language for which this {@link SchemaFactory}
-     * is created.
-     *
-     * <p>Also, implementations are allowed to use implementation-specific
-     * property/feature to alter the semantics of this method.</p>
-     *
-     * <p>Implementors and developers should pay particular attention
-     * to how the features set on this {@link SchemaFactory} are
-     * processed by this special {@link javax.xml.validation.Schema}.
-     * In some cases, for example, when the
-     * {@link SchemaFactory} and the class actually loading the
-     * schema come from different implementations, it may not be possible
-     * for {@link SchemaFactory} features to be inherited automatically.
-     * Developers should
-     * make sure that features, such as secure processing, are explicitly
-     * set in both places.</p>
-     *
-     * <h2>W3C XML Schema 1.0</h2>
-     * <p>
-     * For XML Schema, this method creates a {@link javax.xml.validation.Schema} object that
-     * performs validation by using location hints specified in documents.
-     *
-     * <p>
-     * The returned {@link javax.xml.validation.Schema} object assumes that if documents
-     * refer to the same URL in the schema location hints,
-     * they will always resolve to the same schema document. This
-     * asusmption allows implementations to reuse parsed results of
-     * schema documents so that multiple validations against the same
-     * schema will run faster.
-     *
-     * <p>
-     * Note that the use of schema location hints introduces a
-     * vulnerability to denial-of-service attacks.
-     *
-     *
-     * <h2>RELAX NG</h2>
-     * <p>
-     * RELAX NG does not support this operation.
-     *
-     * @return
-     *      Always return non-null valid {@link javax.xml.validation.Schema} object.
-     *
-     * @throws UnsupportedOperationException
-     *      If this operation is not supported by the callee.
-     * @throws SAXException
-     *      If this operation is supported but failed for some reason.
-     */
-    public abstract Schema newSchema() throws SAXException;
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/SecuritySupport.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/SecuritySupport.java b/Build/src/main/java/org/openjdk/javax/xml/validation/SecuritySupport.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/SecuritySupport.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,163 +0,0 @@
-/*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-import java.io.IOException;
-import java.net.URL;
-import java.security.*;
-import java.net.*;
-import java.io.*;
-import java.util.*;
-
-/**
- * This class is duplicated for each JAXP subpackage so keep it in sync.
- * It is package private and therefore is not exposed as part of the JAXP
- * API.
- *
- * Security related methods that only work on J2SE 1.2 and newer.
- */
-class SecuritySupport  {
-
-
-    ClassLoader getContextClassLoader() {
-        return (ClassLoader)
-        AccessController.doPrivileged(new PrivilegedAction() {
-            public Object run() {
-                ClassLoader cl = null;
-                //try {
-                cl = Thread.currentThread().getContextClassLoader();
-                //} catch (SecurityException ex) { }
-                if (cl == null)
-                    cl = ClassLoader.getSystemClassLoader();
-                return cl;
-            }
-        });
-    }
-
-    String getSystemProperty(final String propName) {
-        return (String)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(propName);
-                }
-            });
-    }
-
-    FileInputStream getFileInputStream(final File file)
-        throws FileNotFoundException
-    {
-        try {
-            return (FileInputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws FileNotFoundException {
-                        return new FileInputStream(file);
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (FileNotFoundException)e.getException();
-        }
-    }
-
-    InputStream getURLInputStream(final URL url)
-        throws IOException
-    {
-        try {
-            return (InputStream)
-                AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                    public Object run() throws IOException {
-                        return url.openStream();
-                    }
-                });
-        } catch (PrivilegedActionException e) {
-            throw (IOException)e.getException();
-        }
-    }
-
-    URL getResourceAsURL(final ClassLoader cl,
-                                           final String name)
-    {
-        return (URL)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    URL url;
-                    if (cl == null) {
-                        url = Object.class.getResource(name);
-                    } else {
-                        url = cl.getResource(name);
-                    }
-                    return url;
-                }
-            });
-    }
-
-    Enumeration getResources(final ClassLoader cl,
-                                           final String name) throws IOException
-    {
-        try{
-        return (Enumeration)
-            AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                public Object run() throws IOException{
-                    Enumeration enumeration;
-                    if (cl == null) {
-                        enumeration = ClassLoader.getSystemResources(name);
-                    } else {
-                        enumeration = cl.getResources(name);
-                    }
-                    return enumeration;
-                }
-            });
-        }catch(PrivilegedActionException e){
-            throw (IOException)e.getException();
-        }
-    }
-
-    InputStream getResourceAsStream(final ClassLoader cl,
-                                           final String name)
-    {
-        return (InputStream)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    InputStream ris;
-                    if (cl == null) {
-                        ris = Object.class.getResourceAsStream(name);
-                    } else {
-                        ris = cl.getResourceAsStream(name);
-                    }
-                    return ris;
-                }
-            });
-    }
-
-    boolean doesFileExist(final File f) {
-    return ((Boolean)
-            AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return new Boolean(f.exists());
-                }
-            })).booleanValue();
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/TypeInfoProvider.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/TypeInfoProvider.java b/Build/src/main/java/org/openjdk/javax/xml/validation/TypeInfoProvider.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/TypeInfoProvider.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,198 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-import javax.xml.parsers.DocumentBuilder;
-import org.w3c.dom.TypeInfo;
-
-/**
- * This class provides access to the type information determined
- * by {@link javax.xml.validation.ValidatorHandler}.
- *
- * <p>
- * Some schema languages, such as W3C XML Schema, encourages a validator
- * to report the "type" it assigns to each attribute/element.
- * Those applications who wish to access this type information can invoke
- * methods defined on this "interface" to access such type information.
- *
- * <p>
- * Implementation of this "interface" can be obtained through the
- * {@link javax.xml.validation.ValidatorHandler#getTypeInfoProvider()} method.
- *
- * @author  <a href="mailto:Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @see org.w3c.dom.TypeInfo
- * @since 1.5
- */
-public abstract class TypeInfoProvider {
-
-    /**
-     * Constructor for the derived class.
-     *
-     * <p>
-     * The constructor does nothing.
-     */
-    protected TypeInfoProvider() {
-    }
-
-    /**
-     * <p>Returns the immutable {@link TypeInfo} object for the current
-     * element.</p>
-     *
-     * <p>The method may only be called by the startElement event
-     * or the endElement event
-     * of the {@link org.xml.sax.ContentHandler} that the application sets to
-     * the {@link javax.xml.validation.ValidatorHandler}.</p>
-     *
-     * <p>When W3C XML Schema validation is being performed, in the
-     * case where an element has a union type, the {@link TypeInfo}
-     * returned by a call to <code>getElementTypeInfo()</code> from the
-     * startElement
-     * event will be the union type. The <code>TypeInfo</code>
-     * returned by a call
-     * from the endElement event will be the actual member type used
-     * to validate the element.</p>
-     *
-     * @throws IllegalStateException
-     *      If this method is called from other {@link org.xml.sax.ContentHandler}
-     *      methods.
-     * @return
-     *      An immutable {@link TypeInfo} object that represents the
-     *      type of the current element.
-     *      Note that the caller can keep references to the obtained
-     *      {@link TypeInfo} longer than the callback scope.
-     *
-     *      Otherwise, this method returns
-     *      null if the validator is unable to
-     *      determine the type of the current element for some reason
-     *      (for example, if the validator is recovering from
-     *      an earlier error.)
-     *
-     */
-    public abstract TypeInfo getElementTypeInfo();
-
-    /**
-     * Returns the immutable {@link TypeInfo} object for the specified
-     * attribute of the current element.
-     *
-     * <p>
-     * The method may only be called by the startElement event of
-     * the {@link org.xml.sax.ContentHandler} that the application sets to the
-     * {@link javax.xml.validation.ValidatorHandler}.</p>
-     *
-     * @param index
-     *      The index of the attribute. The same index for
-     *      the {@link org.xml.sax.Attributes} object passed to the
-     *      <code>startElement</code> callback.
-     *
-     * @throws IndexOutOfBoundsException
-     *      If the index is invalid.
-     * @throws IllegalStateException
-     *      If this method is called from other {@link org.xml.sax.ContentHandler}
-     *      methods.
-     *
-     * @return
-     *      An immutable {@link TypeInfo} object that represents the
-     *      type of the specified attribute.
-     *      Note that the caller can keep references to the obtained
-     *      {@link TypeInfo} longer than the callback scope.
-     *
-     *      Otherwise, this method returns
-     *      null if the validator is unable to
-     *      determine the type.
-     */
-    public abstract TypeInfo getAttributeTypeInfo(int index);
-
-    /**
-     * Returns <code>true</code> if the specified attribute is determined
-     * to be ID.
-     *
-     * <p>
-     * Exacly how an attribute is "determined to be ID" is up to the
-     * schema language. In case of W3C XML Schema, this means
-     * that the actual type of the attribute is the built-in ID type
-     * or its derived type.
-     *
-     * <p>
-     * A {@link DocumentBuilder} uses this information
-     * to properly implement {@link org.w3c.dom.Attr#isId()}.
-     *
-     * <p>
-     * The method may only be called by the startElement event of
-     * the {@link org.xml.sax.ContentHandler} that the application sets to the
-     * {@link javax.xml.validation.ValidatorHandler}.
-     *
-     * @param index
-     *      The index of the attribute. The same index for
-     *      the {@link org.xml.sax.Attributes} object passed to the
-     *      <code>startElement</code> callback.
-     *
-     * @throws IndexOutOfBoundsException
-     *      If the index is invalid.
-     * @throws IllegalStateException
-     *      If this method is called from other {@link org.xml.sax.ContentHandler}
-     *      methods.
-     *
-     * @return true
-     *      if the type of the specified attribute is ID.
-     */
-    public abstract boolean isIdAttribute(int index);
-
-    /**
-     * Returns <code>false</code> if the attribute was added by the validator.
-     *
-     * <p>
-     * This method provides information necessary for
-     * a {@link DocumentBuilder} to determine what
-     * the DOM tree should return from the {@link org.w3c.dom.Attr#getSpecified()} method.
-     *
-     * <p>
-     * The method may only be called by the startElement event of
-     * the {@link org.xml.sax.ContentHandler} that the application sets to the
-     * {@link ValidatorHandler}.
-     *
-     * <p>
-     * A general guideline for validators is to return true if
-     * the attribute was originally present in the pipeline, and
-     * false if it was added by the validator.
-     *
-     * @param index
-     *      The index of the attribute. The same index for
-     *      the {@link org.xml.sax.Attributes} object passed to the
-     *      <code>startElement</code> callback.
-     *
-     * @throws IndexOutOfBoundsException
-     *      If the index is invalid.
-     * @throws IllegalStateException
-     *      If this method is called from other {@link org.xml.sax.ContentHandler}
-     *      methods.
-     *
-     * @return
-     *      <code>true</code> if the attribute was present before the validator
-     *      processes input. <code>false</code> if the attribute was added
-     *      by the validator.
-     */
-    public abstract boolean isSpecified(int index);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/ValidatorHandler.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/ValidatorHandler.java b/Build/src/main/java/org/openjdk/javax/xml/validation/ValidatorHandler.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/ValidatorHandler.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,486 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-import javax.xml.XMLConstants;
-import org.w3c.dom.ls.LSResourceResolver;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXNotSupportedException;
-
-/**
- * Streaming validator that works on SAX stream.
- *
- * <p>
- * A {@link ValidatorHandler} object is not thread-safe and not reentrant.
- * In other words, it is the application's responsibility to make
- * sure that one {@link ValidatorHandler} object is not used from
- * more than one thread at any given time.
- *
- * <p>
- * {@link ValidatorHandler} checks if the SAX events follow
- * the set of constraints described in the associated {@link Schema},
- * and additionally it may modify the SAX events (for example
- * by adding default values, etc.)
- *
- * <p>
- * {@link ValidatorHandler} extends from {@link ContentHandler},
- * but it refines the underlying {@link ContentHandler} in
- * the following way:
- * <ol>
- *  <li>startElement/endElement events must receive non-null String
- *      for <code>uri</code>, <code>localName</code>, and <code>qname</code>,
- *      even though SAX allows some of them to be null.
- *      Similarly, the user-specified {@link ContentHandler} will receive non-null
- *      Strings for all three parameters.
- *
- *  <li>Applications must ensure that {@link ValidatorHandler}'s
- *      {@link ContentHandler#startPrefixMapping(String,String)} and
- *      {@link ContentHandler#endPrefixMapping(String)} are invoked
- *      properly. Similarly, the user-specified {@link ContentHandler}
- *      will receive startPrefixMapping/endPrefixMapping events.
- *      If the {@link ValidatorHandler} introduces additional namespace
- *      bindings, the user-specified {@link ContentHandler} will receive
- *      additional startPrefixMapping/endPrefixMapping events.
- *
- *  <li>{@link org.xml.sax.Attributes} for the
- *      {@link ContentHandler#startElement(String,String,String,Attributes)} method
- *      may or may not include xmlns* attributes.
- * </ol>
- *
- * <p>
- * A {@link ValidatorHandler} is automatically reset every time
- * the startDocument method is invoked.
- *
- * <h2>Recognized Properties and Features</h2>
- * <p>
- * This spec defines the following feature that must be recognized
- * by all {@link ValidatorHandler} implementations.
- *
- * <h3><code>http://xml.org/sax/features/namespace-prefixes</code></h3>
- * <p>
- * This feature controls how a {@link ValidatorHandler} introduces
- * namespace bindings that were not present in the original SAX event
- * stream.
- * When this feature is set to true, it must make
- * sure that the user's {@link ContentHandler} will see
- * the corresponding <code>xmlns*</code> attribute in
- * the {@link org.xml.sax.Attributes} object of the
- * {@link ContentHandler#startElement(String,String,String,Attributes)}
- * callback. Otherwise, <code>xmlns*</code> attributes must not be
- * added to {@link org.xml.sax.Attributes} that's passed to the
- * user-specified {@link ContentHandler}.
- * <p>
- * (Note that regardless of this switch, namespace bindings are
- * always notified to applications through
- * {@link ContentHandler#startPrefixMapping(String,String)} and
- * {@link ContentHandler#endPrefixMapping(String)} methods of the
- * {@link ContentHandler} specified by the user.)
- *
- * <p>
- * Note that this feature does <em>NOT</em> affect the way
- * a {@link ValidatorHandler} receives SAX events. It merely
- * changes the way it augments SAX events.
- *
- * <p>This feature is set to <code>false</code> by default.</p>
- *
- * @author  <a href="mailto:Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @since 1.5
- */
-public abstract class ValidatorHandler implements ContentHandler {
-
-    /**
-     * <p>Constructor for derived classes.</p>
-     *
-     * <p>The constructor does nothing.</p>
-     *
-     * <p>Derived classes must create {@link ValidatorHandler} objects that have
-     * <code>null</code> {@link ErrorHandler} and
-     * <code>null</code> {@link LSResourceResolver}.</p>
-     */
-    protected ValidatorHandler() {
-    }
-
-    /**
-     * Sets the {@link ContentHandler} which receives
-     * the augmented validation result.
-     *
-     * <p>
-     * When a {@link ContentHandler} is specified, a
-     * {@link ValidatorHandler} will work as a filter
-     * and basically copy the incoming events to the
-     * specified {@link ContentHandler}.
-     *
-     * <p>
-     * In doing so, a {@link ValidatorHandler} may modify
-     * the events, for example by adding defaulted attributes.
-     *
-     * <p>
-     * A {@link ValidatorHandler} may buffer events to certain
-     * extent, but to allow {@link ValidatorHandler} to be used
-     * by a parser, the following requirement has to be met.
-     *
-     * <ol>
-     *  <li>When
-     *      {@link ContentHandler#startElement(String, String, String, Attributes)},
-     *      {@link ContentHandler#endElement(String, String, String)},
-     *      {@link ContentHandler#startDocument()}, or
-     *      {@link ContentHandler#endDocument()}
-     *      are invoked on a {@link ValidatorHandler},
-     *      the same method on the user-specified {@link ContentHandler}
-     *      must be invoked for the same event before the callback
-     *      returns.
-     *  <li>{@link ValidatorHandler} may not introduce new elements that
-     *      were not present in the input.
-     *
-     *  <li>{@link ValidatorHandler} may not remove attributes that were
-     *      present in the input.
-     * </ol>
-     *
-     * <p>
-     * When a callback method on the specified {@link ContentHandler}
-     * throws an exception, the same exception object must be thrown
-     * from the {@link ValidatorHandler}. The {@link ErrorHandler}
-     * should not be notified of such an exception.
-     *
-     * <p>
-     * This method can be called even during a middle of a validation.
-     *
-     * @param receiver
-     *      A {@link ContentHandler} or a null value.
-     */
-    public abstract void setContentHandler(ContentHandler receiver);
-
-    /**
-     * Gets the {@link ContentHandler} which receives the
-     * augmented validation result.
-     *
-     * @return
-     *      This method returns the object that was last set through
-     *      the {@link #getContentHandler()} method, or null
-     *      if that method has never been called since this {@link ValidatorHandler}
-     *      has created.
-     *
-     * @see #setContentHandler(ContentHandler)
-     */
-    public abstract ContentHandler getContentHandler();
-
-    /**
-     * Sets the {@link ErrorHandler} to receive errors encountered
-     * during the validation.
-     *
-     * <p>
-     * Error handler can be used to customize the error handling process
-     * during a validation. When an {@link ErrorHandler} is set,
-     * errors found during the validation will be first sent
-     * to the {@link ErrorHandler}.
-     *
-     * <p>
-     * The error handler can abort further validation immediately
-     * by throwing {@link org.xml.sax.SAXException} from the handler. Or for example
-     * it can print an error to the screen and try to continue the
-     * validation by returning normally from the {@link ErrorHandler}
-     *
-     * <p>
-     * If any {@link Throwable} is thrown from an {@link ErrorHandler},
-     * the same {@link Throwable} object will be thrown toward the
-     * root of the call stack.
-     *
-     * <p>
-     * {@link ValidatorHandler} is not allowed to
-     * throw {@link org.xml.sax.SAXException} without first reporting it to
-     * {@link ErrorHandler}.
-     *
-     * <p>
-     * When the {@link ErrorHandler} is null, the implementation will
-     * behave as if the following {@link ErrorHandler} is set:
-     * <pre>
-     * class DraconianErrorHandler implements {@link ErrorHandler} {
-     *     public void fatalError( {@link org.xml.sax.SAXParseException} e ) throws {@link org.xml.sax.SAXException} {
-     *         throw e;
-     *     }
-     *     public void error( {@link org.xml.sax.SAXParseException} e ) throws {@link org.xml.sax.SAXException} {
-     *         throw e;
-     *     }
-     *     public void warning( {@link org.xml.sax.SAXParseException} e ) throws {@link org.xml.sax.SAXException} {
-     *         // noop
-     *     }
-     * }
-     * </pre>
-     *
-     * <p>
-     * When a new {@link ValidatorHandler} object is created, initially
-     * this field is set to null.
-     *
-     * @param   errorHandler
-     *      A new error handler to be set. This parameter can be null.
-     */
-    public abstract void setErrorHandler(ErrorHandler errorHandler);
-
-    /**
-     * Gets the current {@link ErrorHandler} set to this {@link ValidatorHandler}.
-     *
-     * @return
-     *      This method returns the object that was last set through
-     *      the {@link #setErrorHandler(ErrorHandler)} method, or null
-     *      if that method has never been called since this {@link ValidatorHandler}
-     *      has created.
-     *
-     * @see #setErrorHandler(ErrorHandler)
-     */
-    public abstract ErrorHandler getErrorHandler();
-
-    /**
-     * Sets the {@link LSResourceResolver} to customize
-     * resource resolution while in a validation episode.
-     *
-     * <p>
-     * {@link ValidatorHandler} uses a {@link LSResourceResolver}
-     * when it needs to locate external resources while a validation,
-     * although exactly what constitutes "locating external resources" is
-     * up to each schema language.
-     *
-     * <p>
-     * When the {@link LSResourceResolver} is null, the implementation will
-     * behave as if the following {@link LSResourceResolver} is set:
-     * <pre>
-     * class DumbLSResourceResolver implements {@link LSResourceResolver} {
-     *     public {@link org.w3c.dom.ls.LSInput} resolveResource(
-     *         String publicId, String systemId, String baseURI) {
-     *
-     *         return null; // always return null
-     *     }
-     * }
-     * </pre>
-     *
-     * <p>
-     * If a {@link LSResourceResolver} throws a {@link RuntimeException}
-     *  (or instances of its derived classes),
-     * then the {@link ValidatorHandler} will abort the parsing and
-     * the caller of the <code>validate</code> method will receive
-     * the same {@link RuntimeException}.
-     *
-     * <p>
-     * When a new {@link ValidatorHandler} object is created, initially
-     * this field is set to null.
-     *
-     * @param   resourceResolver
-     *      A new resource resolver to be set. This parameter can be null.
-     */
-    public abstract void setResourceResolver(LSResourceResolver resourceResolver);
-
-    /**
-     * Gets the current {@link LSResourceResolver} set to this {@link ValidatorHandler}.
-     *
-     * @return
-     *      This method returns the object that was last set through
-     *      the {@link #setResourceResolver(LSResourceResolver)} method, or null
-     *      if that method has never been called since this {@link ValidatorHandler}
-     *      has created.
-     *
-     * @see #setErrorHandler(ErrorHandler)
-     */
-    public abstract LSResourceResolver getResourceResolver();
-
-    /**
-     * Obtains the {@link javax.xml.validation.TypeInfoProvider} implementation of this
-     * {@link ValidatorHandler}.
-     *
-     * <p>
-     * The obtained {@link javax.xml.validation.TypeInfoProvider} can be queried during a parse
-     * to access the type information determined by the validator.
-     *
-     * <p>
-     * Some schema languages do not define the notion of type,
-     * for those languages, this method may not be supported.
-     * However, to be compliant with this specification, implementations
-     * for W3C XML Schema 1.0 must support this operation.
-     *
-     * @return
-     *      null if the validator / schema language does not support
-     *      the notion of {@link org.w3c.dom.TypeInfo}.
-     *      Otherwise a non-null valid {@link javax.xml.validation.TypeInfoProvider}.
-     */
-    public abstract TypeInfoProvider getTypeInfoProvider();
-
-
-    /**
-     * Look up the value of a feature flag.
-     *
-     * <p>The feature name is any fully-qualified URI.  It is
-     * possible for a {@link ValidatorHandler} to recognize a feature name but
-     * temporarily be unable to return its value.
-     * Some feature values may be available only in specific
-     * contexts, such as before, during, or after a validation.
-     *
-     * <p>Implementors are free (and encouraged) to invent their own features,
-     * using names built on their own URIs.</p>
-     *
-     * @param name The feature name, which is a non-null fully-qualified URI.
-     *
-     * @return The current value of the feature (true or false).
-     *
-     * @throws SAXNotRecognizedException If the feature
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link ValidatorHandler} recognizes the feature name but
-     *   cannot determine its value at this time.
-     * @throws NullPointerException When <code>name</code> is <code>null</code>.
-     *
-     * @see #setFeature(String, boolean)
-     */
-    public boolean getFeature(String name)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException();
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * <p>Set a feature for this <code>ValidatorHandler</code>.</p>
-     *
-     * <p>Feature can be used to control the way a
-     * {@link ValidatorHandler} parses schemas. The feature name is
-     * any fully-qualified URI. It is possible for a
-     * {@link SchemaFactory} to
-     * expose a feature value but to be unable to change the current
-     * value. Some feature values may be immutable or mutable only in
-     * specific contexts, such as before, during, or after a
-     * validation.</p>
-     *
-     * <p>All implementations are required to support the {@link XMLConstants#FEATURE_SECURE_PROCESSING} feature.
-     * When the feature is:</p>
-     * <ul>
-     *   <li>
-     *     <code>true</code>: the implementation will limit XML processing to conform to implementation limits.
-     *     Examples include enity expansion limits and XML Schema constructs that would consume large amounts of resources.
-     *     If XML processing is limited for security reasons, it will be reported via a call to the registered
-     *    {@link ErrorHandler#fatalError(SAXParseException exception)}.
-     *     See {@link #setErrorHandler(ErrorHandler errorHandler)}.
-     *   </li>
-     *   <li>
-     *     <code>false</code>: the implementation will processing XML according to the XML specifications without
-     *     regard to possible implementation limits.
-     *   </li>
-     * </ul>
-     *
-     * @param name The feature name, which is a non-null fully-qualified URI.
-     * @param value The requested value of the feature (true or false).
-     *
-     * @throws SAXNotRecognizedException If the feature
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link ValidatorHandler} recognizes the feature name but
-     *   cannot set the requested value.
-     * @throws NullPointerException When <code>name</code> is <code>null</code>.
-     *
-     * @see #getFeature(String)
-     */
-    public void setFeature(String name, boolean value)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException();
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Set the value of a property.
-     *
-     * <p>The property name is any fully-qualified URI.  It is
-     * possible for a {@link ValidatorHandler} to recognize a property name but
-     * to be unable to change the current value.
-     * Some property values may be immutable or mutable only
-     * in specific contexts, such as before, during, or after
-     * a validation.</p>
-     *
-     * <p>{@link ValidatorHandler}s are not required to recognize setting
-     * any specific property names.</p>
-     *
-     * @param name The property name, which is a non-null fully-qualified URI.
-     * @param object The requested value for the property.
-     *
-     * @throws SAXNotRecognizedException If the property
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   {@link ValidatorHandler} recognizes the property name but
-     *   cannot set the requested value.
-     * @throws NullPointerException When <code>name</code> is <code>null</code>.
-     */
-    public void setProperty(String name, Object object)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException();
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-
-    /**
-     * Look up the value of a property.
-     *
-     * <p>The property name is any fully-qualified URI.  It is
-     * possible for a {@link ValidatorHandler} to recognize a property name but
-     * temporarily be unable to return its value.
-     * Some property values may be available only in specific
-     * contexts, such as before, during, or after a validation.</p>
-     *
-     * <p>{@link ValidatorHandler}s are not required to recognize any specific
-     * property names.</p>
-     *
-     * <p>Implementors are free (and encouraged) to invent their own properties,
-     * using names built on their own URIs.</p>
-     *
-     * @param name The property name, which is a non-null fully-qualified URI.
-     *
-     * @return The current value of the property.
-     *
-     * @throws SAXNotRecognizedException If the property
-     *   value can't be assigned or retrieved.
-     * @throws SAXNotSupportedException When the
-     *   XMLReader recognizes the property name but
-     *   cannot determine its value at this time.
-     * @throws NullPointerException When <code>name</code> is <code>null</code>.
-     *
-     * @see #setProperty(String, Object)
-     */
-    public Object getProperty(String name)
-        throws SAXNotRecognizedException, SAXNotSupportedException {
-
-        if (name == null) {
-            throw new NullPointerException();
-        }
-
-        throw new SAXNotRecognizedException(name);
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryFinder.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryFinder.java b/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryFinder.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryFinder.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,448 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-import java.io.File;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.net.URL;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Properties;
-import java.util.ServiceConfigurationError;
-import java.util.ServiceLoader;
-
-/**
- * Implementation of {@link javax.xml.validation.SchemaFactory#newInstance(String)}.
- *
- * @author <a href="Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @version $Revision: 1.8 $, $Date: 2010-11-01 04:36:13 $
- * @since 1.5
- */
-class SchemaFactoryFinder  {
-
-    /** debug support code. */
-    private static boolean debug = false;
-    /**
-     *<p> Take care of restrictions imposed by java security model </p>
-     */
-    private static final SecuritySupport ss = new SecuritySupport();
-    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xerces.internal";
-    /**
-     * <p>Cache properties for performance.</p>
-     */
-    private static final Properties cacheProps = new Properties();
-
-    /**
-     * <p>First time requires initialization overhead.</p>
-     */
-    private static volatile boolean firstTime = true;
-
-    static {
-        // Use try/catch block to support applets
-        try {
-            debug = ss.getSystemProperty("jaxp.debug") != null;
-        } catch (Exception unused) {
-            debug = false;
-        }
-    }
-
-    /**
-     * <p>Conditional debug printing.</p>
-     *
-     * @param msg to print
-     */
-    private static void debugPrintln(String msg) {
-        if (debug) {
-            System.err.println("JAXP: " + msg);
-        }
-    }
-
-    /**
-     * <p><code>ClassLoader</code> to use to find <code>SchemaFactory</code>.</p>
-     */
-    private final ClassLoader classLoader;
-
-    /**
-     * <p>Constructor that specifies <code>ClassLoader</code> to use
-     * to find <code>SchemaFactory</code>.</p>
-     *
-     * @param loader
-     *      to be used to load resource, {@link javax.xml.validation.SchemaFactory}, and
-     *      {@link SchemaFactoryLoader} implementations during
-     *      the resolution process.
-     *      If this parameter is null, the default system class loader
-     *      will be used.
-     */
-    public SchemaFactoryFinder(ClassLoader loader) {
-        this.classLoader = loader;
-        if( debug ) {
-            debugDisplayClassLoader();
-        }
-    }
-
-    private void debugDisplayClassLoader() {
-        try {
-            if( classLoader == ss.getContextClassLoader() ) {
-                debugPrintln("using thread context class loader ("+classLoader+") for search");
-                return;
-            }
-        } catch( Throwable unused ) {
-            // getContextClassLoader() undefined in JDK1.1
-        }
-
-        if( classLoader==ClassLoader.getSystemClassLoader() ) {
-            debugPrintln("using system class loader ("+classLoader+") for search");
-            return;
-        }
-
-        debugPrintln("using class loader ("+classLoader+") for search");
-    }
-
-    /**
-     * <p>Creates a new {@link javax.xml.validation.SchemaFactory} object for the specified
-     * schema language.</p>
-     *
-     * @param schemaLanguage
-     *      See {@link javax.xml.validation.SchemaFactory Schema Language} table in <code>SchemaFactory</code>
-     *      for the list of available schema languages.
-     *
-     * @return <code>null</code> if the callee fails to create one.
-     *
-     * @throws NullPointerException
-     *      If the <code>schemaLanguage</code> parameter is null.
-     * @throws SchemaFactoryConfigurationError
-     *      If a configuration error is encountered.
-     */
-    public javax.xml.validation.SchemaFactory newFactory(String schemaLanguage) {
-        if(schemaLanguage==null) {
-            throw new NullPointerException();
-        }
-        javax.xml.validation.SchemaFactory f = _newFactory(schemaLanguage);
-        if (f != null) {
-            debugPrintln("factory '" + f.getClass().getName() + "' was found for " + schemaLanguage);
-        } else {
-            debugPrintln("unable to find a factory for " + schemaLanguage);
-        }
-        return f;
-    }
-
-    /**
-     * <p>Lookup a <code>SchemaFactory</code> for the given <code>schemaLanguage</code>.</p>
-     *
-     * @param schemaLanguage Schema language to lookup <code>SchemaFactory</code> for.
-     *
-     * @return <code>SchemaFactory</code> for the given <code>schemaLanguage</code>.
-     */
-    private javax.xml.validation.SchemaFactory _newFactory(String schemaLanguage) {
-        javax.xml.validation.SchemaFactory sf;
-
-        String propertyName = SERVICE_CLASS.getName() + ":" + schemaLanguage;
-
-        // system property look up
-        try {
-            debugPrintln("Looking up system property '"+propertyName+"'" );
-            String r = ss.getSystemProperty(propertyName);
-            if(r!=null) {
-                debugPrintln("The value is '"+r+"'");
-                sf = createInstance(r, true);
-                if(sf!=null)    return sf;
-            } else
-                debugPrintln("The property is undefined.");
-        } catch( Throwable t ) {
-            if( debug ) {
-                debugPrintln("failed to look up system property '"+propertyName+"'" );
-                t.printStackTrace();
-            }
-        }
-
-        String javah = ss.getSystemProperty( "java.home" );
-        String configFile = javah + File.separator +
-        "lib" + File.separator + "jaxp.properties";
-
-
-        // try to read from $java.home/lib/jaxp.properties
-        try {
-            if(firstTime){
-                synchronized(cacheProps){
-                    if(firstTime){
-                        File f=new File( configFile );
-                        firstTime = false;
-                        if(ss.doesFileExist(f)){
-                            debugPrintln("Read properties file " + f);
-                            cacheProps.load(ss.getFileInputStream(f));
-                        }
-                    }
-                }
-            }
-            final String factoryClassName = cacheProps.getProperty(propertyName);
-            debugPrintln("found " + factoryClassName + " in $java.home/jaxp.properties");
-
-            if (factoryClassName != null) {
-                sf = createInstance(factoryClassName, true);
-                if(sf != null){
-                    return sf;
-                }
-            }
-        } catch (Exception ex) {
-            if (debug) {
-                ex.printStackTrace();
-            }
-        }
-
-        // Try with ServiceLoader
-        final javax.xml.validation.SchemaFactory factoryImpl = findServiceProvider(schemaLanguage);
-
-        // The following assertion should always be true.
-        // Uncomment it, recompile, and run with -ea in case of doubts:
-        // assert factoryImpl == null || factoryImpl.isSchemaLanguageSupported(schemaLanguage);
-
-        if (factoryImpl != null) {
-            return factoryImpl;
-        }
-
-        // platform default
-        if(schemaLanguage.equals("http://www.w3.org/2001/XMLSchema")) {
-            debugPrintln("attempting to use the platform default XML Schema validator");
-            return createInstance("com.sun.org.apache.xerces.internal.jaxp.validation.XMLSchemaFactory", true);
-        }
-
-        debugPrintln("all things were tried, but none was found. bailing out.");
-        return null;
-    }
-
-    /** <p>Create class using appropriate ClassLoader.</p>
-     *
-     * @param className Name of class to create.
-     * @return Created class or <code>null</code>.
-     */
-    private Class<?> createClass(String className) {
-        Class<?> clazz;
-        // make sure we have access to restricted packages
-        boolean internal = false;
-        if (System.getSecurityManager() != null) {
-            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
-                internal = true;
-            }
-        }
-
-        try {
-            if (classLoader != null && !internal) {
-                clazz = Class.forName(className, false, classLoader);
-            } else {
-                clazz = Class.forName(className);
-            }
-        } catch (Throwable t) {
-            if(debug)  {
-                t.printStackTrace();
-            }
-            return null;
-        }
-
-        return clazz;
-    }
-
-    /**
-     * <p>Creates an instance of the specified and returns it.</p>
-     *
-     * @param className
-     *      fully qualified class name to be instantiated.
-     *
-     * @return null
-     *      if it fails. Error messages will be printed by this method.
-     */
-    javax.xml.validation.SchemaFactory createInstance(String className ) {
-        return createInstance( className, false );
-    }
-
-    javax.xml.validation.SchemaFactory createInstance(String className, boolean useServicesMechanism ) {
-        javax.xml.validation.SchemaFactory schemaFactory = null;
-
-        debugPrintln("createInstance(" + className + ")");
-
-        // get Class from className
-        Class<?> clazz = createClass(className);
-        if (clazz == null) {
-                debugPrintln("failed to getClass(" + className + ")");
-                return null;
-        }
-        debugPrintln("loaded " + className + " from " + which(clazz));
-
-        // instantiate Class as a SchemaFactory
-        try {
-                if (!javax.xml.validation.SchemaFactory.class.isAssignableFrom(clazz)) {
-                    throw new ClassCastException(clazz.getName()
-                                + " cannot be cast to " + javax.xml.validation.SchemaFactory.class);
-                }
-                if (!useServicesMechanism) {
-                    schemaFactory = newInstanceNoServiceLoader(clazz);
-                }
-                if (schemaFactory == null) {
-                    schemaFactory = (javax.xml.validation.SchemaFactory) clazz.newInstance();
-                }
-        } catch (ClassCastException classCastException) {
-                debugPrintln("could not instantiate " + clazz.getName());
-                if (debug) {
-                        classCastException.printStackTrace();
-                }
-                return null;
-        } catch (IllegalAccessException illegalAccessException) {
-                debugPrintln("could not instantiate " + clazz.getName());
-                if (debug) {
-                        illegalAccessException.printStackTrace();
-                }
-                return null;
-        } catch (InstantiationException instantiationException) {
-                debugPrintln("could not instantiate " + clazz.getName());
-                if (debug) {
-                        instantiationException.printStackTrace();
-                }
-                return null;
-        }
-
-        return schemaFactory;
-    }
-
-    /**
-     * Try to construct using newXMLSchemaFactoryNoServiceLoader
-     *   method if available.
-     */
-    private static javax.xml.validation.SchemaFactory newInstanceNoServiceLoader(
-         Class<?> providerClass
-    ) {
-        // Retain maximum compatibility if no security manager.
-        if (System.getSecurityManager() == null) {
-            return null;
-        }
-        try {
-            final Method creationMethod =
-                providerClass.getDeclaredMethod(
-                    "newXMLSchemaFactoryNoServiceLoader"
-                );
-            final int modifiers = creationMethod.getModifiers();
-
-            // Do not call the method if it's not public static.
-            if (!Modifier.isStatic(modifiers) || !Modifier.isPublic(modifiers)) {
-                return null;
-            }
-
-            // Only calls "newXMLSchemaFactoryNoServiceLoader" if it's
-            // declared to return an instance of SchemaFactory.
-            final Class<?> returnType = creationMethod.getReturnType();
-            if (SERVICE_CLASS.isAssignableFrom(returnType)) {
-                return SERVICE_CLASS.cast(creationMethod.invoke(null, (Object[])null));
-            } else {
-                // Should not happen since
-                // XMLSchemaFactory.newXMLSchemaFactoryNoServiceLoader is
-                // declared to return XMLSchemaFactory.
-                throw new ClassCastException(returnType
-                            + " cannot be cast to " + SERVICE_CLASS);
-            }
-        } catch(ClassCastException e) {
-            throw new SchemaFactoryConfigurationError(e.getMessage(), e);
-        } catch (NoSuchMethodException exc) {
-            return null;
-        } catch (Exception exc) {
-            return null;
-        }
-    }
-
-    // Call isSchemaLanguageSupported with initial context.
-    private boolean isSchemaLanguageSupportedBy(final javax.xml.validation.SchemaFactory factory,
-            final String schemaLanguage,
-            AccessControlContext acc) {
-        return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
-            public Boolean run() {
-                return factory.isSchemaLanguageSupported(schemaLanguage);
-            }
-        }, acc);
-    }
-
-    /**
-     * Finds a service provider subclass of SchemaFactory that supports the
-     * given schema language using the ServiceLoader.
-     *
-     * @param schemaLanguage The schema language for which we seek a factory.
-     * @return A SchemaFactory supporting the specified schema language, or null
-     *         if none is found.
-     * @throws SchemaFactoryConfigurationError if a configuration error is found.
-     */
-    private javax.xml.validation.SchemaFactory findServiceProvider(final String schemaLanguage) {
-        assert schemaLanguage != null;
-        // store current context.
-        final AccessControlContext acc = AccessController.getContext();
-        try {
-            return AccessController.doPrivileged(new PrivilegedAction<javax.xml.validation.SchemaFactory>() {
-                public javax.xml.validation.SchemaFactory run() {
-                    final ServiceLoader<javax.xml.validation.SchemaFactory> loader =
-                            ServiceLoader.load(SERVICE_CLASS);
-                    for (javax.xml.validation.SchemaFactory factory : loader) {
-                        // restore initial context to call
-                        // factory.isSchemaLanguageSupported
-                        if (isSchemaLanguageSupportedBy(factory, schemaLanguage, acc)) {
-                            return factory;
-                        }
-                    }
-                    return null; // no factory found.
-                }
-            });
-        } catch (ServiceConfigurationError error) {
-            throw new SchemaFactoryConfigurationError(
-                    "Provider for " + SERVICE_CLASS + " cannot be created", error);
-        }
-    }
-
-    private static final Class<javax.xml.validation.SchemaFactory> SERVICE_CLASS = SchemaFactory.class;
-
-
-    private static String which( Class<?> clazz ) {
-        return which( clazz.getName(), clazz.getClassLoader() );
-    }
-
-    /**
-     * <p>Search the specified classloader for the given classname.</p>
-     *
-     * @param classname the fully qualified name of the class to search for
-     * @param loader the classloader to search
-     *
-     * @return the source location of the resource, or null if it wasn't found
-     */
-    private static String which(String classname, ClassLoader loader) {
-
-        String classnameAsResource = classname.replace('.', '/') + ".class";
-
-        if( loader==null )  loader = ClassLoader.getSystemClassLoader();
-
-        //URL it = loader.getResource(classnameAsResource);
-        URL it = ss.getResourceAsURL(loader, classnameAsResource);
-        if (it != null) {
-            return it.toString();
-        } else {
-            return null;
-        }
-    }
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryLoader.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryLoader.java b/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryLoader.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryLoader.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2004, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-/**
- * <p>Factory that creates {@link javax.xml.validation.SchemaFactory}.</p>
- *
- * <p><b>DO NOT USE THIS CLASS</b></p>
- *
- * <p>
- * This class was introduced as a part of an early proposal during the
- * JSR-206 standardization process. The proposal was eventually abandoned
- * but this class accidentally remained in the source tree, and made its
- * way into the final version.
- * </p><p>
- * This class does not participate in any JAXP 1.3 or JAXP 1.4 processing.
- * It must not be used by users or JAXP implementations.
- * </p>
- *
- * @author <a href="Kohsuke.Kawaguchi@Sun.com">Kohsuke Kawaguchi</a>
- * @since 1.5
- */
-public abstract class SchemaFactoryLoader {
-
-    /**
-     * A do-nothing constructor.
-     */
-    protected SchemaFactoryLoader() {
-    }
-
-    /**
-     * Creates a new {@link javax.xml.validation.SchemaFactory} object for the specified
-     * schema language.
-     *
-     * @param schemaLanguage
-     *      See <a href="SchemaFactory.html#schemaLanguage">
-     *      the list of available schema languages</a>.
-     *
-     * @throws NullPointerException
-     *      If the <tt>schemaLanguage</tt> parameter is null.
-     *
-     * @return <code>null</code> if the callee fails to create one.
-     */
-    public abstract SchemaFactory newFactory(String schemaLanguage);
-}
Index: Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryConfigurationError.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryConfigurationError.java b/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryConfigurationError.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/validation/SchemaFactoryConfigurationError.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml.validation;
-
-/**
- * Thrown when a problem with configuration with the Schema Factories
- * exists. This error will typically be thrown when the class of a
- * schema factory specified in the system properties cannot be found
- * or instantiated.
- * @since 1.8
- */
-public final class SchemaFactoryConfigurationError extends Error {
-
-    static final long serialVersionUID = 3531438703147750126L;
-
-    /**
-     * Create a new <code>SchemaFactoryConfigurationError</code> with no
-     * detail message.
-     */
-    public SchemaFactoryConfigurationError() {
-    }
-
-
-    /**
-     * Create a new <code>SchemaFactoryConfigurationError</code> with
-     * the <code>String</code> specified as an error message.
-     *
-     * @param message The error message for the exception.
-     */
-    public SchemaFactoryConfigurationError(String message) {
-        super(message);
-    }
-
-    /**
-     * Create a new <code>SchemaFactoryConfigurationError</code> with the
-     * given <code>Throwable</code> base cause.
-     *
-     * @param cause The exception or error to be encapsulated in a
-     * SchemaFactoryConfigurationError.
-     */
-    public SchemaFactoryConfigurationError(Throwable cause) {
-        super(cause);
-    }
-
-    /**
-     * Create a new <code>SchemaFactoryConfigurationError</code> with the
-     * given <code>Throwable</code> base cause and detail message.
-     *
-     * @param cause The exception or error to be encapsulated in a
-     * SchemaFactoryConfigurationError.
-     * @param message The detail message.
-     */
-    public SchemaFactoryConfigurationError(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-}
Index: Build/src/main/java/org/openjdk/javax/xml/XMLConstants.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/javax/xml/XMLConstants.java b/Build/src/main/java/org/openjdk/javax/xml/XMLConstants.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/javax/xml/XMLConstants.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,398 +0,0 @@
-/*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package javax.xml;
-
-import javax.xml.parsers.SAXParser;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerConfigurationException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.validation.SchemaFactory;
-
-/**
- * <p>Utility class to contain basic XML values as constants.</p>
- *
- * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
- * @version $Revision: 1.8 $, $Date: 2010/05/25 16:19:45 $
- * @see <a href="http://www.w3.org/TR/xml11/">Extensible Markup Language (XML) 1.1</a>
- * @see <a href="http://www.w3.org/TR/REC-xml">Extensible Markup Language (XML) 1.0 (Second Edition)</a>
- * @see <a href="http://www.w3.org/XML/xml-V10-2e-errata">XML 1.0 Second Edition Specification Errata</a>
- * @see <a href="http://www.w3.org/TR/xml-names11/">Namespaces in XML 1.1</a>
- * @see <a href="http://www.w3.org/TR/REC-xml-names">Namespaces in XML</a>
- * @see <a href="http://www.w3.org/XML/xml-names-19990114-errata">Namespaces in XML Errata</a>
- * @see <a href="http://www.w3.org/TR/xmlschema-1/">XML Schema Part 1: Structures</a>
- * @since 1.5
- **/
-
-public final class XMLConstants {
-
-    /**
-     * <p>Private constructor to prevent instantiation.</p>
-     */
-        private XMLConstants() {
-        }
-
-    /**
-     * <p>Namespace URI to use to represent that there is no Namespace.</p>
-     *
-     * <p>Defined by the Namespace specification to be "".</p>
-     *
-     * @see <a href="http://www.w3.org/TR/REC-xml-names/#defaulting">
-     * Namespaces in XML, 5.2 Namespace Defaulting</a>
-     */
-    public static final String NULL_NS_URI = "";
-
-    /**
-     * <p>Prefix to use to represent the default XML Namespace.</p>
-     *
-     * <p>Defined by the XML specification to be "".</p>
-     *
-     * @see <a
-     * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">
-     * Namespaces in XML, 3. Qualified Names</a>
-     */
-    public static final String DEFAULT_NS_PREFIX = "";
-
-    /**
-     * <p>The official XML Namespace name URI.</p>
-     *
-     * <p>Defined by the XML specification to be
-     * "{@code http://www.w3.org/XML/1998/namespace}".</p>
-     *
-     * @see <a
-     * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">
-     * Namespaces in XML, 3. Qualified Names</a>
-     */
-    public static final String XML_NS_URI =
-        "http://www.w3.org/XML/1998/namespace";
-
-    /**
-     * <p>The official XML Namespace prefix.</p>
-     *
-     * <p>Defined by the XML specification to be "{@code xml}".</p>
-     *
-     * @see <a
-     * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">
-     * Namespaces in XML, 3. Qualified Names<</a>
-     */
-    public static final String XML_NS_PREFIX = "xml";
-
-    /**
-     * <p>The official XML attribute used for specifying XML Namespace
-     * declarations, {@link #XMLNS_ATTRIBUTE
-     * XMLConstants.XMLNS_ATTRIBUTE}, Namespace name URI.</p>
-     *
-     * <p>Defined by the XML specification to be
-     * "{@code http://www.w3.org/2000/xmlns/}".</p>
-     *
-     * @see <a
-     * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">
-     * Namespaces in XML, 3. Qualified Names</a>
-     * @see <a
-     * href="http://www.w3.org/XML/xml-names-19990114-errata">
-     * Namespaces in XML Errata</a>
-     */
-    public static final String XMLNS_ATTRIBUTE_NS_URI =
-        "http://www.w3.org/2000/xmlns/";
-
-    /**
-     * <p>The official XML attribute used for specifying XML Namespace
-     * declarations.</p>
-     *
-     * <p>It is <strong><em>NOT</em></strong> valid to use as a
-     * prefix.  Defined by the XML specification to be
-     * "{@code xmlns}".</p>
-     *
-     * @see <a
-     * href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">
-     * Namespaces in XML, 3. Qualified Names</a>
-     */
-    public static final String XMLNS_ATTRIBUTE = "xmlns";
-
-    /**
-     * <p>W3C XML Schema Namespace URI.</p>
-     *
-     * <p>Defined to be "{@code http://www.w3.org/2001/XMLSchema}".
-     *
-     * @see <a href=
-     *  "http://www.w3.org/TR/xmlschema-1/#Instance_Document_Constructions">
-     *  XML Schema Part 1:
-     *  Structures, 2.6 Schema-Related Markup in Documents Being Validated</a>
-     */
-    public static final String W3C_XML_SCHEMA_NS_URI =
-        "http://www.w3.org/2001/XMLSchema";
-
-    /**
-     * <p>W3C XML Schema Instance Namespace URI.</p>
-     *
-     * <p>Defined to be "{@code http://www.w3.org/2001/XMLSchema-instance}".</p>
-     *
-     * @see <a href=
-     *  "http://www.w3.org/TR/xmlschema-1/#Instance_Document_Constructions">
-     *  XML Schema Part 1:
-     *  Structures, 2.6 Schema-Related Markup in Documents Being Validated</a>
-     */
-    public static final String W3C_XML_SCHEMA_INSTANCE_NS_URI =
-        "http://www.w3.org/2001/XMLSchema-instance";
-
-        /**
-         * <p>W3C XPath Datatype Namespace URI.</p>
-         *
-         * <p>Defined to be "{@code http://www.w3.org/2003/11/xpath-datatypes}".</p>
-         *
-         * @see <a href="http://www.w3.org/TR/xpath-datamodel">XQuery 1.0 and XPath 2.0 Data Model</a>
-         */
-        public static final String W3C_XPATH_DATATYPE_NS_URI = "http://www.w3.org/2003/11/xpath-datatypes";
-
-    /**
-     * <p>XML Document Type Declaration Namespace URI as an arbitrary value.</p>
-     *
-     * <p>Since not formally defined by any existing standard, arbitrarily define to be "{@code http://www.w3.org/TR/REC-xml}".
-     */
-    public static final String XML_DTD_NS_URI = "http://www.w3.org/TR/REC-xml";
-
-        /**
-         * <p>RELAX NG Namespace URI.</p>
-         *
-         * <p>Defined to be "{@code http://relaxng.org/ns/structure/1.0}".</p>
-         *
-         * @see <a href="http://relaxng.org/spec-20011203.html">RELAX NG Specification</a>
-         */
-        public static final String RELAXNG_NS_URI = "http://relaxng.org/ns/structure/1.0";
-
-        /**
-         * <p>Feature for secure processing.</p>
-         *
-         * <ul>
-         *   <li>
-         *     {@code true} instructs the implementation to process XML securely.
-         *     This may set limits on XML constructs to avoid conditions such as denial of service attacks.
-         *   </li>
-         *   <li>
-         *     {@code false} instructs the implementation to process XML in accordance with the XML specifications
-         *     ignoring security issues such as limits on XML constructs to avoid conditions such as denial of service attacks.
-         *   </li>
-         * </ul>
-         */
-        public static final String FEATURE_SECURE_PROCESSING = "http://javax.xml.XMLConstants/feature/secure-processing";
-
-
-        /**
-         * <p>Property: accessExternalDTD</p>
-         *
-         * <p>
-         * Restrict access to external DTDs and external Entity References to the protocols specified.
-         * If access is denied due to the restriction of this property, a runtime exception that
-         * is specific to the context is thrown. In the case of {@link SAXParser}
-         * for example, {@link org.xml.sax.SAXException} is thrown.
-         * </p>
-         *
-         * <p>
-         * <b>Value: </b> a list of protocols separated by comma. A protocol is the scheme portion of a
-         * {@link java.net.URI}, or in the case of the JAR protocol, "jar" plus the scheme portion
-         * separated by colon.
-         * A scheme is defined as:
-         *
-         * <blockquote>
-         * scheme = alpha *( alpha | digit | "+" | "-" | "." )<br>
-         * where alpha = a-z and A-Z.<br><br>
-         *
-         * And the JAR protocol:<br>
-         *
-         * jar[:scheme]<br><br>
-         *
-         * Protocols including the keyword "jar" are case-insensitive. Any whitespaces as defined by
-         * {@link java.lang.Character#isSpaceChar } in the value will be ignored.
-         * Examples of protocols are file, http, jar:file.
-         *
-         * </blockquote>
-         *</p>
-         *
-         *<p>
-         * <b>Default value:</b> The default value is implementation specific and therefore not specified.
-         * The following options are provided for consideration:
-         * <blockquote>
-         * <UL>
-         *     <LI>an empty string to deny all access to external references;</LI>
-         *     <LI>a specific protocol, such as file, to give permission to only the protocol;</LI>
-         *     <LI>the keyword "all" to grant  permission to all protocols.</LI>
-         *</UL><br>
-         *      When FEATURE_SECURE_PROCESSING is enabled,  it is recommended that implementations
-         *      restrict external connections by default, though this may cause problems for applications
-         *      that process XML/XSD/XSL with external references.
-         * </blockquote>
-         * </p>
-         *
-         * <p>
-         * <b>Granting all access:</b>  the keyword "all" grants permission to all protocols.
-         * </p>
-         * <p>
-         * <b>System Property:</b> The value of this property can be set or overridden by
-         * system property {@code javax.xml.accessExternalDTD}.
-         * </p>
-         *
-         * <p>
-         * <b>${JAVA_HOME}/lib/jaxp.properties:</b> This configuration file is in standard
-         * {@link java.util.Properties} format. If the file exists and the system property is specified,
-         * its value will be used to override the default of the property.
-         * </p>
-         *
-         * <p>
-         *
-         * </p>
-         * @since 1.7
-         */
-        public static final String ACCESS_EXTERNAL_DTD = "http://javax.xml.XMLConstants/property/accessExternalDTD";
-
-        /**
-         * <p>Property: accessExternalSchema</p>
-         *
-         * <p>
-         * Restrict access to the protocols specified for external reference set by the
-         * schemaLocation attribute, Import and Include element. If access is denied
-         * due to the restriction of this property, a runtime exception that is specific
-         * to the context is thrown. In the case of {@link SchemaFactory}
-         * for example, org.xml.sax.SAXException is thrown.
-         * </p>
-         * <p>
-         * <b>Value:</b> a list of protocols separated by comma. A protocol is the scheme portion of a
-         * {@link java.net.URI}, or in the case of the JAR protocol, "jar" plus the scheme portion
-         * separated by colon.
-         * A scheme is defined as:
-         *
-         * <blockquote>
-         * scheme = alpha *( alpha | digit | "+" | "-" | "." )<br>
-         * where alpha = a-z and A-Z.<br><br>
-         *
-         * And the JAR protocol:<br>
-         *
-         * jar[:scheme]<br><br>
-         *
-         * Protocols including the keyword "jar" are case-insensitive. Any whitespaces as defined by
-         * {@link java.lang.Character#isSpaceChar } in the value will be ignored.
-         * Examples of protocols are file, http, jar:file.
-         *
-         * </blockquote>
-         *</p>
-         *
-         *<p>
-         * <b>Default value:</b> The default value is implementation specific and therefore not specified.
-         * The following options are provided for consideration:
-         * <blockquote>
-         * <UL>
-         *     <LI>an empty string to deny all access to external references;</LI>
-         *     <LI>a specific protocol, such as file, to give permission to only the protocol;</LI>
-         *     <LI>the keyword "all" to grant  permission to all protocols.</LI>
-         *</UL><br>
-         *      When FEATURE_SECURE_PROCESSING is enabled,  it is recommended that implementations
-         *      restrict external connections by default, though this may cause problems for applications
-         *      that process XML/XSD/XSL with external references.
-         * </blockquote>
-         * </p>
-         * <p>
-         * <b>Granting all access:</b>  the keyword "all" grants permission to all protocols.
-         * </p>
-         *
-         * <p>
-         * <b>System Property:</b> The value of this property can be set or overridden by
-         * system property {@code javax.xml.accessExternalSchema}
-         * </p>
-         *
-         * <p>
-         * <b>${JAVA_HOME}/lib/jaxp.properties:</b> This configuration file is in standard
-         * java.util.Properties format. If the file exists and the system property is specified,
-         * its value will be used to override the default of the property.
-         *
-         * @since 1.7
-         * </p>
-         */
-        public static final String ACCESS_EXTERNAL_SCHEMA = "http://javax.xml.XMLConstants/property/accessExternalSchema";
-
-        /**
-         * <p>Property: accessExternalStylesheet</p>
-         *
-         * <p>
-         * Restrict access to the protocols specified for external references set by the
-         * stylesheet processing instruction, Import and Include element, and document function.
-         * If access is denied due to the restriction of this property, a runtime exception
-         * that is specific to the context is thrown. In the case of constructing new
-         * {@link Transformer} for example,
-         * {@link TransformerConfigurationException}
-         * will be thrown by the {@link TransformerFactory}.
-         * </p>
-         * <p>
-         * <b>Value:</b> a list of protocols separated by comma. A protocol is the scheme portion of a
-         * {@link java.net.URI}, or in the case of the JAR protocol, "jar" plus the scheme portion
-         * separated by colon.
-         * A scheme is defined as:
-         *
-         * <blockquote>
-         * scheme = alpha *( alpha | digit | "+" | "-" | "." )<br>
-         * where alpha = a-z and A-Z.<br><br>
-         *
-         * And the JAR protocol:<br>
-         *
-         * jar[:scheme]<br><br>
-         *
-         * Protocols including the keyword "jar" are case-insensitive. Any whitespaces as defined by
-         * {@link java.lang.Character#isSpaceChar } in the value will be ignored.
-         * Examples of protocols are file, http, jar:file.
-         *
-         * </blockquote>
-         *</p>
-         *
-         *<p>
-         * <b>Default value:</b> The default value is implementation specific and therefore not specified.
-         * The following options are provided for consideration:
-         * <blockquote>
-         * <UL>
-         *     <LI>an empty string to deny all access to external references;</LI>
-         *     <LI>a specific protocol, such as file, to give permission to only the protocol;</LI>
-         *     <LI>the keyword "all" to grant  permission to all protocols.</LI>
-         *</UL><br>
-         *      When FEATURE_SECURE_PROCESSING is enabled,  it is recommended that implementations
-         *      restrict external connections by default, though this may cause problems for applications
-         *      that process XML/XSD/XSL with external references.
-         * </blockquote>
-         * </p>
-         * <p>
-         * <b>Granting all access:</b>  the keyword "all" grants permission to all protocols.
-         * </p>
-         *
-         * <p>
-         * <b>System Property:</b> The value of this property can be set or overridden by
-         * system property {@code javax.xml.accessExternalStylesheet}
-         * </p>
-         *
-         * <p>
-         * <b>${JAVA_HOME}/lib/jaxp.properties: </b> This configuration file is in standard
-         * java.util.Properties format. If the file exists and the system property is specified,
-         * its value will be used to override the default of the property.
-         *
-         * @since 1.7
-         */
-        public static final String ACCESS_EXTERNAL_STYLESHEET = "http://javax.xml.XMLConstants/property/accessExternalStylesheet";
-
-}
Index: Build/src/main/java/org/openjdk/tools/javac/file/FSInfo.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/tools/javac/file/FSInfo.java b/Build/src/main/java/org/openjdk/tools/javac/file/FSInfo.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/tools/javac/file/FSInfo.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,122 +0,0 @@
-package com.sun.tools.javac.file;
-
-import com.github.marschall.com.sun.nio.zipfs.ZipFileSystemProvider;
-
-import java.io.IOException;
-import java.nio.file.FileSystems;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.spi.FileSystemProvider;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.StringTokenizer;
-import java.util.jar.Attributes;
-import java.util.jar.JarFile;
-import java.util.jar.Manifest;
-import java.util.jar.Attributes.Name;
-import com.sun.tools.javac.util.Context;
-
-public class FSInfo {
-    private FileSystemProvider jarFSProvider;
-
-    public static FSInfo instance(Context var0) {
-        FSInfo var1 = (FSInfo)var0.get(FSInfo.class);
-        if (var1 == null) {
-            var1 = new FSInfo();
-        }
-
-        return var1;
-    }
-
-    protected FSInfo() {
-    }
-
-    protected FSInfo(Context var1) {
-        var1.put(FSInfo.class, this);
-    }
-
-    public Path getCanonicalFile(Path var1) {
-        try {
-            return var1.toRealPath();
-        } catch (IOException var3) {
-            return var1.toAbsolutePath().normalize();
-        }
-    }
-
-    public boolean exists(Path var1) {
-        return Files.exists(var1);
-    }
-
-    public boolean isDirectory(Path var1) {
-        return Files.isDirectory(var1);
-    }
-
-    public boolean isFile(Path var1) {
-        return Files.isRegularFile(var1);
-    }
-
-    public List<Path> getJarClassPath(Path var1) throws IOException {
-        Path var2 = var1.getParent();
-        JarFile var3 = new JarFile(var1.toFile());
-        Throwable var4 = null;
-
-        List<Path> var8;
-        try {
-            Manifest var5 = var3.getManifest();
-            if (var5 == null) {
-                return Collections.emptyList();
-            }
-
-            Attributes var6 = var5.getMainAttributes();
-            if (var6 == null) {
-                return Collections.emptyList();
-            }
-
-            String var7 = var6.getValue(Name.CLASS_PATH);
-            if (var7 != null) {
-                ArrayList<Path> var26 = new ArrayList<>();
-
-                Path var11;
-                for(StringTokenizer var9 = new StringTokenizer(var7); var9.hasMoreTokens(); var26.add(var11)) {
-                    String var10 = var9.nextToken();
-                    var11 = FileSystems.getDefault().getPath(var10);
-                    if (!var11.isAbsolute() && var2 != null) {
-                        var11 = var2.resolve(var11).toAbsolutePath();
-                    }
-                }
-
-                return var26;
-            }
-
-            var8 = Collections.emptyList();
-        } catch (Throwable var22) {
-            var4 = var22;
-            throw var22;
-        } finally {
-            if (var3 != null) {
-                if (var4 != null) {
-                    try {
-                        var3.close();
-                    } catch (Throwable var21) {
-                        var4.addSuppressed(var21);
-                    }
-                } else {
-                    var3.close();
-                }
-            }
-
-        }
-
-        return var8;
-    }
-
-    public synchronized FileSystemProvider getJarFSProvider() {
-        if (this.jarFSProvider != null) {
-            return this.jarFSProvider;
-        } else {
-            this.jarFSProvider = new ZipFileSystemProvider();
-            return jarFSProvider;
-        }
-    }
-}
\ No newline at end of file
Index: Build/src/main/java/org/openjdk/tools/javac/file/JavacFileManager.java
===================================================================
diff --git a/Build/src/main/java/org/openjdk/tools/javac/file/JavacFileManager.java b/Build/src/main/java/org/openjdk/tools/javac/file/JavacFileManager.java
deleted file mode 100644
--- a/Build/src/main/java/org/openjdk/tools/javac/file/JavacFileManager.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,1011 +0,0 @@
-//
-// Source code recreated from a .class file by IntelliJ IDEA
-// (powered by FernFlower decompiler)
-//
-
-package com.sun.tools.javac.file;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.file.FileSystem;
-import java.nio.file.FileVisitOption;
-import java.nio.file.FileVisitResult;
-import java.nio.file.Files;
-import java.nio.file.InvalidPathException;
-import java.nio.file.LinkOption;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.nio.file.ProviderNotFoundException;
-import java.nio.file.SimpleFileVisitor;
-import java.nio.file.attribute.BasicFileAttributes;
-import java.nio.file.spi.FileSystemProvider;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Objects;
-import java.util.ServiceLoader;
-import java.util.Set;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.lang.model.SourceVersion;
-import javax.tools.FileObject;
-import javax.tools.JavaFileManager;
-import javax.tools.JavaFileObject;
-import javax.tools.StandardJavaFileManager;
-import javax.tools.StandardLocation;
-import javax.tools.JavaFileManager.Location;
-import javax.tools.JavaFileObject.Kind;
-import javax.tools.StandardJavaFileManager.PathFactory;
-import com.sun.tools.javac.file.JRTIndex.Entry;
-import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
-import com.sun.tools.javac.file.RelativePath.RelativeFile;
-import com.sun.tools.javac.util.Assert;
-import com.sun.tools.javac.util.Context;
-import com.sun.tools.javac.util.List;
-import com.sun.tools.javac.util.ListBuffer;
-import com.sun.tools.javac.util.JDK9Wrappers.Configuration;
-import com.sun.tools.javac.util.JDK9Wrappers.Layer;
-import com.sun.tools.javac.util.JDK9Wrappers.Module;
-import com.sun.tools.javac.util.JDK9Wrappers.ModuleFinder;
-import com.sun.tools.javac.util.JDK9Wrappers.ServiceLoaderHelper;
-
-/**
- * I have modified this a bit to use the custom file system manager because
- * android doesn't provide a ZipFileSystemProvider
- */
-@SuppressWarnings("ALL")
-public class JavacFileManager extends BaseFileManager implements StandardJavaFileManager {
-    private FSInfo fsInfo;
-    private final Set<Kind> sourceOrClass;
-    protected boolean symbolFileEnabled;
-    private PathFactory pathFactory;
-    protected JavacFileManager.SortFiles sortFiles;
-    private final Map<Path, JavacFileManager.Container> containers;
-    private static final JavacFileManager.Container MISSING_CONTAINER = new JavacFileManager.Container() {
-        public void list(Path var1, RelativeDirectory var2, Set<Kind> var3, boolean var4, ListBuffer<JavaFileObject> var5) throws IOException {
-        }
-
-        public JavaFileObject getFileObject(Path var1, RelativeFile var2) throws IOException {
-            return null;
-        }
-
-        public void close() throws IOException {
-        }
-    };
-    private JRTIndex jrtIndex;
-    private static final boolean fileSystemIsCaseSensitive;
-
-    public static char[] toArray(CharBuffer var0) {
-        return var0.hasArray() ? ((CharBuffer)var0.compact().flip()).array() : var0.toString().toCharArray();
-    }
-
-    public static void preRegister(Context var0) {
-        var0.put(JavaFileManager.class, (Context.Factory<JavaFileManager>) context -> new JavacFileManager(context, true, null));
-    }
-
-    public JavacFileManager(Context var1, boolean var2, Charset var3) {
-        super(var3);
-        this.sourceOrClass = EnumSet.of(Kind.SOURCE, Kind.CLASS);
-        this.pathFactory = Paths::get;
-        this.containers = new HashMap<>();
-        if (var2) {
-            var1.put(JavaFileManager.class, this);
-        }
-
-        this.setContext(var1);
-    }
-
-    public void setContext(Context var1) {
-        super.setContext(var1);
-        this.fsInfo = FSInfo.instance(var1);
-        this.symbolFileEnabled = !this.options.isSet("ignore.symbol.file");
-        String var2 = this.options.get("sortFiles");
-        if (var2 != null) {
-            this.sortFiles = var2.equals("reverse") ? JavacFileManager.SortFiles.REVERSE : JavacFileManager.SortFiles.FORWARD;
-        }
-
-    }
-
-    public void setPathFactory(PathFactory var1) {
-        this.pathFactory = Objects.requireNonNull(var1);
-        this.locations.setPathFactory(var1);
-    }
-
-    private Path getPath(String var1, String... var2) {
-        return this.pathFactory.getPath(var1, var2);
-    }
-
-    public void setSymbolFileEnabled(boolean var1) {
-        this.symbolFileEnabled = var1;
-    }
-
-    public boolean isSymbolFileEnabled() {
-        return this.symbolFileEnabled;
-    }
-
-    public JavaFileObject getJavaFileObject(String var1) {
-        return this.getJavaFileObjects(var1).iterator().next();
-    }
-
-    public JavaFileObject getJavaFileObject(Path var1) {
-        return this.getJavaFileObjects(var1).iterator().next();
-    }
-
-    public JavaFileObject getFileForOutput(String var1, Kind var2, JavaFileObject var3) throws IOException {
-        return this.getJavaFileForOutput(StandardLocation.CLASS_OUTPUT, var1, var2, var3);
-    }
-
-    public Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings(Iterable<String> var1) {
-        ListBuffer<Path> var2 = new ListBuffer<>();
-
-        for (String var4 : var1) {
-            var2.append(this.getPath(BaseFileManager.nullCheck(var4)));
-        }
-
-        return this.getJavaFileObjectsFromPaths(var2.toList());
-    }
-
-    public Iterable<? extends JavaFileObject> getJavaFileObjects(String... var1) {
-        return this.getJavaFileObjectsFromStrings(Arrays.asList((BaseFileManager.nullCheck(var1))));
-    }
-
-    private static boolean isValidName(String var0) {
-        String[] var1 = var0.split("\\.", -1);
-        int var2 = var1.length;
-
-        for (String var4 : var1) {
-            if (!SourceVersion.isIdentifier(var4)) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    private static void validateClassName(String var0) {
-        if (!isValidName(var0)) {
-            throw new IllegalArgumentException("Invalid class name: " + var0);
-        }
-    }
-
-    private static void validatePackageName(String var0) {
-        if (var0.length() > 0 && !isValidName(var0)) {
-            throw new IllegalArgumentException("Invalid packageName name: " + var0);
-        }
-    }
-
-    public static void testName(String var0, boolean var1, boolean var2) {
-        try {
-            validatePackageName(var0);
-            if (!var1) {
-                throw new AssertionError("Invalid package name accepted: " + var0);
-            }
-
-            printAscii("Valid package name: \"%s\"", var0);
-        } catch (IllegalArgumentException var5) {
-            if (var1) {
-                throw new AssertionError("Valid package name rejected: " + var0);
-            }
-
-            printAscii("Invalid package name: \"%s\"", var0);
-        }
-
-        try {
-            validateClassName(var0);
-            if (!var2) {
-                throw new AssertionError("Invalid class name accepted: " + var0);
-            }
-
-            printAscii("Valid class name: \"%s\"", var0);
-        } catch (IllegalArgumentException var4) {
-            if (var2) {
-                throw new AssertionError("Valid class name rejected: " + var0);
-            }
-
-            printAscii("Invalid class name: \"%s\"", var0);
-        }
-
-    }
-
-    private static void printAscii(String var0, Object... var1) {
-        String var2;
-        try {
-            var2 = new String(String.format((Locale)null, var0, var1).getBytes("US-ASCII"), "US-ASCII");
-        } catch (UnsupportedEncodingException var4) {
-            throw new AssertionError(var4);
-        }
-
-        System.out.println(var2);
-    }
-
-    synchronized JavacFileManager.Container getContainer(Path var1) throws IOException {
-        JavacFileManager.Container var2 = (JavacFileManager.Container)this.containers.get(var1);
-        if (var2 != null) {
-            return var2;
-        } else if (this.fsInfo.isFile(var1) && var1.equals(Locations.thisSystemModules)) {
-            JavacFileManager.JRTImageContainer var9;
-            this.containers.put(var1, var9 = new JavacFileManager.JRTImageContainer());
-            return var9;
-        } else {
-            Path var3 = this.fsInfo.getCanonicalFile(var1);
-            JavacFileManager.Container var8 = this.containers.get(var3);
-            if (var8 != null) {
-                this.containers.put(var1, var8);
-                return var8;
-            } else {
-                BasicFileAttributes var4 = null;
-
-                try {
-                    var4 = Files.readAttributes(var3, BasicFileAttributes.class);
-                } catch (IOException var7) {
-                    var8 = MISSING_CONTAINER;
-                }
-
-                if (var4 != null) {
-                    if (var4.isDirectory()) {
-                        var8 = new JavacFileManager.DirectoryContainer(var1);
-                    } else {
-                        try {
-                            var8 = new JavacFileManager.ArchiveContainer(var1);
-                        } catch (SecurityException | ProviderNotFoundException var6) {
-                            throw new IOException(var6);
-                        }
-                    }
-                }
-
-                this.containers.put(var3, var8);
-                this.containers.put(var1, var8);
-                return (JavacFileManager.Container)var8;
-            }
-        }
-    }
-
-    private synchronized JRTIndex getJRTIndex() {
-        if (this.jrtIndex == null) {
-            this.jrtIndex = JRTIndex.getSharedInstance();
-        }
-
-        return this.jrtIndex;
-    }
-
-    private boolean isValidFile(String var1, Set<Kind> var2) {
-        Kind var3 = BaseFileManager.getKind(var1);
-        return var2.contains(var3);
-    }
-
-    private boolean caseMapCheck(Path var1, RelativePath var2) {
-        if (fileSystemIsCaseSensitive) {
-            return true;
-        } else {
-            String var3;
-            char var4;
-            try {
-                var3 = var1.toRealPath(LinkOption.NOFOLLOW_LINKS).toString();
-                var4 = var1.getFileSystem().getSeparator().charAt(0);
-            } catch (IOException var9) {
-                return false;
-            }
-
-            char[] var5 = var3.toCharArray();
-            char[] var6 = var2.path.toCharArray();
-            int var7 = var5.length - 1;
-            int var8 = var6.length - 1;
-
-            while(var7 >= 0 && var8 >= 0) {
-                while(var7 >= 0 && var5[var7] == var4) {
-                    --var7;
-                }
-
-                while(var8 >= 0 && var6[var8] == '/') {
-                    --var8;
-                }
-
-                if (var7 >= 0 && var8 >= 0) {
-                    if (var5[var7] != var6[var8]) {
-                        return false;
-                    }
-
-                    --var7;
-                    --var8;
-                }
-            }
-
-            return var8 < 0;
-        }
-    }
-
-    public void flush() {
-        this.contentCache.clear();
-    }
-
-    public void close() throws IOException {
-        if (this.deferredCloseTimeout > 0L) {
-            this.deferredClose();
-        } else {
-            this.locations.close();
-            Iterator var1 = this.containers.values().iterator();
-
-            while(var1.hasNext()) {
-                JavacFileManager.Container var2 = (JavacFileManager.Container)var1.next();
-                var2.close();
-            }
-
-            this.containers.clear();
-            this.contentCache.clear();
-        }
-    }
-
-    public ClassLoader getClassLoader(Location var1) {
-        this.checkNotModuleOrientedLocation(var1);
-        Iterable<? extends File> var2 = this.getLocation(var1);
-        if (var2 == null) {
-            return null;
-        } else {
-            ListBuffer<URL> var3 = new ListBuffer<>();
-
-            for (File var5 : var2) {
-                try {
-                    var3.append(var5.toURI().toURL());
-                } catch (MalformedURLException var7) {
-                    throw new AssertionError(var7);
-                }
-            }
-
-            return this.getClassLoader(var3.toArray(new URL[0]));
-        }
-    }
-
-    public Iterable<JavaFileObject> list(Location var1, String var2, Set<Kind> var3, boolean var4) throws IOException {
-        this.checkNotModuleOrientedLocation(var1);
-        BaseFileManager.nullCheck(var2);
-        BaseFileManager.nullCheck(var3);
-        Iterable var5 = this.getLocationAsPaths(var1);
-        if (var5 == null) {
-            return List.nil();
-        } else {
-            RelativeDirectory var6 = RelativeDirectory.forPackage(var2);
-            ListBuffer var7 = new ListBuffer();
-            Iterator var8 = var5.iterator();
-
-            while(var8.hasNext()) {
-                Path var9 = (Path)var8.next();
-                JavacFileManager.Container var10 = this.getContainer(var9);
-                var10.list(var9, var6, var3, var4, var7);
-            }
-
-            return var7.toList();
-        }
-    }
-
-    public String inferBinaryName(Location var1, JavaFileObject var2) {
-        this.checkNotModuleOrientedLocation(var1);
-        Objects.requireNonNull(var2);
-        Iterable<? extends Path> var3 = this.getLocationAsPaths(var1);
-        if (var3 == null) {
-            return null;
-        } else if (var2 instanceof PathFileObject) {
-            return ((PathFileObject)var2).inferBinaryName(var3);
-        } else {
-            throw new IllegalArgumentException(var2.getClass().getName());
-        }
-    }
-
-    public boolean isSameFile(FileObject var1, FileObject var2) {
-        BaseFileManager.nullCheck(var1);
-        BaseFileManager.nullCheck(var2);
-        return var1 instanceof PathFileObject && var2 instanceof PathFileObject ? ((PathFileObject)var1).isSameFile((PathFileObject)var2) : var1.equals(var2);
-    }
-
-    public boolean hasLocation(Location var1) {
-        BaseFileManager.nullCheck(var1);
-        return this.locations.hasLocation(var1);
-    }
-
-    public JavaFileObject getJavaFileForInput(Location var1, String var2, Kind var3) throws IOException {
-        this.checkNotModuleOrientedLocation(var1);
-        BaseFileManager.nullCheck(var2);
-        BaseFileManager.nullCheck(var3);
-        if (!this.sourceOrClass.contains(var3)) {
-            throw new IllegalArgumentException("Invalid kind: " + var3);
-        } else {
-            return this.getFileForInput(var1, RelativeFile.forClass(var2, var3));
-        }
-    }
-
-    public FileObject getFileForInput(Location var1, String var2, String var3) throws IOException {
-        this.checkNotModuleOrientedLocation(var1);
-        BaseFileManager.nullCheck(var2);
-        if (!isRelativeUri(var3)) {
-            throw new IllegalArgumentException("Invalid relative name: " + var3);
-        } else {
-            RelativeFile var4 = var2.length() == 0 ? new RelativeFile(var3) : new RelativeFile(RelativeDirectory.forPackage(var2), var3);
-            return this.getFileForInput(var1, var4);
-        }
-    }
-
-    private JavaFileObject getFileForInput(Location var1, RelativeFile var2) throws IOException {
-        Iterable<? extends Path> var3 = this.getLocationAsPaths(var1);
-        if (var3 == null) {
-            return null;
-        } else {
-            Iterator<? extends Path> var4 = var3.iterator();
-
-            JavaFileObject var6;
-            do {
-                if (!var4.hasNext()) {
-                    return null;
-                }
-
-                Path var5 = (Path)var4.next();
-                var6 = this.getContainer(var5).getFileObject(var5, var2);
-            } while(var6 == null);
-
-            return var6;
-        }
-    }
-
-    public JavaFileObject getJavaFileForOutput(Location var1, String var2, Kind var3, FileObject var4) throws IOException {
-        this.checkOutputLocation(var1);
-        BaseFileManager.nullCheck(var2);
-        BaseFileManager.nullCheck(var3);
-        if (!this.sourceOrClass.contains(var3)) {
-            throw new IllegalArgumentException("Invalid kind: " + var3);
-        } else {
-            return this.getFileForOutput(var1, RelativeFile.forClass(var2, var3), var4);
-        }
-    }
-
-    public FileObject getFileForOutput(Location var1, String var2, String var3, FileObject var4) throws IOException {
-        this.checkOutputLocation(var1);
-        BaseFileManager.nullCheck(var2);
-        if (!isRelativeUri(var3)) {
-            throw new IllegalArgumentException("Invalid relative name: " + var3);
-        } else {
-            RelativeFile var5 = var2.length() == 0 ? new RelativeFile(var3) : new RelativeFile(RelativeDirectory.forPackage(var2), var3);
-            return this.getFileForOutput(var1, var5, var4);
-        }
-    }
-
-    private JavaFileObject getFileForOutput(Location var1, RelativeFile var2, FileObject var3) throws IOException {
-        Path var4;
-        Path var7;
-        if (var1 == StandardLocation.CLASS_OUTPUT) {
-            if (this.getClassOutDir() == null) {
-                String var5 = var2.basename();
-                if (var3 != null && var3 instanceof PathFileObject) {
-                    return ((PathFileObject)var3).getSibling(var5);
-                }
-
-                Path var6 = this.getPath(var5);
-                var7 = this.fsInfo.getCanonicalFile(var6);
-                return PathFileObject.forSimplePath(this, var7, var6);
-            }
-
-            var4 = this.getClassOutDir();
-        } else if (var1 == StandardLocation.SOURCE_OUTPUT) {
-            var4 = this.getSourceOutDir() != null ? this.getSourceOutDir() : this.getClassOutDir();
-        } else {
-            Collection var9 = this.locations.getLocation(var1);
-            var4 = null;
-            Iterator var11 = var9.iterator();
-            if (var11.hasNext()) {
-                var7 = (Path)var11.next();
-                var4 = var7;
-            }
-        }
-
-        try {
-            if (var4 == null) {
-                var4 = this.getPath(System.getProperty("user.dir"));
-            }
-
-            Path var10 = var2.resolveAgainst(this.fsInfo.getCanonicalFile(var4));
-            return PathFileObject.forDirectoryPath(this, var10, var4, var2);
-        } catch (InvalidPathException var8) {
-            throw new IOException("bad filename " + var2, var8);
-        }
-    }
-
-    public Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> var1) {
-        ArrayList<JavaFileObject> var2;
-        if (var1 instanceof Collection) {
-            var2 = new ArrayList<>(((Collection<? extends JavaFileObject>) var1).size());
-        } else {
-            var2 = new ArrayList<>();
-        }
-
-        for (File var4 : var1) {
-            Objects.requireNonNull(var4);
-            Path var5 = var4.toPath();
-            var2.add(PathFileObject.forSimplePath(this, this.fsInfo.getCanonicalFile(var5), var5));
-        }
-
-        return var2;
-    }
-
-    public Iterable<? extends JavaFileObject> getJavaFileObjectsFromPaths(Iterable<? extends Path> var1) {
-        ArrayList var2;
-        if (var1 instanceof Collection) {
-            var2 = new ArrayList(((Collection)var1).size());
-        } else {
-            var2 = new ArrayList();
-        }
-
-        Iterator var3 = var1.iterator();
-
-        while(var3.hasNext()) {
-            Path var4 = (Path)var3.next();
-            var2.add(PathFileObject.forSimplePath(this, this.fsInfo.getCanonicalFile(var4), var4));
-        }
-
-        return var2;
-    }
-
-    public Iterable<? extends JavaFileObject> getJavaFileObjects(File... var1) {
-        return this.getJavaFileObjectsFromFiles(Arrays.asList(BaseFileManager.nullCheck(var1)));
-    }
-
-    public Iterable<? extends JavaFileObject> getJavaFileObjects(Path... var1) {
-        return this.getJavaFileObjectsFromPaths(Arrays.asList(BaseFileManager.nullCheck(var1)));
-    }
-
-    public void setLocation(Location var1, Iterable<? extends File> var2) throws IOException {
-        BaseFileManager.nullCheck(var1);
-        this.locations.setLocation(var1, asPaths(var2));
-    }
-
-    public void setLocationFromPaths(Location var1, Collection<? extends Path> var2) throws IOException {
-        BaseFileManager.nullCheck(var1);
-        this.locations.setLocation(var1, BaseFileManager.nullCheck(var2));
-    }
-
-    public Iterable<? extends File> getLocation(Location var1) {
-        BaseFileManager.nullCheck(var1);
-        return asFiles(this.locations.getLocation(var1));
-    }
-
-    public Iterable<? extends Path> getLocationAsPaths(Location var1) {
-        BaseFileManager.nullCheck(var1);
-        return this.locations.getLocation(var1);
-    }
-
-    public boolean contains(Location var1, FileObject var2) throws IOException {
-        BaseFileManager.nullCheck(var1);
-        BaseFileManager.nullCheck(var2);
-        Path var3 = this.asPath(var2);
-        return this.locations.contains(var1, var3);
-    }
-
-    private Path getClassOutDir() {
-        return this.locations.getOutputLocation(StandardLocation.CLASS_OUTPUT);
-    }
-
-    private Path getSourceOutDir() {
-        return this.locations.getOutputLocation(StandardLocation.SOURCE_OUTPUT);
-    }
-
-    public Location getLocationForModule(Location var1, String var2) throws IOException {
-        this.checkModuleOrientedOrOutputLocation((Location)var1);
-        BaseFileManager.nullCheck(var2);
-        if (var1 == StandardLocation.SOURCE_OUTPUT && this.getSourceOutDir() == null) {
-            var1 = StandardLocation.CLASS_OUTPUT;
-        }
-
-        return this.locations.getLocationForModule((Location)var1, var2);
-    }
-
-    public <S> ServiceLoader<S> getServiceLoader(Location var1, Class<S> var2) throws IOException {
-        BaseFileManager.nullCheck(var1);
-        BaseFileManager.nullCheck(var2);
-        Module.getModule(this.getClass()).addUses(var2);
-        if (var1.isModuleOrientedLocation()) {
-            Collection var3 = this.locations.getLocation(var1);
-            ModuleFinder var4 = ModuleFinder.of((Path[])var3.toArray(new Path[var3.size()]));
-            Layer var5 = Layer.boot();
-            Configuration var6 = var5.configuration().resolveAndBind(ModuleFinder.of(new Path[0]), var4, Collections.emptySet());
-            Layer var7 = var5.defineModulesWithOneLoader(var6, ClassLoader.getSystemClassLoader());
-            return ServiceLoaderHelper.load(var7, var2);
-        } else {
-            return ServiceLoader.load(var2, this.getClassLoader(var1));
-        }
-    }
-
-    public Location getLocationForModule(Location var1, JavaFileObject var2) throws IOException {
-        this.checkModuleOrientedOrOutputLocation(var1);
-        if (!(var2 instanceof PathFileObject)) {
-            return null;
-        } else {
-            Path var3 = Locations.normalize(((PathFileObject)var2).path);
-            return this.locations.getLocationForModule(var1, var3);
-        }
-    }
-
-    public void setLocationForModule(Location var1, String var2, Collection<? extends Path> var3) throws IOException {
-        BaseFileManager.nullCheck(var1);
-        this.checkModuleOrientedOrOutputLocation(var1);
-        this.locations.setLocationForModule(var1, (String) BaseFileManager.nullCheck(var2), BaseFileManager.nullCheck(var3));
-    }
-
-    public String inferModuleName(Location var1) {
-        this.checkNotModuleOrientedLocation(var1);
-        return this.locations.inferModuleName(var1);
-    }
-
-    public Iterable<Set<Location>> listLocationsForModules(Location var1) throws IOException {
-        this.checkModuleOrientedOrOutputLocation(var1);
-        return this.locations.listLocationsForModules(var1);
-    }
-
-    public Path asPath(FileObject var1) {
-        if (var1 instanceof PathFileObject) {
-            return ((PathFileObject)var1).path;
-        } else {
-            throw new IllegalArgumentException(var1.getName());
-        }
-    }
-
-    protected static boolean isRelativeUri(URI var0) {
-        if (var0.isAbsolute()) {
-            return false;
-        } else {
-            String var1 = var0.normalize().getPath();
-            if (var1.length() == 0) {
-                return false;
-            } else if (!var1.equals(var0.getPath())) {
-                return false;
-            } else {
-                return !var1.startsWith("/") && !var1.startsWith("./") && !var1.startsWith("../");
-            }
-        }
-    }
-
-    protected static boolean isRelativeUri(String var0) {
-        try {
-            return isRelativeUri(new URI(var0));
-        } catch (URISyntaxException var2) {
-            return false;
-        }
-    }
-
-    public static String getRelativeName(File var0) {
-        if (!var0.isAbsolute()) {
-            String var1 = var0.getPath().replace(File.separatorChar, '/');
-            if (isRelativeUri(var1)) {
-                return var1;
-            }
-        }
-
-        throw new IllegalArgumentException("Invalid relative path: " + var0);
-    }
-
-    public static String getMessage(IOException var0) {
-        String var1 = var0.getLocalizedMessage();
-        if (var1 != null) {
-            return var1;
-        } else {
-            var1 = var0.getMessage();
-            return var1 != null ? var1 : var0.toString();
-        }
-    }
-
-    private void checkOutputLocation(Location var1) {
-        Objects.requireNonNull(var1);
-        if (!var1.isOutputLocation()) {
-            throw new IllegalArgumentException("location is not an output location: " + var1.getName());
-        }
-    }
-
-    private void checkModuleOrientedOrOutputLocation(Location var1) {
-        Objects.requireNonNull(var1);
-        if (!var1.isModuleOrientedLocation() && !var1.isOutputLocation()) {
-            throw new IllegalArgumentException("location is not an output location or a module-oriented location: " + var1.getName());
-        }
-    }
-
-    private void checkNotModuleOrientedLocation(Location var1) {
-        Objects.requireNonNull(var1);
-        if (var1.isModuleOrientedLocation()) {
-            throw new IllegalArgumentException("location is module-oriented: " + var1.getName());
-        }
-    }
-
-    private static Iterable<Path> asPaths(Iterable<? extends File> var0) {
-        return var0 == null ? null : () -> {
-            return new Iterator<Path>() {
-                Iterator iter = var0.iterator();
-
-                public boolean hasNext() {
-                    return this.iter.hasNext();
-                }
-
-                public Path next() {
-                    return ((File)this.iter.next()).toPath();
-                }
-            };
-        };
-    }
-
-    private static Iterable<File> asFiles(Iterable<? extends Path> var0) {
-        return var0 == null ? null : () -> {
-            return new Iterator<File>() {
-                Iterator iter = var0.iterator();
-
-                public boolean hasNext() {
-                    return this.iter.hasNext();
-                }
-
-                public File next() {
-                    try {
-                        return ((Path)this.iter.next()).toFile();
-                    } catch (UnsupportedOperationException var2) {
-                        throw new IllegalStateException(var2);
-                    }
-                }
-            };
-        };
-    }
-
-    static {
-        fileSystemIsCaseSensitive = File.separatorChar == '/';
-    }
-
-    private final class ArchiveContainer implements JavacFileManager.Container {
-        private final Path archivePath;
-        private final FileSystem fileSystem;
-        private final Map<RelativePath, Path> packages;
-
-        public ArchiveContainer(Path var2) throws IOException, ProviderNotFoundException, SecurityException {
-            this.archivePath = var2;
-//            if (JavacFileManager.this.multiReleaseValue != null && var2.toString().endsWith(".jar")) {
-                Map<String, String> var3 = Collections.singletonMap("multi-release", JavacFileManager.this.multiReleaseValue);
-                FileSystemProvider var4 = JavacFileManager.this.fsInfo.getJarFSProvider();
-                Assert.checkNonNull(var4, "should have been caught before!");
-                this.fileSystem = var4.newFileSystem(var2, var3);
-//            } else {
-//                this.fileSystem = FileSystems.newFileSystem(var2, (ClassLoader)null);
-//            }
-
-            this.packages = new HashMap<>();
-
-            for (Path var6 : this.fileSystem.getRootDirectories()) {
-                Files.walkFileTree(var6, EnumSet.noneOf(FileVisitOption.class), 2147483647, new SimpleFileVisitor<Path>() {
-                    public FileVisitResult preVisitDirectory(Path var1, BasicFileAttributes var2) {
-                        if (ArchiveContainer.this.isValid(var1.getFileName())) {
-                            ArchiveContainer.this.packages.put(new RelativeDirectory(var6.relativize(var1).toString()), var1);
-                            return FileVisitResult.CONTINUE;
-                        } else {
-                            return FileVisitResult.SKIP_SUBTREE;
-                        }
-                    }
-                });
-            }
-
-        }
-
-        public void list(Path var1, RelativeDirectory var2, final Set<Kind> var3, boolean var4, final ListBuffer<JavaFileObject> var5) throws IOException {
-            Path var6 = (Path)this.packages.get(var2);
-            if (var6 != null) {
-                int var7 = var4 ? 2147483647 : 1;
-                EnumSet<FileVisitOption> var8 = EnumSet.of(FileVisitOption.FOLLOW_LINKS);
-                Files.walkFileTree(var6, var8, var7, new SimpleFileVisitor<Path>() {
-                    public FileVisitResult preVisitDirectory(Path var1, BasicFileAttributes var2) {
-                        return ArchiveContainer.this.isValid(var1.getFileName()) ? FileVisitResult.CONTINUE : FileVisitResult.SKIP_SUBTREE;
-                    }
-
-                    public FileVisitResult visitFile(Path var1, BasicFileAttributes var2) {
-                        if (var2.isRegularFile() && var3.contains(BaseFileManager.getKind(var1.getFileName().toString()))) {
-                            PathFileObject var3x = PathFileObject.forJarPath(JavacFileManager.this, var1, ArchiveContainer.this.archivePath);
-                            var5.append(var3x);
-                        }
-
-                        return FileVisitResult.CONTINUE;
-                    }
-                });
-            }
-        }
-
-        private boolean isValid(Path var1) {
-            if (var1 == null) {
-                return true;
-            } else {
-                String var2 = var1.toString();
-                if (var2.endsWith("/")) {
-                    var2 = var2.substring(0, var2.length() - 1);
-                }
-
-                return SourceVersion.isIdentifier(var2);
-            }
-        }
-
-        public JavaFileObject getFileObject(Path var1, RelativeFile var2) throws IOException {
-            RelativeDirectory var3 = var2.dirname();
-            Path var4 = (Path)this.packages.get(var3);
-            if (var4 != null) {
-                Path var5 = var4.resolve(var2.basename());
-                if (Files.exists(var5)) {
-                    return PathFileObject.forJarPath(JavacFileManager.this, var5, var1);
-                }
-            }
-
-            return null;
-        }
-
-        public void close() throws IOException {
-            this.fileSystem.close();
-        }
-    }
-
-    private final class DirectoryContainer implements JavacFileManager.Container {
-        private final Path directory;
-
-        public DirectoryContainer(Path var2) {
-            this.directory = var2;
-        }
-
-        public void list(Path var1, RelativeDirectory var2, Set<Kind> var3, boolean var4, ListBuffer<JavaFileObject> var5) throws IOException {
-            Path var6;
-            try {
-                var6 = var2.resolveAgainst(var1);
-            } catch (InvalidPathException var22) {
-                return;
-            }
-
-            if (Files.exists(var6)) {
-                if (JavacFileManager.this.caseMapCheck(var6, var2)) {
-                    java.util.List<Path> var7;
-                    try {
-                        Stream<Path> var8 = Files.list(var6);
-                        Throwable var9 = null;
-
-                        try {
-                            var7 = (JavacFileManager.this.sortFiles == null ? var8 : var8.sorted(JavacFileManager.this.sortFiles)).collect(Collectors.toList());
-                        } catch (Throwable var21) {
-                            var9 = var21;
-                            throw var21;
-                        } finally {
-                            if (var8 != null) {
-                                if (var9 != null) {
-                                    try {
-                                        var8.close();
-                                    } catch (Throwable var20) {
-                                        var9.addSuppressed(var20);
-                                    }
-                                } else {
-                                    var8.close();
-                                }
-                            }
-
-                        }
-                    } catch (IOException var25) {
-                        return;
-                    }
-
-                    for (Path var27 : var7) {
-                        String var10 = var27.getFileName().toString();
-                        if (var10.endsWith("/")) {
-                            var10 = var10.substring(0, var10.length() - 1);
-                        }
-
-                        if (Files.isDirectory(var27)) {
-                            if (var4 && SourceVersion.isIdentifier(var10)) {
-                                this.list(var1, new RelativeDirectory(var2, var10), var3, var4, var5);
-                            }
-                        } else if (JavacFileManager.this.isValidFile(var10, var3)) {
-                            try {
-                                RelativeFile var11 = new RelativeFile(var2, var10);
-                                PathFileObject var12 = PathFileObject.forDirectoryPath(JavacFileManager.this, var11.resolveAgainst(this.directory), var1, var11);
-                                var5.append(var12);
-                            } catch (InvalidPathException var23) {
-                                throw new IOException("error accessing directory " + this.directory + var23);
-                            }
-                        }
-                    }
-
-                }
-            }
-        }
-
-        public JavaFileObject getFileObject(Path var1, RelativeFile var2) throws IOException {
-            try {
-                Path var3 = var2.resolveAgainst(var1);
-                if (Files.exists(var3)) {
-                    return PathFileObject.forSimplePath(JavacFileManager.this, JavacFileManager.this.fsInfo.getCanonicalFile(var3), var3);
-                }
-            } catch (InvalidPathException ignored) {
-            }
-
-            return null;
-        }
-
-        public void close() throws IOException {
-        }
-    }
-
-    private final class JRTImageContainer implements JavacFileManager.Container {
-        private JRTImageContainer() {
-        }
-
-        public void list(Path var1, RelativeDirectory var2, Set<Kind> var3, boolean var4, ListBuffer<JavaFileObject> var5) throws IOException {
-            try {
-                Entry var6 = JavacFileManager.this.getJRTIndex().getEntry(var2);
-                if (JavacFileManager.this.symbolFileEnabled && var6.ctSym.hidden) {
-                    return;
-                }
-
-                Iterator var7 = var6.files.values().iterator();
-
-                while(var7.hasNext()) {
-                    Path var8 = (Path)var7.next();
-                    if (var3.contains(BaseFileManager.getKind(var8))) {
-                        PathFileObject var9 = PathFileObject.forJRTPath(JavacFileManager.this, var8);
-                        var5.append(var9);
-                    }
-                }
-
-                if (var4) {
-                    var7 = var6.subdirs.iterator();
-
-                    while(var7.hasNext()) {
-                        RelativeDirectory var11 = (RelativeDirectory)var7.next();
-                        this.list(var1, var11, var3, var4, var5);
-                    }
-                }
-            } catch (IOException var10) {
-                var10.printStackTrace(System.err);
-                JavacFileManager.this.log.error("error.reading.file", var1, JavacFileManager.getMessage(var10));
-            }
-
-        }
-
-        public JavaFileObject getFileObject(Path var1, RelativeFile var2) throws IOException {
-            Entry var3 = JavacFileManager.this.getJRTIndex().getEntry(var2.dirname());
-            if (JavacFileManager.this.symbolFileEnabled && var3.ctSym.hidden) {
-                return null;
-            } else {
-                Path var4 = var3.files.get(var2.basename());
-                return var4 != null ? PathFileObject.forJRTPath(JavacFileManager.this, var4) : null;
-            }
-        }
-
-        public void close() throws IOException {
-        }
-    }
-
-    private interface Container {
-        void list(Path var1, RelativeDirectory var2, Set<Kind> var3, boolean var4, ListBuffer<JavaFileObject> var5) throws IOException;
-
-        JavaFileObject getFileObject(Path var1, RelativeFile var2) throws IOException;
-
-        void close() throws IOException;
-    }
-
-    protected static enum SortFiles implements Comparator<Path> {
-        FORWARD {
-            public int compare(Path var1, Path var2) {
-                return var1.getFileName().compareTo(var2.getFileName());
-            }
-        },
-        REVERSE {
-            public int compare(Path var1, Path var2) {
-                return -var1.getFileName().compareTo(var2.getFileName());
-            }
-        };
-
-        private SortFiles() {
-        }
-    }
-}
Index: Build/src/main/resources/com.sun.tools/javac/resources/javac.properties
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/javac.properties b/Build/src/main/resources/com.sun.tools/javac/resources/javac.properties
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/javac.properties	(date 0)
+++ /dev/null	(date 0)
@@ -1,256 +0,0 @@
-#
-# Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-## standard options
-
-javac.opt.g=\
-    Generate all debugging info
-javac.opt.g.none=\
-    Generate no debugging info
-javac.opt.g.lines.vars.source=\
-    Generate only some debugging info
-javac.opt.nowarn=\
-    Generate no warnings
-javac.opt.verbose=\
-    Output messages about what the compiler is doing
-javac.opt.deprecation=\
-    Output source locations where deprecated APIs are used
-javac.opt.classpath=\
-    Specify where to find user class files and annotation processors
-javac.opt.sourcepath=\
-    Specify where to find input source files
-javac.opt.bootclasspath=\
-    Override location of bootstrap class files
-javac.opt.Xbootclasspath.p=\
-    Prepend to the bootstrap class path
-javac.opt.Xbootclasspath.a=\
-    Append to the bootstrap class path
-javac.opt.endorseddirs=\
-    Override location of endorsed standards path
-javac.opt.extdirs=\
-    Override location of installed extensions
-javac.opt.processorpath=\
-    Specify where to find annotation processors
-javac.opt.processor=\
-    Names of the annotation processors to run; bypasses default discovery process
-javac.opt.parameters=\
-    Generate metadata for reflection on method parameters
-javac.opt.proc.none.only=\
-    Control whether annotation processing and/or compilation is done.
-javac.opt.d=\
-    Specify where to place generated class files
-javac.opt.sourceDest=\
-    Specify where to place generated source files
-javac.opt.headerDest=\
-    Specify where to place generated native header files
-javac.opt.J=\
-    Pass <flag> directly to the runtime system
-javac.opt.encoding=\
-    Specify character encoding used by source files
-javac.opt.profile=\
-    Check that API used is available in the specified profile
-javac.opt.target=\
-    Generate class files for specific VM version
-javac.opt.source=\
-    Provide source compatibility with specified release
-javac.opt.Werror=\
-    Terminate compilation if warnings occur
-javac.opt.A=\
-    Options to pass to annotation processors
-javac.opt.implicit=\
-    Specify whether or not to generate class files for implicitly referenced files
-javac.opt.pkginfo=\
-    Specify handling of package-info files
-javac.opt.arg.class=\
-    <class>
-javac.opt.arg.class.list=\
-    <class1>[,<class2>,<class3>...]
-javac.opt.arg.flag=\
-    <flag>
-javac.opt.arg.key.equals.value=\
-    key[=value]
-javac.opt.arg.path=\
-    <path>
-javac.opt.arg.dirs=\
-    <dirs>
-javac.opt.arg.directory=\
-    <directory>
-javac.opt.arg.encoding=\
-    <encoding>
-javac.opt.arg.profile=\
-    <profile>
-javac.opt.arg.release=\
-    <release>
-javac.opt.arg.number=\
-    <number>
-javac.opt.plugin=\
-    Name and optional arguments for a plug-in to be run
-javac.opt.arg.plugin=\
-    "name args"
-
-## extended options
-
-javac.opt.maxerrs=\
-    Set the maximum number of errors to print
-javac.opt.maxwarns=\
-    Set the maximum number of warnings to print
-javac.opt.nogj=\
-    Don't accept generics in the language
-javac.opt.moreinfo=\
-    Print extended information for type variables
-javac.opt.printflat=\
-    Print abstract syntax tree after inner class conversion
-javac.opt.printsearch=\
-    Print information where classfiles are searched
-javac.opt.prompt=\
-    Stop after each error
-javac.opt.retrofit=\
-    Retrofit existing classfiles with generic types
-javac.opt.s=\
-    Emit java sources instead of classfiles
-javac.opt.scramble=\
-    Scramble private identifiers in bytecode
-javac.opt.scrambleall=\
-    Scramble package visible identifiers in bytecode
-javac.opt.version=\
-    Version information
-javac.opt.arg.pathname=\
-    <pathname>
-javac.opt.arg.file=\
-    <filename>
-javac.opt.Xlint=\
-    Enable recommended warnings
-javac.opt.Xlint.suboptlist=\
-    Enable or disable specific warnings
-javac.opt.Xdoclint=\
-    Enable recommended checks for problems in javadoc comments
-# L10N: do not localize: all none
-javac.opt.Xdoclint.subopts = \
-    (all|none|[-]<group>)[/<access>]
-
-# L10N: do not localize: accessibility html missing reference syntax
-# L10N: do not localize: public protected package private
-javac.opt.Xdoclint.custom=\n\
-\        Enable or disable specific checks for problems in javadoc comments,\n\
-\        where <group> is one of accessibility, html, missing, reference, or syntax,\n\
-\        and <access> is one of public, protected, package, or private.
-javac.opt.Xstdout=\
-    Redirect standard output
-javac.opt.X=\
-    Print a synopsis of nonstandard options
-javac.opt.help=\
-    Print a synopsis of standard options
-javac.opt.print=\
-    Print out a textual representation of specified types
-javac.opt.printRounds=\
-    Print information about rounds of annotation processing
-javac.opt.printProcessorInfo=\
-    Print information about which annotations a processor is asked to process
-javac.opt.prefer=\
-    Specify which file to read when both a source file and class file are found for an implicitly compiled class
-javac.opt.AT=\
-    Read options and filenames from file
-javac.opt.diags=\
-    Select a diagnostic mode
-
-## errors
-
-javac.err.empty.A.argument=\
-    -A requires an argument; use ''-Akey'' or ''-Akey=value''
-javac.err.invalid.arg=\
-    invalid argument: {0}
-javac.err.invalid.A.key=\
-     key in annotation processor option ''{0}'' is not a dot-separated sequence of identifiers
-javac.err.invalid.flag=\
-    invalid flag: {0}
-javac.err.profile.bootclasspath.conflict=\
-    profile and bootclasspath options cannot be used together
-javac.err.invalid.profile=\
-    invalid profile: {0}
-javac.err.invalid.target=\
-    invalid target release: {0}
-javac.err.no.source.files=\
-    no source files
-javac.err.no.source.files.classes=\
-    no source files or class names
-javac.err.req.arg=\
-    {0} requires an argument
-javac.err.invalid.source=\
-    invalid source release: {0}
-javac.err.error.writing.file=\
-    error writing {0}; {1}
-javac.warn.source.target.conflict=\
-    source release {0} requires target release {1}
-javac.warn.target.default.source.conflict=\
-    target release {0} conflicts with default source release {1}
-javac.warn.profile.target.conflict=\
-    profile {0} is not valid for target release {1}
-javac.err.dir.not.found=\
-    directory not found: {0}
-javac.err.file.not.found=\
-    file not found: {0}
-javac.err.file.not.directory=\
-    not a directory: {0}
-javac.err.file.not.file=\
-    not a file: {0}
-javac.msg.plugin.not.found=\
-    plug-in not found: {0}
-## messages
-
-javac.msg.usage.header=\
-Usage: {0} <options> <source files>\n\
-where possible options include:
-
-javac.msg.usage=\
-    Usage: {0} <options> <source files>\n\
-    use -help for a list of possible options
-
-javac.msg.usage.nonstandard.footer=\
-These options are non-standard and subject to change without notice.
-
-javac.msg.bug=\
-An exception has occurred in the compiler ({0}). \
-Please file a bug at the Java Bug Database (http://bugreport.java.com/bugreport/) \
-after checking the database for duplicates. \
-Include your program and the following diagnostic in your report.  Thank you.
-
-javac.msg.io=\
-\n\nAn input/output error occurred.\n\
-Consult the following stack trace for details.\n
-
-javac.msg.proc.annotation.uncaught.exception=\
-\n\nAn annotation processor threw an uncaught exception.\n\
-Consult the following stack trace for details.\n
-
-javac.msg.plugin.uncaught.exception=\
-\n\nA plugin threw an uncaught exception.\n\
-Consult the following stack trace for details.\n
-
-javac.msg.resource=\
-\n\nThe system is out of resources.\n\
-Consult the following stack trace for details.\n
-
-javac.version={0} {1}
-javac.fullVersion={0} full version "{1}"
Index: Build/src/main/resources/com.sun.tools/javac/resources/legacy.properties
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/legacy.properties b/Build/src/main/resources/com.sun.tools/javac/resources/legacy.properties
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/legacy.properties	(date 0)
+++ /dev/null	(date 0)
@@ -1,573 +0,0 @@
-#
-# Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-com.sun.accessibility.internal.resources = tiger legacy
-com.sun.awt = tiger legacy
-com.sun.beans = tiger legacy
-com.sun.corba.se.impl.activation = tiger legacy
-com.sun.corba.se.impl.copyobject = tiger legacy
-com.sun.corba.se.impl.corba = tiger legacy
-com.sun.corba.se.impl.dynamicany = tiger legacy
-com.sun.corba.se.impl.encoding = tiger legacy
-com.sun.corba.se.impl.interceptors = tiger legacy
-com.sun.corba.se.impl.io = tiger legacy
-com.sun.corba.se.impl.ior = tiger legacy
-com.sun.corba.se.impl.ior.iiop = tiger legacy
-com.sun.corba.se.impl.javax.rmi = tiger legacy
-com.sun.corba.se.impl.javax.rmi.CORBA = tiger legacy
-com.sun.corba.se.impl.legacy.connection = tiger legacy
-com.sun.corba.se.impl.logging = tiger legacy
-com.sun.corba.se.impl.monitoring = tiger legacy
-com.sun.corba.se.impl.naming.cosnaming = tiger legacy
-com.sun.corba.se.impl.naming.namingutil = tiger legacy
-com.sun.corba.se.impl.naming.pcosnaming = tiger legacy
-com.sun.corba.se.impl.oa = tiger legacy
-com.sun.corba.se.impl.oa.poa = tiger legacy
-com.sun.corba.se.impl.oa.toa = tiger legacy
-com.sun.corba.se.impl.orb = tiger legacy
-com.sun.corba.se.impl.orbutil = tiger legacy
-com.sun.corba.se.impl.orbutil.closure = tiger legacy
-com.sun.corba.se.impl.orbutil.concurrent = tiger legacy
-com.sun.corba.se.impl.orbutil.fsm = tiger legacy
-com.sun.corba.se.impl.orbutil.graph = tiger legacy
-com.sun.corba.se.impl.orbutil.resources = tiger legacy
-com.sun.corba.se.impl.orbutil.threadpool = tiger legacy
-com.sun.corba.se.impl.presentation.rmi = tiger legacy
-com.sun.corba.se.impl.protocol = tiger legacy
-com.sun.corba.se.impl.protocol.giopmsgheaders = tiger legacy
-com.sun.corba.se.impl.resolver = tiger legacy
-com.sun.corba.se.impl.transport = tiger legacy
-com.sun.corba.se.impl.util = tiger legacy
-com.sun.corba.se.internal.CosNaming = tiger legacy
-com.sun.corba.se.internal.Interceptors = tiger legacy
-com.sun.corba.se.internal.POA = tiger legacy
-com.sun.corba.se.internal.corba = tiger legacy
-com.sun.corba.se.internal.iiop = tiger legacy
-com.sun.corba.se.org.omg.CORBA = tiger legacy
-com.sun.corba.se.pept.broker = tiger legacy
-com.sun.corba.se.pept.encoding = tiger legacy
-com.sun.corba.se.pept.protocol = tiger legacy
-com.sun.corba.se.pept.transport = tiger legacy
-com.sun.corba.se.spi.activation = tiger legacy
-com.sun.corba.se.spi.activation.InitialNameServicePackage = tiger legacy
-com.sun.corba.se.spi.activation.LocatorPackage = tiger legacy
-com.sun.corba.se.spi.activation.RepositoryPackage = tiger legacy
-com.sun.corba.se.spi.copyobject = tiger legacy
-com.sun.corba.se.spi.encoding = tiger legacy
-com.sun.corba.se.spi.extension = tiger legacy
-com.sun.corba.se.spi.ior = tiger legacy
-com.sun.corba.se.spi.ior.iiop = tiger legacy
-com.sun.corba.se.spi.legacy.connection = tiger legacy
-com.sun.corba.se.spi.legacy.interceptor = tiger legacy
-com.sun.corba.se.spi.logging = tiger legacy
-com.sun.corba.se.spi.monitoring = tiger legacy
-com.sun.corba.se.spi.oa = tiger legacy
-com.sun.corba.se.spi.orb = tiger legacy
-com.sun.corba.se.spi.orbutil.closure = tiger legacy
-com.sun.corba.se.spi.orbutil.fsm = tiger legacy
-com.sun.corba.se.spi.orbutil.proxy = tiger legacy
-com.sun.corba.se.spi.orbutil.threadpool = tiger legacy
-com.sun.corba.se.spi.presentation.rmi = tiger legacy
-com.sun.corba.se.spi.protocol = tiger legacy
-com.sun.corba.se.spi.resolver = tiger legacy
-com.sun.corba.se.spi.servicecontext = tiger legacy
-com.sun.corba.se.spi.transport = tiger legacy
-com.sun.imageio.metadata = tiger legacy
-com.sun.imageio.plugins.bmp = tiger legacy
-com.sun.imageio.plugins.common = tiger legacy
-com.sun.imageio.plugins.gif = tiger legacy
-com.sun.imageio.plugins.jpeg = tiger legacy
-com.sun.imageio.plugins.png = tiger legacy
-com.sun.imageio.plugins.wbmp = tiger legacy
-com.sun.imageio.spi = tiger legacy
-com.sun.java.browser.dom = tiger legacy
-com.sun.java.browser.net = tiger legacy
-com.sun.java.swing = tiger legacy
-com.sun.java.swing.plaf.gtk = tiger legacy
-com.sun.java.swing.plaf.gtk.icons = tiger legacy
-com.sun.java.swing.plaf.gtk.resources = tiger legacy
-com.sun.java.swing.plaf.gtk.resources.metacity.SwingFallbackTheme.metacity-1 = tiger legacy
-com.sun.java.swing.plaf.motif = tiger legacy
-com.sun.java.swing.plaf.motif.icons = tiger legacy
-com.sun.java.swing.plaf.motif.resources = tiger legacy
-com.sun.java.swing.plaf.nimbus = tiger legacy
-com.sun.java.swing.plaf.windows = tiger legacy
-com.sun.java.swing.plaf.windows.icons = tiger legacy
-com.sun.java.swing.plaf.windows.resources = tiger legacy
-com.sun.java.util.jar.pack = tiger legacy
-com.sun.java_cup.internal = tiger legacy
-com.sun.java_cup.internal.runtime = tiger legacy
-com.sun.jlex.internal = tiger legacy
-com.sun.jmx.defaults = tiger legacy
-com.sun.jmx.interceptor = tiger legacy
-com.sun.jmx.mbeanserver = tiger legacy
-com.sun.jmx.remote.internal = tiger legacy
-com.sun.jmx.remote.protocol.iiop = tiger legacy
-com.sun.jmx.remote.protocol.rmi = tiger legacy
-com.sun.jmx.remote.security = tiger legacy
-com.sun.jmx.remote.util = tiger legacy
-com.sun.jmx.snmp = tiger legacy
-com.sun.jmx.snmp.IPAcl = tiger legacy
-com.sun.jmx.snmp.agent = tiger legacy
-com.sun.jmx.snmp.daemon = tiger legacy
-com.sun.jmx.snmp.defaults = tiger legacy
-com.sun.jmx.snmp.internal = tiger legacy
-com.sun.jmx.snmp.mpm = tiger legacy
-com.sun.jmx.snmp.tasks = tiger legacy
-com.sun.jmx.trace = tiger legacy
-com.sun.jndi.cosnaming = tiger legacy
-com.sun.jndi.dns = tiger legacy
-com.sun.jndi.ldap = tiger legacy
-com.sun.jndi.ldap.ext = tiger legacy
-com.sun.jndi.ldap.pool = tiger legacy
-com.sun.jndi.ldap.sasl = tiger legacy
-com.sun.jndi.rmi.registry = tiger legacy
-com.sun.jndi.toolkit.corba = tiger legacy
-com.sun.jndi.toolkit.ctx = tiger legacy
-com.sun.jndi.toolkit.dir = tiger legacy
-com.sun.jndi.toolkit.url = tiger legacy
-com.sun.jndi.url.corbaname = tiger legacy
-com.sun.jndi.url.dns = tiger legacy
-com.sun.jndi.url.iiop = tiger legacy
-com.sun.jndi.url.iiopname = tiger legacy
-com.sun.jndi.url.ldap = tiger legacy
-com.sun.jndi.url.ldaps = tiger legacy
-com.sun.jndi.url.rmi = tiger legacy
-com.sun.management = tiger legacy
-com.sun.management.jmx = tiger legacy
-com.sun.media.sound = tiger legacy
-com.sun.naming.internal = tiger legacy
-com.sun.net.ssl = tiger legacy
-com.sun.net.ssl.internal.ssl = tiger legacy
-com.sun.net.ssl.internal.www.protocol.https = tiger legacy
-com.sun.org.apache.bcel.internal = tiger legacy
-com.sun.org.apache.bcel.internal.classfile = tiger legacy
-com.sun.org.apache.bcel.internal.generic = tiger legacy
-com.sun.org.apache.bcel.internal.util = tiger legacy
-com.sun.org.apache.bcel.internal.verifier = tiger legacy
-com.sun.org.apache.bcel.internal.verifier.exc = tiger legacy
-com.sun.org.apache.bcel.internal.verifier.statics = tiger legacy
-com.sun.org.apache.bcel.internal.verifier.structurals = tiger legacy
-com.sun.org.apache.html.internal.dom = tiger legacy
-com.sun.org.apache.regexp.internal = tiger legacy
-com.sun.org.apache.wml.internal = tiger legacy
-com.sun.org.apache.wml.internal.dom = tiger legacy
-com.sun.org.apache.xalan.internal = tiger legacy
-com.sun.org.apache.xalan.internal.client = tiger legacy
-com.sun.org.apache.xalan.internal.extensions = tiger legacy
-com.sun.org.apache.xalan.internal.lib = tiger legacy
-com.sun.org.apache.xalan.internal.res = tiger legacy
-com.sun.org.apache.xalan.internal.templates = tiger legacy
-com.sun.org.apache.xalan.internal.xslt = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.cmdline = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.cmdline.getopt = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.compiler = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.compiler.util = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.dom = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.runtime = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.runtime.output = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.trax = tiger legacy
-com.sun.org.apache.xalan.internal.xsltc.util = tiger legacy
-com.sun.org.apache.xerces.internal.dom = tiger legacy
-com.sun.org.apache.xerces.internal.dom.events = tiger legacy
-com.sun.org.apache.xerces.internal.dom3.as = tiger legacy
-com.sun.org.apache.xerces.internal.impl = tiger legacy
-com.sun.org.apache.xerces.internal.impl.dtd = tiger legacy
-com.sun.org.apache.xerces.internal.impl.dtd.models = tiger legacy
-com.sun.org.apache.xerces.internal.impl.dv = tiger legacy
-com.sun.org.apache.xerces.internal.impl.dv.dtd = tiger legacy
-com.sun.org.apache.xerces.internal.impl.dv.util = tiger legacy
-com.sun.org.apache.xerces.internal.impl.dv.xs = tiger legacy
-com.sun.org.apache.xerces.internal.impl.io = tiger legacy
-com.sun.org.apache.xerces.internal.impl.msg = tiger legacy
-com.sun.org.apache.xerces.internal.impl.validation = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xpath = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xpath.regex = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xs = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xs.dom = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xs.identity = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xs.models = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xs.opti = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xs.traversers = tiger legacy
-com.sun.org.apache.xerces.internal.impl.xs.util = tiger legacy
-com.sun.org.apache.xerces.internal.jaxp = tiger legacy
-com.sun.org.apache.xerces.internal.jaxp.datatype = tiger legacy
-com.sun.org.apache.xerces.internal.jaxp.validation = tiger legacy
-com.sun.org.apache.xerces.internal.jaxp.validation.xs = tiger legacy
-com.sun.org.apache.xerces.internal.parsers = tiger legacy
-com.sun.org.apache.xerces.internal.util = tiger legacy
-com.sun.org.apache.xerces.internal.xinclude = tiger legacy
-com.sun.org.apache.xerces.internal.xni = tiger legacy
-com.sun.org.apache.xerces.internal.xni.grammars = tiger legacy
-com.sun.org.apache.xerces.internal.xni.parser = tiger legacy
-com.sun.org.apache.xerces.internal.xs = tiger legacy
-com.sun.org.apache.xml.internal.dtm = tiger legacy
-com.sun.org.apache.xml.internal.dtm.ref = tiger legacy
-com.sun.org.apache.xml.internal.dtm.ref.dom2dtm = tiger legacy
-com.sun.org.apache.xml.internal.dtm.ref.sax2dtm = tiger legacy
-com.sun.org.apache.xml.internal.res = tiger legacy
-com.sun.org.apache.xml.internal.serialize = tiger legacy
-com.sun.org.apache.xml.internal.serializer = tiger legacy
-com.sun.org.apache.xml.internal.utils = tiger legacy
-com.sun.org.apache.xml.internal.utils.res = tiger legacy
-com.sun.org.apache.xml.internal.utils.synthetic = tiger legacy
-com.sun.org.apache.xml.internal.utils.synthetic.reflection = tiger legacy
-com.sun.org.apache.xpath.internal = tiger legacy
-com.sun.org.apache.xpath.internal.axes = tiger legacy
-com.sun.org.apache.xpath.internal.compiler = tiger legacy
-com.sun.org.apache.xpath.internal.functions = tiger legacy
-com.sun.org.apache.xpath.internal.jaxp = tiger legacy
-com.sun.org.apache.xpath.internal.objects = tiger legacy
-com.sun.org.apache.xpath.internal.operations = tiger legacy
-com.sun.org.apache.xpath.internal.patterns = tiger legacy
-com.sun.org.apache.xpath.internal.res = tiger legacy
-com.sun.org.omg.CORBA = tiger legacy
-com.sun.org.omg.CORBA.ValueDefPackage = tiger legacy
-com.sun.org.omg.CORBA.portable = tiger legacy
-com.sun.org.omg.SendingContext = tiger legacy
-com.sun.org.omg.SendingContext.CodeBasePackage = tiger legacy
-com.sun.rmi.rmid = tiger legacy
-com.sun.rowset = tiger legacy
-com.sun.rowset.internal = tiger legacy
-com.sun.rowset.providers = tiger legacy
-com.sun.security.auth = tiger legacy
-com.sun.security.auth.callback = tiger legacy
-com.sun.security.auth.login = tiger legacy
-com.sun.security.auth.module = tiger legacy
-com.sun.security.cert.internal.x509 = tiger legacy
-com.sun.security.jgss = tiger legacy
-com.sun.security.sasl = tiger legacy
-com.sun.security.sasl.digest = tiger legacy
-com.sun.security.sasl.gsskerb = tiger legacy
-com.sun.security.sasl.util = tiger legacy
-com.sun.swing.internal.plaf.basic.resources = tiger legacy
-com.sun.swing.internal.plaf.metal.resources = tiger legacy
-com.sun.swing.internal.plaf.synth.resources = tiger legacy
-com.sun.tracing = tiger legacy
-com.sun.tracing.dtrace = tiger legacy
-java.applet = tiger legacy
-java.awt = tiger legacy
-java.awt.color = tiger legacy
-java.awt.datatransfer = tiger legacy
-java.awt.dnd = tiger legacy
-java.awt.dnd.peer = tiger legacy
-java.awt.event = tiger legacy
-java.awt.font = tiger legacy
-java.awt.geom = tiger legacy
-java.awt.im = tiger legacy
-java.awt.im.spi = tiger legacy
-java.awt.image = tiger legacy
-java.awt.image.renderable = tiger legacy
-java.awt.peer = tiger legacy
-java.awt.print = tiger legacy
-java.beans = tiger legacy
-java.beans.beancontext = tiger legacy
-java.io = tiger legacy
-java.lang = tiger legacy
-java.lang.annotation = tiger legacy
-java.lang.instrument = tiger legacy
-java.lang.management = tiger legacy
-java.lang.ref = tiger legacy
-java.lang.reflect = tiger legacy
-java.math = tiger legacy
-java.net = tiger legacy
-java.nio = tiger legacy
-java.nio.channels = tiger legacy
-java.nio.channels.spi = tiger legacy
-java.nio.charset = tiger legacy
-java.nio.charset.spi = tiger legacy
-java.rmi = tiger legacy
-java.rmi.activation = tiger legacy
-java.rmi.dgc = tiger legacy
-java.rmi.registry = tiger legacy
-java.rmi.server = tiger legacy
-java.security = tiger legacy
-java.security.acl = tiger legacy
-java.security.cert = tiger legacy
-java.security.interfaces = tiger legacy
-java.security.spec = tiger legacy
-java.sql = tiger legacy
-java.text = tiger legacy
-java.util = tiger legacy
-java.util.concurrent = tiger legacy
-java.util.concurrent.atomic = tiger legacy
-java.util.concurrent.locks = tiger legacy
-java.util.jar = tiger legacy
-java.util.logging = tiger legacy
-java.util.prefs = tiger legacy
-java.util.regex = tiger legacy
-java.util.zip = tiger legacy
-javax.accessibility = tiger legacy
-javax.activity = tiger legacy
-javax.imageio = tiger legacy
-javax.imageio.event = tiger legacy
-javax.imageio.metadata = tiger legacy
-javax.imageio.plugins.bmp = tiger legacy
-javax.imageio.plugins.jpeg = tiger legacy
-javax.imageio.spi = tiger legacy
-javax.imageio.stream = tiger legacy
-javax.management = tiger legacy
-javax.management.loading = tiger legacy
-javax.management.modelmbean = tiger legacy
-javax.management.monitor = tiger legacy
-javax.management.openmbean = tiger legacy
-javax.management.relation = tiger legacy
-javax.management.remote = tiger legacy
-javax.management.remote.rmi = tiger legacy
-javax.management.timer = tiger legacy
-javax.naming = tiger legacy
-javax.naming.directory = tiger legacy
-javax.naming.event = tiger legacy
-javax.naming.ldap = tiger legacy
-javax.naming.spi = tiger legacy
-javax.net = tiger legacy
-javax.net.ssl = tiger legacy
-javax.print = tiger legacy
-javax.print.attribute = tiger legacy
-javax.print.attribute.standard = tiger legacy
-javax.print.event = tiger legacy
-javax.rmi = tiger legacy
-javax.rmi.CORBA = tiger legacy
-javax.rmi.ssl = tiger legacy
-javax.security.auth = tiger legacy
-javax.security.auth.callback = tiger legacy
-javax.security.auth.kerberos = tiger legacy
-javax.security.auth.login = tiger legacy
-javax.security.auth.spi = tiger legacy
-javax.security.auth.x500 = tiger legacy
-javax.security.cert = tiger legacy
-javax.security.sasl = tiger legacy
-javax.sound.midi = tiger legacy
-javax.sound.midi.spi = tiger legacy
-javax.sound.sampled = tiger legacy
-javax.sound.sampled.spi = tiger legacy
-javax.sql = tiger legacy
-javax.sql.rowset = tiger legacy
-javax.sql.rowset.serial = tiger legacy
-javax.sql.rowset.spi = tiger legacy
-javax.swing = tiger legacy
-javax.swing.border = tiger legacy
-javax.swing.colorchooser = tiger legacy
-javax.swing.event = tiger legacy
-javax.swing.filechooser = tiger legacy
-javax.swing.plaf = tiger legacy
-javax.swing.plaf.basic = tiger legacy
-javax.swing.plaf.basic.icons = tiger legacy
-javax.swing.plaf.metal = tiger legacy
-javax.swing.plaf.metal.icons = tiger legacy
-javax.swing.plaf.metal.icons.ocean = tiger legacy
-javax.swing.plaf.metal.sounds = tiger legacy
-javax.swing.plaf.multi = tiger legacy
-javax.swing.plaf.nimbus = tiger legacy
-javax.swing.plaf.synth = tiger legacy
-javax.swing.table = tiger legacy
-javax.swing.text = tiger legacy
-javax.swing.text.html = tiger legacy
-javax.swing.text.html.icons = tiger legacy
-javax.swing.text.html.parser = tiger legacy
-javax.swing.text.rtf = tiger legacy
-javax.swing.text.rtf.charsets = tiger legacy
-javax.swing.tree = tiger legacy
-javax.swing.undo = tiger legacy
-javax.transaction = tiger legacy
-javax.transaction.xa = tiger legacy
-javax.xml = tiger legacy
-javax.xml.datatype = tiger legacy
-javax.xml.namespace = tiger legacy
-javax.xml.parsers = tiger legacy
-javax.xml.transform = tiger legacy
-javax.xml.transform.dom = tiger legacy
-javax.xml.transform.sax = tiger legacy
-javax.xml.transform.stream = tiger legacy
-javax.xml.validation = tiger legacy
-javax.xml.xpath = tiger legacy
-org.ietf.jgss = tiger legacy
-org.omg.CORBA = tiger legacy
-org.omg.CORBA.DynAnyPackage = tiger legacy
-org.omg.CORBA.ORBPackage = tiger legacy
-org.omg.CORBA.TypeCodePackage = tiger legacy
-org.omg.CORBA.portable = tiger legacy
-org.omg.CORBA_2_3 = tiger legacy
-org.omg.CORBA_2_3.portable = tiger legacy
-org.omg.CosNaming = tiger legacy
-org.omg.CosNaming.NamingContextExtPackage = tiger legacy
-org.omg.CosNaming.NamingContextPackage = tiger legacy
-org.omg.Dynamic = tiger legacy
-org.omg.DynamicAny = tiger legacy
-org.omg.DynamicAny.DynAnyFactoryPackage = tiger legacy
-org.omg.DynamicAny.DynAnyPackage = tiger legacy
-org.omg.IOP = tiger legacy
-org.omg.IOP.CodecFactoryPackage = tiger legacy
-org.omg.IOP.CodecPackage = tiger legacy
-org.omg.Messaging = tiger legacy
-org.omg.PortableInterceptor = tiger legacy
-org.omg.PortableInterceptor.ORBInitInfoPackage = tiger legacy
-org.omg.PortableServer = tiger legacy
-org.omg.PortableServer.CurrentPackage = tiger legacy
-org.omg.PortableServer.POAManagerPackage = tiger legacy
-org.omg.PortableServer.POAPackage = tiger legacy
-org.omg.PortableServer.ServantLocatorPackage = tiger legacy
-org.omg.PortableServer.portable = tiger legacy
-org.omg.SendingContext = tiger legacy
-org.omg.stub.java.rmi = tiger legacy
-org.omg.stub.javax.management.remote.rmi = tiger legacy
-org.w3c.dom = tiger legacy
-org.w3c.dom.bootstrap = tiger legacy
-org.w3c.dom.css = tiger legacy
-org.w3c.dom.events = tiger legacy
-org.w3c.dom.html = tiger legacy
-org.w3c.dom.ls = tiger legacy
-org.w3c.dom.ranges = tiger legacy
-org.w3c.dom.stylesheets = tiger legacy
-org.w3c.dom.traversal = tiger legacy
-org.w3c.dom.views = tiger legacy
-org.xml.sax = tiger legacy
-org.xml.sax.ext = tiger legacy
-org.xml.sax.helpers = tiger legacy
-sun.applet = tiger legacy
-sun.applet.resources = tiger legacy
-sun.audio = tiger legacy
-sun.awt = tiger legacy
-sun.awt.X11 = tiger legacy
-sun.awt.color = tiger legacy
-sun.awt.datatransfer = tiger legacy
-sun.awt.dnd = tiger legacy
-sun.awt.geom = tiger legacy
-sun.awt.im = tiger legacy
-sun.awt.image = tiger legacy
-sun.awt.image.codec = tiger legacy
-sun.awt.motif = tiger legacy
-sun.awt.resources = tiger legacy
-sun.awt.shell = tiger legacy
-sun.awt.windows = tiger legacy
-sun.beans.editors = tiger legacy
-sun.beans.infos = tiger legacy
-sun.corba = tiger legacy
-sun.dc.path = tiger legacy
-sun.dc.pr = tiger legacy
-sun.font = tiger legacy
-sun.instrument = tiger legacy
-sun.io = tiger legacy
-sun.java2d = tiger legacy
-sun.java2d.loops = tiger legacy
-sun.java2d.opengl = tiger legacy
-sun.java2d.pipe = tiger legacy
-sun.jdbc.odbc = tiger legacy
-sun.jdbc.odbc.ee = tiger legacy
-sun.management = tiger legacy
-sun.management.counter = tiger legacy
-sun.management.counter.perf = tiger legacy
-sun.management.jmxremote = tiger legacy
-sun.management.resources = tiger legacy
-sun.management.snmp = tiger legacy
-sun.management.snmp.jvminstr = tiger legacy
-sun.management.snmp.jvmmib = tiger legacy
-sun.management.snmp.util = tiger legacy
-sun.misc = tiger legacy
-sun.misc.resources = tiger legacy
-sun.net = tiger legacy
-sun.net.dns = tiger legacy
-sun.net.ftp = tiger legacy
-sun.net.smtp = tiger legacy
-sun.net.spi = tiger legacy
-sun.net.spi.nameservice = tiger legacy
-sun.net.util = tiger legacy
-sun.net.www = tiger legacy
-sun.net.www.content.audio = tiger legacy
-sun.net.www.content.image = tiger legacy
-sun.net.www.content.text = tiger legacy
-sun.net.www.http = tiger legacy
-sun.net.www.protocol.doc = tiger legacy
-sun.net.www.protocol.file = tiger legacy
-sun.net.www.protocol.ftp = tiger legacy
-sun.net.www.protocol.gopher = tiger legacy
-sun.net.www.protocol.http = tiger legacy
-sun.net.www.protocol.https = tiger legacy
-sun.net.www.protocol.jar = tiger legacy
-sun.net.www.protocol.mailto = tiger legacy
-sun.net.www.protocol.netdoc = tiger legacy
-sun.net.www.protocol.systemresource = tiger legacy
-sun.net.www.protocol.verbatim = tiger legacy
-sun.nio = tiger legacy
-sun.nio.ch = tiger legacy
-sun.nio.cs = tiger legacy
-sun.print = tiger legacy
-sun.print.resources = tiger legacy
-sun.reflect = tiger legacy
-sun.reflect.annotation = tiger legacy
-sun.reflect.generics.factory = tiger legacy
-sun.reflect.generics.parser = tiger legacy
-sun.reflect.generics.reflectiveObjects = tiger legacy
-sun.reflect.generics.repository = tiger legacy
-sun.reflect.generics.scope = tiger legacy
-sun.reflect.generics.tree = tiger legacy
-sun.reflect.generics.visitor = tiger legacy
-sun.rmi.log = tiger legacy
-sun.rmi.registry = tiger legacy
-sun.rmi.registry.resources = tiger legacy
-sun.rmi.rmid.resources = tiger legacy
-sun.rmi.runtime = tiger legacy
-sun.rmi.server = tiger legacy
-sun.rmi.transport = tiger legacy
-sun.rmi.transport.proxy = tiger legacy
-sun.rmi.transport.tcp = tiger legacy
-sun.security.acl = tiger legacy
-sun.security.action = tiger legacy
-sun.security.jca = tiger legacy
-sun.security.jgss = tiger legacy
-sun.security.jgss.krb5 = tiger legacy
-sun.security.jgss.spi = tiger legacy
-sun.security.krb5 = tiger legacy
-sun.security.krb5.internal = tiger legacy
-sun.security.krb5.internal.ccache = tiger legacy
-sun.security.krb5.internal.crypto = tiger legacy
-sun.security.krb5.internal.crypto.dk = tiger legacy
-sun.security.krb5.internal.ktab = tiger legacy
-sun.security.krb5.internal.rcache = tiger legacy
-sun.security.krb5.internal.tools = tiger legacy
-sun.security.krb5.internal.util = tiger legacy
-sun.security.pkcs = tiger legacy
-sun.security.provider = tiger legacy
-sun.security.provider.certpath = tiger legacy
-sun.security.rsa = tiger legacy
-sun.security.timestamp = tiger legacy
-sun.security.tools = tiger legacy
-sun.security.util = tiger legacy
-sun.security.validator = tiger legacy
-sun.security.x509 = tiger legacy
-sun.swing = tiger legacy
-sun.swing.plaf.synth = tiger legacy
-sun.text = tiger legacy
-sun.text.resources = tiger legacy
-sun.tools.hprof = tiger legacy
-sun.tools.jar = tiger legacy
-sun.tools.jar.resources = tiger legacy
-sun.util = tiger legacy
-sun.util.calendar = tiger legacy
-sun.util.locale = tiger legacy
-sun.util.logging.resources = tiger legacy
-sunw.io = tiger legacy
-sunw.util = tiger legacy
Index: Build/src/main/resources/com.sun.tools/javac/resources/compiler.properties
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/compiler.properties b/Build/src/main/resources/com.sun.tools/javac/resources/compiler.properties
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/compiler.properties	(date 0)
+++ /dev/null	(date 0)
@@ -1,2576 +0,0 @@
-#
-# Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
-# are preceded by a stylized comment describing the type of the corresponding
-# values.
-# The types currently in use are
-#
-# boolean           true or false
-# file name         the name of an input file; e.g.   MyFile.java
-# message segment   a sub-message; see compiler.misc.*
-# modifier          a Java modifier; e.g. public, private, protected
-# name              a name, typically a Java identifier
-# number            an integer
-# option name       the name of a command line option
-# source version    a source version number, such as 1.5, 1.6, 1.7
-# string            a general string
-# symbol            the name of a declared type
-# symbol kind       a description of the kind of a declaration; see compiler.misc.kindname.*
-# token             the name of a non-terminal in source code; see compiler.misc.token.*
-# type              a Java type; e.g. int, X, X<T>
-# unused            the value is not used in this message
-#
-# list of X         a comma-separated list of items; e.g. list of type
-# X or Y            alternation; e.g. message segment or type
-# set of X          a comma-separated collection of items; e.g. set of modifier
-#
-# These may be composed: e.g.   list of type or message segment
-#
-# These comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
-# using info derived from the collected set of examples in test/tools/javac/diags/examples.
-# MessageInfo can also be run as a standalone utility providing more facilities
-# for manipulating this file. For more details, see MessageInfo.java.
-
-##
-## errors
-##
-
-# 0: symbol
-compiler.err.abstract.cant.be.instantiated=\
-    {0} is abstract; cannot be instantiated
-
-compiler.err.abstract.meth.cant.have.body=\
-    abstract methods cannot have a body
-
-compiler.err.already.annotated=\
-    {0} {1} has already been annotated
-
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol
-compiler.err.already.defined=\
-    {0} {1} is already defined in {2} {3}
-
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol kind, 4: symbol
-compiler.err.already.defined.in.clinit=\
-    {0} {1} is already defined in {2} of {3} {4}
-
-# 0: string
-compiler.err.already.defined.single.import=\
-    a type with the same simple name is already defined by the single-type-import of {0}
-
-# 0: string
-compiler.err.already.defined.static.single.import=\
-    a type with the same simple name is already defined by the static single-type-import of {0}
-
-compiler.err.already.defined.this.unit=\
-    {0} is already defined in this compilation unit
-
-# 0: type, 1: list of name
-compiler.err.annotation.missing.default.value=\
-    annotation @{0} is missing a default value for the element ''{1}''
-
-# 0: type, 1: list of name
-compiler.err.annotation.missing.default.value.1=\
-    annotation @{0} is missing default values for elements {1}
-
-# 0: type
-compiler.err.annotation.not.valid.for.type=\
-    annotation not valid for an element of type {0}
-
-compiler.err.annotation.type.not.applicable=\
-    annotation type not applicable to this kind of declaration
-
-compiler.err.annotation.value.must.be.annotation=\
-    annotation value must be an annotation
-
-compiler.err.annotation.value.must.be.class.literal=\
-    annotation value must be a class literal
-
-compiler.err.annotation.value.must.be.name.value=\
-    annotation values must be of the form ''name=value''
-
-compiler.err.annotation.value.not.allowable.type=\
-    annotation value not of an allowable type
-
-compiler.err.anon.class.impl.intf.no.args=\
-    anonymous class implements interface; cannot have arguments
-
-compiler.err.anon.class.impl.intf.no.typeargs=\
-    anonymous class implements interface; cannot have type arguments
-
-compiler.err.anon.class.impl.intf.no.qual.for.new=\
-    anonymous class implements interface; cannot have qualifier for new
-
-compiler.err.cant.inherit.from.anon=\
-    cannot inherit from anonymous class
-
-# 0: symbol, 1: symbol, 2: symbol
-compiler.err.array.and.varargs=\
-    cannot declare both {0} and {1} in {2}
-
-compiler.err.array.dimension.missing=\
-    array dimension missing
-
-# 0: type
-compiler.err.array.req.but.found=\
-    array required, but {0} found
-
-compiler.err.attribute.value.must.be.constant=\
-    element value must be a constant expression
-
-# 0: statement type
-compiler.err.bad.initializer=\
-    bad initializer for {0}
-
-compiler.err.break.outside.switch.loop=\
-    break outside switch or loop
-
-# 0: name
-compiler.err.call.must.be.first.stmt.in.ctor=\
-    call to {0} must be first statement in constructor
-
-# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
-compiler.err.cant.apply.symbol=\
-    {0} {1} in {4} {5} cannot be applied to given types;\n\
-    required: {2}\n\
-    found: {3}\n\
-    reason: {6}
-
-# 0: symbol kind, 1: name, 2: list of type
-compiler.err.cant.apply.symbols=\
-    no suitable {0} found for {1}({2})
-
-# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
-compiler.misc.cant.apply.symbol=\
-    {0} {1} in {4} {5} cannot be applied to given types\n\
-    required: {2}\n\
-    found: {3}\n\
-    reason: {6}
-
-# 0: symbol kind, 1: name, 2: list of type
-compiler.misc.cant.apply.symbols=\
-    no suitable {0} found for {1}({2})
-
-# 0: symbol kind, 1: symbol
-compiler.misc.no.abstracts=\
-    no abstract method found in {0} {1}
-
-# 0: symbol kind, 1: symbol
-compiler.misc.incompatible.abstracts=\
-    multiple non-overriding abstract methods found in {0} {1}
-
-compiler.err.bad.functional.intf.anno=\
-    Unexpected @FunctionalInterface annotation
-
-# 0: message segment
-compiler.err.bad.functional.intf.anno.1=\
-    Unexpected @FunctionalInterface annotation\n\
-    {0}
-
-# 0: symbol
-compiler.misc.not.a.functional.intf=\
-    {0} is not a functional interface
-
-# 0: symbol, 1: message segment
-compiler.misc.not.a.functional.intf.1=\
-    {0} is not a functional interface\n\
-    {1}
-
-# 0: symbol, 1: symbol kind, 2: symbol
-compiler.misc.invalid.generic.lambda.target=\
-    invalid functional descriptor for lambda expression\n\
-    method {0} in {1} {2} is generic
-
-# 0: symbol kind, 1: symbol
-compiler.misc.incompatible.descs.in.functional.intf=\
-    incompatible function descriptors found in {0} {1}
-
-# 0: name, 1: list of type, 2: type, 3: list of type
-compiler.misc.descriptor=\
-    descriptor: {2} {0}({1})
-
-# 0: name, 1: list of type, 2: type, 3: list of type
-compiler.misc.descriptor.throws=\
-    descriptor: {2} {0}({1}) throws {3}
-
-# 0: type
-compiler.misc.no.suitable.functional.intf.inst=\
-    cannot infer functional interface descriptor for {0}
-
-# 0: message segment
-compiler.misc.bad.intersection.target.for.functional.expr=\
-    bad intersection type target for lambda or method reference\n\
-    {0}
-
-# 0: symbol or type
-compiler.misc.not.an.intf.component=\
-    component type {0} is not an interface
-
-# 0: symbol kind, 1: message segment
-compiler.err.invalid.mref=\
-    invalid {0} reference\n\
-    {1}
-
-# 0: symbol kind, 1: message segment
-compiler.misc.invalid.mref=\
-    invalid {0} reference\n\
-    {1}
-
-compiler.misc.static.mref.with.targs=\
-    parameterized qualifier on static method reference
-
-compiler.misc.static.bound.mref=\
-    static bound method reference
-
-# 0: symbol
-compiler.err.cant.assign.val.to.final.var=\
-    cannot assign a value to final variable {0}
-
-# 0: symbol, 1: message segment
-compiler.err.cant.ref.non.effectively.final.var=\
-    local variables referenced from {1} must be final or effectively final
-
-
-compiler.misc.lambda=\
-    a lambda expression
-
-compiler.misc.inner.cls=\
-    an inner class
-
-# 0: type
-compiler.err.cant.deref=\
-    {0} cannot be dereferenced
-
-compiler.err.cant.extend.intf.annotation=\
-    ''extends'' not allowed for @interfaces
-
-# 0: symbol
-compiler.err.cant.inherit.from.final=\
-    cannot inherit from final {0}
-
-# 0: symbol
-compiler.err.cant.ref.before.ctor.called=\
-    cannot reference {0} before supertype constructor has been called
-
-compiler.err.cant.select.static.class.from.param.type=\
-    cannot select a static class from a parameterized type
-
-# 0: symbol, 1: string, 2: string
-compiler.err.cant.inherit.diff.arg=\
-    {0} cannot be inherited with different arguments: <{1}> and <{2}>
-
-compiler.err.catch.without.try=\
-    ''catch'' without ''try''
-
-# 0: symbol kind, 1: symbol
-compiler.err.clash.with.pkg.of.same.name=\
-    {0} {1} clashes with package of same name
-
-compiler.err.class.not.allowed=\
-    class, interface or enum declaration not allowed here
-
-compiler.err.const.expr.req=\
-    constant expression required
-
-compiler.err.cont.outside.loop=\
-    continue outside of loop
-
-# 0: symbol
-compiler.err.cyclic.inheritance=\
-    cyclic inheritance involving {0}
-
-# 0: symbol
-compiler.err.cyclic.annotation.element=\
-    type of element {0} is cyclic
-
-# 0: unused
-compiler.err.call.to.super.not.allowed.in.enum.ctor=\
-    call to super not allowed in enum constructor
-
-# 0: type
-compiler.err.no.superclass=\
-    {0} has no superclass.
-
-# 0: symbol, 1: type, 2: symbol, 3: type, 4: unused
-compiler.err.concrete.inheritance.conflict=\
-    methods {0} from {1} and {2} from {3} are inherited with the same signature
-
-compiler.err.default.allowed.in.intf.annotation.member=\
-    default value only allowed in an annotation type declaration
-
-# 0: symbol
-compiler.err.doesnt.exist=\
-    package {0} does not exist
-
-# 0: type
-compiler.err.duplicate.annotation.invalid.repeated=\
-    annotation {0} is not a valid repeatable annotation
-
-# 0: name, 1: type
-compiler.err.duplicate.annotation.member.value=\
-    duplicate element ''{0}'' in annotation @{1}.
-
-# 0: name, 1: unused
-compiler.err.duplicate.annotation.missing.container=\
-    {0} is not a repeatable annotation type
-
-# 0: type, 1: unused
-compiler.err.invalid.repeatable.annotation=\
-    duplicate annotation: {0} is annotated with an invalid @Repeatable annotation
-
-# 0: symbol or type
-compiler.err.invalid.repeatable.annotation.no.value=\
-    {0} is not a valid @Repeatable, no value element method declared
-
-# 0: type, 1: number
-compiler.err.invalid.repeatable.annotation.multiple.values=\
-    {0} is not a valid @Repeatable, {1} element methods named ''value'' declared
-
-# 0: type
-compiler.err.invalid.repeatable.annotation.invalid.value=\
-    {0} is not a valid @Repeatable: invalid value element
-
-# 0: symbol type, 1: unused, 2: type
-compiler.err.invalid.repeatable.annotation.value.return=\
-    containing annotation type ({0}) must declare an element named ''value'' of type {2}
-
-# 0: symbol or type, 1: symbol
-compiler.err.invalid.repeatable.annotation.elem.nondefault=\
-    containing annotation type ({0}) does not have a default value for element {1}
-
-# 0: symbol, 1: unused, 2: symbol, 3: unused
-compiler.err.invalid.repeatable.annotation.retention=\
-    retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.not.documented=\
-    repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.not.inherited=\
-    repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.incompatible.target=\
-    containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})
-
-# 0: symbol
-compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\
-    container {0} must not be present at the same time as the element it contains
-
-# 0: name
-compiler.err.duplicate.class=\
-    duplicate class: {0}
-
-compiler.err.duplicate.case.label=\
-    duplicate case label
-
-compiler.err.duplicate.default.label=\
-    duplicate default label
-
-compiler.err.else.without.if=\
-    ''else'' without ''if''
-
-compiler.err.empty.char.lit=\
-    empty character literal
-
-# 0: symbol
-compiler.err.encl.class.required=\
-    an enclosing instance that contains {0} is required
-
-compiler.err.enum.annotation.must.be.enum.constant=\
-    an enum annotation value must be an enum constant
-
-compiler.err.enum.cant.be.instantiated=\
-    enum types may not be instantiated
-
-compiler.err.enum.label.must.be.unqualified.enum=\
-    an enum switch case label must be the unqualified name of an enumeration constant
-
-compiler.err.enum.no.subclassing=\
-    classes cannot directly extend java.lang.Enum
-
-compiler.err.enum.types.not.extensible=\
-    enum types are not extensible
-
-compiler.err.enum.no.finalize=\
-    enums cannot have finalize methods
-
-# 0: file name, 1: string
-compiler.err.error.reading.file=\
-    error reading {0}; {1}
-
-# 0: type
-compiler.err.except.already.caught=\
-    exception {0} has already been caught
-
-# 0: type
-compiler.err.except.never.thrown.in.try=\
-    exception {0} is never thrown in body of corresponding try statement
-
-# 0: symbol
-compiler.err.final.parameter.may.not.be.assigned=\
-    final parameter {0} may not be assigned
-
-# 0: symbol
-compiler.err.try.resource.may.not.be.assigned=\
-    auto-closeable resource {0} may not be assigned
-
-# 0: symbol
-compiler.err.multicatch.parameter.may.not.be.assigned=\
-    multi-catch parameter {0} may not be assigned
-
-# 0: type, 1: type
-compiler.err.multicatch.types.must.be.disjoint=\
-    Alternatives in a multi-catch statement cannot be related by subclassing\n\
-    Alternative {0} is a subclass of alternative {1}
-
-compiler.err.finally.without.try=\
-    ''finally'' without ''try''
-
-# 0: type, 1: message segment
-compiler.err.foreach.not.applicable.to.type=\
-    for-each not applicable to expression type\n\
-    required: {1}\n\
-    found:    {0}
-
-compiler.err.fp.number.too.large=\
-    floating point number too large
-
-compiler.err.fp.number.too.small=\
-    floating point number too small
-
-compiler.err.generic.array.creation=\
-    generic array creation
-
-compiler.err.generic.throwable=\
-    a generic class may not extend java.lang.Throwable
-
-# 0: symbol
-compiler.err.icls.cant.have.static.decl=\
-    Illegal static declaration in inner class {0}\n\
-    modifier \''static\'' is only allowed in constant variable declarations
-
-# 0: string
-compiler.err.illegal.char=\
-    illegal character: ''{0}''
-
-compiler.err.illegal.char.for.encoding=\
-    unmappable character for encoding {0}
-
-# 0: set of modifier, 1: set of modifier
-compiler.err.illegal.combination.of.modifiers=\
-    illegal combination of modifiers: {0} and {1}
-
-compiler.err.illegal.enum.static.ref=\
-    illegal reference to static field from initializer
-
-compiler.err.illegal.esc.char=\
-    illegal escape character
-
-compiler.err.illegal.forward.ref=\
-    illegal forward reference
-
-# 0: symbol, 1: string
-compiler.err.not.in.profile=\
-    {0} is not available in profile ''{1}''
-
-# 0: symbol
-compiler.warn.forward.ref=\
-    reference to variable ''{0}'' before it has been initialized
-
-compiler.err.illegal.self.ref=\
-    self-reference in initializer
-
-# 0: symbol
-compiler.warn.self.ref=\
-    self-reference in initializer of variable ''{0}''
-
-compiler.err.illegal.generic.type.for.instof=\
-    illegal generic type for instanceof
-
-# 0: type
-compiler.err.illegal.initializer.for.type=\
-    illegal initializer for {0}
-
-compiler.err.illegal.line.end.in.char.lit=\
-    illegal line end in character literal
-
-compiler.err.illegal.nonascii.digit=\
-    illegal non-ASCII digit
-
-compiler.err.illegal.underscore=\
-    illegal underscore
-
-compiler.err.illegal.dot=\
-    illegal ''.''
-
-# 0: symbol
-compiler.err.illegal.qual.not.icls=\
-    illegal qualifier; {0} is not an inner class
-
-compiler.err.illegal.start.of.expr=\
-    illegal start of expression
-
-compiler.err.illegal.start.of.stmt=\
-    illegal start of statement
-
-compiler.err.illegal.start.of.type=\
-    illegal start of type
-
-compiler.err.illegal.unicode.esc=\
-    illegal unicode escape
-
-# 0: symbol
-compiler.err.import.requires.canonical=\
-    import requires canonical name for {0}
-
-compiler.err.improperly.formed.type.param.missing=\
-    improperly formed type, some parameters are missing
-
-compiler.err.improperly.formed.type.inner.raw.param=\
-    improperly formed type, type arguments given on a raw type
-
-# 0: type, 1: type
-compiler.err.incomparable.types=\
-    incomparable types: {0} and {1}
-
-# 0: number
-compiler.err.int.number.too.large=\
-    integer number too large: {0}
-
-compiler.err.intf.annotation.members.cant.have.params=\
-    elements in annotation type declarations cannot declare formal parameters
-
-# 0: symbol
-compiler.err.intf.annotation.cant.have.type.params=\
-    annotation type {0} cannot be generic
-
-compiler.err.intf.annotation.members.cant.have.type.params=\
-    elements in annotation type declarations cannot be generic methods
-
-# 0: symbol, 1: type
-compiler.err.intf.annotation.member.clash=\
-    annotation type {1} declares an element with the same name as method {0}
-
-compiler.err.intf.expected.here=\
-    interface expected here
-
-compiler.err.intf.meth.cant.have.body=\
-    interface abstract methods cannot have body
-
-# 0: symbol
-compiler.err.invalid.annotation.member.type=\
-    invalid type for element {0} of annotation type
-
-compiler.err.invalid.binary.number=\
-    binary numbers must contain at least one binary digit
-
-compiler.err.invalid.hex.number=\
-    hexadecimal numbers must contain at least one hexadecimal digit
-
-compiler.err.invalid.meth.decl.ret.type.req=\
-    invalid method declaration; return type required
-
-compiler.err.varargs.and.old.array.syntax=\
-    legacy array notation not allowed on variable-arity parameter
-
-compiler.err.varargs.and.receiver =\
-    varargs notation not allowed on receiver parameter
-
-compiler.err.array.and.receiver =\
-    legacy array notation not allowed on receiver parameter
-
-compiler.err.variable.not.allowed=\
-    variable declaration not allowed here
-
-# 0: name
-compiler.err.label.already.in.use=\
-    label {0} already in use
-
-# 0: symbol
-compiler.err.local.var.accessed.from.icls.needs.final=\
-    local variable {0} is accessed from within inner class; needs to be declared final
-
-compiler.err.local.enum=\
-    enum types must not be local
-
-compiler.err.cannot.create.array.with.type.arguments=\
-    cannot create array with type arguments
-
-compiler.err.cannot.create.array.with.diamond=\
-    cannot create array with ''<>''
-
-#
-# limits.  We don't give the limits in the diagnostic because we expect
-# them to change, yet we want to use the same diagnostic.  These are all
-# detected during code generation.
-#
-compiler.err.limit.code=\
-    code too large
-
-compiler.err.limit.code.too.large.for.try.stmt=\
-    code too large for try statement
-
-compiler.err.limit.dimensions=\
-    array type has too many dimensions
-
-compiler.err.limit.locals=\
-    too many local variables
-
-compiler.err.limit.parameters=\
-    too many parameters
-
-compiler.err.limit.pool=\
-    too many constants
-
-compiler.err.limit.pool.in.class=\
-    too many constants in class {0}
-
-compiler.err.limit.stack=\
-    code requires too much stack
-
-compiler.err.limit.string=\
-    constant string too long
-
-compiler.err.limit.string.overflow=\
-    UTF8 representation for string \"{0}...\" is too long for the constant pool
-
-compiler.err.malformed.fp.lit=\
-    malformed floating point literal
-
-compiler.err.method.does.not.override.superclass=\
-    method does not override or implement a method from a supertype
-
-compiler.err.missing.meth.body.or.decl.abstract=\
-    missing method body, or declare abstract
-
-compiler.err.missing.ret.stmt=\
-    missing return statement
-
-# 0: unused
-compiler.misc.missing.ret.val=\
-    missing return value
-
-compiler.misc.unexpected.ret.val=\
-    unexpected return value
-
-# 0: set of modifier
-compiler.err.mod.not.allowed.here=\
-    modifier {0} not allowed here
-
-compiler.err.intf.not.allowed.here=\
-    interface not allowed here
-
-compiler.err.enums.must.be.static=\
-    enum declarations allowed only in static contexts
-
-# 0: symbol, 1: symbol
-compiler.err.name.clash.same.erasure=\
-    name clash: {0} and {1} have the same erasure
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: unused, 5: unused
-compiler.err.name.clash.same.erasure.no.override=\
-    name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither overrides the other
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: symbol, 5: symbol
-compiler.err.name.clash.same.erasure.no.override.1=\
-    name clash: {0} in {1} overrides a method whose erasure is the same as another method, yet neither overrides the other\n\
-    first method:  {2} in {3}\n\
-    second method: {4} in {5}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.err.name.clash.same.erasure.no.hide=\
-    name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other
-
-compiler.err.name.reserved.for.internal.use=\
-    {0} is reserved for internal use
-
-compiler.err.native.meth.cant.have.body=\
-    native methods cannot have a body
-
-# 0: type, 1: type
-compiler.err.neither.conditional.subtype=\
-    incompatible types for ?: neither is a subtype of the other\n\
-    second operand: {0}\n\
-    third operand : {1}
-
-# 0: message segment
-compiler.misc.incompatible.type.in.conditional=\
-    bad type in conditional expression\n\
-    {0}
-
-compiler.misc.conditional.target.cant.be.void=\
-    target-type for conditional expression cannot be void
-
-# 0: type
-compiler.misc.incompatible.ret.type.in.lambda=\
-    bad return type in lambda expression\n\
-    {0}
-
-# 0: type
-compiler.misc.incompatible.ret.type.in.mref=\
-    bad return type in method reference\n\
-    {0}
-
-compiler.err.lambda.body.neither.value.nor.void.compatible=\
-    lambda body is neither value nor void compatible
-
-# 0: list of type
-compiler.err.incompatible.thrown.types.in.mref=\
-    incompatible thrown types {0} in method reference
-
-compiler.misc.incompatible.arg.types.in.lambda=\
-    incompatible parameter types in lambda expression
-
-compiler.misc.incompatible.arg.types.in.mref=\
-    incompatible parameter types in method reference
-
-compiler.err.new.not.allowed.in.annotation=\
-    ''new'' not allowed in an annotation
-
-compiler.err.no.annotation.member=\
-    no annotation member {0} in {1}
-
-compiler.err.no.encl.instance.of.type.in.scope=\
-    no enclosing instance of type {0} is in scope
-
-compiler.err.no.intf.expected.here=\
-    no interface expected here
-
-compiler.err.no.match.entry=\
-    {0} has no match in entry in {1}; required {2}
-
-compiler.err.not.annotation.type=\
-    {0} is not an annotation type
-
-# 0: symbol, 1: symbol
-compiler.err.not.def.access.class.intf.cant.access=\
-    {0} in {1} is defined in an inaccessible class or interface
-
-# 0: symbol, 1: symbol
-compiler.misc.not.def.access.class.intf.cant.access=\
-    {0} in {1} is defined in an inaccessible class or interface
-
-# 0: symbol, 1: list of type, 2: type
-compiler.misc.cant.access.inner.cls.constr=\
-    cannot access constructor {0}({1})\n\
-    an enclosing instance of type {2} is not in scope
-
-# 0: symbol, 1: symbol
-compiler.err.not.def.public.cant.access=\
-    {0} is not public in {1}; cannot be accessed from outside package
-
-# 0: symbol, 1: symbol
-compiler.misc.not.def.public.cant.access=\
-    {0} is not public in {1}; cannot be accessed from outside package
-
-# 0: name
-compiler.err.not.loop.label=\
-    not a loop label: {0}
-
-compiler.err.not.stmt=\
-    not a statement
-
-# 0: symbol
-compiler.err.not.encl.class=\
-    not an enclosing class: {0}
-
-# 0: name, 1: type, 2: unused
-compiler.err.operator.cant.be.applied=\
-    bad operand type {1} for unary operator ''{0}''
-
-# 0: name, 1: type, 2: type
-compiler.err.operator.cant.be.applied.1=\
-    bad operand types for binary operator ''{0}''\n\
-    first type:  {1}\n\
-    second type: {2}
-
-compiler.err.pkg.annotations.sb.in.package-info.java=\
-    package annotations should be in file package-info.java
-
-# 0: symbol
-compiler.err.pkg.clashes.with.class.of.same.name=\
-    package {0} clashes with class of same name
-
-compiler.err.warnings.and.werror=\
-    warnings found and -Werror specified
-
-# Errors related to annotation processing
-
-# 0: symbol, 1: string, 2: stack-trace
-compiler.err.proc.cant.access=\
-    cannot access {0}\n\
-    {1}\n\
-    Consult the following stack trace for details.\n\
-    {2}
-
-# 0: symbol, 1: string
-compiler.err.proc.cant.access.1=\
-    cannot access {0}\n\
-    {1}
-
-# 0: string
-compiler.err.proc.cant.find.class=\
-    Could not find class file for ''{0}''.
-
-# Print a client-generated error message; assumed to be localized, no translation required
-# 0: string
-compiler.err.proc.messager=\
-    {0}
-
-# 0: list of string
-compiler.err.proc.no.explicit.annotation.processing.requested=\
-    Class names, ''{0}'', are only accepted if annotation processing is explicitly requested
-
-compiler.err.proc.no.service=\
-    A ServiceLoader was not usable and is required for annotation processing.
-
-compiler.err.proc.processor.bad.option.name=\
-    Bad option name ''{0}'' provided by processor ''{1}''
-
-# 0: string
-compiler.err.proc.processor.cant.instantiate=\
-    Could not instantiate an instance of processor ''{0}''
-
-# 0: string
-compiler.err.proc.processor.not.found=\
-    Annotation processor ''{0}'' not found
-
-# 0: string
-compiler.err.proc.processor.wrong.type=\
-    Annotation processor ''{0}'' does not implement javax.annotation.processing.Processor
-
-compiler.err.proc.service.problem=\
-    Error creating a service loader to load Processors.
-
-compiler.err.proc.bad.config.file=\
-    Bad service configuration file, or exception thrown while constructing Processor object: {0}
-
-compiler.err.proc.cant.create.loader=\
-    Could not create class loader for annotation processors: {0}
-
-# 0: unused
-compiler.err.qualified.new.of.static.class=\
-    qualified new of static class
-
-compiler.err.recursive.ctor.invocation=\
-    recursive constructor invocation
-
-# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
-compiler.err.ref.ambiguous=\
-    reference to {0} is ambiguous\n\
-    both {1} {2} in {3} and {4} {5} in {6} match
-
-# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
-compiler.misc.ref.ambiguous=\
-    reference to {0} is ambiguous\n\
-    both {1} {2} in {3} and {4} {5} in {6} match
-
-compiler.err.repeated.annotation.target=\
-    repeated annotation target
-
-compiler.err.repeated.interface=\
-    repeated interface
-
-compiler.err.repeated.modifier=\
-    repeated modifier
-
-# 0: symbol, 1: set of modifier, 2: symbol
-compiler.err.report.access=\
-    {0} has {1} access in {2}
-
-# 0: symbol, 1: set of modifier, 2: symbol
-compiler.misc.report.access=\
-    {0} has {1} access in {2}
-
-compiler.err.ret.outside.meth=\
-    return outside method
-
-compiler.err.signature.doesnt.match.supertype=\
-    signature does not match {0}; incompatible supertype
-
-compiler.err.signature.doesnt.match.intf=\
-    signature does not match {0}; incompatible interfaces
-
-# 0: number, 1: number
-compiler.err.method.invoked.with.incorrect.number.arguments=\
-    method invoked with incorrect number of arguments; expected {0}, found {1}
-
-# 0: symbol, 1: symbol, 2: symbol
-compiler.err.does.not.override.abstract=\
-    {0} is not abstract and does not override abstract method {1} in {2}
-
-compiler.err.source.cant.overwrite.input.file=\
-    error writing source; cannot overwrite input file {0}
-
-compiler.err.stack.sim.error=\
-    Internal error: stack sim error on {0}
-
-compiler.err.static.imp.only.classes.and.interfaces=\
-    static import only from classes and interfaces
-
-compiler.err.string.const.req=\
-    constant string expression required
-
-# 0: symbol, 1: symbol
-compiler.err.synthetic.name.conflict=\
-    the symbol {0} conflicts with a compiler-synthesized symbol in {1}
-
-# 0: symbol, 1: symbol
-compiler.warn.synthetic.name.conflict=\
-    the symbol {0} conflicts with a compiler-synthesized symbol in {1}
-
-compiler.err.throws.not.allowed.in.intf.annotation=\
-    throws clause not allowed in @interface members
-
-compiler.err.try.without.catch.or.finally=\
-    ''try'' without ''catch'' or ''finally''
-
-compiler.err.try.without.catch.finally.or.resource.decls=\
-    ''try'' without ''catch'', ''finally'' or resource declarations
-
-# 0: symbol
-compiler.err.type.doesnt.take.params=\
-    type {0} does not take parameters
-
-compiler.err.type.var.cant.be.deref=\
-    cannot select from a type variable
-
-compiler.err.type.var.may.not.be.followed.by.other.bounds=\
-    a type variable may not be followed by other bounds
-
-compiler.err.type.var.more.than.once=\
-    type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
-
-compiler.err.type.var.more.than.once.in.result=\
-    type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
-
-# 0: type, 1: type, 2: string
-compiler.err.types.incompatible.diff.ret=\
-    types {0} and {1} are incompatible; both define {2}, but with unrelated return types
-
-# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
-compiler.err.types.incompatible.unrelated.defaults=\
-    {0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}
-
-# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
-compiler.err.types.incompatible.abstract.default=\
-    {0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}
-
-# 0: name, 1: kind, 2: symbol
-compiler.err.default.overrides.object.member=\
-    default method {0} in {1} {2} overrides a member of java.lang.Object
-
-# 0: type
-compiler.err.illegal.static.intf.meth.call=\
-    illegal static interface method call\n\
-    the receiver expression should be replaced with the type qualifier ''{0}''
-
-# 0: type, 1: message segment
-compiler.err.illegal.default.super.call=\
-    bad type qualifier {0} in default super call\n\
-    {1}
-
-# 0: symbol, 1: type
-compiler.misc.overridden.default=\
-    method {0} is overridden in {1}
-
-# 0: symbol, 1: type or symbol
-compiler.misc.redundant.supertype=\
-    redundant interface {0} is extended by {1}
-
-compiler.err.unclosed.char.lit=\
-    unclosed character literal
-
-compiler.err.unclosed.comment=\
-    unclosed comment
-
-compiler.err.unclosed.str.lit=\
-    unclosed string literal
-
-# 0: name
-compiler.err.unsupported.encoding=\
-    unsupported encoding: {0}
-
-compiler.err.io.exception=\
-    error reading source file: {0}
-
-# 0: name
-compiler.err.undef.label=\
-    undefined label: {0}
-
-# 0: message segment, 1: unused
-compiler.err.cant.apply.diamond=\
-    cannot infer type arguments for {0}
-
-# 0: message segment or type, 1: message segment
-compiler.err.cant.apply.diamond.1=\
-    cannot infer type arguments for {0}\n\
-    reason: {1}
-
-# 0: message segment or type, 1: message segment
-compiler.misc.cant.apply.diamond.1=\
-    cannot infer type arguments for {0}\n\
-    reason: {1}
-
-compiler.err.unreachable.stmt=\
-    unreachable statement
-
-compiler.err.initializer.must.be.able.to.complete.normally=\
-    initializer must be able to complete normally
-
-# 0: type
-compiler.err.unreported.exception.need.to.catch.or.throw=\
-    unreported exception {0}; must be caught or declared to be thrown
-
-# 0: type
-compiler.err.unreported.exception.default.constructor=\
-    unreported exception {0} in default constructor
-
-# 0: type, 1: name
-compiler.err.unreported.exception.implicit.close=\
-    unreported exception {0}; must be caught or declared to be thrown\n\
-    exception thrown from implicit call to close() on resource variable ''{1}''
-
-compiler.err.unsupported.cross.fp.lit=\
-    hexadecimal floating-point literals are not supported on this VM
-
-compiler.err.void.not.allowed.here=\
-    ''void'' type not allowed here
-
-# 0: string
-compiler.err.wrong.number.type.args=\
-    wrong number of type arguments; required {0}
-
-# 0: symbol
-compiler.err.var.might.already.be.assigned=\
-    variable {0} might already have been assigned
-
-# 0: symbol
-compiler.err.var.might.not.have.been.initialized=\
-    variable {0} might not have been initialized
-
-# 0: symbol
-compiler.err.var.not.initialized.in.default.constructor=\
-    variable {0} not initialized in the default constructor
-
-# 0: symbol
-compiler.err.var.might.be.assigned.in.loop=\
-    variable {0} might be assigned in loop
-
-# 0: symbol, 1: message segment
-compiler.err.varargs.invalid.trustme.anno=\
-    Invalid {0} annotation. {1}
-
-# 0: type
-compiler.misc.varargs.trustme.on.reifiable.varargs=\
-    Varargs element type {0} is reifiable.
-
-# 0: symbol
-compiler.misc.varargs.trustme.on.non.varargs.meth=\
-    Method {0} is not a varargs method.
-
-# 0: symbol
-compiler.misc.varargs.trustme.on.virtual.varargs=\
-    Instance method {0} is not final.
-
-# 0: type, 1: symbol kind, 2: symbol
-compiler.misc.inaccessible.varargs.type=\
-    formal varargs element type {0} is not accessible from {1} {2}
-
-# In the following string, {1} will always be the detail message from
-# java.io.IOException.
-# 0: symbol, 1: string
-compiler.err.class.cant.write=\
-    error while writing {0}: {1}
-
-# In the following string, {0} is the name of the class in the Java source.
-# It really should be used two times..
-# 0: name
-compiler.err.class.public.should.be.in.file=\
-    class {0} is public, should be declared in a file named {0}.java
-
-## All errors which do not refer to a particular line in the source code are
-## preceded by this string.
-compiler.err.error=\
-    error:\u0020
-
-# The following error messages do not refer to a line in the source code.
-compiler.err.cant.read.file=\
-    cannot read: {0}
-
-#####
-
-# Fatal Errors
-
-compiler.misc.fatal.err.no.java.lang=\
-    Fatal Error: Unable to find package java.lang in classpath or bootclasspath
-
-compiler.misc.fatal.err.cant.locate.meth=\
-    Fatal Error: Unable to find method {0}
-
-compiler.misc.fatal.err.cant.locate.field=\
-    Fatal Error: Unable to find field {0}
-
-compiler.misc.fatal.err.cant.locate.ctor=\
-    Fatal Error: Unable to find constructor for {0}
-
-compiler.misc.fatal.err.cant.close=\
-    Fatal Error: Cannot close compiler resources
-
-#####
-
-##
-## miscellaneous strings
-##
-
-compiler.misc.source.unavailable=\
-    (source unavailable)
-
-compiler.misc.base.membership=\
-    all your base class are belong to us
-
-# 0: string, 1: string, 2: boolean
-compiler.misc.x.print.processor.info=\
-    Processor {0} matches {1} and returns {2}.
-
-# 0: number, 1: string, 2: set of symbol, 3: boolean
-compiler.misc.x.print.rounds=\
-    Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}
-
-#####
-
-## The following string will appear before all messages keyed as:
-## "compiler.note".
-
-compiler.note.compressed.diags=\
-    Some messages have been simplified; recompile with -Xdiags:verbose to get full output
-
-compiler.note.potential.lambda.found=\
-    This anonymous inner class creation can be turned into a lambda expression.
-
-# 0: boolean, 1: symbol
-compiler.note.lambda.stat=\
-    Translating lambda expression\n\
-    alternate metafactory = {0}\n\
-    synthetic method = {1}
-
-# 0: boolean, 1: unused
-compiler.note.mref.stat=\
-    Translating method reference\n\
-    alternate metafactory = {0}\n\
-
-# 0: boolean, 1: symbol
-compiler.note.mref.stat.1=\
-    Translating method reference\n\
-    alternate metafactory = {0}\n\
-    bridge method = {1}
-
-compiler.note.note=\
-    Note:\u0020
-
-# 0: file name
-compiler.note.deprecated.filename=\
-    {0} uses or overrides a deprecated API.
-
-compiler.note.deprecated.plural=\
-    Some input files use or override a deprecated API.
-
-# The following string may appear after one of the above deprecation
-# messages.
-compiler.note.deprecated.recompile=\
-    Recompile with -Xlint:deprecation for details.
-
-# 0: file name
-compiler.note.deprecated.filename.additional=\
-    {0} has additional uses or overrides of a deprecated API.
-
-compiler.note.deprecated.plural.additional=\
-    Some input files additionally use or override a deprecated API.
-
-# 0: file name
-compiler.note.unchecked.filename=\
-    {0} uses unchecked or unsafe operations.
-
-compiler.note.unchecked.plural=\
-    Some input files use unchecked or unsafe operations.
-
-# The following string may appear after one of the above deprecation
-# messages.
-compiler.note.unchecked.recompile=\
-    Recompile with -Xlint:unchecked for details.
-
-# 0: file name
-compiler.note.unchecked.filename.additional=\
-    {0} has additional unchecked or unsafe operations.
-
-compiler.note.unchecked.plural.additional=\
-    Some input files additionally use unchecked or unsafe operations.
-
-# 0: file name
-compiler.note.sunapi.filename=\
-    {0} uses internal proprietary API that may be removed in a future release.
-
-compiler.note.sunapi.plural=\
-    Some input files use internal proprietary API that may be removed in a future release.
-
-# The following string may appear after one of the above sunapi messages.
-compiler.note.sunapi.recompile=\
-    Recompile with -Xlint:sunapi for details.
-
-# 0: file name
-compiler.note.sunapi.filename.additional=\
-    {0} uses additional internal proprietary API that may be removed in a future release.
-
-compiler.note.sunapi.plural.additional=\
-    Some input files additionally use internal proprietary API that may be removed in a future release.
-
-# Notes related to annotation processing
-
-# Print a client-generated note; assumed to be localized, no translation required
-# 0: string
-compiler.note.proc.messager=\
-    {0}
-
-#####
-
-# 0: number
-compiler.misc.count.error=\
-    {0} error
-
-# 0: number
-compiler.misc.count.error.plural=\
-    {0} errors
-
-# 0: number
-compiler.misc.count.warn=\
-    {0} warning
-
-# 0: number
-compiler.misc.count.warn.plural=\
-    {0} warnings
-
-compiler.misc.version.not.available=\
-    (version info not available)
-
-## extra output when using -verbose (JavaCompiler)
-
-# 0: symbol
-compiler.misc.verbose.checking.attribution=\
-    [checking {0}]
-
-# 0: string
-compiler.misc.verbose.parsing.done=\
-    [parsing completed {0}ms]
-
-# 0: file name
-compiler.misc.verbose.parsing.started=\
-    [parsing started {0}]
-
-# 0: string
-compiler.misc.verbose.total=\
-    [total {0}ms]
-
-# 0: file name
-compiler.misc.verbose.wrote.file=\
-    [wrote {0}]
-
-## extra output when using -verbose (Retro)
-compiler.misc.verbose.retro=\
-    [retrofitting {0}]
-
-compiler.misc.verbose.retro.with=\
-    \tretrofitting {0} with {1}
-
-compiler.misc.verbose.retro.with.list=\
-    \tretrofitting {0} with type parameters {1}, supertype {2}, interfaces {3}
-
-## extra output when using -verbose (code/ClassReader)
-# 0: string
-compiler.misc.verbose.loading=\
-    [loading {0}]
-
-# 0: string
-compiler.misc.verbose.sourcepath=\
-    [search path for source files: {0}]
-
-# 0: string
-compiler.misc.verbose.classpath=\
-    [search path for class files: {0}]
-
-## extra output when using -checkclassfile (code/ClassReader)
-compiler.misc.ccf.found.later.version=\
-    class file has later version than expected: {0}
-
-compiler.misc.ccf.unrecognized.attribute=\
-    unrecognized attribute: {0}
-
-## extra output when using -prompt (util/Log)
-compiler.misc.resume.abort=\
-    R)esume, A)bort>
-
-#####
-
-##
-## warnings
-##
-
-## All warning messages are preceded by the following string.
-compiler.warn.warning=\
-    warning:\u0020
-
-## Warning messages may also include the following prefix to identify a
-## lint option
-# 0: option name
-compiler.warn.lintOption=\
-    [{0}]\u0020
-
-# 0: symbol
-compiler.warn.constant.SVUID=\
-    serialVersionUID must be constant in class {0}
-
-# 0: file name
-compiler.warn.dir.path.element.not.found=\
-    bad path element "{0}": no such directory
-
-compiler.warn.finally.cannot.complete=\
-    finally clause cannot complete normally
-
-# 0: symbol, 1: symbol
-compiler.warn.has.been.deprecated=\
-    {0} in {1} has been deprecated
-
-# 0: symbol
-compiler.warn.sun.proprietary=\
-    {0} is internal proprietary API and may be removed in a future release
-
-compiler.warn.illegal.char.for.encoding=\
-    unmappable character for encoding {0}
-
-# 0: symbol
-compiler.warn.improper.SVUID=\
-    serialVersionUID must be declared static final in class {0}
-
-# 0: type, 1: type
-compiler.warn.inexact.non-varargs.call=\
-    non-varargs call of varargs method with inexact argument type for last parameter;\n\
-    cast to {0} for a varargs call\n\
-    cast to {1} for a non-varargs call and to suppress this warning
-
-# 0: list of type
-compiler.warn.unreachable.catch=\
-    unreachable catch clause\n\
-    thrown type {0} has already been caught
-
-# 0: list of type
-compiler.warn.unreachable.catch.1=\
-    unreachable catch clause\n\
-    thrown types {0} have already been caught
-
-# 0: symbol
-compiler.warn.long.SVUID=\
-    serialVersionUID must be of type long in class {0}
-
-# 0: symbol
-compiler.warn.missing.SVUID=\
-    serializable class {0} has no definition of serialVersionUID
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.warn.potentially.ambiguous.overload=\
-    {0} in {1} is potentially ambiguous with {2} in {3}
-
-# 0: message segment
-compiler.warn.override.varargs.missing=\
-    {0}; overridden method has no ''...''
-
-# 0: message segment
-compiler.warn.override.varargs.extra=\
-    {0}; overriding method is missing ''...''
-
-compiler.warn.override.bridge=\
-    {0}; overridden method is a bridge method
-
-# 0: symbol
-compiler.warn.pkg-info.already.seen=\
-    a package-info.java file has already been seen for package {0}
-
-# 0: file name
-compiler.warn.path.element.not.found=\
-    bad path element "{0}": no such file or directory
-
-compiler.warn.possible.fall-through.into.case=\
-    possible fall-through into case
-
-# 0: type
-compiler.warn.redundant.cast=\
-    redundant cast to {0}
-
-# 0: number
-compiler.warn.position.overflow=\
-    Position encoding overflows at line {0}
-
-# 0: file name, 1: number, 2: number
-compiler.warn.big.major.version=\
-    {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\
-    It is recommended that the compiler be upgraded.
-
-# 0: symbol kind, 1: symbol
-compiler.warn.static.not.qualified.by.type=\
-    static {0} should be qualified by type name, {1}, instead of by an expression
-
-# 0: string
-compiler.warn.source.no.bootclasspath=\
-    bootstrap class path not set in conjunction with -source {0}
-
-# 0: string
-compiler.warn.option.obsolete.source=\
-    source value {0} is obsolete and will be removed in a future release
-
-# 0: string
-compiler.warn.option.obsolete.target=\
-    target value {0} is obsolete and will be removed in a future release
-
-compiler.warn.option.obsolete.suppression=\
-    To suppress warnings about obsolete options, use -Xlint:-options.
-
-# 0: name, 1: number, 2: number, 3: number, 4: number
-compiler.warn.future.attr=\
-    {0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files
-
-# Warnings related to annotation processing
-# 0: name
-compiler.warn.proc.package.does.not.exist=\
-    package {0} does not exist
-
-# 0: name
-compiler.warn.proc.file.reopening=\
-    Attempt to create a file for ''{0}'' multiple times
-
-# 0: name
-compiler.warn.proc.type.already.exists=\
-    A file for type ''{0}'' already exists on the sourcepath or classpath
-
-# 0: name
-compiler.warn.proc.type.recreate=\
-    Attempt to create a file for type ''{0}'' multiple times
-
-# 0: string
-compiler.warn.proc.illegal.file.name=\
-    Cannot create file for illegal name ''{0}''.
-
-# 0: string, 1: string
-compiler.warn.proc.suspicious.class.name=\
-    Creating file for a type whose name ends in {1}: ''{0}''
-
-# 0: name
-compiler.warn.proc.file.create.last.round=\
-    File for type ''{0}'' created in the last round will not be subject to annotation processing.
-
-# 0: string, 1: string
-compiler.warn.proc.malformed.supported.string=\
-    Malformed string ''{0}'' for a supported annotation type returned by processor ''{1}''
-
-# 0: set of string
-compiler.warn.proc.annotations.without.processors=\
-    No processor claimed any of these annotations: {0}
-
-# 0: source version, 1: string, 2: string
-compiler.warn.proc.processor.incompatible.source.version=\
-    Supported source version ''{0}'' from annotation processor ''{1}'' less than -source ''{2}''
-
-compiler.warn.proc.proc-only.requested.no.procs=\
-    Annotation processing without compilation requested but no processors were found.
-
-compiler.warn.proc.use.implicit=\
-    Implicitly compiled files were not subject to annotation processing.\n\
-    Use -implicit to specify a policy for implicit compilation.
-
-compiler.warn.proc.use.proc.or.implicit=\
-    Implicitly compiled files were not subject to annotation processing.\n\
-    Use -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.
-
-# Print a client-generated warning; assumed to be localized, no translation required
-# 0: string
-compiler.warn.proc.messager=\
-    {0}
-
-# 0: set of name
-compiler.warn.proc.unclosed.type.files=\
-    Unclosed files for the types ''{0}''; these types will not undergo annotation processing
-
-# 0: string
-compiler.warn.proc.unmatched.processor.options=\
-    The following options were not recognized by any processor: ''{0}''
-
-compiler.warn.try.explicit.close.call=\
-    explicit call to close() on an auto-closeable resource
-
-# 0: symbol
-compiler.warn.try.resource.not.referenced=\
-    auto-closeable resource {0} is never referenced in body of corresponding try statement
-
-# 0: type
-compiler.warn.try.resource.throws.interrupted.exc=\
-    auto-closeable resource {0} has a member method close() that could throw InterruptedException
-
-compiler.warn.unchecked.assign=\
-    unchecked assignment: {0} to {1}
-
-# 0: symbol, 1: type
-compiler.warn.unchecked.assign.to.var=\
-    unchecked assignment to variable {0} as member of raw type {1}
-
-# 0: symbol, 1: type
-compiler.warn.unchecked.call.mbr.of.raw.type=\
-    unchecked call to {0} as a member of the raw type {1}
-
-compiler.warn.unchecked.cast.to.type=\
-    unchecked cast to type {0}
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list of type, 4: symbol kind, 5: symbol
-compiler.warn.unchecked.meth.invocation.applied=\
-    unchecked method invocation: {0} {1} in {4} {5} is applied to given types\n\
-    required: {2}\n\
-    found: {3}
-
-# 0: type
-compiler.warn.unchecked.generic.array.creation=\
-    unchecked generic array creation for varargs parameter of type {0}
-
-# 0: type
-compiler.warn.unchecked.varargs.non.reifiable.type=\
-    Possible heap pollution from parameterized vararg type {0}
-
-# 0: symbol
-compiler.warn.varargs.unsafe.use.varargs.param=\
-    Varargs method could cause heap pollution from non-reifiable varargs parameter {0}
-
-compiler.warn.missing.deprecated.annotation=\
-    deprecated item is not annotated with @Deprecated
-
-compiler.warn.invalid.archive.file=\
-    Unexpected file on path: {0}
-
-compiler.warn.unexpected.archive.file=\
-    Unexpected extension for archive file: {0}
-
-compiler.warn.div.zero=\
-    division by zero
-
-compiler.warn.empty.if=\
-    empty statement after if
-
-compiler.warn.annotation.method.not.found=\
-    Cannot find annotation method ''{1}()'' in type ''{0}''
-
-compiler.warn.annotation.method.not.found.reason=\
-    Cannot find annotation method ''{1}()'' in type ''{0}'': {2}
-
-# 0: symbol, 1: name
-compiler.warn.unknown.enum.constant=\
-    unknown enum constant {1}.{2}
-
-# 0: symbol, 1: name, 2: message segment
-compiler.warn.unknown.enum.constant.reason=\
-    unknown enum constant {1}.{2}\n\
-    reason: {3}
-
-# 0: type, 1: type
-compiler.warn.raw.class.use=\
-    found raw type: {0}\n\
-    missing type arguments for generic class {1}
-
-# 0: unused, 1: unused
-compiler.warn.diamond.redundant.args=\
-    redundant type arguments in new expression (use diamond operator instead).
-
-# 0: type, 1: type
-compiler.warn.diamond.redundant.args.1=\
-    redundant type arguments in new expression (use diamond operator instead).\n\
-    explicit: {0}\n\
-    inferred: {1}
-
-# 0: symbol, 1: message segment
-compiler.warn.varargs.redundant.trustme.anno=\
-    Redundant {0} annotation. {1}
-
-# 0: symbol
-compiler.warn.access.to.sensitive.member.from.serializable.element=\
-    access to sensitive member {0} from serializable element can be publicly accessible to untrusted code
-
-#####
-
-## The following are tokens which are non-terminals in the language. They should
-## be named as JLS3 calls them when translated to the appropriate language.
-compiler.misc.token.identifier=\
-    <identifier>
-
-compiler.misc.token.character=\
-    <character>
-
-compiler.misc.token.string=\
-    <string>
-
-compiler.misc.token.integer=\
-    <integer>
-
-compiler.misc.token.long-integer=\
-    <long integer>
-
-compiler.misc.token.float=\
-    <float>
-
-compiler.misc.token.double=\
-    <double>
-
-compiler.misc.token.bad-symbol=\
-    <bad symbol>
-
-compiler.misc.token.end-of-input=\
-    <end of input>
-
-## The argument to the following string will always be one of the following:
-## 1. one of the above non-terminals
-## 2. a keyword (JLS1.8)
-## 3. a boolean literal (JLS3.10.3)
-## 4. the null literal (JLS3.10.7)
-## 5. a Java separator (JLS3.11)
-## 6. an operator (JLS3.12)
-##
-## This is the only place these tokens will be used.
-# 0: token
-compiler.err.expected=\
-    {0} expected
-
-# 0: token, 1: token
-compiler.err.expected2=\
-    {0} or {1} expected
-
-# 0: token, 1: token, 2: token
-compiler.err.expected3=\
-    {0}, {1}, or {2} expected
-
-compiler.err.premature.eof=\
-    reached end of file while parsing
-
-## The following are related in form, but do not easily fit the above paradigm.
-compiler.err.dot.class.expected=\
-    ''.class'' expected
-
-## The argument to this string will always be either 'case' or 'default'.
-# 0: token
-compiler.err.orphaned=\
-    orphaned {0}
-
-# 0: name
-compiler.misc.anonymous.class=\
-    <anonymous {0}>
-
-# 0: name, 1: type
-compiler.misc.type.captureof=\
-    capture#{0} of {1}
-
-compiler.misc.type.captureof.1=\
-    capture#{0}
-
-compiler.misc.type.none=\
-    <none>
-
-compiler.misc.unnamed.package=\
-    unnamed package
-
-#####
-
-# 0: symbol, 1: message segment
-compiler.err.cant.access=\
-    cannot access {0}\n\
-    {1}
-
-# 0: file name, 1: expected CP entry type, 2: constant pool index
-compiler.misc.bad.const.pool.entry=\
-    bad constant pool entry in {0}\n\
-    expected {1} at index {2}
-
-# 0: file name, 1: message segment
-compiler.misc.bad.class.file.header=\
-    bad class file: {0}\n\
-    {1}\n\
-    Please remove or make sure it appears in the correct subdirectory of the classpath.
-
-# 0: file name, 1: message segment
-compiler.misc.bad.source.file.header=\
-    bad source file: {0}\n\
-    {1}\n\
-    Please remove or make sure it appears in the correct subdirectory of the sourcepath.
-
-## The following are all possible strings for the second argument ({1}) of the
-## above strings.
-compiler.misc.bad.class.signature=\
-    bad class signature: {0}
-
-#0: symbol, 1: symbol
-compiler.misc.bad.enclosing.class=\
-    bad enclosing class for {0}: {1}
-
-# 0: symbol
-compiler.misc.bad.enclosing.method=\
-    bad enclosing method attribute for class {0}
-
-compiler.misc.bad.runtime.invisible.param.annotations=\
-    bad RuntimeInvisibleParameterAnnotations attribute: {0}
-
-compiler.misc.bad.const.pool.tag=\
-    bad constant pool tag: {0}
-
-compiler.misc.bad.const.pool.tag.at=\
-    bad constant pool tag: {0} at {1}
-
-compiler.misc.bad.signature=\
-    bad signature: {0}
-
-compiler.misc.bad.type.annotation.value=\
-    bad type annotation target type value: {0}
-
-compiler.misc.class.file.wrong.class=\
-    class file contains wrong class: {0}
-
-compiler.misc.class.file.not.found=\
-    class file for {0} not found
-
-# 0: classfile major version, 1: classfile minor version
-compiler.misc.invalid.default.interface=\
-    default method found in version {0}.{1} classfile
-
-# 0: classfile major version, 1: classfile minor version
-compiler.misc.invalid.static.interface=\
-    static method found in version {0}.{1} classfile
-
-# 0: name
-compiler.misc.file.doesnt.contain.class=\
-    file does not contain class {0}
-
-compiler.misc.file.does.not.contain.package=\
-    file does not contain package {0}
-
-compiler.misc.illegal.start.of.class.file=\
-    illegal start of class file
-
-compiler.misc.unable.to.access.file=\
-    unable to access file: {0}
-
-compiler.misc.unicode.str.not.supported=\
-    unicode string in class file not supported
-
-compiler.misc.undecl.type.var=\
-    undeclared type variable: {0}
-
-compiler.misc.wrong.version=\
-    class file has wrong version {0}.{1}, should be {2}.{3}
-
-#####
-
-# 0: type, 1: type or symbol
-compiler.err.not.within.bounds=\
-    type argument {0} is not within bounds of type-variable {1}
-
-## The following are all possible strings for the second argument ({1}) of the
-## above string.
-
-## none yet...
-
-#####
-
-# 0: message segment
-compiler.err.prob.found.req=\
-    incompatible types: {0}
-
-# 0: message segment
-compiler.misc.prob.found.req=\
-    incompatible types: {0}
-
-# 0: message segment, 1: type, 2: type
-compiler.warn.prob.found.req=\
-    {0}\n\
-    required: {2}\n\
-    found:    {1}
-
-# 0: type, 1: type
-compiler.misc.inconvertible.types=\
-    {0} cannot be converted to {1}
-
-# 0: type, 1: type
-compiler.misc.possible.loss.of.precision=\
-    possible lossy conversion from {0} to {1}
-
-compiler.misc.unchecked.assign=\
-    unchecked conversion
-
-# compiler.misc.storecheck=\
-#     assignment might cause later store checks to fail
-# compiler.misc.unchecked=\
-#     assigned array cannot dynamically check its stores
-compiler.misc.unchecked.cast.to.type=\
-    unchecked cast
-
-# compiler.err.star.expected=\
-#     ''*'' expected
-# compiler.err.no.elem.type=\
-#     \[\*\] cannot have a type
-
-# 0: type
-compiler.misc.try.not.applicable.to.type=\
-    try-with-resources not applicable to variable type\n\
-    ({0})
-
-#####
-
-# 0: message segment or type, 1: message segment
-compiler.err.type.found.req=\
-    unexpected type\n\
-    required: {1}\n\
-    found:    {0}
-
-## The following are all possible strings for the first argument ({0}) of the
-## above string.
-compiler.misc.type.req.class=\
-    class
-
-compiler.misc.type.req.class.array=\
-    class or array
-
-compiler.misc.type.req.array.or.iterable=\
-    array or java.lang.Iterable
-
-compiler.misc.type.req.ref=\
-    reference
-
-compiler.misc.type.req.exact=\
-    class or interface without bounds
-
-# 0: type
-compiler.misc.type.parameter=\
-    type parameter {0}
-
-#####
-
-## The following are all possible strings for the last argument of all those
-## diagnostics whose key ends in ".1"
-
-# 0: type, 1: list of type
-compiler.misc.no.unique.maximal.instance.exists=\
-    no unique maximal instance exists for type variable {0} with upper bounds {1}
-
-compiler.misc.no.unique.minimal.instance.exists=\
-    no unique minimal instance exists for type variable {0} with lower bounds {1}
-
-# 0: type, 1: list of type
-compiler.misc.incompatible.upper.bounds=\
-    inference variable {0} has incompatible upper bounds {1}
-
-# 0: type, 1: list of type, 2: list of type
-compiler.misc.incompatible.eq.upper.bounds=\
-    inference variable {0} has incompatible bounds\n\
-    equality constraints: {1}\n\
-    upper bounds: {2}
-
-# 0: type, 1: list of type, 2: list of type
-compiler.misc.incompatible.eq.lower.bounds=\
-    inference variable {0} has incompatible bounds\n\
-    equality constraints: {1}\n\
-    lower bounds: {2}
-
-# 0: list of type, 1: type, 2: type
-compiler.misc.infer.no.conforming.instance.exists=\
-    no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}
-
-# 0: list of type, 1: message segment
-compiler.misc.infer.no.conforming.assignment.exists=\
-    cannot infer type-variable(s) {0}\n\
-    (argument mismatch; {1})
-
-# 0: list of type
-compiler.misc.infer.arg.length.mismatch=\
-    cannot infer type-variable(s) {0}\n\
-    (actual and formal argument lists differ in length)
-
-# 0: list of type, 1: message segment
-compiler.misc.infer.varargs.argument.mismatch=\
-    cannot infer type-variable(s) {0}\n\
-    (varargs mismatch; {1})
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.upper.bounds=\
-    inferred type does not conform to upper bound(s)\n\
-    inferred: {0}\n\
-    upper bound(s): {1}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.lower.bounds=\
-    inferred type does not conform to lower bound(s)\n\
-    inferred: {0}\n\
-    lower bound(s): {1}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.eq.bounds=\
-    inferred type does not conform to equality constraint(s)\n\
-    inferred: {0}\n\
-    equality constraints(s): {1}
-
-# 0: symbol
-compiler.misc.diamond=\
-    {0}<>
-
-# 0: type
-compiler.misc.diamond.non.generic=\
-    cannot use ''<>'' with non-generic class {0}
-
-# 0: unused
-compiler.misc.diamond.and.explicit.params=\
-    cannot use ''<>'' with explicit type parameters for constructor
-
-# 0: unused
-compiler.misc.mref.infer.and.explicit.params=\
-    cannot use raw constructor reference with explicit type parameters for constructor
-
-# 0: type, 1: list of type
-compiler.misc.explicit.param.do.not.conform.to.bounds=\
-    explicit type argument {0} does not conform to declared bound(s) {1}
-
-compiler.misc.arg.length.mismatch=\
-    actual and formal argument lists differ in length
-
-# 0: message segment
-compiler.misc.no.conforming.assignment.exists=\
-    argument mismatch; {0}
-
-# 0: message segment
-compiler.misc.varargs.argument.mismatch=\
-    varargs mismatch; {0}
-
-#####
-
-# 0: symbol or type, 1: file name
-compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\
-    auxiliary class {0} in {1} should not be accessed from outside its own source file
-
-## The first argument ({0}) is a "kindname".
-# 0: symbol kind, 1: symbol, 2: symbol
-compiler.err.abstract.cant.be.accessed.directly=\
-    abstract {0} {1} in {2} cannot be accessed directly
-
-## The first argument ({0}) is a "kindname".
-# 0: symbol kind, 1: symbol
-compiler.err.non-static.cant.be.ref=\
-    non-static {0} {1} cannot be referenced from a static context
-
-# 0: symbol kind, 1: symbol
-compiler.misc.non-static.cant.be.ref=\
-    non-static {0} {1} cannot be referenced from a static context
-
-# 0: symbol kind, 1: symbol
-compiler.misc.static.method.in.unbound.lookup=\
-    static {0} {1} found in unbound lookup
-
-## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
-## of kindnames (the list should be identical to that provided in source.
-compiler.err.unexpected.type=\
-    unexpected type\n\
-    required: {0}\n\
-    found:    {1}
-
-compiler.err.unexpected.lambda=\
-   lambda expression not expected here
-
-compiler.err.unexpected.mref=\
-   method reference not expected here
-
-## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
-## The second argument {1} is the non-resolved symbol
-## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
-## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
-# 0: symbol kind, 1: name, 2: unused, 3: unused
-compiler.err.cant.resolve=\
-    cannot find symbol\n\
-    symbol: {0} {1}
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type
-compiler.err.cant.resolve.args=\
-    cannot find symbol\n\
-    symbol: {0} {1}({3})
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list of type
-compiler.err.cant.resolve.args.params=\
-    cannot find symbol\n\
-    symbol: {0} <{2}>{1}({3})
-
-## arguments from {0} to {3} have the same meaning as above
-## The fifth argument {4} is a location subdiagnostic (see below)
-# 0: symbol kind, 1: name, 2: unused, 3: unused, 4: message segment
-compiler.err.cant.resolve.location=\
-    cannot find symbol\n\
-    symbol:   {0} {1}\n\
-    location: {4}
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
-compiler.err.cant.resolve.location.args=\
-    cannot find symbol\n\
-    symbol:   {0} {1}({3})\n\
-    location: {4}
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
-compiler.err.cant.resolve.location.args.params=\
-    cannot find symbol\n\
-    symbol:   {0} <{2}>{1}({3})\n\
-    location: {4}
-
-### Following are replicated/used for method reference diagnostics
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
-compiler.misc.cant.resolve.location.args=\
-    cannot find symbol\n\
-    symbol:   {0} {1}({3})\n\
-    location: {4}
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
-compiler.misc.cant.resolve.location.args.params=\
-    cannot find symbol\n\
-    symbol:   {0} <{2}>{1}({3})\n\
-    location: {4}
-
-##a location subdiagnostic is composed as follows:
-## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
-## The second argument {1} is the location name
-## The third argument {2} is the location type (only when {1} is a variable name)
-
-# 0: symbol kind, 1: type or symbol, 2: unused
-compiler.misc.location=\
-    {0} {1}
-
-# 0: symbol kind, 1: symbol, 2: type
-compiler.misc.location.1=\
-    {0} {1} of type {2}
-
-## The following are all possible string for "kindname".
-## They should be called whatever the JLS calls them after it been translated
-## to the appropriate language.
-# compiler.misc.kindname.constructor=\
-#     static member
-compiler.misc.kindname.annotation=\
-    @interface
-
-compiler.misc.kindname.constructor=\
-    constructor
-
-compiler.misc.kindname.enum=\
-    enum
-
-compiler.misc.kindname.interface=\
-    interface
-
-compiler.misc.kindname.static=\
-    static
-
-compiler.misc.kindname.type.variable=\
-    type variable
-
-compiler.misc.kindname.type.variable.bound=\
-    bound of type variable
-
-compiler.misc.kindname.variable=\
-    variable
-
-compiler.misc.kindname.value=\
-    value
-
-compiler.misc.kindname.method=\
-    method
-
-compiler.misc.kindname.class=\
-    class
-
-compiler.misc.kindname.package=\
-    package
-
-compiler.misc.kindname.static.init=\
-    static initializer
-
-compiler.misc.kindname.instance.init=\
-    instance initializer
-
-#####
-
-compiler.misc.no.args=\
-    no arguments
-
-# 0: message segment
-compiler.err.override.static=\
-    {0}\n\
-    overriding method is static
-
-# 0: message segment, 1: set of modifier
-compiler.err.override.meth=\
-    {0}\n\
-    overridden method is {1}
-
-# 0: message segment, 1: type
-compiler.err.override.meth.doesnt.throw=\
-    {0}\n\
-    overridden method does not throw {1}
-
-# In the following string {1} is a space separated list of Java Keywords, as
-# they would have been declared in the source code
-# 0: message segment, 1: set of modifier
-compiler.err.override.weaker.access=\
-    {0}\n\
-    attempting to assign weaker access privileges; was {1}
-
-# 0: message segment, 1: type, 2: type
-compiler.err.override.incompatible.ret=\
-    {0}\n\
-    return type {1} is not compatible with {2}
-
-# 0: message segment, 1: type, 2: type
-compiler.warn.override.unchecked.ret=\
-    {0}\n\
-    return type requires unchecked conversion from {1} to {2}
-
-# 0: message segment, 1: type
-compiler.warn.override.unchecked.thrown=\
-    {0}\n\
-    overridden method does not throw {1}
-
-# 0: symbol
-compiler.warn.override.equals.but.not.hashcode=\
-    Class {0} overrides equals, but neither it nor any superclass overrides hashCode method
-
-## The following are all possible strings for the first argument ({0}) of the
-## above strings.
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.cant.override=\
-    {0} in {1} cannot override {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.cant.implement=\
-    {0} in {1} cannot implement {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.clashes.with=\
-    {0} in {1} clashes with {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.override=\
-    {0} in {1} overrides {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.implement=\
-    {0} in {1} implements {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.clash.with=\
-    {0} in {1} overrides {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.override=\
-    {0} in {1} overrides {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.implement=\
-    {0} in {1} implements {2} in {3}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.clash.with=\
-    {0} in {1} overrides {2} in {3}
-
-# 0: unused
-compiler.misc.diamond.and.anon.class=\
-    cannot use ''<>'' with anonymous inner classes
-
-# 0: symbol kind, 1: symbol, 2: symbol, 3: message segment
-compiler.misc.inapplicable.method=\
-    {0} {1}.{2} is not applicable\n\
-    ({3})
-
-########################################
-# Diagnostics for language feature changes
-########################################
-# 0: string
-compiler.err.unsupported.fp.lit=\
-    hexadecimal floating point literals are not supported in -source {0}\n\
-    (use -source 5 or higher to enable hexadecimal floating point literals)
-
-# 0: string
-compiler.err.unsupported.binary.lit=\
-    binary literals are not supported in -source {0}\n\
-    (use -source 7 or higher to enable binary literals)
-
-# 0: string
-compiler.err.unsupported.underscore.lit=\
-    underscores in literals are not supported in -source {0}\n\
-    (use -source 7 or higher to enable underscores in literals)
-
-# 0: string
-compiler.err.try.with.resources.not.supported.in.source=\
-    try-with-resources is not supported in -source {0}\n\
-    (use -source 7 or higher to enable try-with-resources)
-
-compiler.warn.enum.as.identifier=\
-    as of release 5, ''enum'' is a keyword, and may not be used as an identifier\n\
-    (use -source 5 or higher to use ''enum'' as a keyword)
-
-compiler.warn.assert.as.identifier=\
-    as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier\n\
-    (use -source 1.4 or higher to use ''assert'' as a keyword)
-
-compiler.warn.underscore.as.identifier=\
-    ''_'' used as an identifier\n\
-    (use of ''_'' as an identifier might not be supported in releases after Java SE 8)
-
-compiler.err.underscore.as.identifier.in.lambda=\
-    ''_'' used as an identifier\n\
-    (use of ''_'' as an identifier is forbidden for lambda parameters)
-
-compiler.err.enum.as.identifier=\
-    as of release 5, ''enum'' is a keyword, and may not be used as an identifier\n\
-    (use -source 1.4 or lower to use ''enum'' as an identifier)
-
-compiler.err.assert.as.identifier=\
-    as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier\n\
-    (use -source 1.3 or lower to use ''assert'' as an identifier)
-
-# TODO 308: make a better error message
-compiler.err.this.as.identifier=\
-    as of release 8, ''this'' is allowed as the parameter name for the receiver type only, which has to be the first parameter
-
-# 0: symbol
-compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=\
-    receiver parameter not applicable for constructor of top-level class
-
-# TODO 308: make a better error message
-# 0: symbol
-compiler.err.cant.type.annotate.scoping.1=\
-    scoping construct cannot be annotated with type-use annotation: {0}
-
-# TODO 308: make a better error message
-# 0: list of symbol
-compiler.err.cant.type.annotate.scoping=\
-    scoping construct cannot be annotated with type-use annotations: {0}
-
-# 0: type, 1: type
-compiler.err.incorrect.receiver.name=\
-    the receiver name does not match the enclosing class type\n\
-    required: {0}\n\
-    found: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.receiver.type=\
-    the receiver type does not match the enclosing class type\n\
-    required: {0}\n\
-    found: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.constructor.receiver.type=\
-    the receiver type does not match the enclosing outer class type\n\
-    required: {0}\n\
-    found: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.constructor.receiver.name=\
-    the receiver name does not match the enclosing outer class type\n\
-    required: {0}\n\
-    found: {1}
-
-compiler.err.no.annotations.on.dot.class=\
-    no annotations are allowed in the type of a class literal
-
-# 0: string
-compiler.err.generics.not.supported.in.source=\
-    generics are not supported in -source {0}\n\
-    (use -source 5 or higher to enable generics)
-
-# 0: string
-compiler.err.varargs.not.supported.in.source=\
-    variable-arity methods are not supported in -source {0}\n\
-    (use -source 5 or higher to enable variable-arity methods)
-
-# 0: string
-compiler.err.annotations.not.supported.in.source=\
-    annotations are not supported in -source {0}\n\
-    (use -source 5 or higher to enable annotations)
-
-# 0: string
-compiler.err.type.annotations.not.supported.in.source=\
-    type annotations are not supported in -source {0}\n\
-(use -source 8 or higher to enable type annotations)
-
-# 0: string
-compiler.err.annotations.after.type.params.not.supported.in.source=\
-    annotations after method type parameters are not supported in -source {0}\n\
-(use -source 8 or higher to enable annotations after method type parameters)
-
-# 0: string
-compiler.err.repeatable.annotations.not.supported.in.source=\
-    repeated annotations are not supported in -source {0}\n\
-(use -source 8 or higher to enable repeated annotations)
-
-# 0: string
-compiler.err.foreach.not.supported.in.source=\
-    enhanced for loops are not supported in -source {0}\n\
-    (use -source 5 or higher to enable for-each loops)
-
-# 0: string
-compiler.err.static.import.not.supported.in.source=\
-    static import declarations are not supported in -source {0}\n\
-    (use -source 5 or higher to enable static import declarations)
-
-# 0: string
-compiler.err.enums.not.supported.in.source=\
-    enums are not supported in -source {0}\n\
-    (use -source 5 or higher to enable enums)
-
-# 0: string
-compiler.err.diamond.not.supported.in.source=\
-    diamond operator is not supported in -source {0}\n\
-    (use -source 7 or higher to enable diamond operator)
-
-# 0: string
-compiler.err.multicatch.not.supported.in.source=\
-    multi-catch statement is not supported in -source {0}\n\
-    (use -source 7 or higher to enable multi-catch statement)
-
-# 0: string
-compiler.err.string.switch.not.supported.in.source=\
-    strings in switch are not supported in -source {0}\n\
-    (use -source 7 or higher to enable strings in switch)
-
-# 0: string
-compiler.err.lambda.not.supported.in.source=\
-    lambda expressions are not supported in -source {0}\n\
-    (use -source 8 or higher to enable lambda expressions)
-
-# 0: string
-compiler.err.method.references.not.supported.in.source=\
-    method references are not supported in -source {0}\n\
-    (use -source 8 or higher to enable method references)
-
-# 0: string
-compiler.err.default.methods.not.supported.in.source=\
-    default methods are not supported in -source {0}\n\
-    (use -source 8 or higher to enable default methods)
-
-# 0: string
-compiler.err.intersection.types.in.cast.not.supported.in.source=\
-    intersection types in cast are not supported in -source {0}\n\
-    (use -source 8 or higher to enable default methods)
-
-# 0: string
-compiler.err.static.intf.methods.not.supported.in.source=\
-    static interface methods are not supported in -source {0}\n\
-    (use -source 8 or higher to enable static interface methods)
-
-# 0: string
-compiler.err.static.intf.method.invoke.not.supported.in.source=\
-    static interface method invocations are not supported in -source {0}\n\
-    (use -source 8 or higher to enable static interface method invocations)
-
-########################################
-# Diagnostics for verbose resolution
-# used by Resolve (debug only)
-########################################
-
-# 0: number, 1: symbol, 2: unused
-compiler.misc.applicable.method.found=\
-    #{0} applicable method found: {1}
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.applicable.method.found.1=\
-    #{0} applicable method found: {1}\n\
-    ({2})
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.not.applicable.method.found=\
-    #{0} not applicable method found: {1}\n\
-    ({2})
-
-# 0: type
-compiler.misc.partial.inst.sig=\
-    partially instantiated to: {0}
-
-# 0: name, 1: symbol, 2: number, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi=\
-    resolving method {0} in type {1} to candidate {2}\n\
-    phase: {3}\n\
-    with actuals: {4}\n\
-    with type-args: {5}\n\
-    candidates:
-
-# 0: name, 1: symbol, 2: unused, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi.1=\
-    erroneous resolution for method {0} in type {1}\n\
-    phase: {3}\n\
-    with actuals: {4}\n\
-    with type-args: {5}\n\
-    candidates:
-
-# 0: symbol, 1: type, 2: type
-compiler.note.deferred.method.inst=\
-    Deferred instantiation of method {0}\n\
-    instantiated signature: {1}\n\
-    target-type: {2}
-
-########################################
-# Diagnostics for where clause implementation
-# used by the RichDiagnosticFormatter.
-########################################
-
-compiler.misc.type.null=\
-    <null>
-
-# X#n (where n is an int id) is disambiguated tvar name
-# 0: name, 1: number
-compiler.misc.type.var=\
-    {0}#{1}
-
-# CAP#n (where n is an int id) is an abbreviation for 'captured type'
-# 0: number
-compiler.misc.captured.type=\
-    CAP#{0}
-
-# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
-# 0: number
-compiler.misc.intersection.type=\
-    INT#{0}
-
-# where clause for captured type: contains upper ('extends {1}') and lower
-# ('super {2}') bound along with the wildcard that generated this captured type ({3})
-# 0: type, 1: type, 2: type, 3: type
-compiler.misc.where.captured=\
-    {0} extends {1} super: {2} from capture of {3}
-
-# compact where clause for captured type: contains upper ('extends {1}') along
-# with the wildcard that generated this captured type ({3})
-# 0: type, 1: type, 2: unused, 3: type
-compiler.misc.where.captured.1=\
-    {0} extends {1} from capture of {3}
-
-# where clause for type variable: contains upper bound(s) ('extends {1}') along with
-# the kindname ({2}) and location ({3}) in which the typevar has been declared
-# 0: type, 1: list of type, 2: symbol kind, 3: symbol
-compiler.misc.where.typevar=\
-    {0} extends {1} declared in {2} {3}
-
-# compact where clause for type variable: contains the kindname ({2}) and location ({3})
-# in which the typevar has been declared
-# 0: type, 1: list of type, 2: symbol kind, 3: symbol
-compiler.misc.where.typevar.1=\
-    {0} declared in {2} {3}
-
-# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
-# Since a fresh type-variable is synthetic - there's no location/kindname here.
-# 0: type, 1: list of type
-compiler.misc.where.fresh.typevar=\
-    {0} extends {1}
-
-# where clause for type variable: contains all the upper bound(s) ('extends {1}')
-# of this intersection type
-# 0: type, 1: list of type
-compiler.misc.where.intersection=\
-    {0} extends {1}
-
-### Where clause headers ###
-compiler.misc.where.description.captured=\
-    where {0} is a fresh type-variable:
-
-# 0: set of type
-compiler.misc.where.description.typevar=\
-    where {0} is a type-variable:
-
-# 0: set of type
-compiler.misc.where.description.intersection=\
-    where {0} is an intersection type:
-
-# 0: set of type
-compiler.misc.where.description.captured.1=\
-    where {0} are fresh type-variables:
-
-# 0: set of type
-compiler.misc.where.description.typevar.1=\
-    where {0} are type-variables:
-
-compiler.misc.where.description.intersection.1=\
-    where {0} are intersection types:
-
-###
-# errors related to doc comments
-
-compiler.err.dc.bad.entity=\
-    bad HTML entity
-
-compiler.err.dc.bad.gt=\
-    bad use of ''>''
-
-compiler.err.dc.bad.inline.tag=\
-    incorrect use of inline tag
-
-compiler.err.dc.identifier.expected=\
-    identifier expected
-
-compiler.err.dc.malformed.html=\
-    malformed HTML
-
-compiler.err.dc.missing.semicolon=\
-    semicolon missing
-
-compiler.err.dc.no.content=\
-    no content
-
-compiler.err.dc.no.tag.name=\
-    no tag name after '@'
-
-compiler.err.dc.gt.expected=\
-    ''>'' expected
-
-compiler.err.dc.ref.bad.parens=\
-    '')'' missing in reference
-
-compiler.err.dc.ref.syntax.error=\
-    syntax error in reference
-
-compiler.err.dc.ref.unexpected.input=\
-    unexpected text
-
-compiler.err.dc.unexpected.content=\
-    unexpected content
-
-compiler.err.dc.unterminated.inline.tag=\
-    unterminated inline tag
-
-compiler.err.dc.unterminated.signature=\
-    unterminated signature
-
-compiler.err.dc.unterminated.string=\
-    unterminated string
-
-
Index: Build/src/main/resources/com.sun.tools/javac/resources/javac_ja.properties
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/javac_ja.properties b/Build/src/main/resources/com.sun.tools/javac/resources/javac_ja.properties
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/javac_ja.properties	(date 0)
+++ /dev/null	(date 0)
@@ -1,147 +0,0 @@
-#
-# Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-## standard options
-
-javac.opt.g=\u3059\u3079\u3066\u306E\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u3092\u751F\u6210\u3059\u308B
-javac.opt.g.none=\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u3092\u751F\u6210\u3057\u306A\u3044
-javac.opt.g.lines.vars.source=\u3044\u304F\u3064\u304B\u306E\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u306E\u307F\u3092\u751F\u6210\u3059\u308B
-javac.opt.nowarn=\u8B66\u544A\u3092\u767A\u751F\u3055\u305B\u306A\u3044
-javac.opt.verbose=\u30B3\u30F3\u30D1\u30A4\u30E9\u306E\u52D5\u4F5C\u306B\u3064\u3044\u3066\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u51FA\u529B\u3059\u308B
-javac.opt.deprecation=\u975E\u63A8\u5968\u306EAPI\u304C\u4F7F\u7528\u3055\u308C\u3066\u3044\u308B\u30BD\u30FC\u30B9\u306E\u5834\u6240\u3092\u51FA\u529B\u3059\u308B
-javac.opt.classpath=\u30E6\u30FC\u30B6\u30FC\u30FB\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u304A\u3088\u3073\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u3092\u691C\u7D22\u3059\u308B\u4F4D\u7F6E\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.sourcepath=\u5165\u529B\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u691C\u7D22\u3059\u308B\u4F4D\u7F6E\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.bootclasspath=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D1\u30B9\u306E\u5834\u6240\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
-javac.opt.Xbootclasspath.p=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D1\u30B9\u306B\u4ED8\u52A0\u3059\u308B
-javac.opt.Xbootclasspath.a=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D1\u30B9\u306B\u8FFD\u52A0\u3059\u308B
-javac.opt.endorseddirs=\u63A8\u5968\u898F\u683C\u30D1\u30B9\u306E\u5834\u6240\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
-javac.opt.extdirs=\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u6E08\u62E1\u5F35\u6A5F\u80FD\u306E\u5834\u6240\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
-javac.opt.processorpath=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u3092\u691C\u7D22\u3059\u308B\u4F4D\u7F6E\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.processor=\u5B9F\u884C\u3059\u308B\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u306E\u540D\u524D\u3002\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u691C\u51FA\u51E6\u7406\u3092\u30D0\u30A4\u30D1\u30B9
-javac.opt.parameters=\u30E1\u30BD\u30C3\u30C9\u30FB\u30D1\u30E9\u30E1\u30FC\u30BF\u306B\u30EA\u30D5\u30EC\u30AF\u30B7\u30E7\u30F3\u7528\u306E\u30E1\u30BF\u30C7\u30FC\u30BF\u3092\u751F\u6210\u3057\u307E\u3059
-javac.opt.proc.none.only=\u6CE8\u91C8\u51E6\u7406\u3084\u30B3\u30F3\u30D1\u30A4\u30EB\u3092\u5B9F\u884C\u3059\u308B\u304B\u3069\u3046\u304B\u3092\u5236\u5FA1\u3057\u307E\u3059\u3002
-javac.opt.d=\u751F\u6210\u3055\u308C\u305F\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u683C\u7D0D\u3059\u308B\u4F4D\u7F6E\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.sourceDest=\u751F\u6210\u3055\u308C\u305F\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u683C\u7D0D\u3059\u308B\u5834\u6240\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.headerDest=\u751F\u6210\u3055\u308C\u305F\u30CD\u30A4\u30C6\u30A3\u30D6\u30FB\u30D8\u30C3\u30C0\u30FC\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u683C\u7D0D\u3059\u308B\u5834\u6240\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.J=<flag>\u3092\u5B9F\u884C\u30B7\u30B9\u30C6\u30E0\u306B\u76F4\u63A5\u6E21\u3059
-javac.opt.encoding=\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u304C\u4F7F\u7528\u3059\u308B\u6587\u5B57\u30A8\u30F3\u30B3\u30FC\u30C7\u30A3\u30F3\u30B0\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.profile=\u4F7F\u7528\u3055\u308C\u3066\u3044\u308BAPI\u304C\u6307\u5B9A\u3057\u305F\u30D7\u30ED\u30D5\u30A1\u30A4\u30EB\u3067\u4F7F\u7528\u53EF\u80FD\u304B\u3069\u3046\u304B\u3092\u78BA\u8A8D\u3057\u307E\u3059
-javac.opt.target=\u7279\u5B9A\u306EVM\u30D0\u30FC\u30B8\u30E7\u30F3\u7528\u306E\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u751F\u6210\u3059\u308B
-javac.opt.source=\u6307\u5B9A\u3055\u308C\u305F\u30EA\u30EA\u30FC\u30B9\u3068\u30BD\u30FC\u30B9\u306E\u4E92\u63DB\u6027\u3092\u4FDD\u3064
-javac.opt.Werror=\u8B66\u544A\u304C\u767A\u751F\u3057\u305F\u5834\u5408\u306B\u30B3\u30F3\u30D1\u30A4\u30EB\u3092\u7D42\u4E86\u3059\u308B
-javac.opt.A=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u306B\u6E21\u3055\u308C\u308B\u30AA\u30D7\u30B7\u30E7\u30F3
-javac.opt.implicit=\u6697\u9ED9\u7684\u306B\u53C2\u7167\u3055\u308C\u308B\u30D5\u30A1\u30A4\u30EB\u306B\u3064\u3044\u3066\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u751F\u6210\u3059\u308B\u304B\u3069\u3046\u304B\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.pkginfo=package-info\u30D5\u30A1\u30A4\u30EB\u306E\u51E6\u7406\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.arg.class=<class>
-javac.opt.arg.class.list=<class1>[,<class2>,<class3>...]
-javac.opt.arg.flag=<flag>
-javac.opt.arg.key.equals.value=key[=value]
-javac.opt.arg.path=<path>
-javac.opt.arg.dirs=<dirs>
-javac.opt.arg.directory=<directory>
-javac.opt.arg.encoding=<encoding>
-javac.opt.arg.profile=<profile>
-javac.opt.arg.release=<release>
-javac.opt.arg.number=<number>
-javac.opt.plugin=\u5B9F\u884C\u3055\u308C\u308B\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u540D\u524D\u3068\u30AA\u30D7\u30B7\u30E7\u30F3\u5F15\u6570
-javac.opt.arg.plugin="name args"
-
-## extended options
-
-javac.opt.maxerrs=\u51FA\u529B\u3059\u308B\u30A8\u30E9\u30FC\u306E\u6700\u5927\u6570\u3092\u8A2D\u5B9A\u3059\u308B
-javac.opt.maxwarns=\u51FA\u529B\u3059\u308B\u8B66\u544A\u306E\u6700\u5927\u6570\u3092\u8A2D\u5B9A\u3059\u308B
-javac.opt.nogj=\u8A00\u8A9E\u306E\u6C4E\u7528\u6027\u3092\u53D7\u3051\u4ED8\u3051\u306A\u3044
-javac.opt.moreinfo=\u578B\u5909\u6570\u306E\u62E1\u5F35\u60C5\u5831\u3092\u51FA\u529B\u3059\u308B
-javac.opt.printflat=\u5185\u90E8\u30AF\u30E9\u30B9\u306E\u5909\u63DB\u5F8C\u306B\u62BD\u8C61\u69CB\u6587\u30C4\u30EA\u30FC\u3092\u51FA\u529B\u3059\u308B
-javac.opt.printsearch=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u691C\u7D22\u4F4D\u7F6E\u60C5\u5831\u3092\u51FA\u529B\u3059\u308B
-javac.opt.prompt=\u5404\u30A8\u30E9\u30FC\u3067\u505C\u6B62\u3059\u308B
-javac.opt.retrofit=\u65E2\u5B58\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u6C4E\u7528\u578B\u3067\u7D44\u307F\u66FF\u3048\u308B
-javac.opt.s=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u304B\u308F\u308A\u306Bjava\u30BD\u30FC\u30B9\u3092\u767A\u884C\u3059\u308B
-javac.opt.scramble=\u30D0\u30A4\u30C8\u30B3\u30FC\u30C9\u306Eprivate\u8B58\u5225\u5B50\u306B\u30B9\u30AF\u30E9\u30F3\u30D6\u30EB\u3092\u304B\u3051\u308B
-javac.opt.scrambleall=\u30D0\u30A4\u30C8\u30B3\u30FC\u30C9\u306Epackage\u53EF\u8996\u8B58\u5225\u5B50\u306B\u30B9\u30AF\u30E9\u30F3\u30D6\u30EB\u3092\u304B\u3051\u308B
-javac.opt.version=\u30D0\u30FC\u30B8\u30E7\u30F3\u60C5\u5831
-javac.opt.arg.pathname=<pathname>
-javac.opt.arg.file=<filename>
-javac.opt.Xlint=\u63A8\u5968\u306E\u8B66\u544A\u3092\u6709\u52B9\u306B\u3059\u308B
-javac.opt.Xlint.suboptlist=\u7279\u5B9A\u306E\u8B66\u544A\u3092\u6709\u52B9\u307E\u305F\u306F\u7121\u52B9\u306B\u3059\u308B
-javac.opt.Xdoclint=javadoc\u30B3\u30E1\u30F3\u30C8\u306E\u554F\u984C\u306B\u95A2\u3059\u308B\u63A8\u5968\u30C1\u30A7\u30C3\u30AF\u3092\u6709\u52B9\u306B\u3059\u308B
-# L10N: do not localize: all none
-javac.opt.Xdoclint.subopts = (all|none|[-]<group>)[/<access>]
-
-# L10N: do not localize: accessibility html missing reference syntax
-# L10N: do not localize: public protected package private
-javac.opt.Xdoclint.custom=\n        javadoc\u30B3\u30E1\u30F3\u30C8\u306E\u554F\u984C\u306B\u95A2\u3059\u308B\u7279\u5B9A\u306E\u30C1\u30A7\u30C3\u30AF\u3092\u6709\u52B9\u307E\u305F\u306F\u7121\u52B9\u306B\u3057\u307E\u3059\u3002\n        \u3053\u3053\u3067\u3001<group>\u306Faccessibility\u3001html\u3001missing\u3001reference\u307E\u305F\u306Fsyntax\u306E\u3044\u305A\u308C\u304B\u3067\u3001\n        <access>\u306Fpublic\u3001protected\u3001package\u307E\u305F\u306Fprivate\u306E\u3044\u305A\u308C\u304B\u3067\u3059\u3002
-javac.opt.Xstdout=\u6A19\u6E96\u51FA\u529B\u3092\u30EA\u30C0\u30A4\u30EC\u30AF\u30C8\u3059\u308B
-javac.opt.X=\u975E\u6A19\u6E96\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u6982\u8981\u3092\u51FA\u529B\u3059\u308B
-javac.opt.help=\u6A19\u6E96\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u6982\u8981\u3092\u51FA\u529B\u3059\u308B
-javac.opt.print=\u6307\u5B9A\u3057\u305F\u578B\u306E\u30C6\u30AD\u30B9\u30C8\u8868\u793A\u3092\u51FA\u529B\u3059\u308B
-javac.opt.printRounds=\u6CE8\u91C8\u51E6\u7406\u306E\u5F80\u5FA9\u306B\u3064\u3044\u3066\u306E\u60C5\u5831\u3092\u5370\u5237\u3059\u308B
-javac.opt.printProcessorInfo=\u30D7\u30ED\u30BB\u30C3\u30B5\u304C\u51E6\u7406\u3092\u4F9D\u983C\u3055\u308C\u308B\u6CE8\u91C8\u306B\u3064\u3044\u3066\u306E\u60C5\u5831\u3092\u5370\u5237\u3059\u308B
-javac.opt.prefer=\u6697\u9ED9\u7684\u306B\u30B3\u30F3\u30D1\u30A4\u30EB\u3055\u308C\u308B\u30AF\u30E9\u30B9\u306B\u3064\u3044\u3066\u3001\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3068\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u4E21\u65B9\u304C\u898B\u3064\u304B\u3063\u305F\u969B\u3069\u3061\u3089\u3092\u8AAD\u307F\u8FBC\u3080\u304B\u6307\u5B9A\u3059\u308B
-javac.opt.AT=\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u306E\u8AAD\u53D6\u308A\u30AA\u30D7\u30B7\u30E7\u30F3\u304A\u3088\u3073\u30D5\u30A1\u30A4\u30EB\u540D
-javac.opt.diags=\u8A3A\u65AD\u30E2\u30FC\u30C9\u306E\u9078\u629E
-
-## errors
-
-javac.err.empty.A.argument=-A\u306B\u306F\u5F15\u6570\u304C\u5FC5\u8981\u3067\u3059\u3002''-Akey''\u307E\u305F\u306F''-Akey=value''\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044
-javac.err.invalid.arg={0}\u306F\u7121\u52B9\u306A\u5F15\u6570\u3067\u3059
-javac.err.invalid.A.key=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u30FB\u30AA\u30D7\u30B7\u30E7\u30F3''{0}''\u306E\u30AD\u30FC\u306B\u6307\u5B9A\u3055\u308C\u3066\u3044\u308B\u4E00\u9023\u306E\u8B58\u5225\u5B50\u304C\u3001\u30C9\u30C3\u30C8\u3067\u533A\u5207\u3089\u308C\u3066\u3044\u307E\u305B\u3093
-javac.err.invalid.flag={0}\u306F\u7121\u52B9\u306A\u30D5\u30E9\u30B0\u3067\u3059
-javac.err.profile.bootclasspath.conflict=profile\u3068bootclasspath\u30AA\u30D7\u30B7\u30E7\u30F3\u306F\u540C\u6642\u306B\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-javac.err.invalid.profile=\u7121\u52B9\u306A\u30D7\u30ED\u30D5\u30A1\u30A4\u30EB: {0}
-javac.err.invalid.target={0}\u306F\u7121\u52B9\u306A\u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30EA\u30EA\u30FC\u30B9\u3067\u3059
-javac.err.no.source.files=\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u304C\u3042\u308A\u307E\u305B\u3093
-javac.err.no.source.files.classes=\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u307E\u305F\u306F\u30AF\u30E9\u30B9\u540D\u304C\u3042\u308A\u307E\u305B\u3093
-javac.err.req.arg={0}\u306B\u306F\u5F15\u6570\u304C\u5FC5\u8981\u3067\u3059
-javac.err.invalid.source={0}\u306F\u7121\u52B9\u306A\u30BD\u30FC\u30B9\u30FB\u30EA\u30EA\u30FC\u30B9\u3067\u3059
-javac.err.error.writing.file={0}\u306E\u66F8\u8FBC\u307F\u30A8\u30E9\u30FC\u3067\u3059\u3002{1}
-javac.warn.source.target.conflict=\u30BD\u30FC\u30B9\u30FB\u30EA\u30EA\u30FC\u30B9{0}\u306B\u306F\u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30EA\u30EA\u30FC\u30B9{1}\u304C\u5FC5\u8981\u3067\u3059
-javac.warn.target.default.source.conflict=\u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30EA\u30EA\u30FC\u30B9{0}\u304C\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30BD\u30FC\u30B9\u30FB\u30EA\u30EA\u30FC\u30B9{1}\u3068\u7AF6\u5408\u3057\u3066\u3044\u307E\u3059
-javac.warn.profile.target.conflict=\u30D7\u30ED\u30D5\u30A1\u30A4\u30EB{0}\u306F\u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30EA\u30EA\u30FC\u30B9{1}\u306B\u5BFE\u3057\u3066\u6709\u52B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-javac.err.dir.not.found=\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u304C\u3042\u308A\u307E\u305B\u3093: {0}
-javac.err.file.not.found=\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {0}
-javac.err.file.not.directory=\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u3067\u306F\u3042\u308A\u307E\u305B\u3093: {0}
-javac.err.file.not.file=\u30D5\u30A1\u30A4\u30EB\u3067\u306F\u3042\u308A\u307E\u305B\u3093: {0}
-javac.msg.plugin.not.found=\u30D7\u30E9\u30B0\u30A4\u30F3\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {0}
-## messages
-
-javac.msg.usage.header=\u4F7F\u7528\u65B9\u6CD5: {0} <options> <source files>\n\u4F7F\u7528\u53EF\u80FD\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u306B\u306F\u6B21\u306E\u3082\u306E\u304C\u3042\u308A\u307E\u3059\u3002
-
-javac.msg.usage=\u4F7F\u7528\u65B9\u6CD5: {0} <options> <source files>\n\u4F7F\u7528\u53EF\u80FD\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u30EA\u30B9\u30C8\u306B\u3064\u3044\u3066\u306F\u3001-help\u3092\u4F7F\u7528\u3057\u307E\u3059
-
-javac.msg.usage.nonstandard.footer=\u3053\u308C\u3089\u306F\u975E\u6A19\u6E96\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3042\u308A\u4E88\u544A\u306A\u3057\u306B\u5909\u66F4\u3055\u308C\u308B\u3053\u3068\u304C\u3042\u308A\u307E\u3059\u3002
-
-javac.msg.bug=\u30B3\u30F3\u30D1\u30A4\u30E9\u3067\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F({0})\u3002\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u3067\u91CD\u8907\u304C\u306A\u3044\u304B\u3092\u3054\u78BA\u8A8D\u306E\u3046\u3048\u3001Java Bug Database (http://bugreport.java.com/bugreport/)\u3067bug\u306E\u767B\u9332\u3092\u304A\u9858\u3044\u3044\u305F\u3057\u307E\u3059\u3002\u30EC\u30DD\u30FC\u30C8\u306B\u306F\u3001\u305D\u306E\u30D7\u30ED\u30B0\u30E9\u30E0\u3068\u4E0B\u8A18\u306E\u8A3A\u65AD\u5185\u5BB9\u3092\u542B\u3081\u3066\u304F\u3060\u3055\u3044\u3002\u3054\u5354\u529B\u3042\u308A\u304C\u3068\u3046\u3054\u3056\u3044\u307E\u3059\u3002
-
-javac.msg.io=\n\n\u5165\u51FA\u529B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\n\u8A73\u7D30\u306F\u6B21\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30C8\u30EC\u30FC\u30B9\u3067\u8ABF\u67FB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n
-
-javac.msg.proc.annotation.uncaught.exception=\n\n\u6CE8\u91C8\u51E6\u7406\u3067\u6355\u6349\u3055\u308C\u306A\u3044\u4F8B\u5916\u304C\u30B9\u30ED\u30FC\u3055\u308C\u307E\u3057\u305F\u3002\n\u8A73\u7D30\u306F\u6B21\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30C8\u30EC\u30FC\u30B9\u3067\u8ABF\u67FB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n
-
-javac.msg.plugin.uncaught.exception=\n\n\u30D7\u30E9\u30B0\u30A4\u30F3\u3067\u6355\u6349\u3055\u308C\u306A\u3044\u4F8B\u5916\u304C\u30B9\u30ED\u30FC\u3055\u308C\u307E\u3057\u305F\u3002\n\u8A73\u7D30\u306F\u6B21\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30C8\u30EC\u30FC\u30B9\u3067\u8ABF\u67FB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n
-
-javac.msg.resource=\n\n\u30B7\u30B9\u30C6\u30E0\u30FB\u30EA\u30BD\u30FC\u30B9\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059\u3002\n\u8A73\u7D30\u306F\u6B21\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30C8\u30EC\u30FC\u30B9\u3067\u8ABF\u67FB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n
-
-javac.version={0} {1}
-javac.fullVersion={0}\u30D5\u30EB\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3"{1}"
Index: Build/src/main/resources/com.sun.tools/javac/resources/compiler_ja.properties
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/compiler_ja.properties b/Build/src/main/resources/com.sun.tools/javac/resources/compiler_ja.properties
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/compiler_ja.properties	(date 0)
+++ /dev/null	(date 0)
@@ -1,1810 +0,0 @@
-#
-# Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
-# are preceded by a stylized comment describing the type of the corresponding
-# values.
-# The types currently in use are
-#
-# boolean           true or false
-# file name         the name of an input file; e.g.   MyFile.java
-# message segment   a sub-message; see compiler.misc.*
-# modifier          a Java modifier; e.g. public, private, protected
-# name              a name, typically a Java identifier
-# number            an integer
-# option name       the name of a command line option
-# source version    a source version number, such as 1.5, 1.6, 1.7
-# string            a general string
-# symbol            the name of a declared type
-# symbol kind       a description of the kind of a declaration; see compiler.misc.kindname.*
-# token             the name of a non-terminal in source code; see compiler.misc.token.*
-# type              a Java type; e.g. int, X, X<T>
-# unused            the value is not used in this message
-#
-# list of X         a comma-separated list of items; e.g. list of type
-# X or Y            alternation; e.g. message segment or type
-# set of X          a comma-separated collection of items; e.g. set of modifier
-#
-# These may be composed: e.g.   list of type or message segment
-#
-# These comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
-# using info derived from the collected set of examples in test/tools/javac/diags/examples.
-# MessageInfo can also be run as a standalone utility providing more facilities
-# for manipulating this file. For more details, see MessageInfo.java.
-
-##
-## errors
-##
-
-# 0: symbol
-compiler.err.abstract.cant.be.instantiated={0}\u306Fabstract\u3067\u3059\u3002\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u751F\u6210\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.abstract.meth.cant.have.body=abstract\u30E1\u30BD\u30C3\u30C9\u304C\u672C\u4F53\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.already.annotated={0} {1}\u306F\u6CE8\u91C8\u304C\u4ED8\u3044\u3066\u3044\u307E\u3059
-
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol
-compiler.err.already.defined={0} {1}\u306F\u3059\u3067\u306B{2} {3}\u3067\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol kind, 4: symbol
-compiler.err.already.defined.in.clinit={0} {1}\u306F\u3059\u3067\u306B{3} {4}\u306E{2}\u3067\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: string
-compiler.err.already.defined.single.import=\u540C\u3058\u5358\u7D14\u540D\u306E\u578B\u304C{0}\u306E\u5358\u4E00\u578B\u30A4\u30F3\u30DD\u30FC\u30C8\u306B\u3088\u3063\u3066\u3059\u3067\u306B\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: string
-compiler.err.already.defined.static.single.import=\u540C\u3058\u5358\u7D14\u540D\u306E\u578B\u304C{0}\u306Estatic\u5358\u4E00\u578B\u30A4\u30F3\u30DD\u30FC\u30C8\u306B\u3088\u3063\u3066\u3059\u3067\u306B\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.already.defined.this.unit={0}\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u5358\u4F4D\u3067\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: type, 1: list of name
-compiler.err.annotation.missing.default.value=\u6CE8\u91C8@{0}\u306B\u306F\u8981\u7D20''{1}''\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: type, 1: list of name
-compiler.err.annotation.missing.default.value.1=\u6CE8\u91C8@{0}\u306B\u306F\u8981\u7D20{1}\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: type
-compiler.err.annotation.not.valid.for.type=\u6CE8\u91C8\u306F\u578B{0}\u306E\u8981\u7D20\u306B\u5BFE\u3057\u3066\u6709\u52B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.annotation.type.not.applicable=\u6CE8\u91C8\u578B\u306F\u3053\u306E\u7A2E\u985E\u306E\u5BA3\u8A00\u306B\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.annotation.value.must.be.annotation=\u6CE8\u91C8\u306E\u5024\u306F\u6CE8\u91C8\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.annotation.value.must.be.class.literal=\u6CE8\u91C8\u306E\u5024\u306F\u30AF\u30E9\u30B9\u30FB\u30EA\u30C6\u30E9\u30EB\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.annotation.value.must.be.name.value=\u6CE8\u91C8\u306E\u5024\u306F''name=value''\u3068\u3044\u3046\u5F62\u5F0F\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.annotation.value.not.allowable.type=\u4F7F\u7528\u3067\u304D\u306A\u3044\u578B\u306E\u6CE8\u91C8\u306E\u5024\u3067\u3059
-
-compiler.err.anon.class.impl.intf.no.args=\u533F\u540D\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002\u5F15\u6570\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.anon.class.impl.intf.no.typeargs=\u533F\u540D\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002\u578B\u5F15\u6570\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.anon.class.impl.intf.no.qual.for.new=\u533F\u540D\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002new\u306B\u4FEE\u98FE\u5B50\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002
-
-compiler.err.cant.inherit.from.anon=\u533F\u540D\u30AF\u30E9\u30B9\u304B\u3089\u7D99\u627F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol, 2: symbol
-compiler.err.array.and.varargs={2}\u3067{0}\u3068{1}\u306E\u4E21\u65B9\u3092\u5BA3\u8A00\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.array.dimension.missing=\u914D\u5217\u306E\u5927\u304D\u3055\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: type
-compiler.err.array.req.but.found=\u914D\u5217\u304C\u8981\u6C42\u3055\u308C\u307E\u3057\u305F\u304C\u3001{0}\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F
-
-compiler.err.attribute.value.must.be.constant=\u8981\u7D20\u5024\u306F\u5B9A\u6570\u5F0F\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: statement type
-compiler.err.bad.initializer={0}\u306E\u4E0D\u6B63\u306A\u521D\u671F\u5316\u5B50
-
-compiler.err.break.outside.switch.loop=break\u304Cswitch\u6587\u307E\u305F\u306F\u30EB\u30FC\u30D7\u306E\u5916\u306B\u3042\u308A\u307E\u3059
-
-# 0: name
-compiler.err.call.must.be.first.stmt.in.ctor={0}\u306E\u547C\u51FA\u3057\u306F\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u5148\u982D\u6587\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
-compiler.err.cant.apply.symbol={4} {5}\u306E{0} {1}\u306F\u6307\u5B9A\u3055\u308C\u305F\u578B\u306B\u9069\u7528\u3067\u304D\u307E\u305B\u3093\u3002\n\u671F\u5F85\u5024: {2}\n\u691C\u51FA\u5024: {3}\n\u7406\u7531: {6}
-
-# 0: symbol kind, 1: name, 2: list of type
-compiler.err.cant.apply.symbols={1}\u306B\u9069\u5207\u306A{0}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093({2})
-
-# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
-compiler.misc.cant.apply.symbol={4} {5}\u306E{0} {1}\u306F\u6307\u5B9A\u3055\u308C\u305F\u578B\u306B\u9069\u7528\u3067\u304D\u307E\u305B\u3093\n\u671F\u5F85\u5024: {2}\n\u691C\u51FA\u5024: {3}\n\u7406\u7531: {6}
-
-# 0: symbol kind, 1: name, 2: list of type
-compiler.misc.cant.apply.symbols={1}\u306B\u9069\u5207\u306A{0}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093({2})
-
-# 0: symbol kind, 1: symbol
-compiler.misc.no.abstracts={0} {1}\u3067\u62BD\u8C61\u30E1\u30BD\u30C3\u30C9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093
-
-# 0: symbol kind, 1: symbol
-compiler.misc.incompatible.abstracts={0} {1}\u3067\u8907\u6570\u306E\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u306A\u3044\u62BD\u8C61\u30E1\u30BD\u30C3\u30C9\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F
-
-compiler.err.bad.functional.intf.anno=\u4E88\u671F\u3057\u306A\u3044@FunctionalInterface\u6CE8\u91C8
-
-# 0: message segment
-compiler.err.bad.functional.intf.anno.1=\u4E88\u671F\u3057\u306A\u3044@FunctionalInterface\u6CE8\u91C8\n{0}
-
-# 0: symbol
-compiler.misc.not.a.functional.intf={0}\u306F\u6A5F\u80FD\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-# 0: symbol, 1: message segment
-compiler.misc.not.a.functional.intf.1={0}\u306F\u6A5F\u80FD\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093\n{1}
-
-# 0: symbol, 1: symbol kind, 2: symbol
-compiler.misc.invalid.generic.lambda.target=\u30E9\u30E0\u30C0\u5F0F\u306E\u6A5F\u80FD\u30C7\u30A3\u30B9\u30AF\u30EA\u30D7\u30BF\u304C\u7121\u52B9\u3067\u3059\n{1} {2}\u306E\u30E1\u30BD\u30C3\u30C9{0}\u306F\u6C4E\u7528\u3067\u3059
-
-# 0: symbol kind, 1: symbol
-compiler.misc.incompatible.descs.in.functional.intf={0} {1}\u3067\u4E0D\u9069\u5408\u306A\u6A5F\u80FD\u30C7\u30A3\u30B9\u30AF\u30EA\u30D7\u30BF\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F
-
-# 0: name, 1: list of type, 2: type, 3: list of type
-compiler.misc.descriptor=\u30C7\u30A3\u30B9\u30AF\u30EA\u30D7\u30BF: {2} {0}({1})
-
-# 0: name, 1: list of type, 2: type, 3: list of type
-compiler.misc.descriptor.throws=\u30C7\u30A3\u30B9\u30AF\u30EA\u30D7\u30BF: {2} {0}({1})\u3067{3}\u304C\u30B9\u30ED\u30FC\u3055\u308C\u307E\u3059
-
-# 0: type
-compiler.misc.no.suitable.functional.intf.inst={0}\u306E\u6A5F\u80FD\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u30FB\u30C7\u30A3\u30B9\u30AF\u30EA\u30D7\u30BF\u3092\u63A8\u8AD6\u3067\u304D\u307E\u305B\u3093
-
-# 0: message segment
-compiler.misc.bad.intersection.target.for.functional.expr=\u30E9\u30E0\u30C0\u307E\u305F\u306F\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u306E\u4EA4\u5DEE\u30BF\u30A4\u30D7\u30FB\u30BF\u30FC\u30B2\u30C3\u30C8\u304C\u4E0D\u6B63\u3067\u3059\n{0}
-
-# 0: symbol or type
-compiler.misc.not.an.intf.component=\u30B3\u30F3\u30DD\u30FC\u30CD\u30F3\u30C8\u30FB\u30BF\u30A4\u30D7{0}\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-# 0: symbol kind, 1: message segment
-compiler.err.invalid.mref={0}\u53C2\u7167\u304C\u7121\u52B9\u3067\u3059\n{1}
-
-# 0: symbol kind, 1: message segment
-compiler.misc.invalid.mref={0}\u53C2\u7167\u304C\u7121\u52B9\u3067\u3059\n{1}
-
-compiler.misc.static.mref.with.targs=static\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u306E\u30D1\u30E9\u30E1\u30FC\u30BF\u5316\u3055\u308C\u305F\u4FEE\u98FE\u5B50
-
-compiler.misc.static.bound.mref=static\u306E\u30D0\u30A4\u30F3\u30C7\u30A3\u30F3\u30B0\u3055\u308C\u305F\u30E1\u30BD\u30C3\u30C9\u53C2\u7167
-
-# 0: symbol
-compiler.err.cant.assign.val.to.final.var=final\u5909\u6570{0}\u306B\u5024\u3092\u4EE3\u5165\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: message segment
-compiler.err.cant.ref.non.effectively.final.var={1}\u304B\u3089\u53C2\u7167\u3055\u308C\u308B\u30ED\u30FC\u30AB\u30EB\u5909\u6570\u306F\u3001final\u307E\u305F\u306F\u4E8B\u5B9F\u4E0A\u306Efinal\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-
-compiler.misc.lambda=\u30E9\u30E0\u30C0\u5F0F
-
-compiler.misc.inner.cls=\u5185\u90E8\u30AF\u30E9\u30B9
-
-# 0: type
-compiler.err.cant.deref={0}\u306F\u9593\u63A5\u53C2\u7167\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.cant.extend.intf.annotation=@interfaces\u3067\u306F''extends''\u306F\u8A31\u53EF\u3055\u308C\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.cant.inherit.from.final=final {0}\u304B\u3089\u306F\u7D99\u627F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.cant.ref.before.ctor.called=\u30B9\u30FC\u30D1\u30FC\u30BF\u30A4\u30D7\u306E\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u547C\u51FA\u3057\u524D\u306F{0}\u3092\u53C2\u7167\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.cant.select.static.class.from.param.type=\u30D1\u30E9\u30E1\u30FC\u30BF\u306B\u3055\u308C\u305F\u578B\u304B\u3089static\u30AF\u30E9\u30B9\u3092\u9078\u629E\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: string, 2: string
-compiler.err.cant.inherit.diff.arg={0}\u3092\u7570\u306A\u308B\u5F15\u6570<{1}>\u3068<{2}>\u3067\u7D99\u627F\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.catch.without.try=''catch''\u3078\u306E''try''\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: symbol kind, 1: symbol
-compiler.err.clash.with.pkg.of.same.name={0} {1}\u306F\u540C\u540D\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u3068\u7AF6\u5408\u3057\u307E\u3059
-
-compiler.err.class.not.allowed=\u30AF\u30E9\u30B9\u3001\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u307E\u305F\u306F\u5217\u6319\u578B\u306E\u5BA3\u8A00\u3092\u3053\u3053\u3067\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.const.expr.req=\u5B9A\u6570\u5F0F\u304C\u5FC5\u8981\u3067\u3059
-
-compiler.err.cont.outside.loop=continue\u304C\u30EB\u30FC\u30D7\u306E\u5916\u306B\u3042\u308A\u307E\u3059
-
-# 0: symbol
-compiler.err.cyclic.inheritance={0}\u3092\u542B\u3080\u7D99\u627F\u304C\u30EB\u30FC\u30D7\u3057\u3066\u3044\u307E\u3059
-
-# 0: symbol
-compiler.err.cyclic.annotation.element=\u8981\u7D20{0}\u306E\u578B\u304C\u30EB\u30FC\u30D7\u3057\u3066\u3044\u307E\u3059
-
-# 0: unused
-compiler.err.call.to.super.not.allowed.in.enum.ctor=\u5217\u6319\u578B\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u3067\u306F\u3001\u30B9\u30FC\u30D1\u30FC\u30AF\u30E9\u30B9\u306E\u547C\u51FA\u3057\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: type
-compiler.err.no.superclass={0}\u306B\u306F\u30B9\u30FC\u30D1\u30FC\u30AF\u30E9\u30B9\u304C\u3042\u308A\u307E\u305B\u3093\u3002
-
-# 0: symbol, 1: type, 2: symbol, 3: type, 4: unused
-compiler.err.concrete.inheritance.conflict={1}\u306E\u30E1\u30BD\u30C3\u30C9{0}\u3068{3}\u306E{2}\u306F\u540C\u3058\u30B7\u30B0\u30CD\u30C1\u30E3\u304B\u3089\u7D99\u627F\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.default.allowed.in.intf.annotation.member=\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u306F\u6CE8\u91C8\u578B\u306E\u5BA3\u8A00\u3067\u306E\u307F\u4F7F\u7528\u3067\u304D\u307E\u3059
-
-# 0: symbol
-compiler.err.doesnt.exist=\u30D1\u30C3\u30B1\u30FC\u30B8{0}\u306F\u5B58\u5728\u3057\u307E\u305B\u3093
-
-# 0: type
-compiler.err.duplicate.annotation.invalid.repeated=\u6CE8\u91C8{0}\u306F\u6709\u52B9\u306A\u7E70\u8FD4\u3057\u53EF\u80FD\u306A\u6CE8\u91C8\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-# 0: name, 1: type
-compiler.err.duplicate.annotation.member.value=\u6CE8\u91C8@{1}\u306B\u91CD\u8907\u3057\u305F\u8981\u7D20''{0}''\u304C\u3042\u308A\u307E\u3059\u3002
-
-# 0: name, 1: unused
-compiler.err.duplicate.annotation.missing.container={0}\u306F\u7E70\u8FD4\u3057\u53EF\u80FD\u306A\u6CE8\u91C8\u578B\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-# 0: type, 1: unused
-compiler.err.invalid.repeatable.annotation=\u6CE8\u91C8\u304C\u91CD\u8907\u3057\u3066\u3044\u307E\u3059: {0}\u306F\u7121\u52B9\u306A@Repeatable\u6CE8\u91C8\u3067\u6CE8\u91C8\u4ED8\u3051\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: symbol or type
-compiler.err.invalid.repeatable.annotation.no.value={0}\u306F\u6709\u52B9\u306A@Repeatable\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\u5024\u8981\u7D20\u30E1\u30BD\u30C3\u30C9\u304C\u5BA3\u8A00\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: type, 1: number
-compiler.err.invalid.repeatable.annotation.multiple.values={0}\u306F\u6709\u52B9\u306A@Repeatable\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002{1}\u8981\u7D20\u30E1\u30BD\u30C3\u30C9''value''\u304C\u5BA3\u8A00\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: type
-compiler.err.invalid.repeatable.annotation.invalid.value={0}\u306F\u6709\u52B9\u306A@Repeatable\u3067\u306F\u3042\u308A\u307E\u305B\u3093: \u5024\u8981\u7D20\u304C\u7121\u52B9\u3067\u3059
-
-# 0: symbol type, 1: unused, 2: type
-compiler.err.invalid.repeatable.annotation.value.return=\u5305\u542B\u3059\u308B\u6CE8\u91C8\u578B({0})\u306F\u578B{2}\u306E\u8981\u7D20''value''\u3092\u5BA3\u8A00\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol or type, 1: symbol
-compiler.err.invalid.repeatable.annotation.elem.nondefault=\u5305\u542B\u3059\u308B\u6CE8\u91C8\u578B{0}\u306B\u306F\u8981\u7D20{1}\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: symbol, 1: unused, 2: symbol, 3: unused
-compiler.err.invalid.repeatable.annotation.retention=\u5305\u542B\u3059\u308B\u6CE8\u91C8\u578B({0})\u306E\u4FDD\u6709\u304C\u3001\u7E70\u8FD4\u3057\u53EF\u80FD\u306A\u6CE8\u91C8\u578B({2})\u306E\u4FDD\u6709\u3088\u308A\u77ED\u304F\u306A\u3063\u3066\u3044\u307E\u3059
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.not.documented=\u7E70\u8FD4\u3057\u53EF\u80FD\u306A\u6CE8\u91C8\u578B({1})\u306F@Documented\u3067\u3059\u304C\u3001\u5305\u542B\u3059\u308B\u6CE8\u91C8\u578B({0})\u306F\u9055\u3044\u307E\u3059
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.not.inherited=\u7E70\u8FD4\u3057\u53EF\u80FD\u306A\u6CE8\u91C8\u578B({1})\u306F@Inherited\u3067\u3059\u304C\u3001\u5305\u542B\u3059\u308B\u6CE8\u91C8\u578B({0})\u306F\u9055\u3044\u307E\u3059
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.incompatible.target=\u5305\u542B\u3059\u308B\u6CE8\u91C8\u578B({0})\u306F\u3001\u7E70\u8FD4\u3057\u53EF\u80FD\u306A\u6CE8\u91C8\u578B({1})\u3088\u308A\u591A\u304F\u306E\u30BF\u30FC\u30B2\u30C3\u30C8\u306B\u9069\u7528\u3055\u308C\u307E\u3059
-
-# 0: symbol
-compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\u30B3\u30F3\u30C6\u30CA{0}\u306F\u542B\u307E\u308C\u3066\u3044\u308B\u8981\u7D20\u3068\u540C\u6642\u306B\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093
-
-# 0: name
-compiler.err.duplicate.class=\u30AF\u30E9\u30B9{0}\u304C\u91CD\u8907\u3057\u3066\u3044\u307E\u3059
-
-compiler.err.duplicate.case.label=case\u30E9\u30D9\u30EB\u304C\u91CD\u8907\u3057\u3066\u3044\u307E\u3059
-
-compiler.err.duplicate.default.label=default\u30E9\u30D9\u30EB\u304C\u91CD\u8907\u3057\u3066\u3044\u307E\u3059
-
-compiler.err.else.without.if=''else''\u3078\u306E''if''\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.empty.char.lit=\u7A7A\u306E\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3067\u3059
-
-# 0: symbol
-compiler.err.encl.class.required={0}\u3092\u542B\u3080\u56F2\u3046\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u304C\u5FC5\u8981\u3067\u3059
-
-compiler.err.enum.annotation.must.be.enum.constant=\u5217\u6319\u578B\u6CE8\u91C8\u5024\u306F\u3001\u5217\u6319\u578B\u5B9A\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.enum.cant.be.instantiated=\u5217\u6319\u578B\u306F\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u5316\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.enum.label.must.be.unqualified.enum=\u5217\u6319\u578B\u306Eswitch case\u30E9\u30D9\u30EB\u306F\u5217\u6319\u578B\u5B9A\u6570\u306E\u975E\u4FEE\u98FE\u540D\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.enum.no.subclassing=\u30AF\u30E9\u30B9\u306F\u76F4\u63A5java.lang.Enum\u3092\u62E1\u5F35\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.enum.types.not.extensible=\u5217\u6319\u578B\u306F\u62E1\u5F35\u53EF\u80FD\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.enum.no.finalize=\u5217\u6319\u578B\u306Ffinalize\u30E1\u30BD\u30C3\u30C9\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: file name, 1: string
-compiler.err.error.reading.file={0}\u306E\u8AAD\u8FBC\u307F\u30A8\u30E9\u30FC\u3067\u3059\u3002{1}
-
-# 0: type
-compiler.err.except.already.caught=\u4F8B\u5916{0}\u306F\u3059\u3067\u306B\u6355\u6349\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: type
-compiler.err.except.never.thrown.in.try=\u4F8B\u5916{0}\u306F\u5BFE\u5FDC\u3059\u308Btry\u6587\u306E\u672C\u4F53\u3067\u306F\u30B9\u30ED\u30FC\u3055\u308C\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.final.parameter.may.not.be.assigned=final\u30D1\u30E9\u30E1\u30FC\u30BF{0}\u306B\u5024\u3092\u4EE3\u5165\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.try.resource.may.not.be.assigned=\u81EA\u52D5\u30AF\u30ED\u30FC\u30BA\u53EF\u80FD\u306A\u30EA\u30BD\u30FC\u30B9{0}\u306B\u5024\u3092\u4EE3\u5165\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.multicatch.parameter.may.not.be.assigned=\u8907\u6570catch\u30D1\u30E9\u30E1\u30FC\u30BF{0}\u306B\u5024\u3092\u4EE3\u5165\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: type, 1: type
-compiler.err.multicatch.types.must.be.disjoint=\u8907\u6570catch\u6587\u306E\u4EE3\u66FF\u3092\u30B5\u30D6\u30AF\u30E9\u30B9\u5316\u306B\u3088\u3063\u3066\u95A2\u9023\u4ED8\u3051\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\n\u4EE3\u66FF{0}\u306F\u4EE3\u66FF{1}\u306E\u30B5\u30D6\u30AF\u30E9\u30B9\u3067\u3059
-
-compiler.err.finally.without.try=''finally''\u3078\u306E''try''\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: type, 1: message segment
-compiler.err.foreach.not.applicable.to.type=for-each\u306F\u5F0F\u306E\u30BF\u30A4\u30D7\u306B\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093\n\u671F\u5F85\u5024: {1}\n\u691C\u51FA\u5024: {0}
-
-compiler.err.fp.number.too.large=\u6D6E\u52D5\u5C0F\u6570\u70B9\u6570\u304C\u5927\u304D\u3059\u304E\u307E\u3059
-
-compiler.err.fp.number.too.small=\u6D6E\u52D5\u5C0F\u6570\u70B9\u6570\u304C\u5C0F\u3055\u3059\u304E\u307E\u3059
-
-compiler.err.generic.array.creation=\u6C4E\u7528\u914D\u5217\u3092\u4F5C\u6210\u3057\u307E\u3059
-
-compiler.err.generic.throwable=\u6C4E\u7528\u30AF\u30E9\u30B9\u306Fjava.lang.Throwable\u3092\u62E1\u5F35\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.icls.cant.have.static.decl=\u5185\u90E8\u30AF\u30E9\u30B9{0}\u306E\u9759\u7684\u5BA3\u8A00\u304C\u4E0D\u6B63\u3067\u3059\n\u4FEE\u98FE\u5B50''static''\u306F\u5B9A\u6570\u304A\u3088\u3073\u5909\u6570\u306E\u5BA3\u8A00\u3067\u306E\u307F\u4F7F\u7528\u3067\u304D\u307E\u3059
-
-# 0: string
-compiler.err.illegal.char=''{0}''\u306F\u4E0D\u6B63\u306A\u6587\u5B57\u3067\u3059
-
-compiler.err.illegal.char.for.encoding=\u3053\u306E\u6587\u5B57\u306F\u3001\u30A8\u30F3\u30B3\u30FC\u30C7\u30A3\u30F3\u30B0{0}\u306B\u30DE\u30C3\u30D7\u3067\u304D\u307E\u305B\u3093
-
-# 0: set of modifier, 1: set of modifier
-compiler.err.illegal.combination.of.modifiers=\u4FEE\u98FE\u5B50{0}\u3068{1}\u306E\u7D44\u5408\u305B\u306F\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.enum.static.ref=\u521D\u671F\u5316\u5B50\u304B\u3089static\u30D5\u30A3\u30FC\u30EB\u30C9\u3078\u306E\u53C2\u7167\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.esc.char=\u30A8\u30B9\u30B1\u30FC\u30D7\u6587\u5B57\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.forward.ref=\u524D\u65B9\u53C2\u7167\u304C\u4E0D\u6B63\u3067\u3059
-
-# 0: symbol, 1: string
-compiler.err.not.in.profile={0}\u306F\u30D7\u30ED\u30D5\u30A1\u30A4\u30EB''{1}''\u3067\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.warn.forward.ref=\u521D\u671F\u5316\u3055\u308C\u308B\u524D\u306E\u5909\u6570''{0}''\u3092\u53C2\u7167\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F
-
-compiler.err.illegal.self.ref=\u521D\u671F\u5316\u5B50\u5185\u306E\u81EA\u5DF1\u53C2\u7167
-
-# 0: symbol
-compiler.warn.self.ref=\u521D\u671F\u5316\u5B50\u5185\u306E\u5909\u6570''{0}''\u306E\u81EA\u5DF1\u53C2\u7167
-
-compiler.err.illegal.generic.type.for.instof=instanceof\u306E\u7DCF\u79F0\u578B\u304C\u4E0D\u6B63\u3067\u3059
-
-# 0: type
-compiler.err.illegal.initializer.for.type={0}\u306E\u521D\u671F\u5316\u5B50\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.line.end.in.char.lit=\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u306E\u884C\u672B\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.nonascii.digit=\u4E0D\u6B63\u306A\u975EASCII\u6570\u5B57\u3067\u3059
-
-compiler.err.illegal.underscore=\u4E0D\u6B63\u306A\u30A2\u30F3\u30C0\u30FC\u30B9\u30B3\u30A2\u3067\u3059
-
-compiler.err.illegal.dot=\u4E0D\u6B63\u306A''.''\u3067\u3059
-
-# 0: symbol
-compiler.err.illegal.qual.not.icls=\u4FEE\u98FE\u5B50\u304C\u4E0D\u6B63\u3067\u3059\u3002{0}\u306F\u5185\u90E8\u30AF\u30E9\u30B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.illegal.start.of.expr=\u5F0F\u306E\u958B\u59CB\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.start.of.stmt=\u6587\u306E\u958B\u59CB\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.start.of.type=\u578B\u306E\u958B\u59CB\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.illegal.unicode.esc=Unicode\u30A8\u30B9\u30B1\u30FC\u30D7\u304C\u4E0D\u6B63\u3067\u3059
-
-# 0: symbol
-compiler.err.import.requires.canonical=\u30A4\u30F3\u30DD\u30FC\u30C8\u306B\u306F{0}\u306E\u6A19\u6E96\u540D\u304C\u5FC5\u8981\u3067\u3059
-
-compiler.err.improperly.formed.type.param.missing=\u578B\u306E\u5F62\u5F0F\u304C\u4E0D\u9069\u5207\u3067\u3059\u3002\u30D1\u30E9\u30E1\u30FC\u30BF\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059
-
-compiler.err.improperly.formed.type.inner.raw.param=\u578B\u306E\u5F62\u5F0F\u304C\u4E0D\u9069\u5207\u3067\u3059\u3002raw\u578B\u306B\u6307\u5B9A\u3055\u308C\u305F\u578B\u5F15\u6570\u3067\u3059
-
-# 0: type, 1: type
-compiler.err.incomparable.types=\u578B{0}\u3068{1}\u306F\u6BD4\u8F03\u3067\u304D\u307E\u305B\u3093
-
-# 0: number
-compiler.err.int.number.too.large=\u6574\u6570{0}\u304C\u5927\u304D\u3059\u304E\u307E\u3059
-
-compiler.err.intf.annotation.members.cant.have.params=\u6CE8\u91C8\u578B\u5BA3\u8A00\u5185\u306E\u8981\u7D20\u304C\u4EEE\u30D1\u30E9\u30E1\u30FC\u30BF\u3092\u5BA3\u8A00\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.intf.annotation.cant.have.type.params=\u6CE8\u91C8\u578B{0}\u306F\u6C4E\u7528\u306B\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.intf.annotation.members.cant.have.type.params=\u6CE8\u91C8\u578B\u5BA3\u8A00\u5185\u306E\u8981\u7D20\u306F\u6C4E\u7528\u30E1\u30BD\u30C3\u30C9\u306B\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: type
-compiler.err.intf.annotation.member.clash=\u6CE8\u91C8\u578B{1}\u3067\u30E1\u30BD\u30C3\u30C9{0}\u3068\u540C\u3058\u540D\u524D\u306E\u8981\u7D20\u304C\u5BA3\u8A00\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.intf.expected.here=\u3053\u3053\u306B\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u304C\u5FC5\u8981\u3067\u3059
-
-compiler.err.intf.meth.cant.have.body=\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u62BD\u8C61\u30E1\u30BD\u30C3\u30C9\u304C\u672C\u4F53\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.invalid.annotation.member.type=\u6CE8\u91C8\u578B\u306E\u8981\u7D20{0}\u306E\u578B\u304C\u7121\u52B9\u3067\u3059
-
-compiler.err.invalid.binary.number=2\u9032\u6570\u5B57\u306F\u5C11\u306A\u304F\u3068\u30821\u6841\u306E2\u9032\u6570\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.invalid.hex.number=16\u9032\u6570\u5B57\u306F\u5C11\u306A\u304F\u3068\u30821\u6841\u306E16\u9032\u6570\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.invalid.meth.decl.ret.type.req=\u7121\u52B9\u306A\u30E1\u30BD\u30C3\u30C9\u5BA3\u8A00\u3067\u3059\u3002\u623B\u308A\u5024\u306E\u578B\u304C\u5FC5\u8981\u3067\u3059\u3002
-
-compiler.err.varargs.and.old.array.syntax=\u65E7\u5F0F\u306E\u914D\u5217\u8868\u8A18\u6CD5\u306F\u53EF\u5909\u5F15\u6570\u30D1\u30E9\u30E1\u30FC\u30BF\u3067\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.varargs.and.receiver =varargs\u8868\u8A18\u306F\u53D7\u53D6\u308A\u5074\u30D1\u30E9\u30E1\u30FC\u30BF\u3067\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.array.and.receiver =\u65E7\u5F0F\u306E\u914D\u5217\u8868\u8A18\u6CD5\u306F\u53D7\u53D6\u308A\u5074\u30D1\u30E9\u30E1\u30FC\u30BF\u3067\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.variable.not.allowed=\u5909\u6570\u306E\u5BA3\u8A00\u3092\u3053\u3053\u3067\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: name
-compiler.err.label.already.in.use=\u30E9\u30D9\u30EB{0}\u306F\u3059\u3067\u306B\u4F7F\u7528\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: symbol
-compiler.err.local.var.accessed.from.icls.needs.final=\u30ED\u30FC\u30AB\u30EB\u5909\u6570{0}\u306F\u5185\u90E8\u30AF\u30E9\u30B9\u304B\u3089\u30A2\u30AF\u30BB\u30B9\u3055\u308C\u307E\u3059\u3002final\u3067\u5BA3\u8A00\u3055\u308C\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.local.enum=\u5217\u6319\u578B\u306F\u30ED\u30FC\u30AB\u30EB\u306B\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.cannot.create.array.with.type.arguments=\u578B\u5F15\u6570\u3092\u6301\u3064\u914D\u5217\u3092\u4F5C\u6210\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.cannot.create.array.with.diamond=''<>''\u3092\u6301\u3064\u914D\u5217\u306F\u4F5C\u6210\u3067\u304D\u307E\u305B\u3093
-
-#
-# limits.  We don't give the limits in the diagnostic because we expect
-# them to change, yet we want to use the same diagnostic.  These are all
-# detected during code generation.
-#
-compiler.err.limit.code=\u30B3\u30FC\u30C9\u304C\u5927\u304D\u3059\u304E\u307E\u3059
-
-compiler.err.limit.code.too.large.for.try.stmt=try\u6587\u306E\u30B3\u30FC\u30C9\u304C\u5927\u304D\u3059\u304E\u307E\u3059
-
-compiler.err.limit.dimensions=\u914D\u5217\u578B\u306E\u6B21\u5143\u304C\u591A\u3059\u304E\u307E\u3059
-
-compiler.err.limit.locals=\u30ED\u30FC\u30AB\u30EB\u5909\u6570\u304C\u591A\u3059\u304E\u307E\u3059
-
-compiler.err.limit.parameters=\u30D1\u30E9\u30E1\u30FC\u30BF\u304C\u591A\u3059\u304E\u307E\u3059
-
-compiler.err.limit.pool=\u5B9A\u6570\u304C\u591A\u3059\u304E\u307E\u3059
-
-compiler.err.limit.pool.in.class=\u30AF\u30E9\u30B9{0}\u5185\u306E\u5B9A\u6570\u304C\u591A\u3059\u304E\u307E\u3059
-
-compiler.err.limit.stack=\u30B3\u30FC\u30C9\u304C\u8981\u6C42\u3059\u308B\u30B9\u30BF\u30C3\u30AF\u304C\u591A\u3059\u304E\u307E\u3059
-
-compiler.err.limit.string=\u5B9A\u6570\u6587\u5B57\u5217\u304C\u9577\u3059\u304E\u307E\u3059
-
-compiler.err.limit.string.overflow=\u6587\u5B57\u5217"{0}..."\u306EUTF8\u8868\u73FE\u304C\u3001\u5B9A\u6570\u30D7\u30FC\u30EB\u306B\u5BFE\u3057\u3066\u9577\u3059\u304E\u307E\u3059
-
-compiler.err.malformed.fp.lit=\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.method.does.not.override.superclass=\u30E1\u30BD\u30C3\u30C9\u306F\u30B9\u30FC\u30D1\u30FC\u30BF\u30A4\u30D7\u306E\u30E1\u30BD\u30C3\u30C9\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u307E\u305F\u306F\u5B9F\u88C5\u3057\u307E\u305B\u3093
-
-compiler.err.missing.meth.body.or.decl.abstract=\u30E1\u30BD\u30C3\u30C9\u672C\u4F53\u304C\u306A\u3044\u304B\u3001abstract\u3068\u3057\u3066\u5BA3\u8A00\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.missing.ret.stmt=return\u6587\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: unused
-compiler.misc.missing.ret.val=\u623B\u308A\u5024\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.misc.unexpected.ret.val=\u4E88\u671F\u3057\u306A\u3044\u623B\u308A\u5024
-
-# 0: set of modifier
-compiler.err.mod.not.allowed.here=\u4FEE\u98FE\u5B50{0}\u3092\u3053\u3053\u3067\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.intf.not.allowed.here=\u3053\u3053\u3067\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306F\u8A31\u53EF\u3055\u308C\u307E\u305B\u3093
-
-compiler.err.enums.must.be.static=\u5217\u6319\u578B\u306E\u5BA3\u8A00\u306Fstatic\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3067\u306E\u307F\u4F7F\u7528\u3067\u304D\u307E\u3059
-
-# 0: symbol, 1: symbol
-compiler.err.name.clash.same.erasure=\u540D\u524D\u304C\u7AF6\u5408\u3057\u3066\u3044\u307E\u3059\u3002{0}\u3068{1}\u306F\u524A\u9664\u5F8C\u306E\u540D\u524D\u304C\u540C\u3058\u3067\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: unused, 5: unused
-compiler.err.name.clash.same.erasure.no.override=\u540D\u524D\u304C\u7AF6\u5408\u3057\u3066\u3044\u307E\u3059\u3002{1}\u306E{0}\u3068{3}\u306E{2}\u306F\u307E\u3060\u4ED6\u65B9\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3066\u3044\u307E\u305B\u3093\u304C\u3001\u524A\u9664\u5F8C\u306E\u540D\u524D\u304C\u540C\u3058\u3067\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: symbol, 5: symbol
-compiler.err.name.clash.same.erasure.no.override.1=\u540D\u524D\u304C\u7AF6\u5408\u3057\u3066\u3044\u307E\u3059\u3002{1}\u306E{0}\u306E\u3069\u3061\u3089\u3082\u3001\u4ED6\u65B9\u306E\u6700\u521D\u306E\u30E1\u30BD\u30C3\u30C9\u3092\u307E\u3060\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3066\u3044\u307E\u305B\u3093\u304C\u3001\u524A\u9664\u5F8C\u306E\u540D\u524D\u304C\u5225\u306E\u30E1\u30BD\u30C3\u30C9\u3068\u540C\u3058\u30E1\u30BD\u30C3\u30C9\u3092\n\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059\u3002\u6700\u521D\u306E\u30E1\u30BD\u30C3\u30C9: {3}\u306E{2}\n2\u756A\u76EE\u306E\u30E1\u30BD\u30C3\u30C9: {5}\u306E{4}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.err.name.clash.same.erasure.no.hide=\u540D\u524D\u304C\u7AF6\u5408\u3057\u3066\u3044\u307E\u3059\u3002{1}\u306E{0}\u3068{3}\u306E{2}\u306F\u307E\u3060\u4ED6\u65B9\u3092\u975E\u8868\u793A\u306B\u3057\u3066\u3044\u307E\u305B\u3093\u304C\u3001\u524A\u9664\u5F8C\u306E\u540D\u524D\u304C\u540C\u3058\u3067\u3059
-
-compiler.err.name.reserved.for.internal.use={0}\u306F\u5185\u90E8\u3067\u306E\u4F7F\u7528\u306E\u305F\u3081\u4E88\u7D04\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.native.meth.cant.have.body=native\u30E1\u30BD\u30C3\u30C9\u304C\u672C\u4F53\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: type, 1: type
-compiler.err.neither.conditional.subtype=?\u306B\u5BFE\u3059\u308B\u4E0D\u9069\u5408\u306A\u578B : \u3069\u3061\u3089\u3082\u4ED6\u65B9\u306E\u30B5\u30D6\u30BF\u30A4\u30D7\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\n2\u756A\u76EE\u306E\u30AA\u30DA\u30E9\u30F3\u30C9 : {0}\n3\u756A\u76EE\u306E\u30AA\u30DA\u30E9\u30F3\u30C9 : {1}
-
-# 0: message segment
-compiler.misc.incompatible.type.in.conditional=\u6761\u4EF6\u5F0F\u306E\u578B\u304C\u4E0D\u6B63\u3067\u3059\n{0}
-
-compiler.misc.conditional.target.cant.be.void=\u6761\u4EF6\u5F0F\u306E\u30BF\u30FC\u30B2\u30C3\u30C8\u578B\u306Fvoid\u306B\u3067\u304D\u307E\u305B\u3093
-
-# 0: type
-compiler.misc.incompatible.ret.type.in.lambda=\u30E9\u30E0\u30C0\u5F0F\u306E\u623B\u308A\u578B\u304C\u4E0D\u6B63\u3067\u3059\n{0}
-
-# 0: type
-compiler.misc.incompatible.ret.type.in.mref=\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u306E\u623B\u308A\u578B\u304C\u4E0D\u6B63\u3067\u3059\n{0}
-
-compiler.err.lambda.body.neither.value.nor.void.compatible=\u30E9\u30E0\u30C0\u30FB\u30DC\u30C7\u30A3\u306F\u5024\u4E92\u63DB\u3067\u3082void\u4E92\u63DB\u3067\u3082\u3042\u308A\u307E\u305B\u3093
-
-# 0: list of type
-compiler.err.incompatible.thrown.types.in.mref=\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u306E\u30B9\u30ED\u30FC\u3055\u308C\u305F\u30BF\u30A4\u30D7{0}\u306F\u4E0D\u9069\u5408\u3067\u3059
-
-compiler.misc.incompatible.arg.types.in.lambda=\u30E9\u30E0\u30C0\u5F0F\u306E\u30D1\u30E9\u30E1\u30FC\u30BF\u578B\u306F\u4E0D\u9069\u5408\u3067\u3059
-
-compiler.misc.incompatible.arg.types.in.mref=\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u306E\u30D1\u30E9\u30E1\u30FC\u30BF\u578B\u306F\u4E0D\u9069\u5408\u3067\u3059
-
-compiler.err.new.not.allowed.in.annotation=''new''\u306F\u6CE8\u91C8\u306B\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.no.annotation.member={1}\u306E\u6CE8\u91C8\u30E1\u30F3\u30D0\u30FC{0}\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.no.encl.instance.of.type.in.scope=\u578B{0}\u306E\u5185\u90E8\u30AF\u30E9\u30B9\u3092\u56F2\u3080\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u304C\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.no.intf.expected.here=\u3053\u3053\u306B\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306F\u5FC5\u8981\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.no.match.entry={0}\u306F{1}\u306E\u30A8\u30F3\u30C8\u30EA\u306B\u9069\u5408\u3057\u307E\u305B\u3093\u3002{2}\u304C\u5FC5\u8981\u3067\u3059
-
-compiler.err.not.annotation.type={0}\u306F\u6CE8\u91C8\u578B\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol
-compiler.err.not.def.access.class.intf.cant.access={1}\u306E{0}\u304C\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306B\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: symbol, 1: symbol
-compiler.misc.not.def.access.class.intf.cant.access={1}\u306E{0}\u304C\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306B\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: symbol, 1: list of type, 2: type
-compiler.misc.cant.access.inner.cls.constr=\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF{0}({1})\u306B\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093\n\u5185\u90E8\u30AF\u30E9\u30B9\u3092\u56F2\u3080\u578B{2}\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u304C\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u3042\u308A\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol
-compiler.err.not.def.public.cant.access={1}\u306E{0}\u306Fpublic\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\u30D1\u30C3\u30B1\u30FC\u30B8\u5916\u304B\u3089\u306F\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol
-compiler.misc.not.def.public.cant.access={1}\u306E{0}\u306Fpublic\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\u30D1\u30C3\u30B1\u30FC\u30B8\u5916\u304B\u3089\u306F\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093
-
-# 0: name
-compiler.err.not.loop.label={0}\u306F\u30EB\u30FC\u30D7\u30FB\u30E9\u30D9\u30EB\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.not.stmt=\u6587\u3067\u306F\u3042\u308A\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.not.encl.class={0}\u306F\u5185\u90E8\u30AF\u30E9\u30B9\u3092\u56F2\u307F\u307E\u305B\u3093
-
-# 0: name, 1: type, 2: unused
-compiler.err.operator.cant.be.applied=\u5358\u9805\u6F14\u7B97\u5B50''{0}''\u306E\u30AA\u30DA\u30E9\u30F3\u30C9\u578B{1}\u304C\u4E0D\u6B63\u3067\u3059
-
-# 0: name, 1: type, 2: type
-compiler.err.operator.cant.be.applied.1=\u4E8C\u9805\u6F14\u7B97\u5B50''{0}''\u306E\u30AA\u30DA\u30E9\u30F3\u30C9\u578B\u304C\u4E0D\u6B63\u3067\u3059\n\u6700\u521D\u306E\u578B: {1}\n2\u756A\u76EE\u306E\u578B: {2}
-
-compiler.err.pkg.annotations.sb.in.package-info.java=\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u6CE8\u91C8\u306F\u30D5\u30A1\u30A4\u30EBpackage-info.java\u5185\u306B\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol
-compiler.err.pkg.clashes.with.class.of.same.name=\u30D1\u30C3\u30B1\u30FC\u30B8{0}\u306F\u540C\u540D\u306E\u30AF\u30E9\u30B9\u3068\u7AF6\u5408\u3057\u3066\u3044\u307E\u3059
-
-compiler.err.warnings.and.werror=\u8B66\u544A\u304C\u898B\u3064\u304B\u308A-Werror\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F
-
-# Errors related to annotation processing
-
-# 0: symbol, 1: string, 2: stack-trace
-compiler.err.proc.cant.access={0}\u306B\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093\n{1}\n\u8A73\u7D30\u306F\u6B21\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30C8\u30EC\u30FC\u30B9\u3067\u8ABF\u67FB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n{2}
-
-# 0: symbol, 1: string
-compiler.err.proc.cant.access.1={0}\u306B\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093\n{1}
-
-# 0: string
-compiler.err.proc.cant.find.class=''{0}''\u306E\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3067\u3057\u305F\u3002
-
-# Print a client-generated error message; assumed to be localized, no translation required
-# 0: string
-compiler.err.proc.messager={0}
-
-# 0: list of string
-compiler.err.proc.no.explicit.annotation.processing.requested=\u30AF\u30E9\u30B9\u540D''{0}''\u304C\u53D7\u3051\u5165\u308C\u3089\u308C\u308B\u306E\u306F\u3001\u6CE8\u91C8\u51E6\u7406\u304C\u660E\u793A\u7684\u306B\u30EA\u30AF\u30A8\u30B9\u30C8\u3055\u308C\u305F\u5834\u5408\u306E\u307F\u3067\u3059
-
-compiler.err.proc.no.service=\u30B5\u30FC\u30D3\u30B9\u30FB\u30ED\u30FC\u30C0\u30FC\u304C\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u304C\u3001\u6CE8\u91C8\u51E6\u7406\u306B\u5FC5\u8981\u3067\u3059\u3002
-
-compiler.err.proc.processor.bad.option.name=\u30D7\u30ED\u30BB\u30C3\u30B5''{1}''\u306B\u3088\u3063\u3066\u6307\u5B9A\u3055\u308C\u305F\u30AA\u30D7\u30B7\u30E7\u30F3\u540D''{0}''\u304C\u4E0D\u6B63\u3067\u3059
-
-# 0: string
-compiler.err.proc.processor.cant.instantiate=\u30D7\u30ED\u30BB\u30C3\u30B5''{0}''\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u5316\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F
-
-# 0: string
-compiler.err.proc.processor.not.found=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5''{0}''\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093
-
-# 0: string
-compiler.err.proc.processor.wrong.type=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5''{0}''\u304Cjavax.annotation.processing.Processor\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u305B\u3093
-
-compiler.err.proc.service.problem=\u30D7\u30ED\u30BB\u30C3\u30B5\u3092\u30ED\u30FC\u30C9\u3059\u308B\u305F\u3081\u306E\u30B5\u30FC\u30D3\u30B9\u30FB\u30ED\u30FC\u30C0\u30FC\u3092\u4F5C\u6210\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002
-
-compiler.err.proc.bad.config.file=\u30B5\u30FC\u30D3\u30B9\u69CB\u6210\u30D5\u30A1\u30A4\u30EB\u304C\u4E0D\u6B63\u3067\u3042\u308B\u304B\u3001\u30D7\u30ED\u30BB\u30C3\u30B5\u30FB\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306E\u69CB\u7BC9\u4E2D\u306B\u4F8B\u5916\u304C\u30B9\u30ED\u30FC\u3055\u308C\u307E\u3057\u305F: {0}
-
-compiler.err.proc.cant.create.loader=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u306E\u30AF\u30E9\u30B9\u30FB\u30ED\u30FC\u30C0\u30FC\u3092\u4F5C\u6210\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F: {0}
-
-# 0: unused
-compiler.err.qualified.new.of.static.class=static\u30AF\u30E9\u30B9\u306Enew\u304C\u4FEE\u98FE\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.recursive.ctor.invocation=\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u547C\u51FA\u3057\u304C\u518D\u5E30\u7684\u3067\u3059
-
-# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
-compiler.err.ref.ambiguous={0}\u306E\u53C2\u7167\u306F\u3042\u3044\u307E\u3044\u3067\u3059\n{3}\u306E{1} {2}\u3068{6}\u306E{4} {5}\u306E\u4E21\u65B9\u304C\u4E00\u81F4\u3057\u307E\u3059
-
-# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
-compiler.misc.ref.ambiguous={0}\u306E\u53C2\u7167\u306F\u3042\u3044\u307E\u3044\u3067\u3059\n{3}\u306E{1} {2}\u3068{6}\u306E{4} {5}\u306E\u4E21\u65B9\u304C\u4E00\u81F4\u3057\u307E\u3059
-
-compiler.err.repeated.annotation.target=\u6CE8\u91C8\u30BF\u30FC\u30B2\u30C3\u30C8\u304C\u7E70\u308A\u8FD4\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.repeated.interface=\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u304C\u7E70\u308A\u8FD4\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.err.repeated.modifier=\u4FEE\u98FE\u5B50\u304C\u7E70\u308A\u8FD4\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: symbol, 1: set of modifier, 2: symbol
-compiler.err.report.access={0}\u306F{2}\u3067{1}\u30A2\u30AF\u30BB\u30B9\u3055\u308C\u307E\u3059
-
-# 0: symbol, 1: set of modifier, 2: symbol
-compiler.misc.report.access={0}\u306F{2}\u3067{1}\u30A2\u30AF\u30BB\u30B9\u3055\u308C\u307E\u3059
-
-compiler.err.ret.outside.meth=\u30E1\u30BD\u30C3\u30C9\u306E\u5916\u306Ereturn\u6587\u3067\u3059
-
-compiler.err.signature.doesnt.match.supertype=\u30B7\u30B0\u30CD\u30C1\u30E3\u304C{0}\u306B\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\u4E0D\u9069\u5408\u306A\u30B9\u30FC\u30D1\u30FC\u30BF\u30A4\u30D7\u3067\u3059
-
-compiler.err.signature.doesnt.match.intf=\u30B7\u30B0\u30CD\u30C1\u30E3\u304C{0}\u306B\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\u4E0D\u9069\u5408\u306A\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3067\u3059
-
-# 0: number, 1: number
-compiler.err.method.invoked.with.incorrect.number.arguments=\u30E1\u30BD\u30C3\u30C9\u3092\u8D77\u52D5\u3057\u305F\u5F15\u6570\u306E\u6570\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002\u4E88\u671F\u3055\u308C\u308B\u6570\u306F{0}\u3067\u3059\u304C\u3001{1}\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F
-
-# 0: symbol, 1: symbol, 2: symbol
-compiler.err.does.not.override.abstract={0}\u306Fabstract\u3067\u306A\u304F\u3001{2}\u5185\u306Eabstract\u30E1\u30BD\u30C3\u30C9{1}\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u305B\u3093
-
-compiler.err.source.cant.overwrite.input.file=\u30BD\u30FC\u30B9\u306E\u66F8\u8FBC\u307F\u30A8\u30E9\u30FC\u3067\u3059\u3002\u5165\u529B\u30D5\u30A1\u30A4\u30EB{0}\u3092\u4E0A\u66F8\u304D\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.stack.sim.error=\u5185\u90E8\u30A8\u30E9\u30FC: {0}\u3067\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30B7\u30DF\u30E5\u30EC\u30FC\u30B7\u30E7\u30F3\u30FB\u30A8\u30E9\u30FC
-
-compiler.err.static.imp.only.classes.and.interfaces=static import\u306F\u30AF\u30E9\u30B9\u3068\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u304B\u3089\u306E\u307F\u3068\u306A\u308A\u307E\u3059
-
-compiler.err.string.const.req=\u5B9A\u6570\u306E\u6587\u5B57\u5217\u5F0F\u304C\u5FC5\u8981\u3067\u3059
-
-# 0: symbol, 1: symbol
-compiler.err.synthetic.name.conflict=\u30B7\u30F3\u30DC\u30EB{0}\u304C\u3001{1}\u3067\u30B3\u30F3\u30D1\u30A4\u30E9\u304C\u5408\u6210\u3057\u305F\u30B7\u30F3\u30DC\u30EB\u3068\u7AF6\u5408\u3057\u307E\u3059
-
-# 0: symbol, 1: symbol
-compiler.warn.synthetic.name.conflict=\u30B7\u30F3\u30DC\u30EB{0}\u304C\u3001{1}\u3067\u30B3\u30F3\u30D1\u30A4\u30E9\u304C\u5408\u6210\u3057\u305F\u30B7\u30F3\u30DC\u30EB\u3068\u7AF6\u5408\u3057\u307E\u3059
-
-compiler.err.throws.not.allowed.in.intf.annotation=throws\u7BC0\u3092@interface\u30E1\u30F3\u30D0\u30FC\u3067\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.try.without.catch.or.finally=''try''\u3078\u306E''catch''\u307E\u305F\u306F''finally''\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.try.without.catch.finally.or.resource.decls=''try''\u3078\u306E''catch''\u3001''finally''\u307E\u305F\u306F\u30EA\u30BD\u30FC\u30B9\u5BA3\u8A00\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.type.doesnt.take.params=\u578B{0}\u306F\u30D1\u30E9\u30E1\u30FC\u30BF\u3092\u3068\u308A\u307E\u305B\u3093
-
-compiler.err.type.var.cant.be.deref=\u578B\u5909\u6570\u304B\u3089\u9078\u629E\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.type.var.may.not.be.followed.by.other.bounds=\u3053\u306E\u578B\u5909\u6570\u306E\u5F8C\u308D\u306B\u4ED6\u306E\u5883\u754C\u3092\u914D\u7F6E\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.type.var.more.than.once=\u578B\u5909\u6570{0}\u306F{1}\u306E\u623B\u308A\u5024\u306E\u578B\u30672\u56DE\u4EE5\u4E0A\u51FA\u73FE\u3057\u307E\u3059\u3002\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u751F\u6210\u3055\u308C\u306A\u3044\u307E\u307E\u306B\u306F\u3067\u304D\u307E\u305B\u3093
-
-compiler.err.type.var.more.than.once.in.result=\u578B\u5909\u6570{0}\u306F{1}\u306E\u578B\u30672\u56DE\u4EE5\u4E0A\u51FA\u73FE\u3057\u307E\u3059\u3002\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u751F\u6210\u3055\u308C\u306A\u3044\u307E\u307E\u306B\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: type, 1: type, 2: string
-compiler.err.types.incompatible.diff.ret=\u578B{0}\u3068\u578B{1}\u304C\u9069\u5408\u3057\u3066\u3044\u307E\u305B\u3093\u3002\u4E21\u65B9\u3068\u3082{2}\u3092\u5B9A\u7FA9\u3057\u3066\u3044\u307E\u3059\u304C\u3001\u623B\u308A\u5024\u306E\u578B\u304C\u7121\u95A2\u4FC2\u3067\u3059
-
-# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
-compiler.err.types.incompatible.unrelated.defaults={0} {1}\u306F\u578B{4}\u3068{5}\u304B\u3089{2}({3})\u306E\u95A2\u9023\u3057\u306A\u3044\u30C7\u30D5\u30A9\u30EB\u30C8\u3092\u7D99\u627F\u3057\u307E\u3059
-
-# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
-compiler.err.types.incompatible.abstract.default={0} {1}\u306F\u578B{4}\u3068{5}\u304B\u3089{2}({3})\u306E\u62BD\u8C61\u3068\u30C7\u30D5\u30A9\u30EB\u30C8\u3092\u7D99\u627F\u3057\u307E\u3059
-
-# 0: name, 1: kind, 2: symbol
-compiler.err.default.overrides.object.member={1} {2}\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30FB\u30E1\u30BD\u30C3\u30C9{0}\u306Fjava.lang.Object\u306E\u30E1\u30F3\u30D0\u30FC\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059
-
-# 0: type
-compiler.err.illegal.static.intf.meth.call=static\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u30FB\u30E1\u30BD\u30C3\u30C9\u30FB\u30B3\u30FC\u30EB\u304C\u4E0D\u6B63\u3067\u3059\n\u53D7\u4FE1\u5F0F\u306F\u578B\u4FEE\u98FE\u5B50''{0}''\u3067\u7F6E\u63DB\u3055\u308C\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: type, 1: message segment
-compiler.err.illegal.default.super.call=\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30B9\u30FC\u30D1\u30FC\u30FB\u30B3\u30FC\u30EB\u306E\u578B\u4FEE\u98FE\u5B50{0}\u304C\u4E0D\u6B63\u3067\u3059\n{1}
-
-# 0: symbol, 1: type
-compiler.misc.overridden.default={1}\u306E\u30E1\u30BD\u30C3\u30C9{0}\u306F\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3055\u308C\u307E\u3059
-
-# 0: symbol, 1: type or symbol
-compiler.misc.redundant.supertype=\u5197\u9577\u306A\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9{0}\u306F{1}\u306B\u3088\u3063\u3066\u62E1\u5F35\u3055\u308C\u307E\u3057\u305F
-
-compiler.err.unclosed.char.lit=\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.err.unclosed.comment=\u30B3\u30E1\u30F3\u30C8\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.err.unclosed.str.lit=\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: name
-compiler.err.unsupported.encoding=\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u306A\u3044\u30A8\u30F3\u30B3\u30FC\u30C7\u30A3\u30F3\u30B0\u3067\u3059: {0}
-
-compiler.err.io.exception=\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u53D6\u308A\u30A8\u30E9\u30FC\u3067\u3059: {0}
-
-# 0: name
-compiler.err.undef.label=\u30E9\u30D9\u30EB{0}\u306F\u672A\u5B9A\u7FA9\u3067\u3059
-
-# 0: message segment, 1: unused
-compiler.err.cant.apply.diamond={0}\u306E\u578B\u5F15\u6570\u3092\u63A8\u8AD6\u3067\u304D\u307E\u305B\u3093
-
-# 0: message segment or type, 1: message segment
-compiler.err.cant.apply.diamond.1={0}\u306E\u578B\u5F15\u6570\u3092\u63A8\u8AD6\u3067\u304D\u307E\u305B\u3093\n\u7406\u7531: {1}
-
-# 0: message segment or type, 1: message segment
-compiler.misc.cant.apply.diamond.1={0}\u306E\u578B\u5F15\u6570\u3092\u63A8\u8AD6\u3067\u304D\u307E\u305B\u3093\n\u7406\u7531: {1}
-
-compiler.err.unreachable.stmt=\u3053\u306E\u6587\u306B\u5236\u5FA1\u304C\u79FB\u308B\u3053\u3068\u306F\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.initializer.must.be.able.to.complete.normally=\u521D\u671F\u5316\u5B50\u306F\u6B63\u5E38\u306B\u5B8C\u4E86\u3067\u304D\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: type
-compiler.err.unreported.exception.need.to.catch.or.throw=\u4F8B\u5916{0}\u306F\u5831\u544A\u3055\u308C\u307E\u305B\u3093\u3002\u30B9\u30ED\u30FC\u3059\u308B\u306B\u306F\u3001\u6355\u6349\u307E\u305F\u306F\u5BA3\u8A00\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: type
-compiler.err.unreported.exception.default.constructor=\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u5185\u306B\u5831\u544A\u3055\u308C\u306A\u3044\u4F8B\u5916{0}\u304C\u5B58\u5728\u3057\u307E\u3059
-
-# 0: type, 1: name
-compiler.err.unreported.exception.implicit.close=\u5831\u544A\u3055\u308C\u306A\u3044\u4F8B\u5916{0}\u306F\u3001\u30B9\u30ED\u30FC\u3059\u308B\u306B\u306F\u6355\u6349\u307E\u305F\u306F\u5BA3\u8A00\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\n\u30EA\u30BD\u30FC\u30B9\u5909\u6570''{1}''\u3067\u306Eclose()\u306E\u6697\u9ED9\u7684\u306A\u30B3\u30FC\u30EB\u304B\u3089\u4F8B\u5916\u304C\u30B9\u30ED\u30FC\u3055\u308C\u307E\u3057\u305F
-
-compiler.err.unsupported.cross.fp.lit=16\u9032\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u306F\u3053\u306EVM\u3067\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.err.void.not.allowed.here=\u3053\u3053\u3067''void''\u578B\u3092\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: string
-compiler.err.wrong.number.type.args=\u578B\u5F15\u6570\u306E\u6570\u304C\u4E0D\u6B63\u3067\u3059\u3002{0}\u500B\u5FC5\u8981\u3067\u3059
-
-# 0: symbol
-compiler.err.var.might.already.be.assigned=\u5909\u6570{0}\u306F\u3059\u3067\u306B\u4EE3\u5165\u3055\u308C\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol
-compiler.err.var.might.not.have.been.initialized=\u5909\u6570{0}\u306F\u521D\u671F\u5316\u3055\u308C\u3066\u3044\u306A\u3044\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol
-compiler.err.var.not.initialized.in.default.constructor=\u5909\u6570{0}\u306F\u3001\u30C7\u30D5\u30A9\u30EB\u30C8\u30FB\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u3067\u521D\u671F\u5316\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: symbol
-compiler.err.var.might.be.assigned.in.loop=\u5909\u6570{0}\u306F\u30EB\u30FC\u30D7\u5185\u3067\u4EE3\u5165\u3055\u308C\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol, 1: message segment
-compiler.err.varargs.invalid.trustme.anno={0}\u6CE8\u91C8\u304C\u7121\u52B9\u3067\u3059\u3002{1}
-
-# 0: type
-compiler.misc.varargs.trustme.on.reifiable.varargs=\u53EF\u5909\u5F15\u6570\u8981\u7D20\u578B{0}\u306Freifiable\u578B\u3067\u3059\u3002
-
-# 0: symbol
-compiler.misc.varargs.trustme.on.non.varargs.meth=\u30E1\u30BD\u30C3\u30C9{0}\u306F\u53EF\u5909\u5F15\u6570\u30E1\u30BD\u30C3\u30C9\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002
-
-# 0: symbol
-compiler.misc.varargs.trustme.on.virtual.varargs=\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u30FB\u30E1\u30BD\u30C3\u30C9{0}\u306Ffinal\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002
-
-# 0: type, 1: symbol kind, 2: symbol
-compiler.misc.inaccessible.varargs.type=\u4EEE\u53EF\u5909\u5F15\u6570\u8981\u7D20\u578B{0}\u306F{1} {2}\u304B\u3089\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093
-
-# In the following string, {1} will always be the detail message from
-# java.io.IOException.
-# 0: symbol, 1: string
-compiler.err.class.cant.write={0}\u306E\u66F8\u8FBC\u307F\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {1}
-
-# In the following string, {0} is the name of the class in the Java source.
-# It really should be used two times..
-# 0: name
-compiler.err.class.public.should.be.in.file=\u30AF\u30E9\u30B9{0}\u306Fpublic\u3067\u3042\u308A\u3001\u30D5\u30A1\u30A4\u30EB{0}.java\u3067\u5BA3\u8A00\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-## All errors which do not refer to a particular line in the source code are
-## preceded by this string.
-compiler.err.error=\u30A8\u30E9\u30FC: 
-
-# The following error messages do not refer to a line in the source code.
-compiler.err.cant.read.file={0}\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093
-
-#####
-
-# Fatal Errors
-
-compiler.misc.fatal.err.no.java.lang=\u81F4\u547D\u7684\u30A8\u30E9\u30FC: \u30AF\u30E9\u30B9\u30D1\u30B9\u307E\u305F\u306F\u30D6\u30FC\u30C8\u30FB\u30AF\u30E9\u30B9\u30D1\u30B9\u3067\u30D1\u30C3\u30B1\u30FC\u30B8java.lang\u3092\u691C\u51FA\u3067\u304D\u307E\u305B\u3093
-
-compiler.misc.fatal.err.cant.locate.meth=\u81F4\u547D\u7684\u30A8\u30E9\u30FC: \u30E1\u30BD\u30C3\u30C9{0}\u3092\u691C\u51FA\u3067\u304D\u307E\u305B\u3093
-
-compiler.misc.fatal.err.cant.locate.field=\u81F4\u547D\u7684\u30A8\u30E9\u30FC: \u30D5\u30A3\u30FC\u30EB\u30C9{0}\u3092\u691C\u51FA\u3067\u304D\u307E\u305B\u3093
-
-compiler.misc.fatal.err.cant.locate.ctor=\u81F4\u547D\u7684\u30A8\u30E9\u30FC: {0}\u306E\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u3092\u691C\u51FA\u3067\u304D\u307E\u305B\u3093
-
-compiler.misc.fatal.err.cant.close=\u81F4\u547D\u7684\u30A8\u30E9\u30FC: \u30B3\u30F3\u30D1\u30A4\u30E9\u30FB\u30EA\u30BD\u30FC\u30B9\u3092\u9589\u3058\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093
-
-#####
-
-##
-## miscellaneous strings
-##
-
-compiler.misc.source.unavailable=(\u30BD\u30FC\u30B9\u304C\u5229\u7528\u4E0D\u53EF)
-
-compiler.misc.base.membership=\u3059\u3079\u3066\u306E\u30D9\u30FC\u30B9\u30FB\u30AF\u30E9\u30B9\u304C\u30E1\u30F3\u30D0\u30FC\u3067\u3059
-
-# 0: string, 1: string, 2: boolean
-compiler.misc.x.print.processor.info=\u30D7\u30ED\u30BB\u30C3\u30B5{0}\u306F{1}\u306B\u4E00\u81F4\u3057\u3001{2}\u3092\u8FD4\u3057\u307E\u3059\u3002
-
-# 0: number, 1: string, 2: set of symbol, 3: boolean
-compiler.misc.x.print.rounds=\u5F80\u5FA9{0}:\n\t\u5165\u529B\u30D5\u30A1\u30A4\u30EB: {1}\n\t\u6CE8\u91C8: {2}\n\t\u6700\u5F8C\u306E\u5F80\u5FA9: {3}
-
-#####
-
-## The following string will appear before all messages keyed as:
-## "compiler.note".
-
-compiler.note.compressed.diags=\u4E00\u90E8\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u306F\u7C21\u7565\u5316\u3055\u308C\u3066\u3044\u307E\u3059\u3002-Xdiags:verbose\u3067\u518D\u30B3\u30F3\u30D1\u30A4\u30EB\u3057\u3066\u5B8C\u5168\u306A\u51FA\u529B\u3092\u53D6\u5F97\u3057\u3066\u304F\u3060\u3055\u3044
-
-compiler.note.potential.lambda.found=\u3053\u306E\u533F\u540D\u5185\u90E8\u30AF\u30E9\u30B9\u3092\u30E9\u30E0\u30C0\u5F0F\u306B\u5909\u63DB\u3067\u304D\u307E\u3059\u3002
-
-# 0: boolean, 1: symbol
-compiler.note.lambda.stat=\u30E9\u30E0\u30C0\u5F0F\u3092\u5909\u63DB\u3057\u3066\u3044\u307E\u3059\n\u4EE3\u66FFmetafactory = {0}\n\u5408\u6210\u30E1\u30BD\u30C3\u30C9 = {1}
-
-# 0: boolean, 1: unused
-compiler.note.mref.stat=\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u3092\u5909\u63DB\u3057\u3066\u3044\u307E\u3059\n\u4EE3\u66FFmetafactory = {0}\n
-# 0: boolean, 1: symbol
-compiler.note.mref.stat.1=\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u3092\u5909\u63DB\u3057\u3066\u3044\u307E\u3059\n\u4EE3\u66FFmetafactory = {0}\n\u30D6\u30EA\u30C3\u30B8\u30FB\u30E1\u30BD\u30C3\u30C9 = {1}
-
-compiler.note.note=\u6CE8\u610F:
-
-# 0: file name
-compiler.note.deprecated.filename={0}\u306F\u975E\u63A8\u5968\u306EAPI\u3092\u4F7F\u7528\u307E\u305F\u306F\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3066\u3044\u307E\u3059\u3002
-
-compiler.note.deprecated.plural=\u4E00\u90E8\u306E\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306F\u975E\u63A8\u5968\u306EAPI\u3092\u4F7F\u7528\u307E\u305F\u306F\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3066\u3044\u307E\u3059\u3002
-
-# The following string may appear after one of the above deprecation
-# messages.
-compiler.note.deprecated.recompile=\u8A73\u7D30\u306F\u3001-Xlint:deprecation\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6307\u5B9A\u3057\u3066\u518D\u30B3\u30F3\u30D1\u30A4\u30EB\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-
-# 0: file name
-compiler.note.deprecated.filename.additional={0}\u306B\u975E\u63A8\u5968\u306EAPI\u306E\u8FFD\u52A0\u4F7F\u7528\u307E\u305F\u306F\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u304C\u3042\u308A\u307E\u3059\u3002
-
-compiler.note.deprecated.plural.additional=\u4E00\u90E8\u306E\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306F\u975E\u63A8\u5968\u306EAPI\u3092\u8FFD\u52A0\u4F7F\u7528\u307E\u305F\u306F\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3066\u3044\u307E\u3059\u3002
-
-# 0: file name
-compiler.note.unchecked.filename={0}\u306E\u64CD\u4F5C\u306F\u3001\u672A\u30C1\u30A7\u30C3\u30AF\u307E\u305F\u306F\u5B89\u5168\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002
-
-compiler.note.unchecked.plural=\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306E\u64CD\u4F5C\u306E\u3046\u3061\u3001\u672A\u30C1\u30A7\u30C3\u30AF\u307E\u305F\u306F\u5B89\u5168\u3067\u306F\u306A\u3044\u3082\u306E\u304C\u3042\u308A\u307E\u3059\u3002
-
-# The following string may appear after one of the above deprecation
-# messages.
-compiler.note.unchecked.recompile=\u8A73\u7D30\u306F\u3001-Xlint:unchecked\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6307\u5B9A\u3057\u3066\u518D\u30B3\u30F3\u30D1\u30A4\u30EB\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-
-# 0: file name
-compiler.note.unchecked.filename.additional={0}\u306B\u672A\u30C1\u30A7\u30C3\u30AF\u307E\u305F\u306F\u5B89\u5168\u3067\u306F\u306A\u3044\u64CD\u4F5C\u304C\u3055\u3089\u306B\u3042\u308A\u307E\u3059\u3002
-
-compiler.note.unchecked.plural.additional=\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306E\u64CD\u4F5C\u306E\u3046\u3061\u3001\u672A\u30C1\u30A7\u30C3\u30AF\u307E\u305F\u306F\u5B89\u5168\u3067\u306F\u306A\u3044\u3082\u306E\u304C\u3055\u3089\u306B\u3042\u308A\u307E\u3059\u3002
-
-# 0: file name
-compiler.note.sunapi.filename={0}\u306F\u3001\u4ECA\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u524A\u9664\u3055\u308C\u308B\u53EF\u80FD\u6027\u304C\u3042\u308B\u5185\u90E8\u6240\u6709\u306EAPI\u3092\u4F7F\u7528\u3057\u3066\u3044\u307E\u3059\u3002
-
-compiler.note.sunapi.plural=\u4E00\u90E8\u306E\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306F\u3001\u4ECA\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u524A\u9664\u3055\u308C\u308B\u53EF\u80FD\u6027\u304C\u3042\u308B\u5185\u90E8\u6240\u6709\u306EAPI\u3092\u4F7F\u7528\u3057\u3066\u3044\u307E\u3059\u3002
-
-# The following string may appear after one of the above sunapi messages.
-compiler.note.sunapi.recompile=\u8A73\u7D30\u306F\u3001-Xlint:sunapi\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6307\u5B9A\u3057\u3066\u518D\u30B3\u30F3\u30D1\u30A4\u30EB\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-
-# 0: file name
-compiler.note.sunapi.filename.additional={0}\u306F\u3001\u4ECA\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u524A\u9664\u3055\u308C\u308B\u53EF\u80FD\u6027\u304C\u3042\u308B\u8FFD\u52A0\u306E\u5185\u90E8\u6240\u6709\u306EAPI\u3092\u4F7F\u7528\u3057\u3066\u3044\u307E\u3059\u3002
-
-compiler.note.sunapi.plural.additional=\u4E00\u90E8\u306E\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306F\u3001\u4ECA\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u524A\u9664\u3055\u308C\u308B\u53EF\u80FD\u6027\u304C\u3042\u308B\u5185\u90E8\u6240\u6709\u306EAPI\u3092\u8FFD\u52A0\u3067\u4F7F\u7528\u3057\u3066\u3044\u307E\u3059\u3002
-
-# Notes related to annotation processing
-
-# Print a client-generated note; assumed to be localized, no translation required
-# 0: string
-compiler.note.proc.messager={0}
-
-#####
-
-# 0: number
-compiler.misc.count.error=\u30A8\u30E9\u30FC{0}\u500B
-
-# 0: number
-compiler.misc.count.error.plural=\u30A8\u30E9\u30FC{0}\u500B
-
-# 0: number
-compiler.misc.count.warn=\u8B66\u544A{0}\u500B
-
-# 0: number
-compiler.misc.count.warn.plural=\u8B66\u544A{0}\u500B
-
-compiler.misc.version.not.available=(\u30D0\u30FC\u30B8\u30E7\u30F3\u60C5\u5831\u304C\u3042\u308A\u307E\u305B\u3093)
-
-## extra output when using -verbose (JavaCompiler)
-
-# 0: symbol
-compiler.misc.verbose.checking.attribution=[{0}\u3092\u78BA\u8A8D\u4E2D]
-
-# 0: string
-compiler.misc.verbose.parsing.done=[{0}\u30DF\u30EA\u79D2\u3067\u69CB\u6587\u89E3\u6790\u5B8C\u4E86]
-
-# 0: file name
-compiler.misc.verbose.parsing.started=[{0}\u3092\u69CB\u6587\u89E3\u6790\u958B\u59CB]
-
-# 0: string
-compiler.misc.verbose.total=[\u5408\u8A08{0}\u30DF\u30EA\u79D2]
-
-# 0: file name
-compiler.misc.verbose.wrote.file=[{0}\u3092\u66F8\u8FBC\u307F\u5B8C\u4E86]
-
-## extra output when using -verbose (Retro)
-compiler.misc.verbose.retro=[{0}\u3092\u7D44\u66FF\u3048\u4E2D]
-
-compiler.misc.verbose.retro.with=\t{0}\u3092{1}\u3067\u7D44\u66FF\u3048\u4E2D\u3067\u3059
-
-compiler.misc.verbose.retro.with.list=\t{0}\u3092\u578B\u30D1\u30E9\u30E1\u30FC\u30BF{1}\u3001\u30B9\u30FC\u30D1\u30FC\u30BF\u30A4\u30D7{2}\u3001\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9{3}\u3067\u7D44\u66FF\u3048\u4E2D\u3067\u3059
-
-## extra output when using -verbose (code/ClassReader)
-# 0: string
-compiler.misc.verbose.loading=[{0}\u3092\u8AAD\u8FBC\u307F\u4E2D]
-
-# 0: string
-compiler.misc.verbose.sourcepath=[\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u691C\u7D22\u30D1\u30B9: {0}]
-
-# 0: string
-compiler.misc.verbose.classpath=[\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u691C\u7D22\u30D1\u30B9: {0}]
-
-## extra output when using -checkclassfile (code/ClassReader)
-compiler.misc.ccf.found.later.version=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB{0}\u306B\u4E88\u60F3\u5916\u306E\u65B0\u30D0\u30FC\u30B8\u30E7\u30F3\u304C\u3042\u308A\u307E\u3059
-
-compiler.misc.ccf.unrecognized.attribute={0}\u306F\u8A8D\u8B58\u3055\u308C\u306A\u3044\u5C5E\u6027\u3067\u3059
-
-## extra output when using -prompt (util/Log)
-compiler.misc.resume.abort=R)\u518D\u958B,A)\u4E2D\u6B62>
-
-#####
-
-##
-## warnings
-##
-
-## All warning messages are preceded by the following string.
-compiler.warn.warning=\u8B66\u544A: 
-
-## Warning messages may also include the following prefix to identify a
-## lint option
-# 0: option name
-compiler.warn.lintOption=[{0}] 
-
-# 0: symbol
-compiler.warn.constant.SVUID=serialVersionUID\u306F\u30AF\u30E9\u30B9{0}\u306E\u5B9A\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: file name
-compiler.warn.dir.path.element.not.found=\u4E0D\u6B63\u306A\u30D1\u30B9\u8981\u7D20"{0}": \u305D\u306E\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u306F\u5B58\u5728\u3057\u307E\u305B\u3093
-
-compiler.warn.finally.cannot.complete=finally\u7BC0\u304C\u6B63\u5E38\u306B\u5B8C\u4E86\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol
-compiler.warn.has.been.deprecated={1}\u306E{0}\u306F\u975E\u63A8\u5968\u306B\u306A\u308A\u307E\u3057\u305F
-
-# 0: symbol
-compiler.warn.sun.proprietary={0}\u306F\u5185\u90E8\u6240\u6709\u306EAPI\u3067\u3042\u308A\u3001\u4ECA\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u524A\u9664\u3055\u308C\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-compiler.warn.illegal.char.for.encoding=\u3053\u306E\u6587\u5B57\u306F\u3001\u30A8\u30F3\u30B3\u30FC\u30C7\u30A3\u30F3\u30B0{0}\u306B\u30DE\u30C3\u30D7\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol
-compiler.warn.improper.SVUID=serialVersionUID\u306F\u3001\u30AF\u30E9\u30B9{0}\u306Bstatic final\u3092\u5BA3\u8A00\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: type, 1: type
-compiler.warn.inexact.non-varargs.call=\u6700\u7D42\u30D1\u30E9\u30E1\u30FC\u30BF\u306E\u4E0D\u6B63\u78BA\u306A\u5F15\u6570\u578B\u3092\u6301\u3063\u305F\u53EF\u5909\u5F15\u6570\u30E1\u30BD\u30C3\u30C9\u306E\u975E\u53EF\u5909\u5F15\u6570\u547C\u51FA\u3057\u3002\n\u53EF\u5909\u5F15\u6570\u547C\u51FA\u3057\u306B\u95A2\u3057\u3066\u306F{0}\u306B\u30AD\u30E3\u30B9\u30C8\u3057\u307E\u3059\u3002\n\u975E\u53EF\u5909\u5F15\u6570\u547C\u51FA\u3057\u306B\u95A2\u3057\u3066\u306F{1}\u306B\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u3053\u306E\u8B66\u544A\u3092\u51FA\u3055\u306A\u3044\u3088\u3046\u306B\u3057\u307E\u3059
-
-# 0: list of type
-compiler.warn.unreachable.catch=catch\u53E5\u306B\u79FB\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\n\u30B9\u30ED\u30FC\u3055\u308C\u305F\u30BF\u30A4\u30D7{0}\u306F\u3059\u3067\u306B\u6355\u6349\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: list of type
-compiler.warn.unreachable.catch.1=catch\u53E5\u306B\u79FB\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\n\u30B9\u30ED\u30FC\u3055\u308C\u305F\u30BF\u30A4\u30D7{0}\u306F\u3059\u3067\u306B\u6355\u6349\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: symbol
-compiler.warn.long.SVUID=serialVersionUID\u306F\u3001\u30AF\u30E9\u30B9{0}\u306Elong\u578B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol
-compiler.warn.missing.SVUID=\u76F4\u5217\u5316\u53EF\u80FD\u306A\u30AF\u30E9\u30B9{0}\u306B\u306F\u3001serialVersionUID\u304C\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.warn.potentially.ambiguous.overload={1}\u5185\u306E{0}\u306F{3}\u5185\u306E{2}\u3068\u77DB\u76FE\u3059\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-# 0: message segment
-compiler.warn.override.varargs.missing={0}\u3002\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3055\u308C\u305F\u30E1\u30BD\u30C3\u30C9\u306B\u306F''...''\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: message segment
-compiler.warn.override.varargs.extra={0}\u3002\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3066\u3044\u308B\u30E1\u30BD\u30C3\u30C9\u306B\u306F''...''\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.warn.override.bridge={0}\u3002\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3055\u308C\u305F\u30E1\u30BD\u30C3\u30C9\u306F\u30D6\u30EA\u30C3\u30B8\u30FB\u30E1\u30BD\u30C3\u30C9\u3067\u3059
-
-# 0: symbol
-compiler.warn.pkg-info.already.seen=package-info.java\u30D5\u30A1\u30A4\u30EB\u304C\u3059\u3067\u306B\u30D1\u30C3\u30B1\u30FC\u30B8{0}\u7528\u306B\u8868\u793A\u3055\u308C\u3066\u3044\u307E\u3059
-
-# 0: file name
-compiler.warn.path.element.not.found=\u4E0D\u6B63\u306A\u30D1\u30B9\u8981\u7D20"{0}": \u305D\u306E\u30D5\u30A1\u30A4\u30EB\u307E\u305F\u306F\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u306F\u3042\u308A\u307E\u305B\u3093
-
-compiler.warn.possible.fall-through.into.case=case\u306Bfall-through\u3059\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-# 0: type
-compiler.warn.redundant.cast={0}\u3078\u306E\u5197\u9577\u306A\u30AD\u30E3\u30B9\u30C8\u3067\u3059
-
-# 0: number
-compiler.warn.position.overflow=\u4F4D\u7F6E\u30A8\u30F3\u30B3\u30FC\u30C7\u30A3\u30F3\u30B0\u304C\u884C{0}\u3067\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u307E\u3059
-
-# 0: file name, 1: number, 2: number
-compiler.warn.big.major.version={0}: \u30E1\u30B8\u30E3\u30FC\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3{1}\u306F\u3001\u3053\u306E\u30B3\u30F3\u30D1\u30A4\u30E9\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u308B\u6700\u65B0\u306E\u30E1\u30B8\u30E3\u30FC\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3{2}\u3088\u308A\u65B0\u3057\u3044\u3067\u3059\u3002\n\u30B3\u30F3\u30D1\u30A4\u30E9\u306E\u30A2\u30C3\u30D7\u30B0\u30EC\u30FC\u30C9\u3092\u304A\u85A6\u3081\u3057\u307E\u3059\u3002
-
-# 0: symbol kind, 1: symbol
-compiler.warn.static.not.qualified.by.type=static {0}\u306F\u5F0F\u3067\u306F\u306A\u304F\u578B\u540D{1}\u3067\u4FEE\u98FE\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: string
-compiler.warn.source.no.bootclasspath=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30D1\u30B9\u304C-source {0}\u3068\u4E00\u7DD2\u306B\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-# 0: string
-compiler.warn.option.obsolete.source=\u30BD\u30FC\u30B9\u5024{0}\u306F\u5EC3\u6B62\u3055\u308C\u3066\u3044\u3066\u3001\u4ECA\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u524A\u9664\u3055\u308C\u308B\u4E88\u5B9A\u3067\u3059
-
-# 0: string
-compiler.warn.option.obsolete.target=\u30BF\u30FC\u30B2\u30C3\u30C8\u5024{0}\u306F\u5EC3\u6B62\u3055\u308C\u3066\u3044\u3066\u3001\u4ECA\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u524A\u9664\u3055\u308C\u308B\u4E88\u5B9A\u3067\u3059
-
-compiler.warn.option.obsolete.suppression=\u5EC3\u6B62\u3055\u308C\u305F\u30AA\u30D7\u30B7\u30E7\u30F3\u306B\u3064\u3044\u3066\u306E\u8B66\u544A\u3092\u8868\u793A\u3057\u306A\u3044\u3088\u3046\u306B\u3059\u308B\u306B\u306F\u3001-Xlint:\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002
-
-# 0: name, 1: number, 2: number, 3: number, 4: number
-compiler.warn.future.attr=\u30D0\u30FC\u30B8\u30E7\u30F3{1}.{2}\u306E\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3067\u5C0E\u5165\u3055\u308C\u305F{0}\u5C5E\u6027\u306F\u3001\u30D0\u30FC\u30B8\u30E7\u30F3{3}.{4}\u306E\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3067\u306F\u7121\u8996\u3055\u308C\u307E\u3059
-
-# Warnings related to annotation processing
-# 0: name
-compiler.warn.proc.package.does.not.exist=\u30D1\u30C3\u30B1\u30FC\u30B8{0}\u306F\u5B58\u5728\u3057\u307E\u305B\u3093
-
-# 0: name
-compiler.warn.proc.file.reopening=''{0}''\u7528\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u8907\u6570\u56DE\u4F5C\u6210\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u307E\u3059
-
-# 0: name
-compiler.warn.proc.type.already.exists=\u30BF\u30A4\u30D7''{0}''\u306E\u30D5\u30A1\u30A4\u30EB\u306F\u3059\u3067\u306B\u30BD\u30FC\u30B9\u30FB\u30D1\u30B9\u307E\u305F\u306F\u30AF\u30E9\u30B9\u30D1\u30B9\u306B\u5B58\u5728\u3057\u307E\u3059
-
-# 0: name
-compiler.warn.proc.type.recreate=\u30BF\u30A4\u30D7''{0}''\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u8907\u6570\u56DE\u4F5C\u6210\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u307E\u3059
-
-# 0: string
-compiler.warn.proc.illegal.file.name=\u7121\u52B9\u306A\u540D\u524D''{0}''\u306E\u30D5\u30A1\u30A4\u30EB\u306F\u4F5C\u6210\u3067\u304D\u307E\u305B\u3093\u3002
-
-# 0: string, 1: string
-compiler.warn.proc.suspicious.class.name=\u540D\u524D\u304C{1}\u3067\u7D42\u308F\u308B\u578B\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u4F5C\u6210\u3057\u3066\u3044\u307E\u3059: ''{0}''
-
-# 0: name
-compiler.warn.proc.file.create.last.round=\u6700\u5F8C\u306B\u4F5C\u6210\u3055\u308C\u305F\u30BF\u30A4\u30D7''{0}''\u306E\u30D5\u30A1\u30A4\u30EB\u306F\u6CE8\u91C8\u51E6\u7406\u306B\u6E21\u3055\u308C\u307E\u305B\u3093\u3002
-
-# 0: string, 1: string
-compiler.warn.proc.malformed.supported.string=\u30D7\u30ED\u30BB\u30C3\u30B5''{1}''\u304C\u8FD4\u3057\u305F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u308B\u6CE8\u91C8\u578B\u306E\u6587\u5B57\u5217''{0}''\u304C\u4E0D\u6B63\u3067\u3059
-
-# 0: set of string
-compiler.warn.proc.annotations.without.processors=\u3053\u308C\u3089\u306E\u6CE8\u91C8\u3092\u8981\u6C42\u3059\u308B\u30D7\u30ED\u30BB\u30C3\u30B5\u306F\u3042\u308A\u307E\u305B\u3093\u3067\u3057\u305F: {0}
-
-# 0: source version, 1: string, 2: string
-compiler.warn.proc.processor.incompatible.source.version=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5''{1}''\u304B\u3089-source ''{2}''\u3088\u308A\u5C0F\u3055\u3044\u30BD\u30FC\u30B9\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3''{0}''\u304C\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u3059
-
-compiler.warn.proc.proc-only.requested.no.procs=\u30B3\u30F3\u30D1\u30A4\u30EB\u306A\u3057\u306E\u6CE8\u91C8\u51E6\u7406\u304C\u30EA\u30AF\u30A8\u30B9\u30C8\u3055\u308C\u307E\u3057\u305F\u304C\u3001\u30D7\u30ED\u30BB\u30C3\u30B5\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3067\u3057\u305F\u3002
-
-compiler.warn.proc.use.implicit=\u6697\u9ED9\u7684\u306B\u30B3\u30F3\u30D1\u30A4\u30EB\u3055\u308C\u305F\u30D5\u30A1\u30A4\u30EB\u306F\u6CE8\u91C8\u51E6\u7406\u306B\u6E21\u3055\u308C\u307E\u305B\u3093\u3002\n-implicit\u3092\u4F7F\u7528\u3057\u6697\u9ED9\u7684\u30B3\u30F3\u30D1\u30A4\u30EB\u306E\u30DD\u30EA\u30B7\u30FC\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-
-compiler.warn.proc.use.proc.or.implicit=\u6697\u9ED9\u7684\u306B\u30B3\u30F3\u30D1\u30A4\u30EB\u3055\u308C\u305F\u30D5\u30A1\u30A4\u30EB\u306F\u6CE8\u91C8\u51E6\u7406\u306B\u6E21\u3055\u308C\u307E\u305B\u3093\u3002\n-proc:none\u3092\u4F7F\u7528\u3057\u6CE8\u91C8\u51E6\u7406\u3092\u7121\u52B9\u306B\u3059\u308B\u304B -implicit\u3092\u4F7F\u7528\u3057\u6697\u9ED9\u7684\u30B3\u30F3\u30D1\u30A4\u30EB\u306E\u30DD\u30EA\u30B7\u30FC\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-
-# Print a client-generated warning; assumed to be localized, no translation required
-# 0: string
-compiler.warn.proc.messager={0}
-
-# 0: set of name
-compiler.warn.proc.unclosed.type.files=\u30BF\u30A4\u30D7''{0}''\u306E\u30D5\u30A1\u30A4\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u3053\u308C\u3089\u306E\u30BF\u30A4\u30D7\u306F\u6CE8\u91C8\u51E6\u7406\u3055\u308C\u307E\u305B\u3093
-
-# 0: string
-compiler.warn.proc.unmatched.processor.options=\u6B21\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u306F\u3069\u306E\u30D7\u30ED\u30BB\u30C3\u30B5\u3067\u3082\u8A8D\u8B58\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F: ''{0}''
-
-compiler.warn.try.explicit.close.call=\u81EA\u52D5\u30AF\u30ED\u30FC\u30BA\u53EF\u80FD\u306A\u30EA\u30BD\u30FC\u30B9\u306B\u304A\u3051\u308Bclose()\u306E\u660E\u793A\u7684\u547C\u51FA\u3057
-
-# 0: symbol
-compiler.warn.try.resource.not.referenced=\u81EA\u52D5\u30AF\u30ED\u30FC\u30BA\u53EF\u80FD\u306A\u30EA\u30BD\u30FC\u30B9{0}\u306F\u5BFE\u5FDC\u3059\u308Btry\u6587\u306E\u672C\u4F53\u3067\u306F\u53C2\u7167\u3055\u308C\u307E\u305B\u3093
-
-# 0: type
-compiler.warn.try.resource.throws.interrupted.exc=\u81EA\u52D5\u30AF\u30ED\u30FC\u30BA\u53EF\u80FD\u306A\u30EA\u30BD\u30FC\u30B9{0}\u306B\u3001InterruptedException\u3092\u30B9\u30ED\u30FC\u3059\u308B\u53EF\u80FD\u6027\u304C\u3042\u308B\u30E1\u30F3\u30D0\u30FC\u30FB\u30E1\u30BD\u30C3\u30C9close()\u304C\u3042\u308A\u307E\u3059
-
-compiler.warn.unchecked.assign={0}\u304B\u3089{1}\u3078\u306E\u7121\u691C\u67FB\u4EE3\u5165\u3067\u3059
-
-# 0: symbol, 1: type
-compiler.warn.unchecked.assign.to.var=raw\u578B{1}\u306E\u30E1\u30F3\u30D0\u30FC\u3068\u3057\u3066\u5909\u6570{0}\u3078\u306E\u7121\u691C\u67FB\u4EE3\u5165\u3067\u3059
-
-# 0: symbol, 1: type
-compiler.warn.unchecked.call.mbr.of.raw.type=raw\u578B{1}\u306E\u30E1\u30F3\u30D0\u30FC\u3068\u3057\u3066\u306E{0}\u3078\u306E\u7121\u691C\u67FB\u547C\u51FA\u3057\u3067\u3059
-
-compiler.warn.unchecked.cast.to.type=\u578B{0}\u3078\u306E\u7121\u691C\u67FB\u30AD\u30E3\u30B9\u30C8\u3067\u3059
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list of type, 4: symbol kind, 5: symbol
-compiler.warn.unchecked.meth.invocation.applied=\u7121\u691C\u67FB\u30E1\u30BD\u30C3\u30C9\u547C\u51FA\u3057: {4} {5}\u306E{0} {1}\u306F\u6307\u5B9A\u3055\u308C\u305F\u578B\u306B\u9069\u7528\u3055\u308C\u307E\u3059\n\u671F\u5F85\u5024: {2}\n\u691C\u51FA\u5024: {3}
-
-# 0: type
-compiler.warn.unchecked.generic.array.creation=\u578B{0}\u306E\u53EF\u5909\u5F15\u6570\u30D1\u30E9\u30E1\u30FC\u30BF\u306B\u5BFE\u3059\u308B\u7DCF\u79F0\u578B\u914D\u5217\u306E\u7121\u691C\u67FB\u4F5C\u6210\u3067\u3059
-
-# 0: type
-compiler.warn.unchecked.varargs.non.reifiable.type=\u30D1\u30E9\u30E1\u30FC\u30BF\u5316\u3055\u308C\u305F\u53EF\u5909\u5F15\u6570\u578B{0}\u304B\u3089\u306E\u30D2\u30FC\u30D7\u6C5A\u67D3\u306E\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol
-compiler.warn.varargs.unsafe.use.varargs.param=\u53EF\u5909\u5F15\u6570\u30E1\u30BD\u30C3\u30C9\u306F\u3001\u578B\u60C5\u5831\u4FDD\u6301\u53EF\u80FD\u3067\u306A\u3044\u53EF\u5909\u5F15\u6570\u30D1\u30E9\u30E1\u30FC\u30BF{0}\u304B\u3089\u306E\u30D2\u30FC\u30D7\u6C5A\u67D3\u306E\u539F\u56E0\u3068\u306A\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-compiler.warn.missing.deprecated.annotation=\u975E\u63A8\u5968\u306E\u9805\u76EE\u306F@Deprecated\u3067\u6CE8\u91C8\u304C\u4ED8\u3051\u3089\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.warn.invalid.archive.file=\u30D1\u30B9\u4E0A\u306E\u4E88\u671F\u3057\u306A\u3044\u30D5\u30A1\u30A4\u30EB: {0}
-
-compiler.warn.unexpected.archive.file=\u30A2\u30FC\u30AB\u30A4\u30D6\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u4E88\u671F\u3057\u306A\u3044\u62E1\u5F35\u5B50: {0}
-
-compiler.warn.div.zero=\u30BC\u30ED\u3067\u9664\u7B97
-
-compiler.warn.empty.if=if\u4EE5\u964D\u304C\u7A7A\u306E\u6587\u3067\u3059
-
-compiler.warn.annotation.method.not.found=\u30BF\u30A4\u30D7''{0}''\u5185\u306B\u6CE8\u91C8\u30E1\u30BD\u30C3\u30C9''{1}()''\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093
-
-compiler.warn.annotation.method.not.found.reason=\u30BF\u30A4\u30D7''{0}''\u5185\u306B\u6CE8\u91C8\u30E1\u30BD\u30C3\u30C9''{1}()''\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {2}
-
-# 0: symbol, 1: name
-compiler.warn.unknown.enum.constant=\u4E0D\u660E\u306A\u5217\u6319\u578B\u5B9A\u6570\u3067\u3059{1}.{2}
-
-# 0: symbol, 1: name, 2: message segment
-compiler.warn.unknown.enum.constant.reason=\u4E0D\u660E\u306A\u5217\u6319\u578B\u5B9A\u6570\u3067\u3059{1}.{2}\n\u7406\u7531: {3}
-
-# 0: type, 1: type
-compiler.warn.raw.class.use=raw\u578B\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F: {0}\n\u6C4E\u7528\u30AF\u30E9\u30B9{1}\u306E\u578B\u5F15\u6570\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: unused, 1: unused
-compiler.warn.diamond.redundant.args=\u65B0\u3057\u3044\u5F0F\u306E\u578B\u5F15\u6570\u304C\u91CD\u8907\u3057\u3066\u3044\u307E\u3059(\u304B\u308F\u308A\u306B\u30C0\u30A4\u30E4\u30E2\u30F3\u30C9\u6F14\u7B97\u5B50\u3092\u4F7F\u7528\u3057\u307E\u3059)\u3002
-
-# 0: type, 1: type
-compiler.warn.diamond.redundant.args.1=\u65B0\u3057\u3044\u5F0F\u306E\u578B\u5F15\u6570\u304C\u91CD\u8907\u3057\u3066\u3044\u307E\u3059(\u304B\u308F\u308A\u306B\u30C0\u30A4\u30E4\u30E2\u30F3\u30C9\u6F14\u7B97\u5B50\u3092\u4F7F\u7528\u3057\u307E\u3059)\u3002\n\u660E\u793A\u7684: {0}\n\u63A8\u8AD6: {1}
-
-# 0: symbol, 1: message segment
-compiler.warn.varargs.redundant.trustme.anno={0}\u6CE8\u91C8\u304C\u5197\u9577\u3067\u3059\u3002{1}
-
-# 0: symbol
-compiler.warn.access.to.sensitive.member.from.serializable.element=\u76F4\u5217\u5316\u53EF\u80FD\u8981\u7D20\u304B\u3089\u6A5F\u5BC6\u30E1\u30F3\u30D0\u30FC{0}\u3078\u306E\u30A2\u30AF\u30BB\u30B9\u306F\u3001\u4FE1\u983C\u3067\u304D\u306A\u3044\u30B3\u30FC\u30C9\u304B\u3089\u30D1\u30D6\u30EA\u30C3\u30AF\u306B\u30A2\u30AF\u30BB\u30B9\u53EF\u80FD\u3067\u3042\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059
-
-#####
-
-## The following are tokens which are non-terminals in the language. They should
-## be named as JLS3 calls them when translated to the appropriate language.
-compiler.misc.token.identifier=<identifier>
-
-compiler.misc.token.character=<character>
-
-compiler.misc.token.string=<string>
-
-compiler.misc.token.integer=<integer>
-
-compiler.misc.token.long-integer=<long integer>
-
-compiler.misc.token.float=<float>
-
-compiler.misc.token.double=<double>
-
-compiler.misc.token.bad-symbol=<bad symbol>
-
-compiler.misc.token.end-of-input=<end of input>
-
-## The argument to the following string will always be one of the following:
-## 1. one of the above non-terminals
-## 2. a keyword (JLS1.8)
-## 3. a boolean literal (JLS3.10.3)
-## 4. the null literal (JLS3.10.7)
-## 5. a Java separator (JLS3.11)
-## 6. an operator (JLS3.12)
-##
-## This is the only place these tokens will be used.
-# 0: token
-compiler.err.expected={0}\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: token, 1: token
-compiler.err.expected2={0}\u307E\u305F\u306F{1}\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: token, 1: token, 2: token
-compiler.err.expected3={0}\u3001{1}\u307E\u305F\u306F{2}\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.premature.eof=\u69CB\u6587\u89E3\u6790\u4E2D\u306B\u30D5\u30A1\u30A4\u30EB\u306E\u7D42\u308F\u308A\u306B\u79FB\u308A\u307E\u3057\u305F
-
-## The following are related in form, but do not easily fit the above paradigm.
-compiler.err.dot.class.expected=''.class''\u304C\u3042\u308A\u307E\u305B\u3093
-
-## The argument to this string will always be either 'case' or 'default'.
-# 0: token
-compiler.err.orphaned={0}\u306B\u306F\u89AA\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: name
-compiler.misc.anonymous.class=<anonymous {0}>
-
-# 0: name, 1: type
-compiler.misc.type.captureof={1}\u306E\u30AD\u30E3\u30D7\u30C1\u30E3#{0}
-
-compiler.misc.type.captureof.1=\u30AD\u30E3\u30D7\u30C1\u30E3#{0}
-
-compiler.misc.type.none=<none>
-
-compiler.misc.unnamed.package=\u540D\u524D\u306E\u306A\u3044\u30D1\u30C3\u30B1\u30FC\u30B8
-
-#####
-
-# 0: symbol, 1: message segment
-compiler.err.cant.access={0}\u306B\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093\n{1}
-
-# 0: file name, 1: expected CP entry type, 2: constant pool index
-compiler.misc.bad.const.pool.entry={0}\u306E\u5B9A\u6570\u30D7\u30FC\u30EB\u30FB\u30A8\u30F3\u30C8\u30EA\u304C\u4E0D\u6B63\u3067\u3059\n\u7D22\u5F15{2}\u3067\u306F{1}\u304C\u5FC5\u8981\u3067\u3059
-
-# 0: file name, 1: message segment
-compiler.misc.bad.class.file.header=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB{0}\u306F\u4E0D\u6B63\u3067\u3059\n{1}\n\u524A\u9664\u3059\u308B\u304B\u3001\u30AF\u30E9\u30B9\u30D1\u30B9\u306E\u6B63\u3057\u3044\u30B5\u30D6\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u306B\u3042\u308B\u304B\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-
-# 0: file name, 1: message segment
-compiler.misc.bad.source.file.header=\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB{0}\u306F\u4E0D\u6B63\u3067\u3059\n{1}\n\u524A\u9664\u3059\u308B\u304B\u3001\u30BD\u30FC\u30B9\u30FB\u30D1\u30B9\u306E\u6B63\u3057\u3044\u30B5\u30D6\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u306B\u3042\u308B\u304B\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-
-## The following are all possible strings for the second argument ({1}) of the
-## above strings.
-compiler.misc.bad.class.signature=\u30AF\u30E9\u30B9{0}\u306E\u30B7\u30B0\u30CD\u30C1\u30E3\u304C\u4E0D\u6B63\u3067\u3059
-
-#0: symbol, 1: symbol
-compiler.misc.bad.enclosing.class={0}\u306E\u5185\u90E8\u30AF\u30E9\u30B9\u304C\u4E0D\u6B63\u3067\u3059: {1}
-
-# 0: symbol
-compiler.misc.bad.enclosing.method=\u30AF\u30E9\u30B9{0}\u306E\u56F2\u3093\u3067\u3044\u308B\u30E1\u30BD\u30C3\u30C9\u5C5E\u6027\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.misc.bad.runtime.invisible.param.annotations=RuntimeInvisibleParameterAnnotations\u5C5E\u6027\u304C\u4E0D\u6B63\u3067\u3059: {0}
-
-compiler.misc.bad.const.pool.tag=\u5B9A\u6570\u30D7\u30FC\u30EB\u30FB\u30BF\u30B0{0}\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.misc.bad.const.pool.tag.at=\u5B9A\u6570\u30D7\u30FC\u30EB\u30FB\u30BF\u30B0{1}\u3067\u306E{0}\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.misc.bad.signature=\u30B7\u30B0\u30CD\u30C1\u30E3{0}\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.misc.bad.type.annotation.value=\u6CE8\u91C8\u30BF\u30FC\u30B2\u30C3\u30C8\u578B\u306E\u5024\u306E\u578B\u304C\u4E0D\u6B63\u3067\u3059: {0}
-
-compiler.misc.class.file.wrong.class=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB{0}\u306B\u4E0D\u6B63\u306A\u30AF\u30E9\u30B9\u304C\u3042\u308A\u307E\u3059
-
-compiler.misc.class.file.not.found={0}\u306E\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093
-
-# 0: classfile major version, 1: classfile minor version
-compiler.misc.invalid.default.interface=\u30D0\u30FC\u30B8\u30E7\u30F3{0}.{1}\u306E\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306B\u30C7\u30D5\u30A9\u30EB\u30C8\u30FB\u30E1\u30BD\u30C3\u30C9\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F
-
-# 0: classfile major version, 1: classfile minor version
-compiler.misc.invalid.static.interface=\u30D0\u30FC\u30B8\u30E7\u30F3{0}.{1}\u306E\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306Bstatic\u30E1\u30BD\u30C3\u30C9\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F
-
-# 0: name
-compiler.misc.file.doesnt.contain.class=\u30D5\u30A1\u30A4\u30EB\u306B\u30AF\u30E9\u30B9{0}\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.misc.file.does.not.contain.package=\u30D5\u30A1\u30A4\u30EB\u306B\u30D1\u30C3\u30B1\u30FC\u30B8{0}\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.misc.illegal.start.of.class.file=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u958B\u59CB\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.misc.unable.to.access.file=\u30D5\u30A1\u30A4\u30EB{0}\u306B\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093
-
-compiler.misc.unicode.str.not.supported=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u5185\u306EUnicode\u6587\u5B57\u5217\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.misc.undecl.type.var=\u578B\u5909\u6570{0}\u306F\u5BA3\u8A00\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.misc.wrong.version=\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u30D0\u30FC\u30B8\u30E7\u30F3{0}.{1}\u306F\u4E0D\u6B63\u3067\u3059\u3002{2}.{3}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-#####
-
-# 0: type, 1: type or symbol
-compiler.err.not.within.bounds=\u578B\u5F15\u6570{0}\u306F\u578B\u5909\u6570{1}\u306E\u5883\u754C\u5185\u306B\u3042\u308A\u307E\u305B\u3093
-
-## The following are all possible strings for the second argument ({1}) of the
-## above string.
-
-## none yet...
-
-#####
-
-# 0: message segment
-compiler.err.prob.found.req=\u4E0D\u9069\u5408\u306A\u578B: {0}
-
-# 0: message segment
-compiler.misc.prob.found.req=\u4E0D\u9069\u5408\u306A\u578B: {0}
-
-# 0: message segment, 1: type, 2: type
-compiler.warn.prob.found.req={0}\n\u671F\u5F85\u5024: {2}\n\u691C\u51FA\u5024:    {1}
-
-# 0: type, 1: type
-compiler.misc.inconvertible.types={0}\u3092{1}\u306B\u5909\u63DB\u3067\u304D\u307E\u305B\u3093:
-
-# 0: type, 1: type
-compiler.misc.possible.loss.of.precision=\u7CBE\u5EA6\u304C\u5931\u308F\u308C\u308B\u53EF\u80FD\u6027\u304C\u3042\u308B{0}\u304B\u3089{1}\u3078\u306E\u5909\u63DB
-
-compiler.misc.unchecked.assign=\u7121\u691C\u67FB\u5909\u63DB
-
-# compiler.misc.storecheck=\
-#     assignment might cause later store checks to fail
-# compiler.misc.unchecked=\
-#     assigned array cannot dynamically check its stores
-compiler.misc.unchecked.cast.to.type=\u7121\u691C\u67FB\u30AD\u30E3\u30B9\u30C8
-
-# compiler.err.star.expected=\
-#     ''*'' expected
-# compiler.err.no.elem.type=\
-#     \[\*\] cannot have a type
-
-# 0: type
-compiler.misc.try.not.applicable.to.type=try-with-resource\u306F\u5909\u6570\u578B\u306B\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093\n({0})
-
-#####
-
-# 0: message segment or type, 1: message segment
-compiler.err.type.found.req=\u4E88\u671F\u3057\u306A\u3044\u578B\n\u671F\u5F85\u5024: {1}\n\u691C\u51FA\u5024:    {0}
-
-## The following are all possible strings for the first argument ({0}) of the
-## above string.
-compiler.misc.type.req.class=\u30AF\u30E9\u30B9
-
-compiler.misc.type.req.class.array=\u30AF\u30E9\u30B9\u307E\u305F\u306F\u914D\u5217
-
-compiler.misc.type.req.array.or.iterable=\u914D\u5217\u307E\u305F\u306Fjava.lang.Iterable
-
-compiler.misc.type.req.ref=\u53C2\u7167
-
-compiler.misc.type.req.exact=\u5883\u754C\u306E\u306A\u3044\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9
-
-# 0: type
-compiler.misc.type.parameter=\u578B\u30D1\u30E9\u30E1\u30FC\u30BF{0}
-
-#####
-
-## The following are all possible strings for the last argument of all those
-## diagnostics whose key ends in ".1"
-
-# 0: type, 1: list of type
-compiler.misc.no.unique.maximal.instance.exists=\u578B\u5909\u6570{0}(\u4E0A\u9650{1})\u306E\u56FA\u6709\u306E\u6700\u5927\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u304C\u5B58\u5728\u3057\u307E\u305B\u3093
-
-compiler.misc.no.unique.minimal.instance.exists=\u578B\u5909\u6570{0}(\u4E0B\u9650{1})\u306E\u56FA\u6709\u306E\u6700\u5C0F\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u304C\u5B58\u5728\u3057\u307E\u305B\u3093
-
-# 0: type, 1: list of type
-compiler.misc.incompatible.upper.bounds=\u63A8\u8AD6\u5909\u6570{0}\u306B\u306F\u3001\u4E0D\u9069\u5408\u306A\u4E0A\u9650{1}\u304C\u3042\u308A\u307E\u3059
-
-# 0: type, 1: list of type, 2: list of type
-compiler.misc.incompatible.eq.upper.bounds=\u63A8\u8AD6\u5909\u6570{0}\u306B\u306F\u3001\u4E0D\u9069\u5408\u306A\u5883\u754C\u304C\u3042\u308A\u307E\u3059\n\u7B49\u4FA1\u5236\u7D04: {1}\n\u4E0A\u9650: {2}
-
-# 0: type, 1: list of type, 2: list of type
-compiler.misc.incompatible.eq.lower.bounds=\u63A8\u8AD6\u5909\u6570{0}\u306B\u306F\u3001\u4E0D\u9069\u5408\u306A\u5883\u754C\u304C\u3042\u308A\u307E\u3059\n\u7B49\u4FA1\u5236\u7D04: {1}\n\u4E0B\u9650: {2}
-
-# 0: list of type, 1: type, 2: type
-compiler.misc.infer.no.conforming.instance.exists=\u578B\u5909\u6570{0}\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u304C\u5B58\u5728\u3057\u306A\u3044\u306E\u3067\u3001{1}\u306F{2}\u306B\u9069\u5408\u3057\u307E\u305B\u3093
-
-# 0: list of type, 1: message segment
-compiler.misc.infer.no.conforming.assignment.exists=\u578B\u5909\u6570{0}\u3092\u63A8\u8AD6\u3067\u304D\u307E\u305B\u3093\n(\u5F15\u6570\u306E\u4E0D\u4E00\u81F4: {1})
-
-# 0: list of type
-compiler.misc.infer.arg.length.mismatch=\u578B\u5909\u6570{0}\u3092\u63A8\u8AD6\u3067\u304D\u307E\u305B\u3093\n(\u5B9F\u5F15\u6570\u30EA\u30B9\u30C8\u3068\u4EEE\u5F15\u6570\u30EA\u30B9\u30C8\u306E\u9577\u3055\u304C\u7570\u306A\u308A\u307E\u3059)
-
-# 0: list of type, 1: message segment
-compiler.misc.infer.varargs.argument.mismatch=\u578B\u5909\u6570{0}\u3092\u63A8\u8AD6\u3067\u304D\u307E\u305B\u3093\n(\u53EF\u5909\u5F15\u6570\u306E\u4E0D\u4E00\u81F4: {1})
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.upper.bounds=\u63A8\u8AD6\u578B\u304C\u4E0A\u9650\u306B\u9069\u5408\u3057\u307E\u305B\u3093\n\u63A8\u8AD6: {0}\n\u4E0A\u9650: {1}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.lower.bounds=\u63A8\u8AD6\u578B\u304C\u4E0B\u9650\u306B\u9069\u5408\u3057\u307E\u305B\u3093\n\u63A8\u8AD6: {0}\n\u4E0B\u9650: {1}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.eq.bounds=\u63A8\u8AD6\u578B\u304C\u7B49\u4FA1\u5236\u7D04\u306B\u9069\u5408\u3057\u307E\u305B\u3093\n\u63A8\u8AD6: {0}\n\u7B49\u4FA1\u5236\u7D04: {1}
-
-# 0: symbol
-compiler.misc.diamond={0}<>
-
-# 0: type
-compiler.misc.diamond.non.generic=\u975E\u6C4E\u7528\u30AF\u30E9\u30B9{0}\u3067''<>''\u3092\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: unused
-compiler.misc.diamond.and.explicit.params=\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u660E\u793A\u7684\u306A\u578B\u30D1\u30E9\u30E1\u30FC\u30BF\u3067\u306F''<>''\u3092\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-# 0: unused
-compiler.misc.mref.infer.and.explicit.params=\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u660E\u793A\u7684\u306A\u578B\u30D1\u30E9\u30E1\u30FC\u30BF\u3067\u306Fraw\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u53C2\u7167\u3092\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-# 0: type, 1: list of type
-compiler.misc.explicit.param.do.not.conform.to.bounds=\u660E\u793A\u7684\u306A\u578B\u5F15\u6570{0}\u306F\u3001\u5BA3\u8A00\u3055\u308C\u305F\u5883\u754C{1}\u306B\u9069\u5408\u3057\u307E\u305B\u3093
-
-compiler.misc.arg.length.mismatch=\u5B9F\u5F15\u6570\u30EA\u30B9\u30C8\u3068\u4EEE\u5F15\u6570\u30EA\u30B9\u30C8\u306E\u9577\u3055\u304C\u7570\u306A\u308A\u307E\u3059
-
-# 0: message segment
-compiler.misc.no.conforming.assignment.exists=\u5F15\u6570\u306E\u4E0D\u4E00\u81F4: {0}
-
-# 0: message segment
-compiler.misc.varargs.argument.mismatch=\u53EF\u5909\u5F15\u6570\u306E\u4E0D\u4E00\u81F4: {0}
-
-#####
-
-# 0: symbol or type, 1: file name
-compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file={1}\u306E\u88DC\u52A9\u30AF\u30E9\u30B9{0}\u306B\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u5916\u304B\u3089\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093
-
-## The first argument ({0}) is a "kindname".
-# 0: symbol kind, 1: symbol, 2: symbol
-compiler.err.abstract.cant.be.accessed.directly=\u62BD\u8C61{0}\u3067\u3042\u308B{1}({2}\u5185)\u306B\u76F4\u63A5\u30A2\u30AF\u30BB\u30B9\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-## The first argument ({0}) is a "kindname".
-# 0: symbol kind, 1: symbol
-compiler.err.non-static.cant.be.ref=static\u3067\u306A\u3044{0} {1}\u3092static\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u53C2\u7167\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol kind, 1: symbol
-compiler.misc.non-static.cant.be.ref=static\u3067\u306A\u3044{0} {1}\u3092static\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u53C2\u7167\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol kind, 1: symbol
-compiler.misc.static.method.in.unbound.lookup=\u975E\u30D0\u30A4\u30F3\u30C9\u691C\u7D22\u3067\u9759\u7684\u306A{0} {1}\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F
-
-## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
-## of kindnames (the list should be identical to that provided in source.
-compiler.err.unexpected.type=\u4E88\u671F\u3057\u306A\u3044\u578B\n\u671F\u5F85\u5024: {0}\n\u691C\u51FA\u5024:    {1}
-
-compiler.err.unexpected.lambda=\u3053\u3053\u3067\u306F\u30E9\u30E0\u30C0\u5F0F\u306F\u4E88\u671F\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-compiler.err.unexpected.mref=\u3053\u3053\u3067\u306F\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u306F\u4E88\u671F\u3055\u308C\u3066\u3044\u307E\u305B\u3093
-
-## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
-## The second argument {1} is the non-resolved symbol
-## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
-## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
-# 0: symbol kind, 1: name, 2: unused, 3: unused
-compiler.err.cant.resolve=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB: {0} {1}
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type
-compiler.err.cant.resolve.args=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB: {0} {1}({3})
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list of type
-compiler.err.cant.resolve.args.params=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB: {0} <{2}>{1}({3})
-
-## arguments from {0} to {3} have the same meaning as above
-## The fifth argument {4} is a location subdiagnostic (see below)
-# 0: symbol kind, 1: name, 2: unused, 3: unused, 4: message segment
-compiler.err.cant.resolve.location=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB:   {0} {1}\n\u5834\u6240: {4}
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
-compiler.err.cant.resolve.location.args=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB:   {0} {1}({3})\n\u5834\u6240: {4}
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
-compiler.err.cant.resolve.location.args.params=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB:   {0} <{2}>{1}({3})\n\u5834\u6240: {4}
-
-### Following are replicated/used for method reference diagnostics
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
-compiler.misc.cant.resolve.location.args=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB:   {0} {1}({3})\n\u5834\u6240: {4}
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
-compiler.misc.cant.resolve.location.args.params=\u30B7\u30F3\u30DC\u30EB\u3092\u898B\u3064\u3051\u3089\u308C\u307E\u305B\u3093\n\u30B7\u30F3\u30DC\u30EB:   {0} <{2}>{1}({3})\n\u5834\u6240: {4}
-
-##a location subdiagnostic is composed as follows:
-## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
-## The second argument {1} is the location name
-## The third argument {2} is the location type (only when {1} is a variable name)
-
-# 0: symbol kind, 1: type or symbol, 2: unused
-compiler.misc.location={0} {1}
-
-# 0: symbol kind, 1: symbol, 2: type
-compiler.misc.location.1=\u30BF\u30A4\u30D7{2}\u306E{0} {1}
-
-## The following are all possible string for "kindname".
-## They should be called whatever the JLS calls them after it been translated
-## to the appropriate language.
-# compiler.misc.kindname.constructor=\
-#     static member
-compiler.misc.kindname.annotation=@interface
-
-compiler.misc.kindname.constructor=\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF
-
-compiler.misc.kindname.enum=\u5217\u6319\u578B
-
-compiler.misc.kindname.interface=\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9
-
-compiler.misc.kindname.static=static
-
-compiler.misc.kindname.type.variable=\u578B\u5909\u6570
-
-compiler.misc.kindname.type.variable.bound=\u578B\u5909\u6570\u306E\u5883\u754C
-
-compiler.misc.kindname.variable=\u5909\u6570
-
-compiler.misc.kindname.value=\u5024
-
-compiler.misc.kindname.method=\u30E1\u30BD\u30C3\u30C9
-
-compiler.misc.kindname.class=\u30AF\u30E9\u30B9
-
-compiler.misc.kindname.package=\u30D1\u30C3\u30B1\u30FC\u30B8
-
-compiler.misc.kindname.static.init=static\u521D\u671F\u5316\u5B50
-
-compiler.misc.kindname.instance.init=\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u521D\u671F\u5316\u5B50
-
-#####
-
-compiler.misc.no.args=\u5F15\u6570\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: message segment
-compiler.err.override.static={0}\n\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u30E1\u30BD\u30C3\u30C9\u304Cstatic\u3067\u3059
-
-# 0: message segment, 1: set of modifier
-compiler.err.override.meth={0}\n\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3055\u308C\u305F\u30E1\u30BD\u30C3\u30C9\u306F{1}\u3067\u3059
-
-# 0: message segment, 1: type
-compiler.err.override.meth.doesnt.throw={0}\n\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3055\u308C\u305F\u30E1\u30BD\u30C3\u30C9\u306F{1}\u3092\u30B9\u30ED\u30FC\u3057\u307E\u305B\u3093
-
-# In the following string {1} is a space separated list of Java Keywords, as
-# they would have been declared in the source code
-# 0: message segment, 1: set of modifier
-compiler.err.override.weaker.access={0}\n({1})\u3088\u308A\u5F31\u3044\u30A2\u30AF\u30BB\u30B9\u6A29\u9650\u3092\u5272\u308A\u5F53\u3066\u3088\u3046\u3068\u3057\u307E\u3057\u305F
-
-# 0: message segment, 1: type, 2: type
-compiler.err.override.incompatible.ret={0}\n\u623B\u308A\u5024\u306E\u578B{1}\u306F{2}\u3068\u4E92\u63DB\u6027\u304C\u3042\u308A\u307E\u305B\u3093
-
-# 0: message segment, 1: type, 2: type
-compiler.warn.override.unchecked.ret={0}\n\u623B\u308A\u5024\u306E\u578B\u306F{1}\u304B\u3089{2}\u3078\u306E\u7121\u691C\u67FB\u5909\u63DB\u304C\u5FC5\u8981\u3067\u3059
-
-# 0: message segment, 1: type
-compiler.warn.override.unchecked.thrown={0}\n\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3055\u308C\u305F\u30E1\u30BD\u30C3\u30C9\u306F{1}\u3092\u30B9\u30ED\u30FC\u3057\u307E\u305B\u3093
-
-# 0: symbol
-compiler.warn.override.equals.but.not.hashcode=\u30AF\u30E9\u30B9{0}\u306Fequals\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059\u304C\u3001\u3053\u306E\u30AF\u30E9\u30B9\u3082\u3001\u307E\u305F\u3001\u3044\u304B\u306A\u308B\u30B9\u30FC\u30D1\u30FC\u30AF\u30E9\u30B9\u3082\u3001hashCode\u30E1\u30BD\u30C3\u30C9\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u305B\u3093
-
-## The following are all possible strings for the first argument ({0}) of the
-## above strings.
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.cant.override={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.cant.implement={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u5B9F\u88C5\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.clashes.with={1}\u306E{0}\u306F{3}\u306E{2}\u3068\u7AF6\u5408\u3057\u307E\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.override={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.implement={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u5B9F\u88C5\u3057\u307E\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.clash.with={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.override={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.implement={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u5B9F\u88C5\u3057\u307E\u3059
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.clash.with={1}\u306E{0}\u306F{3}\u306E{2}\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059
-
-# 0: unused
-compiler.misc.diamond.and.anon.class=\u533F\u540D\u5185\u90E8\u30AF\u30E9\u30B9\u3067\u306F''<>''\u3092\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093
-
-# 0: symbol kind, 1: symbol, 2: symbol, 3: message segment
-compiler.misc.inapplicable.method={0} {1}.{2}\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093\n({3})
-
-########################################
-# Diagnostics for language feature changes
-########################################
-# 0: string
-compiler.err.unsupported.fp.lit=16\u9032\u6570\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(16\u9032\u6570\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.unsupported.binary.lit=2\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(2\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F-source 7\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.unsupported.underscore.lit=\u30EA\u30C6\u30E9\u30EB\u5185\u306E\u30A2\u30F3\u30C0\u30FC\u30B9\u30B3\u30A2\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30EA\u30C6\u30E9\u30EB\u5185\u306E\u30A2\u30F3\u30C0\u30FC\u30B9\u30B3\u30A2\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 7\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.try.with.resources.not.supported.in.source=try-with-resource\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(try-with-resource\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 7\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-compiler.warn.enum.as.identifier=\u30EA\u30EA\u30FC\u30B95\u304B\u3089''enum''\u306F\u30AD\u30FC\u30EF\u30FC\u30C9\u306A\u306E\u3067\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\n(''enum''\u3092\u30AD\u30FC\u30EF\u30FC\u30C9\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u306B\u306F-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-compiler.warn.assert.as.identifier=\u30EA\u30EA\u30FC\u30B91.4\u304B\u3089''assert''\u306F\u30AD\u30FC\u30EF\u30FC\u30C9\u306A\u306E\u3067\u3001\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\n(''assert''\u3092\u30AD\u30FC\u30EF\u30FC\u30C9\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u306B\u306F\u3001-source 1.4\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-compiler.warn.underscore.as.identifier=\u8B58\u5225\u5B50\u3068\u3057\u3066''_''\u304C\u4F7F\u7528\u3055\u308C\u307E\u3057\u305F\n(\u8B58\u5225\u5B50\u3068\u3057\u3066\u306E''_''\u306E\u4F7F\u7528\u306F\u3001Java SE 8\u3088\u308A\u5F8C\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u306A\u3044\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059)
-
-compiler.err.underscore.as.identifier.in.lambda=''_''\u304C\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3055\u308C\u3066\u3044\u307E\u3059\n(\u30E9\u30E0\u30C0\u30FB\u30D1\u30E9\u30E1\u30FC\u30BF\u3067\u306F''_''\u3092\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u7981\u6B62\u3055\u308C\u3066\u3044\u307E\u3059)
-
-compiler.err.enum.as.identifier=\u30EA\u30EA\u30FC\u30B95\u304B\u3089''enum''\u306F\u30AD\u30FC\u30EF\u30FC\u30C9\u306A\u306E\u3067\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\n(''enum''\u3092\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u306B\u306F-source 1.4\u4EE5\u524D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-compiler.err.assert.as.identifier=\u30EA\u30EA\u30FC\u30B91.4\u304B\u3089''assert''\u306F\u30AD\u30FC\u30EF\u30FC\u30C9\u306A\u306E\u3067\u3001\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\n(''assert''\u3092\u8B58\u5225\u5B50\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B\u306B\u306F\u3001-source 1.3\u4EE5\u524D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# TODO 308: make a better error message
-compiler.err.this.as.identifier=\u30EA\u30EA\u30FC\u30B98\u304B\u3089''this''\u306F\u53D7\u4FE1\u30BF\u30A4\u30D7\u306E\u30D1\u30E9\u30E1\u30FC\u30BF\u540D\u3068\u3057\u3066\u306E\u307F\u8A31\u53EF\u3055\u308C\u3001\u6700\u521D\u306E\u30D1\u30E9\u30E1\u30FC\u30BF\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059
-
-# 0: symbol
-compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=\u53D7\u53D6\u308A\u5074\u30D1\u30E9\u30E1\u30FC\u30BF\u306F\u6700\u4E0A\u4F4D\u30EC\u30D9\u30EB\u30FB\u30AF\u30E9\u30B9\u306E\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306B\u9069\u7528\u3067\u304D\u307E\u305B\u3093
-
-# TODO 308: make a better error message
-# 0: symbol
-compiler.err.cant.type.annotate.scoping.1=\u30B9\u30B3\u30FC\u30D7\u30FB\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30C8\u3092\u578B\u4F7F\u7528\u6CE8\u91C8\u3067\u6CE8\u91C8\u4ED8\u3051\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093: {0}
-
-# TODO 308: make a better error message
-# 0: list of symbol
-compiler.err.cant.type.annotate.scoping=\u30B9\u30B3\u30FC\u30D7\u30FB\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30C8\u3092\u578B\u4F7F\u7528\u6CE8\u91C8\u3067\u6CE8\u91C8\u4ED8\u3051\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093: {0}
-
-# 0: type, 1: type
-compiler.err.incorrect.receiver.name=\u53D7\u53D6\u308A\u5074\u306E\u540D\u524D\u304C\u3001\u5305\u542B\u3059\u308B\u30AF\u30E9\u30B9\u30FB\u30BF\u30A4\u30D7\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\n\u5FC5\u9808: {0}\n\u691C\u51FA: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.receiver.type=\u53D7\u53D6\u308A\u5074\u306E\u30BF\u30A4\u30D7\u304C\u3001\u5305\u542B\u3059\u308B\u30AF\u30E9\u30B9\u30FB\u30BF\u30A4\u30D7\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\n\u5FC5\u9808: {0}\n\u691C\u51FA: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.constructor.receiver.type=\u53D7\u53D6\u308A\u5074\u306E\u30BF\u30A4\u30D7\u304C\u3001\u5305\u542B\u3059\u308B\u5916\u90E8\u30AF\u30E9\u30B9\u30FB\u30BF\u30A4\u30D7\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\n\u5FC5\u9808: {0}\n\u691C\u51FA: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.constructor.receiver.name=\u53D7\u53D6\u308A\u5074\u306E\u540D\u524D\u304C\u3001\u5305\u542B\u3059\u308B\u5916\u90E8\u30AF\u30E9\u30B9\u30FB\u30BF\u30A4\u30D7\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\n\u5FC5\u9808: {0}\n\u691C\u51FA: {1}
-
-compiler.err.no.annotations.on.dot.class=\u6CE8\u91C8\u306F\u30AF\u30E9\u30B9\u30FB\u30EA\u30C6\u30E9\u30EB\u306E\u30BF\u30A4\u30D7\u3067\u8A31\u53EF\u3055\u308C\u307E\u305B\u3093
-
-# 0: string
-compiler.err.generics.not.supported.in.source=\u7DCF\u79F0\u578B\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u7DCF\u79F0\u578B\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.varargs.not.supported.in.source=\u53EF\u5909\u5F15\u6570\u30E1\u30BD\u30C3\u30C9\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u53EF\u5909\u5F15\u6570\u30E1\u30BD\u30C3\u30C9\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.annotations.not.supported.in.source=\u6CE8\u91C8\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u6CE8\u91C8\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.type.annotations.not.supported.in.source=\u30BF\u30A4\u30D7\u6CE8\u91C8\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30BF\u30A4\u30D7\u6CE8\u91C8\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.annotations.after.type.params.not.supported.in.source=\u30E1\u30BD\u30C3\u30C9\u30FB\u30BF\u30A4\u30D7\u30FB\u30D1\u30E9\u30E1\u30FC\u30BF\u306E\u5F8C\u306E\u6CE8\u91C8\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30E1\u30BD\u30C3\u30C9\u30FB\u30BF\u30A4\u30D7\u30FB\u30D1\u30E9\u30E1\u30FC\u30BF\u306E\u5F8C\u306E\u6CE8\u91C8\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.repeatable.annotations.not.supported.in.source=\u7E70\u8FD4\u3057\u6CE8\u91C8\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u7E70\u8FD4\u3057\u6CE8\u91C8\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.foreach.not.supported.in.source=\u62E1\u5F35for\u30EB\u30FC\u30D7\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(for-each\u30EB\u30FC\u30D7\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.static.import.not.supported.in.source=static import\u5BA3\u8A00\u306F -source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(static import\u5BA3\u8A00\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.enums.not.supported.in.source=\u5217\u6319\u578B\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u5217\u6319\u578B\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F-source 5\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.diamond.not.supported.in.source=\u30C0\u30A4\u30E4\u30E2\u30F3\u30C9\u6F14\u7B97\u5B50\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30C0\u30A4\u30E4\u30E2\u30F3\u30C9\u6F14\u7B97\u5B50\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 7\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.multicatch.not.supported.in.source=\u8907\u6570catch\u6587\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u8907\u6570catch\u6587\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 7\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.string.switch.not.supported.in.source=switch\u5185\u306E\u6587\u5B57\u5217\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(switch\u5185\u306E\u6587\u5B57\u5217\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 7\u4EE5\u964D\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.lambda.not.supported.in.source=\u30E9\u30E0\u30C0\u5F0F\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30E9\u30E0\u30C0\u5F0F\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.method.references.not.supported.in.source=\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30E1\u30BD\u30C3\u30C9\u53C2\u7167\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.default.methods.not.supported.in.source=\u30C7\u30D5\u30A9\u30EB\u30C8\u30FB\u30E1\u30BD\u30C3\u30C9\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30C7\u30D5\u30A9\u30EB\u30C8\u30FB\u30E1\u30BD\u30C3\u30C9\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.intersection.types.in.cast.not.supported.in.source=\u30AD\u30E3\u30B9\u30C8\u5185\u306Eintersection\u578B\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(\u30C7\u30D5\u30A9\u30EB\u30C8\u30FB\u30E1\u30BD\u30C3\u30C9\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.static.intf.methods.not.supported.in.source=static\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(static\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-# 0: string
-compiler.err.static.intf.method.invoke.not.supported.in.source=static\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u30FB\u30E1\u30BD\u30C3\u30C9\u547C\u51FA\u3057\u306F-source {0}\u3067\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\n(static\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u30FB\u30E1\u30BD\u30C3\u30C9\u547C\u51FA\u3057\u3092\u4F7F\u7528\u53EF\u80FD\u306B\u3059\u308B\u306B\u306F\u3001-source 8\u4EE5\u4E0A\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044)
-
-########################################
-# Diagnostics for verbose resolution
-# used by Resolve (debug only)
-########################################
-
-# 0: number, 1: symbol, 2: unused
-compiler.misc.applicable.method.found=#{0}\u500B\u306E\u4F7F\u7528\u53EF\u80FD\u30E1\u30BD\u30C3\u30C9\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F: {1}
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.applicable.method.found.1=#{0}\u500B\u306E\u4F7F\u7528\u53EF\u80FD\u30E1\u30BD\u30C3\u30C9\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F: {1}\n({2})
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.not.applicable.method.found=#{0}\u500B\u306E\u4F7F\u7528\u3067\u304D\u306A\u3044\u30E1\u30BD\u30C3\u30C9\u304C\u898B\u3064\u304B\u308A\u307E\u3057\u305F: {1}\n({2})
-
-# 0: type
-compiler.misc.partial.inst.sig=\u90E8\u5206\u7684\u306B\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u5316\u3055\u308C\u307E\u3057\u305F: {0}
-
-# 0: name, 1: symbol, 2: number, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi=\u578B{1}\u306E\u30E1\u30BD\u30C3\u30C9{0}\u3092\u5019\u88DC{2}\u306B\u89E3\u6C7A\u3057\u3066\u3044\u307E\u3059\n\u30D5\u30A7\u30FC\u30BA: {3}\n\u5B9F\u969B\u306E\u578B: {4}\n\u578B\u5F15\u6570: {5}\n\u5019\u88DC:
-
-# 0: name, 1: symbol, 2: unused, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi.1=\u578B{1}\u306E\u30E1\u30BD\u30C3\u30C9{0}\u306E\u89E3\u6C7A\u306B\u30A8\u30E9\u30FC\u304C\u3042\u308A\u307E\u3059\n\u30D5\u30A7\u30FC\u30BA: {3}\n\u5B9F\u969B\u306E\u578B: {4}\n\u578B\u5F15\u6570: {5}\n\u5019\u88DC:
-
-# 0: symbol, 1: type, 2: type
-compiler.note.deferred.method.inst=\u30E1\u30BD\u30C3\u30C9{0}\u306E\u9045\u5EF6\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u5316\n\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u5316\u3055\u308C\u305F\u30B7\u30B0\u30CD\u30C1\u30E3: {1}\n\u30BF\u30FC\u30B2\u30C3\u30C8\u578B: {2}
-
-########################################
-# Diagnostics for where clause implementation
-# used by the RichDiagnosticFormatter.
-########################################
-
-compiler.misc.type.null=<null>
-
-# X#n (where n is an int id) is disambiguated tvar name
-# 0: name, 1: number
-compiler.misc.type.var={0}#{1}
-
-# CAP#n (where n is an int id) is an abbreviation for 'captured type'
-# 0: number
-compiler.misc.captured.type=CAP#{0}
-
-# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
-# 0: number
-compiler.misc.intersection.type=INT#{0}
-
-# where clause for captured type: contains upper ('extends {1}') and lower
-# ('super {2}') bound along with the wildcard that generated this captured type ({3})
-# 0: type, 1: type, 2: type, 3: type
-compiler.misc.where.captured={0}\u306F{3}\u306E\u30AD\u30E3\u30D7\u30C1\u30E3\u304B\u3089{1}\u3092\u62E1\u5F35\u3057{2}\u3092\u30B9\u30FC\u30D1\u30FC\u3057\u307E\u3059
-
-# compact where clause for captured type: contains upper ('extends {1}') along
-# with the wildcard that generated this captured type ({3})
-# 0: type, 1: type, 2: unused, 3: type
-compiler.misc.where.captured.1={0}\u306F{3}\u306E\u30AD\u30E3\u30D7\u30C1\u30E3\u304B\u3089{1}\u3092\u62E1\u5F35\u3057\u307E\u3059
-
-# where clause for type variable: contains upper bound(s) ('extends {1}') along with
-# the kindname ({2}) and location ({3}) in which the typevar has been declared
-# 0: type, 1: list of type, 2: symbol kind, 3: symbol
-compiler.misc.where.typevar={2} {3}\u3067\u5BA3\u8A00\u3055\u308C\u3066\u3044\u308B{0}\u306F{1}\u3092\u62E1\u5F35\u3057\u307E\u3059
-
-# compact where clause for type variable: contains the kindname ({2}) and location ({3})
-# in which the typevar has been declared
-# 0: type, 1: list of type, 2: symbol kind, 3: symbol
-compiler.misc.where.typevar.1={2} {3}\u3067\u5BA3\u8A00\u3055\u308C\u305F{0}
-
-# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
-# Since a fresh type-variable is synthetic - there's no location/kindname here.
-# 0: type, 1: list of type
-compiler.misc.where.fresh.typevar={0}\u306F{1}\u3092\u62E1\u5F35\u3057\u307E\u3059
-
-# where clause for type variable: contains all the upper bound(s) ('extends {1}')
-# of this intersection type
-# 0: type, 1: list of type
-compiler.misc.where.intersection={0}\u306F{1}\u3092\u62E1\u5F35\u3057\u307E\u3059
-
-### Where clause headers ###
-compiler.misc.where.description.captured={0}\u304C\u65B0\u3057\u3044\u578B\u5909\u6570\u306E\u5834\u5408:
-
-# 0: set of type
-compiler.misc.where.description.typevar={0}\u304C\u578B\u5909\u6570\u306E\u5834\u5408:
-
-# 0: set of type
-compiler.misc.where.description.intersection={0}\u304Cintersection\u578B\u306E\u5834\u5408:
-
-# 0: set of type
-compiler.misc.where.description.captured.1={0}\u304C\u65B0\u3057\u3044\u578B\u5909\u6570\u306E\u5834\u5408:
-
-# 0: set of type
-compiler.misc.where.description.typevar.1={0}\u304C\u578B\u5909\u6570\u306E\u5834\u5408:
-
-compiler.misc.where.description.intersection.1={0}\u304Cintersection\u578B\u306E\u5834\u5408:
-
-###
-# errors related to doc comments
-
-compiler.err.dc.bad.entity=HTML\u30A8\u30F3\u30C6\u30A3\u30C6\u30A3\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.dc.bad.gt=''>''\u306E\u4F7F\u7528\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.dc.bad.inline.tag=\u30A4\u30F3\u30E9\u30A4\u30F3\u30FB\u30BF\u30B0\u306E\u4F7F\u7528\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.dc.identifier.expected=\u8B58\u5225\u5B50\u304C\u5FC5\u8981\u3067\u3059
-
-compiler.err.dc.malformed.html=HTML\u304C\u4E0D\u6B63\u3067\u3059
-
-compiler.err.dc.missing.semicolon=\u30BB\u30DF\u30B3\u30ED\u30F3\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.dc.no.content=\u30B3\u30F3\u30C6\u30F3\u30C4\u306A\u3057
-
-compiler.err.dc.no.tag.name='@'\u306E\u5F8C\u306B\u30BF\u30B0\u540D\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.dc.gt.expected=''>''\u304C\u5FC5\u8981\u3067\u3059
-
-compiler.err.dc.ref.bad.parens=\u53C2\u7167\u306B'')''\u304C\u3042\u308A\u307E\u305B\u3093
-
-compiler.err.dc.ref.syntax.error=\u53C2\u7167\u306B\u69CB\u6587\u30A8\u30E9\u30FC\u304C\u3042\u308A\u307E\u3059
-
-compiler.err.dc.ref.unexpected.input=\u4E88\u671F\u3057\u306A\u3044\u30C6\u30AD\u30B9\u30C8\u3067\u3059
-
-compiler.err.dc.unexpected.content=\u4E88\u671F\u3057\u306A\u3044\u30B3\u30F3\u30C6\u30F3\u30C4\u3067\u3059
-
-compiler.err.dc.unterminated.inline.tag=\u30A4\u30F3\u30E9\u30A4\u30F3\u30FB\u30BF\u30B0\u304C\u7D42\u4E86\u3057\u3066\u3044\u307E\u305B\u3093
-
-compiler.err.dc.unterminated.signature=\u30B7\u30B0\u30CD\u30C1\u30E3\u304C\u7D42\u4E86\u3057\u3066\u3044\u307E\u305B\u3093
-
-compiler.err.dc.unterminated.string=\u6587\u5B57\u5217\u304C\u7D42\u4E86\u3057\u3066\u3044\u307E\u305B\u3093
-
-
Index: Build/src/main/resources/com.sun.tools/javac/resources/javac_zh_CN.properties
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/javac_zh_CN.properties b/Build/src/main/resources/com.sun.tools/javac/resources/javac_zh_CN.properties
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/javac_zh_CN.properties	(date 0)
+++ /dev/null	(date 0)
@@ -1,147 +0,0 @@
-#
-# Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-## standard options
-
-javac.opt.g=\u751F\u6210\u6240\u6709\u8C03\u8BD5\u4FE1\u606F
-javac.opt.g.none=\u4E0D\u751F\u6210\u4EFB\u4F55\u8C03\u8BD5\u4FE1\u606F
-javac.opt.g.lines.vars.source=\u53EA\u751F\u6210\u67D0\u4E9B\u8C03\u8BD5\u4FE1\u606F
-javac.opt.nowarn=\u4E0D\u751F\u6210\u4EFB\u4F55\u8B66\u544A
-javac.opt.verbose=\u8F93\u51FA\u6709\u5173\u7F16\u8BD1\u5668\u6B63\u5728\u6267\u884C\u7684\u64CD\u4F5C\u7684\u6D88\u606F
-javac.opt.deprecation=\u8F93\u51FA\u4F7F\u7528\u5DF2\u8FC7\u65F6\u7684 API \u7684\u6E90\u4F4D\u7F6E
-javac.opt.classpath=\u6307\u5B9A\u67E5\u627E\u7528\u6237\u7C7B\u6587\u4EF6\u548C\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F\u7684\u4F4D\u7F6E
-javac.opt.sourcepath=\u6307\u5B9A\u67E5\u627E\u8F93\u5165\u6E90\u6587\u4EF6\u7684\u4F4D\u7F6E
-javac.opt.bootclasspath=\u8986\u76D6\u5F15\u5BFC\u7C7B\u6587\u4EF6\u7684\u4F4D\u7F6E
-javac.opt.Xbootclasspath.p=\u7F6E\u4E8E\u5F15\u5BFC\u7C7B\u8DEF\u5F84\u4E4B\u524D
-javac.opt.Xbootclasspath.a=\u7F6E\u4E8E\u5F15\u5BFC\u7C7B\u8DEF\u5F84\u4E4B\u540E
-javac.opt.endorseddirs=\u8986\u76D6\u7B7E\u540D\u7684\u6807\u51C6\u8DEF\u5F84\u7684\u4F4D\u7F6E
-javac.opt.extdirs=\u8986\u76D6\u6240\u5B89\u88C5\u6269\u5C55\u7684\u4F4D\u7F6E
-javac.opt.processorpath=\u6307\u5B9A\u67E5\u627E\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F\u7684\u4F4D\u7F6E
-javac.opt.processor=\u8981\u8FD0\u884C\u7684\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F\u7684\u540D\u79F0; \u7ED5\u8FC7\u9ED8\u8BA4\u7684\u641C\u7D22\u8FDB\u7A0B
-javac.opt.parameters=\u751F\u6210\u5143\u6570\u636E\u4EE5\u7528\u4E8E\u65B9\u6CD5\u53C2\u6570\u7684\u53CD\u5C04
-javac.opt.proc.none.only=\u63A7\u5236\u662F\u5426\u6267\u884C\u6CE8\u91CA\u5904\u7406\u548C/\u6216\u7F16\u8BD1\u3002
-javac.opt.d=\u6307\u5B9A\u653E\u7F6E\u751F\u6210\u7684\u7C7B\u6587\u4EF6\u7684\u4F4D\u7F6E
-javac.opt.sourceDest=\u6307\u5B9A\u653E\u7F6E\u751F\u6210\u7684\u6E90\u6587\u4EF6\u7684\u4F4D\u7F6E
-javac.opt.headerDest=\u6307\u5B9A\u653E\u7F6E\u751F\u6210\u7684\u672C\u673A\u6807\u5934\u6587\u4EF6\u7684\u4F4D\u7F6E
-javac.opt.J=\u76F4\u63A5\u5C06 <\u6807\u8BB0> \u4F20\u9012\u7ED9\u8FD0\u884C\u65F6\u7CFB\u7EDF
-javac.opt.encoding=\u6307\u5B9A\u6E90\u6587\u4EF6\u4F7F\u7528\u7684\u5B57\u7B26\u7F16\u7801
-javac.opt.profile=\u8BF7\u786E\u4FDD\u4F7F\u7528\u7684 API \u5728\u6307\u5B9A\u7684\u914D\u7F6E\u6587\u4EF6\u4E2D\u53EF\u7528
-javac.opt.target=\u751F\u6210\u7279\u5B9A VM \u7248\u672C\u7684\u7C7B\u6587\u4EF6
-javac.opt.source=\u63D0\u4F9B\u4E0E\u6307\u5B9A\u53D1\u884C\u7248\u7684\u6E90\u517C\u5BB9\u6027
-javac.opt.Werror=\u51FA\u73B0\u8B66\u544A\u65F6\u7EC8\u6B62\u7F16\u8BD1
-javac.opt.A=\u4F20\u9012\u7ED9\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F\u7684\u9009\u9879
-javac.opt.implicit=\u6307\u5B9A\u662F\u5426\u4E3A\u9690\u5F0F\u5F15\u7528\u6587\u4EF6\u751F\u6210\u7C7B\u6587\u4EF6
-javac.opt.pkginfo=\u6307\u5B9A package-info \u6587\u4EF6\u7684\u5904\u7406
-javac.opt.arg.class=<\u7C7B>
-javac.opt.arg.class.list=<class1>[,<class2>,<class3>...]
-javac.opt.arg.flag=<\u6807\u8BB0>
-javac.opt.arg.key.equals.value=\u5173\u952E\u5B57[=\u503C]
-javac.opt.arg.path=<\u8DEF\u5F84>
-javac.opt.arg.dirs=<\u76EE\u5F55>
-javac.opt.arg.directory=<\u76EE\u5F55>
-javac.opt.arg.encoding=<\u7F16\u7801>
-javac.opt.arg.profile=<\u914D\u7F6E\u6587\u4EF6>
-javac.opt.arg.release=<\u53D1\u884C\u7248>
-javac.opt.arg.number=<\u7F16\u53F7>
-javac.opt.plugin=\u8981\u8FD0\u884C\u7684\u63D2\u4EF6\u7684\u540D\u79F0\u548C\u53EF\u9009\u53C2\u6570
-javac.opt.arg.plugin="\u540D\u79F0\u53C2\u6570"
-
-## extended options
-
-javac.opt.maxerrs=\u8BBE\u7F6E\u8981\u8F93\u51FA\u7684\u9519\u8BEF\u7684\u6700\u5927\u6570\u76EE
-javac.opt.maxwarns=\u8BBE\u7F6E\u8981\u8F93\u51FA\u7684\u8B66\u544A\u7684\u6700\u5927\u6570\u76EE
-javac.opt.nogj=\u8BED\u8A00\u4E2D\u4E0D\u63A5\u53D7\u6CDB\u578B
-javac.opt.moreinfo=\u8F93\u51FA\u7C7B\u578B\u53D8\u91CF\u7684\u6269\u5C55\u4FE1\u606F
-javac.opt.printflat=\u5728\u5185\u90E8\u7C7B\u8F6C\u6362\u4E4B\u540E\u8F93\u51FA\u62BD\u8C61\u8BED\u6CD5\u6811
-javac.opt.printsearch=\u8F93\u51FA\u6709\u5173\u641C\u7D22\u7C7B\u6587\u4EF6\u7684\u4F4D\u7F6E\u7684\u4FE1\u606F
-javac.opt.prompt=\u5728\u6BCF\u6B21\u51FA\u9519\u540E\u505C\u6B62
-javac.opt.retrofit=\u66F4\u65B0\u4F7F\u7528\u6CDB\u578B\u7684\u73B0\u6709\u7C7B\u6587\u4EF6
-javac.opt.s=\u53D1\u51FA java \u6E90\u800C\u4E0D\u662F\u7C7B\u6587\u4EF6
-javac.opt.scramble=\u5728\u5B57\u8282\u7801\u4E2D\u6DF7\u6DC6\u4E13\u7528\u6807\u8BC6\u7B26
-javac.opt.scrambleall=\u5728\u5B57\u8282\u7801\u4E2D\u6DF7\u6DC6\u7A0B\u5E8F\u5305\u53EF\u89C1\u6807\u8BC6\u7B26
-javac.opt.version=\u7248\u672C\u4FE1\u606F
-javac.opt.arg.pathname=<\u8DEF\u5F84\u540D>
-javac.opt.arg.file=<\u6587\u4EF6\u540D>
-javac.opt.Xlint=\u542F\u7528\u5EFA\u8BAE\u7684\u8B66\u544A
-javac.opt.Xlint.suboptlist=\u542F\u7528\u6216\u7981\u7528\u7279\u5B9A\u7684\u8B66\u544A
-javac.opt.Xdoclint=\u4E3A javadoc \u6CE8\u91CA\u4E2D\u7684\u95EE\u9898\u542F\u7528\u5EFA\u8BAE\u7684\u68C0\u67E5
-# L10N: do not localize: all none
-javac.opt.Xdoclint.subopts = (all|none|[-]<group>)[/<access>]
-
-# L10N: do not localize: accessibility html missing reference syntax
-# L10N: do not localize: public protected package private
-javac.opt.Xdoclint.custom=\n        \u4E3A javadoc \u6CE8\u91CA\u4E2D\u7684\u95EE\u9898\u542F\u7528\u6216\u7981\u7528\u7279\u5B9A\u68C0\u67E5,\n        \u5176\u4E2D <group> \u4E3A accessibility, html, missing, reference \u6216 syntax \u4E4B\u4E00\u3002\n        <access> \u4E3A public, protected, package \u6216 private \u4E4B\u4E00\u3002
-javac.opt.Xstdout=\u91CD\u5B9A\u5411\u6807\u51C6\u8F93\u51FA
-javac.opt.X=\u8F93\u51FA\u975E\u6807\u51C6\u9009\u9879\u7684\u63D0\u8981
-javac.opt.help=\u8F93\u51FA\u6807\u51C6\u9009\u9879\u7684\u63D0\u8981
-javac.opt.print=\u8F93\u51FA\u6307\u5B9A\u7C7B\u578B\u7684\u6587\u672C\u8868\u793A
-javac.opt.printRounds=\u8F93\u51FA\u6709\u5173\u6CE8\u91CA\u5904\u7406\u5FAA\u73AF\u7684\u4FE1\u606F
-javac.opt.printProcessorInfo=\u8F93\u51FA\u6709\u5173\u8BF7\u6C42\u5904\u7406\u7A0B\u5E8F\u5904\u7406\u54EA\u4E9B\u6CE8\u91CA\u7684\u4FE1\u606F
-javac.opt.prefer=\u6307\u5B9A\u8BFB\u53D6\u6587\u4EF6, \u5F53\u540C\u65F6\u627E\u5230\u9690\u5F0F\u7F16\u8BD1\u7C7B\u7684\u6E90\u6587\u4EF6\u548C\u7C7B\u6587\u4EF6\u65F6
-javac.opt.AT=\u4ECE\u6587\u4EF6\u8BFB\u53D6\u9009\u9879\u548C\u6587\u4EF6\u540D
-javac.opt.diags=\u9009\u62E9\u8BCA\u65AD\u6A21\u5F0F
-
-## errors
-
-javac.err.empty.A.argument=-A \u9700\u8981\u4E00\u4E2A\u53C2\u6570; \u4F7F\u7528 ''-Akey'' \u6216 ''-Akey=value''
-javac.err.invalid.arg=\u65E0\u6548\u7684\u53C2\u6570: {0}
-javac.err.invalid.A.key=\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F\u9009\u9879 ''{0}'' \u4E2D\u7684\u5173\u952E\u5B57\u4E0D\u662F\u4EE5\u70B9\u5206\u9694\u7684\u6807\u8BC6\u7B26\u5E8F\u5217
-javac.err.invalid.flag=\u65E0\u6548\u7684\u6807\u8BB0: {0}
-javac.err.profile.bootclasspath.conflict=\u6982\u8981\u4FE1\u606F\u548C\u5F15\u5BFC\u7C7B\u8DEF\u5F84\u9009\u9879\u4E0D\u80FD\u540C\u65F6\u4F7F\u7528
-javac.err.invalid.profile=\u914D\u7F6E\u6587\u4EF6\u65E0\u6548: {0}
-javac.err.invalid.target=\u65E0\u6548\u7684\u76EE\u6807\u53D1\u884C\u7248: {0}
-javac.err.no.source.files=\u65E0\u6E90\u6587\u4EF6
-javac.err.no.source.files.classes=\u65E0\u6E90\u6587\u4EF6\u6216\u7C7B\u540D
-javac.err.req.arg={0}\u9700\u8981\u53C2\u6570
-javac.err.invalid.source=\u65E0\u6548\u7684\u6E90\u53D1\u884C\u7248: {0}
-javac.err.error.writing.file=\u5199\u5165{0}\u65F6\u51FA\u9519; {1}
-javac.warn.source.target.conflict=\u6E90\u53D1\u884C\u7248 {0} \u9700\u8981\u76EE\u6807\u53D1\u884C\u7248 {1}
-javac.warn.target.default.source.conflict=\u76EE\u6807\u53D1\u884C\u7248 {0} \u4E0E\u9ED8\u8BA4\u7684\u6E90\u53D1\u884C\u7248 {1} \u51B2\u7A81
-javac.warn.profile.target.conflict=\u914D\u7F6E\u6587\u4EF6{0}\u5BF9\u4E8E\u76EE\u6807\u53D1\u884C\u7248 {1} \u65E0\u6548
-javac.err.dir.not.found=\u627E\u4E0D\u5230\u76EE\u5F55: {0}
-javac.err.file.not.found=\u627E\u4E0D\u5230\u6587\u4EF6: {0}
-javac.err.file.not.directory=\u4E0D\u662F\u76EE\u5F55: {0}
-javac.err.file.not.file=\u4E0D\u662F\u6587\u4EF6: {0}
-javac.msg.plugin.not.found=\u627E\u4E0D\u5230\u63D2\u4EF6: {0}
-## messages
-
-javac.msg.usage.header=\u7528\u6CD5: {0} <options> <source files>\n\u5176\u4E2D, \u53EF\u80FD\u7684\u9009\u9879\u5305\u62EC:
-
-javac.msg.usage=\u7528\u6CD5: {0} <options> <source files>\n-help \u7528\u4E8E\u5217\u51FA\u53EF\u80FD\u7684\u9009\u9879
-
-javac.msg.usage.nonstandard.footer=\u8FD9\u4E9B\u9009\u9879\u90FD\u662F\u975E\u6807\u51C6\u9009\u9879, \u5982\u6709\u66F4\u6539, \u6055\u4E0D\u53E6\u884C\u901A\u77E5\u3002
-
-javac.msg.bug=\u7F16\u8BD1\u5668 ({0}) \u4E2D\u51FA\u73B0\u5F02\u5E38\u9519\u8BEF\u3002\u5982\u679C\u5728 Java Bug Database (http://bugreport.java.com/bugreport/) \u4E2D\u6CA1\u6709\u627E\u5230\u8BE5\u9519\u8BEF, \u8BF7\u5728\u8BE5\u6570\u636E\u5E93\u4E2D\u5EFA\u7ACB Bug\u3002\u8BF7\u5728\u62A5\u544A\u4E2D\u9644\u4E0A\u60A8\u7684\u7A0B\u5E8F\u548C\u4EE5\u4E0B\u8BCA\u65AD\u4FE1\u606F\u3002\u8C22\u8C22\u3002
-
-javac.msg.io=\n\n\u53D1\u751F\u8F93\u5165/\u8F93\u51FA\u9519\u8BEF\u3002\n\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u53C2\u9605\u4EE5\u4E0B\u5806\u6808\u8DDF\u8E2A\u3002\n
-
-javac.msg.proc.annotation.uncaught.exception=\n\n\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F\u629B\u51FA\u672A\u6355\u83B7\u7684\u5F02\u5E38\u9519\u8BEF\u3002\n\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u53C2\u9605\u4EE5\u4E0B\u5806\u6808\u8DDF\u8E2A\u3002\n
-
-javac.msg.plugin.uncaught.exception=\n\n\u63D2\u4EF6\u629B\u51FA\u672A\u6355\u83B7\u7684\u5F02\u5E38\u9519\u8BEF\u3002\n\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u53C2\u9605\u4EE5\u4E0B\u5806\u6808\u8DDF\u8E2A\u3002\n
-
-javac.msg.resource=\n\n\u7CFB\u7EDF\u8D44\u6E90\u4E0D\u8DB3\u3002\n\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u53C2\u9605\u4EE5\u4E0B\u5806\u6808\u8DDF\u8E2A\u3002\n
-
-javac.version={0} {1}
-javac.fullVersion={0}\u5B8C\u6574\u7248\u672C "{1}"
Index: Build/src/main/resources/com.sun.tools/javac/resources/compiler_zh_CN.properties
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/compiler_zh_CN.properties b/Build/src/main/resources/com.sun.tools/javac/resources/compiler_zh_CN.properties
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/compiler_zh_CN.properties	(date 0)
+++ /dev/null	(date 0)
@@ -1,1810 +0,0 @@
-#
-# Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
-# are preceded by a stylized comment describing the type of the corresponding
-# values.
-# The types currently in use are
-#
-# boolean           true or false
-# file name         the name of an input file; e.g.   MyFile.java
-# message segment   a sub-message; see compiler.misc.*
-# modifier          a Java modifier; e.g. public, private, protected
-# name              a name, typically a Java identifier
-# number            an integer
-# option name       the name of a command line option
-# source version    a source version number, such as 1.5, 1.6, 1.7
-# string            a general string
-# symbol            the name of a declared type
-# symbol kind       a description of the kind of a declaration; see compiler.misc.kindname.*
-# token             the name of a non-terminal in source code; see compiler.misc.token.*
-# type              a Java type; e.g. int, X, X<T>
-# unused            the value is not used in this message
-#
-# list of X         a comma-separated list of items; e.g. list of type
-# X or Y            alternation; e.g. message segment or type
-# set of X          a comma-separated collection of items; e.g. set of modifier
-#
-# These may be composed: e.g.   list of type or message segment
-#
-# These comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
-# using info derived from the collected set of examples in test/tools/javac/diags/examples.
-# MessageInfo can also be run as a standalone utility providing more facilities
-# for manipulating this file. For more details, see MessageInfo.java.
-
-##
-## errors
-##
-
-# 0: symbol
-compiler.err.abstract.cant.be.instantiated={0}\u662F\u62BD\u8C61\u7684; \u65E0\u6CD5\u5B9E\u4F8B\u5316
-
-compiler.err.abstract.meth.cant.have.body=\u62BD\u8C61\u65B9\u6CD5\u4E0D\u80FD\u6709\u4E3B\u4F53
-
-compiler.err.already.annotated={0} {1}\u5DF2\u8FDB\u884C\u6CE8\u91CA
-
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol
-compiler.err.already.defined=\u5DF2\u5728{2} {3}\u4E2D\u5B9A\u4E49\u4E86{0} {1}
-
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol kind, 4: symbol
-compiler.err.already.defined.in.clinit=\u5DF2\u5728{3} {4}\u7684{2}\u4E2D\u5B9A\u4E49\u4E86{0} {1}
-
-# 0: string
-compiler.err.already.defined.single.import={0}\u7684 single-type-import \u5DF2\u5B9A\u4E49\u5177\u6709\u76F8\u540C\u7B80\u540D\u7684\u7C7B\u578B
-
-# 0: string
-compiler.err.already.defined.static.single.import={0}\u7684\u9759\u6001 single-type-import \u5DF2\u5B9A\u4E49\u5177\u6709\u76F8\u540C\u7B80\u540D\u7684\u7C7B\u578B
-
-compiler.err.already.defined.this.unit=\u5DF2\u5728\u8BE5\u7F16\u8BD1\u5355\u5143\u4E2D\u5B9A\u4E49{0}
-
-# 0: type, 1: list of name
-compiler.err.annotation.missing.default.value=\u5BF9\u4E8E\u5143\u7D20 ''{1}'', \u6CE8\u91CA @{0} \u7F3A\u5C11\u9ED8\u8BA4\u503C
-
-# 0: type, 1: list of name
-compiler.err.annotation.missing.default.value.1=\u5BF9\u4E8E\u5143\u7D20{1}, \u6CE8\u91CA @{0} \u7F3A\u5C11\u9ED8\u8BA4\u503C
-
-# 0: type
-compiler.err.annotation.not.valid.for.type=\u6CE8\u91CA\u5BF9\u4E8E\u7C7B\u578B{0}\u7684\u5143\u7D20\u65E0\u6548
-
-compiler.err.annotation.type.not.applicable=\u6CE8\u91CA\u7C7B\u578B\u4E0D\u9002\u7528\u4E8E\u8BE5\u7C7B\u578B\u7684\u58F0\u660E
-
-compiler.err.annotation.value.must.be.annotation=\u6CE8\u91CA\u503C\u5FC5\u987B\u4E3A\u6CE8\u91CA
-
-compiler.err.annotation.value.must.be.class.literal=\u6CE8\u91CA\u503C\u5FC5\u987B\u4E3A\u7C7B\u6587\u5B57
-
-compiler.err.annotation.value.must.be.name.value=\u6CE8\u91CA\u503C\u5FC5\u987B\u91C7\u7528 ''name=value'' \u683C\u5F0F
-
-compiler.err.annotation.value.not.allowable.type=\u6CE8\u91CA\u503C\u4E0D\u662F\u5141\u8BB8\u7684\u7C7B\u578B
-
-compiler.err.anon.class.impl.intf.no.args=\u533F\u540D\u7C7B\u5B9E\u73B0\u63A5\u53E3; \u4E0D\u80FD\u6709\u53C2\u6570
-
-compiler.err.anon.class.impl.intf.no.typeargs=\u533F\u540D\u7C7B\u5B9E\u73B0\u63A5\u53E3; \u4E0D\u80FD\u5177\u6709\u7C7B\u578B\u53C2\u6570
-
-compiler.err.anon.class.impl.intf.no.qual.for.new=\u533F\u540D\u7C7B\u5B9E\u73B0\u63A5\u53E3; \u4E0D\u80FD\u6709\u9650\u5B9A\u7B26 - \u5BF9\u4E8E\u65B0
-
-compiler.err.cant.inherit.from.anon=\u65E0\u6CD5\u4ECE\u533F\u540D\u7C7B\u7EE7\u627F
-
-# 0: symbol, 1: symbol, 2: symbol
-compiler.err.array.and.varargs=\u65E0\u6CD5\u5728{2}\u4E2D\u540C\u65F6\u58F0\u660E{0}\u548C{1}
-
-compiler.err.array.dimension.missing=\u7F3A\u5C11\u6570\u7EC4\u7EF4
-
-# 0: type
-compiler.err.array.req.but.found=\u9700\u8981\u6570\u7EC4, \u4F46\u627E\u5230{0}
-
-compiler.err.attribute.value.must.be.constant=\u5143\u7D20\u503C\u5FC5\u987B\u4E3A\u5E38\u91CF\u8868\u8FBE\u5F0F
-
-# 0: statement type
-compiler.err.bad.initializer={0}\u7684\u521D\u59CB\u5316\u7A0B\u5E8F\u9519\u8BEF
-
-compiler.err.break.outside.switch.loop=\u5728 switch \u6216 loop \u5916\u90E8\u4E2D\u65AD
-
-# 0: name
-compiler.err.call.must.be.first.stmt.in.ctor=\u5BF9{0}\u7684\u8C03\u7528\u5FC5\u987B\u662F\u6784\u9020\u5668\u4E2D\u7684\u7B2C\u4E00\u4E2A\u8BED\u53E5
-
-# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
-compiler.err.cant.apply.symbol=\u65E0\u6CD5\u5C06{4} {5}\u4E2D\u7684{0} {1}\u5E94\u7528\u5230\u7ED9\u5B9A\u7C7B\u578B;\n\u9700\u8981: {2}\n\u627E\u5230: {3}\n\u539F\u56E0: {6}
-
-# 0: symbol kind, 1: name, 2: list of type
-compiler.err.cant.apply.symbols=\u5BF9\u4E8E{1}({2}), \u627E\u4E0D\u5230\u5408\u9002\u7684{0}
-
-# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
-compiler.misc.cant.apply.symbol=\u65E0\u6CD5\u5C06 {4} {5}\u4E2D\u7684 {0} {1}\u5E94\u7528\u5230\u7ED9\u5B9A\u7C7B\u578B\n\u9700\u8981: {2}\n\u627E\u5230: {3}\n\u539F\u56E0: {6}
-
-# 0: symbol kind, 1: name, 2: list of type
-compiler.misc.cant.apply.symbols=\u5BF9\u4E8E{1}({2}), \u627E\u4E0D\u5230\u5408\u9002\u7684{0}
-
-# 0: symbol kind, 1: symbol
-compiler.misc.no.abstracts=\u5728 {0} {1} \u4E2D\u627E\u4E0D\u5230\u62BD\u8C61\u65B9\u6CD5
-
-# 0: symbol kind, 1: symbol
-compiler.misc.incompatible.abstracts=\u5728 {0} {1} \u4E2D\u627E\u5230\u591A\u4E2A\u975E\u8986\u76D6\u62BD\u8C61\u65B9\u6CD5
-
-compiler.err.bad.functional.intf.anno=\u610F\u5916\u7684 @FunctionalInterface \u6CE8\u91CA
-
-# 0: message segment
-compiler.err.bad.functional.intf.anno.1=\u610F\u5916\u7684 @FunctionalInterface \u6CE8\u91CA\n{0}
-
-# 0: symbol
-compiler.misc.not.a.functional.intf={0} \u4E0D\u662F\u51FD\u6570\u63A5\u53E3
-
-# 0: symbol, 1: message segment
-compiler.misc.not.a.functional.intf.1={0} \u4E0D\u662F\u51FD\u6570\u63A5\u53E3\n{1}
-
-# 0: symbol, 1: symbol kind, 2: symbol
-compiler.misc.invalid.generic.lambda.target=lambda \u8868\u8FBE\u5F0F\u7684\u51FD\u6570\u63CF\u8FF0\u7B26\u65E0\u6548\n{1} {2} \u4E2D\u7684\u65B9\u6CD5 {0} \u4E3A\u6CDB\u578B\u65B9\u6CD5
-
-# 0: symbol kind, 1: symbol
-compiler.misc.incompatible.descs.in.functional.intf=\u5728 {0} {1} \u4E2D\u627E\u5230\u4E0D\u517C\u5BB9\u7684\u51FD\u6570\u63CF\u8FF0\u7B26
-
-# 0: name, 1: list of type, 2: type, 3: list of type
-compiler.misc.descriptor=\u63CF\u8FF0\u7B26: {2} {0}({1})
-
-# 0: name, 1: list of type, 2: type, 3: list of type
-compiler.misc.descriptor.throws=\u63CF\u8FF0\u7B26: {2} {0}({1}) \u629B\u51FA{3}
-
-# 0: type
-compiler.misc.no.suitable.functional.intf.inst=\u65E0\u6CD5\u63A8\u65AD{0}\u7684\u51FD\u6570\u63A5\u53E3\u63CF\u8FF0\u7B26
-
-# 0: message segment
-compiler.misc.bad.intersection.target.for.functional.expr=lambda \u6216\u65B9\u6CD5\u5F15\u7528\u7684\u4EA4\u53C9\u7C7B\u578B\u76EE\u6807\u9519\u8BEF\n{0}
-
-# 0: symbol or type
-compiler.misc.not.an.intf.component=\u7EC4\u4EF6\u7C7B\u578B{0}\u4E0D\u662F\u63A5\u53E3
-
-# 0: symbol kind, 1: message segment
-compiler.err.invalid.mref={0}\u5F15\u7528\u65E0\u6548\n{1}
-
-# 0: symbol kind, 1: message segment
-compiler.misc.invalid.mref={0}\u5F15\u7528\u65E0\u6548\n{1}
-
-compiler.misc.static.mref.with.targs=\u6709\u5173\u9759\u6001\u65B9\u6CD5\u5F15\u7528\u7684\u53C2\u6570\u5316\u9650\u5B9A\u7B26
-
-compiler.misc.static.bound.mref=\u9759\u6001\u9650\u5236\u8303\u56F4\u65B9\u6CD5\u5F15\u7528
-
-# 0: symbol
-compiler.err.cant.assign.val.to.final.var=\u65E0\u6CD5\u4E3A\u6700\u7EC8\u53D8\u91CF{0}\u5206\u914D\u503C
-
-# 0: symbol, 1: message segment
-compiler.err.cant.ref.non.effectively.final.var=\u4ECE{1}\u5F15\u7528\u7684\u672C\u5730\u53D8\u91CF\u5FC5\u987B\u662F\u6700\u7EC8\u53D8\u91CF\u6216\u5B9E\u9645\u4E0A\u7684\u6700\u7EC8\u53D8\u91CF
-
-
-compiler.misc.lambda=lambda \u8868\u8FBE\u5F0F
-
-compiler.misc.inner.cls=\u5185\u90E8\u7C7B
-
-# 0: type
-compiler.err.cant.deref=\u65E0\u6CD5\u53D6\u6D88\u5F15\u7528{0}
-
-compiler.err.cant.extend.intf.annotation=\u5BF9\u4E8E @interfaces, \u4E0D\u5141\u8BB8 ''extends''
-
-# 0: symbol
-compiler.err.cant.inherit.from.final=\u65E0\u6CD5\u4ECE\u6700\u7EC8{0}\u8FDB\u884C\u7EE7\u627F
-
-# 0: symbol
-compiler.err.cant.ref.before.ctor.called=\u65E0\u6CD5\u5728\u8C03\u7528\u8D85\u7C7B\u578B\u6784\u9020\u5668\u4E4B\u524D\u5F15\u7528{0}
-
-compiler.err.cant.select.static.class.from.param.type=\u65E0\u6CD5\u4ECE\u53C2\u6570\u5316\u7684\u7C7B\u578B\u4E2D\u9009\u62E9\u9759\u6001\u7C7B
-
-# 0: symbol, 1: string, 2: string
-compiler.err.cant.inherit.diff.arg=\u65E0\u6CD5\u4F7F\u7528\u4EE5\u4E0B\u4E0D\u540C\u7684\u53C2\u6570\u7EE7\u627F{0}: <{1}> \u548C <{2}>
-
-compiler.err.catch.without.try=\u6709 ''catch'', \u4F46\u662F\u6CA1\u6709 ''try''
-
-# 0: symbol kind, 1: symbol
-compiler.err.clash.with.pkg.of.same.name={0} {1}\u4E0E\u5E26\u6709\u76F8\u540C\u540D\u79F0\u7684\u7A0B\u5E8F\u5305\u51B2\u7A81
-
-compiler.err.class.not.allowed=\u6B64\u5904\u4E0D\u5141\u8BB8\u4F7F\u7528\u7C7B, \u63A5\u53E3\u6216\u679A\u4E3E\u58F0\u660E
-
-compiler.err.const.expr.req=\u9700\u8981\u5E38\u91CF\u8868\u8FBE\u5F0F
-
-compiler.err.cont.outside.loop=continue \u5728 loop \u5916\u90E8
-
-# 0: symbol
-compiler.err.cyclic.inheritance=\u6D89\u53CA{0}\u7684\u5FAA\u73AF\u7EE7\u627F
-
-# 0: symbol
-compiler.err.cyclic.annotation.element=\u5143\u7D20 {0} \u7684\u7C7B\u578B\u4E3A\u5FAA\u73AF
-
-# 0: unused
-compiler.err.call.to.super.not.allowed.in.enum.ctor=\u5728\u679A\u4E3E\u6784\u9020\u5668\u4E2D\u4E0D\u5141\u8BB8\u8C03\u7528\u8D85\u7C7B
-
-# 0: type
-compiler.err.no.superclass={0}\u4E0D\u5177\u6709\u8D85\u7C7B\u3002
-
-# 0: symbol, 1: type, 2: symbol, 3: type, 4: unused
-compiler.err.concrete.inheritance.conflict={1}\u4E2D\u7684\u65B9\u6CD5{0}\u548C{3}\u4E2D\u7684\u65B9\u6CD5{2}\u662F\u4F7F\u7528\u76F8\u540C\u7684\u7B7E\u540D\u7EE7\u627F\u7684
-
-compiler.err.default.allowed.in.intf.annotation.member=\u6CE8\u91CA\u7C7B\u578B\u58F0\u660E\u4E2D\u4EC5\u5141\u8BB8\u9ED8\u8BA4\u503C
-
-# 0: symbol
-compiler.err.doesnt.exist=\u7A0B\u5E8F\u5305{0}\u4E0D\u5B58\u5728
-
-# 0: type
-compiler.err.duplicate.annotation.invalid.repeated=\u6CE8\u91CA{0}\u4E0D\u662F\u6709\u6548\u7684\u53EF\u91CD\u590D\u6CE8\u91CA
-
-# 0: name, 1: type
-compiler.err.duplicate.annotation.member.value=\u6CE8\u91CA@{1}\u4E2D\u7684\u5143\u7D20 ''{0}'' \u91CD\u590D\u3002
-
-# 0: name, 1: unused
-compiler.err.duplicate.annotation.missing.container={0} \u4E0D\u662F\u53EF\u91CD\u590D\u7684\u6CE8\u91CA\u7C7B\u578B
-
-# 0: type, 1: unused
-compiler.err.invalid.repeatable.annotation=\u6CE8\u91CA\u91CD\u590D: \u4F7F\u7528\u65E0\u6548\u7684 @Repeatable \u6CE8\u91CA\u5BF9{0}\u8FDB\u884C\u4E86\u6CE8\u91CA
-
-# 0: symbol or type
-compiler.err.invalid.repeatable.annotation.no.value={0}\u4E0D\u662F\u6709\u6548\u7684 @Repeatable, \u672A\u58F0\u660E\u4EFB\u4F55\u503C\u5143\u7D20\u65B9\u6CD5
-
-# 0: type, 1: number
-compiler.err.invalid.repeatable.annotation.multiple.values={0}\u4E0D\u662F\u6709\u6548\u7684 @Repeatable, \u5DF2\u58F0\u660E {1} \u4E2A\u540D\u4E3A ''value'' \u7684\u5143\u7D20\u65B9\u6CD5
-
-# 0: type
-compiler.err.invalid.repeatable.annotation.invalid.value={0}\u4E0D\u662F\u6709\u6548\u7684 @Repeatable: \u503C\u5143\u7D20\u65E0\u6548
-
-# 0: symbol type, 1: unused, 2: type
-compiler.err.invalid.repeatable.annotation.value.return=\u5305\u542B\u6CE8\u91CA\u7C7B\u578B ({0}) \u5FC5\u987B\u58F0\u660E\u7C7B\u578B{2}\u7684\u540D\u4E3A ''value'' \u7684\u5143\u7D20
-
-# 0: symbol or type, 1: symbol
-compiler.err.invalid.repeatable.annotation.elem.nondefault=\u5BF9\u4E8E\u5143\u7D20 {1}, \u5305\u542B\u6CE8\u91CA\u7C7B\u578B ({0}) \u6CA1\u6709\u9ED8\u8BA4\u503C
-
-# 0: symbol, 1: unused, 2: symbol, 3: unused
-compiler.err.invalid.repeatable.annotation.retention=\u5305\u542B\u6CE8\u91CA\u7C7B\u578B ({0}) \u7684\u4FDD\u7559\u671F\u77ED\u4E8E\u53EF\u91CD\u590D\u6CE8\u91CA\u7C7B\u578B ({2}) \u7684\u4FDD\u7559\u671F
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.not.documented=\u53EF\u91CD\u590D\u6CE8\u91CA\u7C7B\u578B ({1}) \u662F @Documented, \u800C\u5305\u542B\u6CE8\u91CA\u7C7B\u578B ({0}) \u5219\u4E0D\u662F
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.not.inherited=\u53EF\u91CD\u590D\u6CE8\u91CA\u7C7B\u578B ({1}) \u662F @Inherited, \u800C\u5305\u542B\u6CE8\u91CA\u7C7B\u578B ({0}) \u5219\u4E0D\u662F
-
-# 0: symbol, 1: symbol
-compiler.err.invalid.repeatable.annotation.incompatible.target=\u5305\u542B\u6CE8\u91CA\u7C7B\u578B ({0}) \u9002\u7528\u7684\u76EE\u6807\u591A\u4E8E\u53EF\u91CD\u590D\u6CE8\u91CA\u7C7B\u578B ({1})
-
-# 0: symbol
-compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\u5BB9\u5668 {0} \u4E0D\u5F97\u4E0E\u5176\u5305\u542B\u7684\u5143\u7D20\u540C\u65F6\u5B58\u5728
-
-# 0: name
-compiler.err.duplicate.class=\u7C7B\u91CD\u590D: {0}
-
-compiler.err.duplicate.case.label=case \u6807\u7B7E\u91CD\u590D
-
-compiler.err.duplicate.default.label=default \u6807\u7B7E\u91CD\u590D
-
-compiler.err.else.without.if=\u6709 ''if'', \u4F46\u662F\u6CA1\u6709 ''else''
-
-compiler.err.empty.char.lit=\u7A7A\u5B57\u7B26\u6587\u5B57
-
-# 0: symbol
-compiler.err.encl.class.required=\u9700\u8981\u5305\u542B{0}\u7684\u5C01\u95ED\u5B9E\u4F8B
-
-compiler.err.enum.annotation.must.be.enum.constant=\u679A\u4E3E\u6CE8\u91CA\u503C\u5FC5\u987B\u662F\u679A\u4E3E\u5E38\u91CF
-
-compiler.err.enum.cant.be.instantiated=\u65E0\u6CD5\u5B9E\u4F8B\u5316\u679A\u4E3E\u7C7B\u578B
-
-compiler.err.enum.label.must.be.unqualified.enum=\u679A\u4E3E switch case \u6807\u7B7E\u5FC5\u987B\u4E3A\u679A\u4E3E\u5E38\u91CF\u7684\u975E\u9650\u5B9A\u540D\u79F0
-
-compiler.err.enum.no.subclassing=\u7C7B\u65E0\u6CD5\u76F4\u63A5\u6269\u5C55 java.lang.Enum
-
-compiler.err.enum.types.not.extensible=\u679A\u4E3E\u7C7B\u578B\u4E0D\u53EF\u7EE7\u627F
-
-compiler.err.enum.no.finalize=\u679A\u4E3E\u4E0D\u80FD\u6709 finalize \u65B9\u6CD5
-
-# 0: file name, 1: string
-compiler.err.error.reading.file=\u8BFB\u53D6{0}\u65F6\u51FA\u9519; {1}
-
-# 0: type
-compiler.err.except.already.caught=\u5DF2\u6355\u83B7\u5230\u5F02\u5E38\u9519\u8BEF{0}
-
-# 0: type
-compiler.err.except.never.thrown.in.try=\u5728\u76F8\u5E94\u7684 try \u8BED\u53E5\u4E3B\u4F53\u4E2D\u4E0D\u80FD\u629B\u51FA\u5F02\u5E38\u9519\u8BEF{0}
-
-# 0: symbol
-compiler.err.final.parameter.may.not.be.assigned=\u4E0D\u80FD\u5206\u914D\u6700\u7EC8\u53C2\u6570{0}
-
-# 0: symbol
-compiler.err.try.resource.may.not.be.assigned=\u53EF\u80FD\u672A\u5206\u914D\u53EF\u81EA\u52A8\u5173\u95ED\u7684\u8D44\u6E90{0}
-
-# 0: symbol
-compiler.err.multicatch.parameter.may.not.be.assigned=\u53EF\u80FD\u672A\u5206\u914D multi-catch \u53C2\u6570{0}
-
-# 0: type, 1: type
-compiler.err.multicatch.types.must.be.disjoint=multi-catch \u8BED\u53E5\u4E2D\u7684\u66FF\u4EE3\u65E0\u6CD5\u901A\u8FC7\u5B50\u7C7B\u5316\u5173\u8054\n\u66FF\u4EE3{0}\u662F\u66FF\u4EE3{1}\u7684\u5B50\u7C7B
-
-compiler.err.finally.without.try=\u6709 ''finally'', \u4F46\u662F\u6CA1\u6709 ''try''
-
-# 0: type, 1: message segment
-compiler.err.foreach.not.applicable.to.type=for-each \u4E0D\u9002\u7528\u4E8E\u8868\u8FBE\u5F0F\u7C7B\u578B\n\u8981\u6C42: {1}\n\u627E\u5230:    {0}
-
-compiler.err.fp.number.too.large=\u6D6E\u70B9\u6570\u8FC7\u5927
-
-compiler.err.fp.number.too.small=\u6D6E\u70B9\u6570\u8FC7\u5C0F
-
-compiler.err.generic.array.creation=\u521B\u5EFA\u6CDB\u578B\u6570\u7EC4
-
-compiler.err.generic.throwable=\u6CDB\u578B\u7C7B\u4E0D\u80FD\u6269\u5C55 java.lang.Throwable
-
-# 0: symbol
-compiler.err.icls.cant.have.static.decl=\u5185\u90E8\u7C7B{0}\u4E2D\u7684\u9759\u6001\u58F0\u660E\u975E\u6CD5\n\u4FEE\u9970\u7B26 ''static'' \u4EC5\u5141\u8BB8\u5728\u5E38\u91CF\u53D8\u91CF\u58F0\u660E\u4E2D\u4F7F\u7528
-
-# 0: string
-compiler.err.illegal.char=\u975E\u6CD5\u5B57\u7B26: ''{0}''
-
-compiler.err.illegal.char.for.encoding=\u7F16\u7801{0}\u7684\u4E0D\u53EF\u6620\u5C04\u5B57\u7B26
-
-# 0: set of modifier, 1: set of modifier
-compiler.err.illegal.combination.of.modifiers=\u975E\u6CD5\u7684\u4FEE\u9970\u7B26\u7EC4\u5408: {0}\u548C{1}
-
-compiler.err.illegal.enum.static.ref=\u521D\u59CB\u5316\u7A0B\u5E8F\u4E2D\u5BF9\u9759\u6001\u5B57\u6BB5\u7684\u5F15\u7528\u4E0D\u5408\u6CD5
-
-compiler.err.illegal.esc.char=\u975E\u6CD5\u8F6C\u4E49\u7B26
-
-compiler.err.illegal.forward.ref=\u975E\u6CD5\u524D\u5411\u5F15\u7528
-
-# 0: symbol, 1: string
-compiler.err.not.in.profile={0}\u5728\u914D\u7F6E\u6587\u4EF6 ''{1}'' \u4E2D\u4E0D\u53EF\u7528
-
-# 0: symbol
-compiler.warn.forward.ref=\u5148\u5F15\u7528\u53D8\u91CF ''{0}'', \u7136\u540E\u518D\u5BF9\u5176\u521D\u59CB\u5316
-
-compiler.err.illegal.self.ref=\u521D\u59CB\u5316\u7A0B\u5E8F\u4E2D\u5B58\u5728\u81EA\u5F15\u7528
-
-# 0: symbol
-compiler.warn.self.ref=\u53D8\u91CF ''{0}'' \u7684\u521D\u59CB\u5316\u7A0B\u5E8F\u4E2D\u5B58\u5728\u81EA\u5F15\u7528
-
-compiler.err.illegal.generic.type.for.instof=instanceof \u7684\u6CDB\u578B\u7C7B\u578B\u4E0D\u5408\u6CD5
-
-# 0: type
-compiler.err.illegal.initializer.for.type={0}\u7684\u521D\u59CB\u5316\u7A0B\u5E8F\u4E0D\u5408\u6CD5
-
-compiler.err.illegal.line.end.in.char.lit=\u5B57\u7B26\u6587\u5B57\u7684\u884C\u7ED3\u5C3E\u4E0D\u5408\u6CD5
-
-compiler.err.illegal.nonascii.digit=\u975E\u6CD5\u7684\u975E ASCII \u6570\u5B57
-
-compiler.err.illegal.underscore=\u975E\u6CD5\u4E0B\u5212\u7EBF
-
-compiler.err.illegal.dot=\u975E\u6CD5 ''.''
-
-# 0: symbol
-compiler.err.illegal.qual.not.icls=\u975E\u6CD5\u9650\u5B9A\u7B26; {0}\u4E0D\u662F\u5185\u90E8\u7C7B
-
-compiler.err.illegal.start.of.expr=\u975E\u6CD5\u7684\u8868\u8FBE\u5F0F\u5F00\u59CB
-
-compiler.err.illegal.start.of.stmt=\u975E\u6CD5\u7684\u8BED\u53E5\u5F00\u59CB
-
-compiler.err.illegal.start.of.type=\u975E\u6CD5\u7684\u7C7B\u578B\u5F00\u59CB
-
-compiler.err.illegal.unicode.esc=\u975E\u6CD5\u7684 Unicode \u8F6C\u4E49
-
-# 0: symbol
-compiler.err.import.requires.canonical=\u5BFC\u5165\u9700\u8981{0}\u7684\u89C4\u8303\u540D\u79F0
-
-compiler.err.improperly.formed.type.param.missing=\u7C7B\u578B\u7684\u683C\u5F0F\u4E0D\u6B63\u786E, \u7F3A\u5C11\u67D0\u4E9B\u53C2\u6570
-
-compiler.err.improperly.formed.type.inner.raw.param=\u7C7B\u578B\u7684\u683C\u5F0F\u4E0D\u6B63\u786E, \u7ED9\u51FA\u4E86\u539F\u59CB\u7C7B\u578B\u7684\u7C7B\u578B\u53C2\u6570
-
-# 0: type, 1: type
-compiler.err.incomparable.types=\u4E0D\u53EF\u6BD4\u8F83\u7684\u7C7B\u578B: {0}\u548C{1}
-
-# 0: number
-compiler.err.int.number.too.large=\u8FC7\u5927\u7684\u6574\u6570: {0}
-
-compiler.err.intf.annotation.members.cant.have.params=\u6CE8\u91CA\u7C7B\u578B\u58F0\u660E\u4E2D\u7684\u5143\u7D20\u65E0\u6CD5\u58F0\u660E\u5F62\u53C2
-
-# 0: symbol
-compiler.err.intf.annotation.cant.have.type.params=\u6CE8\u91CA\u7C7B\u578B {0} \u4E0D\u80FD\u4E3A\u6CDB\u578B
-
-compiler.err.intf.annotation.members.cant.have.type.params=\u6CE8\u91CA\u7C7B\u578B\u58F0\u660E\u4E2D\u7684\u5143\u7D20\u4E0D\u80FD\u4E3A\u6CDB\u578B\u65B9\u6CD5
-
-# 0: symbol, 1: type
-compiler.err.intf.annotation.member.clash=\u6CE8\u91CA\u7C7B\u578B{1}\u58F0\u660E\u4E0E\u65B9\u6CD5 {0} \u540C\u540D\u7684\u5143\u7D20
-
-compiler.err.intf.expected.here=\u6B64\u5904\u9700\u8981\u63A5\u53E3
-
-compiler.err.intf.meth.cant.have.body=\u63A5\u53E3\u62BD\u8C61\u65B9\u6CD5\u4E0D\u80FD\u5E26\u6709\u4E3B\u4F53
-
-# 0: symbol
-compiler.err.invalid.annotation.member.type=\u6CE8\u91CA\u7C7B\u578B\u5143\u7D20 {0} \u7684\u7C7B\u578B\u65E0\u6548
-
-compiler.err.invalid.binary.number=\u4E8C\u8FDB\u5236\u6570\u5B57\u4E2D\u5FC5\u987B\u5305\u542B\u81F3\u5C11\u4E00\u4E2A\u4E8C\u8FDB\u5236\u6570
-
-compiler.err.invalid.hex.number=\u5341\u516D\u8FDB\u5236\u6570\u5B57\u5FC5\u987B\u5305\u542B\u81F3\u5C11\u4E00\u4F4D\u5341\u516D\u8FDB\u5236\u6570
-
-compiler.err.invalid.meth.decl.ret.type.req=\u65B9\u6CD5\u58F0\u660E\u65E0\u6548; \u9700\u8981\u8FD4\u56DE\u7C7B\u578B
-
-compiler.err.varargs.and.old.array.syntax=variable-arity \u53C2\u6570\u4E2D\u4E0D\u5141\u8BB8\u4F7F\u7528\u4F20\u7EDF\u6570\u7EC4\u8BB0\u53F7
-
-compiler.err.varargs.and.receiver =\u63A5\u6536\u65B9\u53C2\u6570\u4E0D\u5141\u8BB8\u4F7F\u7528 varargs \u8BB0\u53F7
-
-compiler.err.array.and.receiver =\u63A5\u6536\u65B9\u53C2\u6570\u4E0D\u5141\u8BB8\u4F7F\u7528\u4F20\u7EDF\u6570\u7EC4\u8BB0\u53F7
-
-compiler.err.variable.not.allowed=\u6B64\u5904\u4E0D\u5141\u8BB8\u4F7F\u7528\u53D8\u91CF\u58F0\u660E
-
-# 0: name
-compiler.err.label.already.in.use=\u6807\u7B7E{0}\u5DF2\u4F7F\u7528
-
-# 0: symbol
-compiler.err.local.var.accessed.from.icls.needs.final=\u4ECE\u5185\u90E8\u7C7B\u4E2D\u8BBF\u95EE\u672C\u5730\u53D8\u91CF{0}; \u9700\u8981\u88AB\u58F0\u660E\u4E3A\u6700\u7EC8\u7C7B\u578B
-
-compiler.err.local.enum=\u679A\u4E3E\u7C7B\u578B\u4E0D\u80FD\u4E3A\u672C\u5730\u7C7B\u578B
-
-compiler.err.cannot.create.array.with.type.arguments=\u65E0\u6CD5\u521B\u5EFA\u5177\u6709\u7C7B\u578B\u53D8\u91CF\u7684\u6570\u7EC4
-
-compiler.err.cannot.create.array.with.diamond=\u65E0\u6CD5\u521B\u5EFA\u5177\u6709 ''<>'' \u7684\u6570\u7EC4
-
-#
-# limits.  We don't give the limits in the diagnostic because we expect
-# them to change, yet we want to use the same diagnostic.  These are all
-# detected during code generation.
-#
-compiler.err.limit.code=\u4EE3\u7801\u8FC7\u957F
-
-compiler.err.limit.code.too.large.for.try.stmt=try \u8BED\u53E5\u7684\u4EE3\u7801\u8FC7\u957F
-
-compiler.err.limit.dimensions=\u6570\u7EC4\u7C7B\u578B\u7EF4\u8FC7\u591A
-
-compiler.err.limit.locals=\u672C\u5730\u53D8\u91CF\u8FC7\u591A
-
-compiler.err.limit.parameters=\u53C2\u6570\u8FC7\u591A
-
-compiler.err.limit.pool=\u5E38\u91CF\u8FC7\u591A
-
-compiler.err.limit.pool.in.class=\u7C7B{0}\u4E2D\u7684\u5E38\u91CF\u8FC7\u591A
-
-compiler.err.limit.stack=\u4EE3\u7801\u9700\u8981\u8FC7\u591A\u5806\u6808
-
-compiler.err.limit.string=\u5E38\u91CF\u5B57\u7B26\u4E32\u8FC7\u957F
-
-compiler.err.limit.string.overflow=\u5BF9\u4E8E\u5E38\u91CF\u6C60\u6765\u8BF4, \u5B57\u7B26\u4E32 "{0}..." \u7684 UTF8 \u8868\u793A\u8FC7\u957F
-
-compiler.err.malformed.fp.lit=\u6D6E\u70B9\u6587\u5B57\u7684\u683C\u5F0F\u9519\u8BEF
-
-compiler.err.method.does.not.override.superclass=\u65B9\u6CD5\u4E0D\u4F1A\u8986\u76D6\u6216\u5B9E\u73B0\u8D85\u7C7B\u578B\u7684\u65B9\u6CD5
-
-compiler.err.missing.meth.body.or.decl.abstract=\u7F3A\u5C11\u65B9\u6CD5\u4E3B\u4F53, \u6216\u58F0\u660E\u62BD\u8C61
-
-compiler.err.missing.ret.stmt=\u7F3A\u5C11\u8FD4\u56DE\u8BED\u53E5
-
-# 0: unused
-compiler.misc.missing.ret.val=\u7F3A\u5C11\u8FD4\u56DE\u503C
-
-compiler.misc.unexpected.ret.val=\u610F\u5916\u7684\u8FD4\u56DE\u503C
-
-# 0: set of modifier
-compiler.err.mod.not.allowed.here=\u6B64\u5904\u4E0D\u5141\u8BB8\u4F7F\u7528\u4FEE\u9970\u7B26{0}
-
-compiler.err.intf.not.allowed.here=\u6B64\u5904\u4E0D\u5141\u8BB8\u4F7F\u7528\u63A5\u53E3
-
-compiler.err.enums.must.be.static=\u53EA\u6709\u5728\u9759\u6001\u4E0A\u4E0B\u6587\u4E2D\u624D\u5141\u8BB8\u4F7F\u7528\u679A\u4E3E\u58F0\u660E
-
-# 0: symbol, 1: symbol
-compiler.err.name.clash.same.erasure=\u540D\u79F0\u51B2\u7A81: {0}\u548C{1}\u5177\u6709\u76F8\u540C\u7591\u7B26
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: unused, 5: unused
-compiler.err.name.clash.same.erasure.no.override=\u540D\u79F0\u51B2\u7A81: {1}\u4E2D\u7684{0}\u548C{3}\u4E2D\u7684{2}\u5177\u6709\u76F8\u540C\u7591\u7B26, \u4F46\u4E24\u8005\u5747\u4E0D\u8986\u76D6\u5BF9\u65B9
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: symbol, 5: symbol
-compiler.err.name.clash.same.erasure.no.override.1=\u540D\u79F0\u51B2\u7A81: {1} \u4E2D\u7684 {0} \u8986\u76D6\u7684\u65B9\u6CD5\u7684\u7591\u7B26\u4E0E\u53E6\u4E00\u4E2A\u65B9\u6CD5\u7684\u76F8\u540C, \u4F46\u4E24\u8005\u5747\u4E0D\u8986\u76D6\u5BF9\u65B9\n\u7B2C\u4E00\u4E2A\u65B9\u6CD5:  {3} \u4E2D\u7684 {2}\n\u7B2C\u4E8C\u4E2A\u65B9\u6CD5: {5} \u4E2D\u7684 {4}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.err.name.clash.same.erasure.no.hide=\u540D\u79F0\u51B2\u7A81: {1} \u4E2D\u7684 {0} \u548C {3} \u4E2D\u7684 {2} \u5177\u6709\u76F8\u540C\u7591\u7B26, \u4F46\u4E24\u8005\u5747\u4E0D\u9690\u85CF\u5BF9\u65B9
-
-compiler.err.name.reserved.for.internal.use={0}\u4E3A\u5185\u90E8\u4F7F\u7528\u4FDD\u7559
-
-compiler.err.native.meth.cant.have.body=\u672C\u673A\u65B9\u6CD5\u4E0D\u80FD\u5E26\u6709\u4E3B\u4F53
-
-# 0: type, 1: type
-compiler.err.neither.conditional.subtype=? \u7684\u4E0D\u517C\u5BB9\u7C7B\u578B: \u4E24\u8005\u90FD\u4E0D\u662F\u5BF9\u65B9\u7684\u5B50\u7C7B\u578B\n\u7B2C\u4E8C\u4E2A\u64CD\u4F5C\u6570: {0}\n\u7B2C\u4E09\u4E2A\u64CD\u4F5C\u6570: {1}
-
-# 0: message segment
-compiler.misc.incompatible.type.in.conditional=\u6761\u4EF6\u8868\u8FBE\u5F0F\u4E2D\u7684\u7C7B\u578B\u9519\u8BEF\n{0}
-
-compiler.misc.conditional.target.cant.be.void=\u6761\u4EF6\u8868\u8FBE\u5F0F\u7684\u76EE\u6807\u7C7B\u578B\u4E0D\u80FD\u4E3A\u7A7A
-
-# 0: type
-compiler.misc.incompatible.ret.type.in.lambda=lambda \u8868\u8FBE\u5F0F\u4E2D\u7684\u8FD4\u56DE\u7C7B\u578B\u9519\u8BEF\n{0}
-
-# 0: type
-compiler.misc.incompatible.ret.type.in.mref=\u65B9\u6CD5\u5F15\u7528\u4E2D\u7684\u8FD4\u56DE\u7C7B\u578B\u9519\u8BEF\n{0}
-
-compiler.err.lambda.body.neither.value.nor.void.compatible=lambda \u4E3B\u4F53\u4E0D\u662F\u503C, \u4E5F\u4E0D\u4E0E void \u517C\u5BB9
-
-# 0: list of type
-compiler.err.incompatible.thrown.types.in.mref=\u65B9\u6CD5\u5F15\u7528\u4E2D\u629B\u51FA\u7684\u7C7B\u578B{0}\u4E0D\u517C\u5BB9
-
-compiler.misc.incompatible.arg.types.in.lambda=lambda \u8868\u8FBE\u5F0F\u4E2D\u7684\u53C2\u6570\u7C7B\u578B\u4E0D\u517C\u5BB9
-
-compiler.misc.incompatible.arg.types.in.mref=\u65B9\u6CD5\u5F15\u7528\u4E2D\u7684\u53C2\u6570\u7C7B\u578B\u4E0D\u517C\u5BB9
-
-compiler.err.new.not.allowed.in.annotation=\u6CE8\u91CA\u4E2D\u4E0D\u5141\u8BB8\u4F7F\u7528 ''new''
-
-compiler.err.no.annotation.member={1}\u4E2D\u6CA1\u6709\u6CE8\u91CA\u6210\u5458{0}
-
-compiler.err.no.encl.instance.of.type.in.scope=\u4F5C\u7528\u57DF\u4E2D\u6CA1\u6709\u7C7B\u578B\u4E3A{0}\u7684\u5C01\u95ED\u5B9E\u4F8B
-
-compiler.err.no.intf.expected.here=\u6B64\u5904\u4E0D\u9700\u8981\u63A5\u53E3
-
-compiler.err.no.match.entry={0}\u5728{1}\u7684\u6761\u76EE\u4E2D\u6CA1\u6709\u5339\u914D\u9879; \u9700\u8981{2}
-
-compiler.err.not.annotation.type={0}\u4E0D\u662F\u6CE8\u91CA\u7C7B\u578B
-
-# 0: symbol, 1: symbol
-compiler.err.not.def.access.class.intf.cant.access={1}\u4E2D\u7684{0}\u662F\u5728\u4E0D\u53EF\u8BBF\u95EE\u7684\u7C7B\u6216\u63A5\u53E3\u4E2D\u5B9A\u4E49\u7684
-
-# 0: symbol, 1: symbol
-compiler.misc.not.def.access.class.intf.cant.access={1}\u4E2D\u7684{0}\u662F\u5728\u4E0D\u53EF\u8BBF\u95EE\u7684\u7C7B\u6216\u63A5\u53E3\u4E2D\u5B9A\u4E49\u7684
-
-# 0: symbol, 1: list of type, 2: type
-compiler.misc.cant.access.inner.cls.constr=\u65E0\u6CD5\u8BBF\u95EE\u6784\u9020\u5668 {0}({1})\n\u4F5C\u7528\u57DF\u4E2D\u6CA1\u6709\u7C7B\u578B\u4E3A{2}\u7684\u5C01\u95ED\u5B9E\u4F8B
-
-# 0: symbol, 1: symbol
-compiler.err.not.def.public.cant.access={0}\u5728{1}\u4E2D\u4E0D\u662F\u516C\u5171\u7684; \u65E0\u6CD5\u4ECE\u5916\u90E8\u7A0B\u5E8F\u5305\u4E2D\u5BF9\u5176\u8FDB\u884C\u8BBF\u95EE
-
-# 0: symbol, 1: symbol
-compiler.misc.not.def.public.cant.access={0}\u5728{1}\u4E2D\u4E0D\u662F\u516C\u5171\u7684; \u65E0\u6CD5\u4ECE\u5916\u90E8\u7A0B\u5E8F\u5305\u4E2D\u5BF9\u5176\u8FDB\u884C\u8BBF\u95EE
-
-# 0: name
-compiler.err.not.loop.label=\u4E0D\u662F loop \u6807\u7B7E: {0}
-
-compiler.err.not.stmt=\u4E0D\u662F\u8BED\u53E5
-
-# 0: symbol
-compiler.err.not.encl.class=\u4E0D\u662F\u5C01\u95ED\u7C7B: {0}
-
-# 0: name, 1: type, 2: unused
-compiler.err.operator.cant.be.applied=\u4E00\u5143\u8FD0\u7B97\u7B26 ''{0}'' \u7684\u64CD\u4F5C\u6570\u7C7B\u578B{1}\u9519\u8BEF
-
-# 0: name, 1: type, 2: type
-compiler.err.operator.cant.be.applied.1=\u4E8C\u5143\u8FD0\u7B97\u7B26 ''{0}'' \u7684\u64CD\u4F5C\u6570\u7C7B\u578B\u9519\u8BEF\n\u7B2C\u4E00\u4E2A\u7C7B\u578B:  {1}\n\u7B2C\u4E8C\u4E2A\u7C7B\u578B: {2}
-
-compiler.err.pkg.annotations.sb.in.package-info.java=\u7A0B\u5E8F\u5305\u6CE8\u91CA\u5E94\u5728\u6587\u4EF6 package-info.java \u4E2D
-
-# 0: symbol
-compiler.err.pkg.clashes.with.class.of.same.name=\u7A0B\u5E8F\u5305{0}\u4E0E\u5E26\u6709\u76F8\u540C\u540D\u79F0\u7684\u7C7B\u51B2\u7A81
-
-compiler.err.warnings.and.werror=\u53D1\u73B0\u8B66\u544A, \u4F46\u6307\u5B9A\u4E86 -Werror
-
-# Errors related to annotation processing
-
-# 0: symbol, 1: string, 2: stack-trace
-compiler.err.proc.cant.access=\u65E0\u6CD5\u8BBF\u95EE{0}\n{1}\n\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u53C2\u9605\u4EE5\u4E0B\u5806\u6808\u8DDF\u8E2A\u3002\n{2}
-
-# 0: symbol, 1: string
-compiler.err.proc.cant.access.1=\u65E0\u6CD5\u8BBF\u95EE{0}\n{1}
-
-# 0: string
-compiler.err.proc.cant.find.class=\u627E\u4E0D\u5230 ''{0}'' \u7684\u7C7B\u6587\u4EF6\u3002
-
-# Print a client-generated error message; assumed to be localized, no translation required
-# 0: string
-compiler.err.proc.messager={0}
-
-# 0: list of string
-compiler.err.proc.no.explicit.annotation.processing.requested=\u4EC5\u5F53\u663E\u5F0F\u8BF7\u6C42\u6CE8\u91CA\u5904\u7406\u65F6\u624D\u63A5\u53D7\u7C7B\u540D\u79F0 ''{0}''
-
-compiler.err.proc.no.service=ServiceLoader \u4E0D\u53EF\u7528, \u4F46\u5B83\u662F\u6CE8\u91CA\u5904\u7406\u6240\u5FC5\u9700\u7684\u3002
-
-compiler.err.proc.processor.bad.option.name=\u5904\u7406\u7A0B\u5E8F ''{1}'' \u63D0\u4F9B\u7684\u9009\u9879\u540D\u79F0 ''{0}'' \u9519\u8BEF
-
-# 0: string
-compiler.err.proc.processor.cant.instantiate=\u65E0\u6CD5\u5B9E\u4F8B\u5316\u5904\u7406\u7A0B\u5E8F ''{0}'' \u7684\u5B9E\u4F8B
-
-# 0: string
-compiler.err.proc.processor.not.found=\u627E\u4E0D\u5230\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F ''{0}''
-
-# 0: string
-compiler.err.proc.processor.wrong.type=\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F ''{0}'' \u672A\u5B9E\u73B0 javax.annotation.processing.Processor
-
-compiler.err.proc.service.problem=\u521B\u5EFA\u670D\u52A1\u52A0\u8F7D\u5668\u4EE5\u52A0\u8F7D\u5904\u7406\u7A0B\u5E8F\u65F6\u51FA\u9519\u3002
-
-compiler.err.proc.bad.config.file=\u670D\u52A1\u914D\u7F6E\u6587\u4EF6\u4E0D\u6B63\u786E, \u6216\u6784\u9020\u5904\u7406\u7A0B\u5E8F\u5BF9\u8C61{0}\u65F6\u629B\u51FA\u5F02\u5E38\u9519\u8BEF
-
-compiler.err.proc.cant.create.loader=\u65E0\u6CD5\u4E3A\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F{0}\u521B\u5EFA\u7C7B\u52A0\u8F7D\u5668
-
-# 0: unused
-compiler.err.qualified.new.of.static.class=\u9650\u5B9A\u7684\u65B0\u9759\u6001\u7C7B
-
-compiler.err.recursive.ctor.invocation=\u9012\u5F52\u6784\u9020\u5668\u8C03\u7528
-
-# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
-compiler.err.ref.ambiguous=\u5BF9{0}\u7684\u5F15\u7528\u4E0D\u660E\u786E\n{3} \u4E2D\u7684{1} {2} \u548C {6} \u4E2D\u7684{4} {5} \u90FD\u5339\u914D
-
-# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
-compiler.misc.ref.ambiguous=\u5BF9{0}\u7684\u5F15\u7528\u4E0D\u660E\u786E\n{3} \u4E2D\u7684{1} {2} \u548C {6} \u4E2D\u7684{4} {5} \u90FD\u5339\u914D
-
-compiler.err.repeated.annotation.target=\u6CE8\u91CA\u76EE\u6807\u91CD\u590D
-
-compiler.err.repeated.interface=\u63A5\u53E3\u91CD\u590D
-
-compiler.err.repeated.modifier=\u4FEE\u9970\u7B26\u91CD\u590D
-
-# 0: symbol, 1: set of modifier, 2: symbol
-compiler.err.report.access={0}\u53EF\u4EE5\u5728{2}\u4E2D\u8BBF\u95EE{1}
-
-# 0: symbol, 1: set of modifier, 2: symbol
-compiler.misc.report.access={0}\u53EF\u4EE5\u5728{2}\u4E2D\u8BBF\u95EE{1}
-
-compiler.err.ret.outside.meth=\u8FD4\u56DE\u5916\u90E8\u65B9\u6CD5
-
-compiler.err.signature.doesnt.match.supertype=\u7B7E\u540D\u4E0E{0}\u4E0D\u5339\u914D; \u4E0D\u517C\u5BB9\u7684\u8D85\u7C7B\u578B
-
-compiler.err.signature.doesnt.match.intf=\u7B7E\u540D\u4E0E{0}\u4E0D\u5339\u914D; \u4E0D\u517C\u5BB9\u7684\u63A5\u53E3
-
-# 0: number, 1: number
-compiler.err.method.invoked.with.incorrect.number.arguments=\u4F7F\u7528\u4E0D\u6B63\u786E\u6570\u91CF\u7684\u53C2\u6570\u8C03\u7528\u4E86\u65B9\u6CD5; \u9884\u671F\u4E3A {0} \u4E2A, \u627E\u5230 {1} \u4E2A
-
-# 0: symbol, 1: symbol, 2: symbol
-compiler.err.does.not.override.abstract={0}\u4E0D\u662F\u62BD\u8C61\u7684, \u5E76\u4E14\u672A\u8986\u76D6{2}\u4E2D\u7684\u62BD\u8C61\u65B9\u6CD5{1}
-
-compiler.err.source.cant.overwrite.input.file=\u5199\u5165\u6E90\u65F6\u51FA\u9519; \u65E0\u6CD5\u8986\u76D6\u8F93\u5165\u6587\u4EF6{0}
-
-compiler.err.stack.sim.error=\u5185\u90E8\u9519\u8BEF: {0}\u4E2D\u7684\u5806\u6808 sim \u9519\u8BEF
-
-compiler.err.static.imp.only.classes.and.interfaces=\u4EC5\u4ECE\u7C7B\u548C\u63A5\u53E3\u9759\u6001\u5BFC\u5165
-
-compiler.err.string.const.req=\u9700\u8981\u5E38\u91CF\u5B57\u7B26\u4E32\u8868\u8FBE\u5F0F
-
-# 0: symbol, 1: symbol
-compiler.err.synthetic.name.conflict=\u7B26\u53F7{0}\u4E0E{1}\u4E2D\u7684 compiler-synthesized \u7B26\u53F7\u51B2\u7A81
-
-# 0: symbol, 1: symbol
-compiler.warn.synthetic.name.conflict=\u7B26\u53F7{0}\u4E0E{1}\u4E2D\u7684 compiler-synthesized \u7B26\u53F7\u51B2\u7A81
-
-compiler.err.throws.not.allowed.in.intf.annotation=@interface \u6210\u5458\u4E2D\u4E0D\u5141\u8BB8\u4F7F\u7528 throws \u5B50\u53E5
-
-compiler.err.try.without.catch.or.finally=\u6709 ''try'', \u4F46\u662F\u6CA1\u6709 ''catch'' \u6216 ''finally''
-
-compiler.err.try.without.catch.finally.or.resource.decls=''try'' \u4E0D\u5E26\u6709 ''catch'', ''finally'' \u6216\u8D44\u6E90\u58F0\u660E
-
-# 0: symbol
-compiler.err.type.doesnt.take.params=\u7C7B\u578B{0}\u4E0D\u5E26\u6709\u53C2\u6570
-
-compiler.err.type.var.cant.be.deref=\u65E0\u6CD5\u4ECE\u7C7B\u578B\u53D8\u91CF\u4E2D\u8FDB\u884C\u9009\u62E9
-
-compiler.err.type.var.may.not.be.followed.by.other.bounds=\u7C7B\u578B\u53D8\u91CF\u540E\u9762\u4E0D\u80FD\u5E26\u6709\u5176\u4ED6\u9650\u5236\u8303\u56F4
-
-compiler.err.type.var.more.than.once=\u7C7B\u578B\u53D8\u91CF{0}\u5728{1}\u7684\u7ED3\u679C\u7C7B\u578B\u4E2D\u591A\u6B21\u51FA\u73B0; \u5FC5\u987B\u5BF9\u5176\u8FDB\u884C\u5B9E\u4F8B\u5316
-
-compiler.err.type.var.more.than.once.in.result=\u7C7B\u578B\u53D8\u91CF{0}\u5728{1}\u7684\u7C7B\u578B\u4E2D\u591A\u6B21\u51FA\u73B0; \u5FC5\u987B\u5BF9\u5176\u8FDB\u884C\u5B9E\u4F8B\u5316
-
-# 0: type, 1: type, 2: string
-compiler.err.types.incompatible.diff.ret=\u7C7B\u578B{0}\u548C{1}\u4E0D\u517C\u5BB9; \u4E24\u8005\u90FD\u5B9A\u4E49\u4E86{2}, \u4F46\u5374\u5E26\u6709\u4E0D\u76F8\u5173\u7684\u8FD4\u56DE\u7C7B\u578B
-
-# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
-compiler.err.types.incompatible.unrelated.defaults={0} {1}\u4ECE\u7C7B\u578B {4} \u548C {5} \u4E2D\u7EE7\u627F\u4E86{2}({3}) \u7684\u4E0D\u76F8\u5173\u9ED8\u8BA4\u503C
-
-# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
-compiler.err.types.incompatible.abstract.default={0} {1}\u4ECE\u7C7B\u578B {4} \u548C {5} \u4E2D\u7EE7\u627F\u4E86{2}({3}) \u7684\u62BD\u8C61\u548C\u9ED8\u8BA4\u503C
-
-# 0: name, 1: kind, 2: symbol
-compiler.err.default.overrides.object.member={1} {2} \u4E2D\u7684\u9ED8\u8BA4\u65B9\u6CD5{0}\u8986\u76D6\u4E86 java.lang.Object \u7684\u6210\u5458
-
-# 0: type
-compiler.err.illegal.static.intf.meth.call=\u9759\u6001\u63A5\u53E3\u65B9\u6CD5\u8C03\u7528\u975E\u6CD5\n\u5E94\u5C06\u63A5\u6536\u65B9\u8868\u8FBE\u5F0F\u66FF\u6362\u4E3A\u7C7B\u578B\u9650\u5B9A\u7B26 ''{0}''
-
-# 0: type, 1: message segment
-compiler.err.illegal.default.super.call=\u9ED8\u8BA4\u8D85\u7EA7\u8C03\u7528\u4E2D\u7684\u7C7B\u578B\u9650\u5B9A\u7B26{0}\u9519\u8BEF\n{1}
-
-# 0: symbol, 1: type
-compiler.misc.overridden.default=\u8986\u76D6\u4E86{1}\u4E2D\u7684\u65B9\u6CD5 {0}
-
-# 0: symbol, 1: type or symbol
-compiler.misc.redundant.supertype=\u5197\u4F59\u63A5\u53E3 {0} \u5DF2\u7531 {1} \u6269\u5C55
-
-compiler.err.unclosed.char.lit=\u672A\u7ED3\u675F\u7684\u5B57\u7B26\u6587\u5B57
-
-compiler.err.unclosed.comment=\u672A\u7ED3\u675F\u7684\u6CE8\u91CA
-
-compiler.err.unclosed.str.lit=\u672A\u7ED3\u675F\u7684\u5B57\u7B26\u4E32\u6587\u5B57
-
-# 0: name
-compiler.err.unsupported.encoding=\u4E0D\u652F\u6301\u7684\u7F16\u7801: {0}
-
-compiler.err.io.exception=\u8BFB\u53D6\u6E90\u6587\u4EF6\u65F6\u51FA\u9519: {0}
-
-# 0: name
-compiler.err.undef.label=\u672A\u5B9A\u4E49\u7684\u6807\u7B7E: {0}
-
-# 0: message segment, 1: unused
-compiler.err.cant.apply.diamond=\u65E0\u6CD5\u63A8\u65AD{0}\u7684\u7C7B\u578B\u53C2\u6570
-
-# 0: message segment or type, 1: message segment
-compiler.err.cant.apply.diamond.1=\u65E0\u6CD5\u63A8\u65AD{0}\u7684\u7C7B\u578B\u53C2\u6570\n\u539F\u56E0: {1}
-
-# 0: message segment or type, 1: message segment
-compiler.misc.cant.apply.diamond.1=\u65E0\u6CD5\u63A8\u65AD{0}\u7684\u7C7B\u578B\u53C2\u6570\n\u539F\u56E0: {1}
-
-compiler.err.unreachable.stmt=\u65E0\u6CD5\u8BBF\u95EE\u7684\u8BED\u53E5
-
-compiler.err.initializer.must.be.able.to.complete.normally=\u521D\u59CB\u5316\u7A0B\u5E8F\u5FC5\u987B\u80FD\u591F\u6B63\u5E38\u5B8C\u6210
-
-# 0: type
-compiler.err.unreported.exception.need.to.catch.or.throw=\u672A\u62A5\u544A\u7684\u5F02\u5E38\u9519\u8BEF{0}; \u5FC5\u987B\u5BF9\u5176\u8FDB\u884C\u6355\u83B7\u6216\u58F0\u660E\u4EE5\u4FBF\u629B\u51FA
-
-# 0: type
-compiler.err.unreported.exception.default.constructor=\u9ED8\u8BA4\u6784\u9020\u5668\u4E2D\u672A\u62A5\u544A\u7684\u5F02\u5E38\u9519\u8BEF{0}
-
-# 0: type, 1: name
-compiler.err.unreported.exception.implicit.close=\u672A\u62A5\u544A\u7684\u5F02\u5E38\u9519\u8BEF{0}; \u5FC5\u987B\u5BF9\u5176\u8FDB\u884C\u6355\u83B7\u6216\u58F0\u660E\u4EE5\u4FBF\u629B\u51FA\n\u5BF9\u8D44\u6E90\u53D8\u91CF ''{1}'' \u9690\u5F0F\u8C03\u7528 close() \u65F6\u629B\u51FA\u4E86\u5F02\u5E38\u9519\u8BEF
-
-compiler.err.unsupported.cross.fp.lit=\u8BE5 VM \u4E0D\u652F\u6301\u5341\u516D\u8FDB\u5236\u6D6E\u70B9\u6587\u5B57
-
-compiler.err.void.not.allowed.here=\u6B64\u5904\u4E0D\u5141\u8BB8\u4F7F\u7528 ''\u7A7A'' \u7C7B\u578B
-
-# 0: string
-compiler.err.wrong.number.type.args=\u7C7B\u578B\u53D8\u91CF\u6570\u76EE\u9519\u8BEF; \u9700\u8981{0}
-
-# 0: symbol
-compiler.err.var.might.already.be.assigned=\u53EF\u80FD\u5DF2\u5206\u914D\u53D8\u91CF{0}
-
-# 0: symbol
-compiler.err.var.might.not.have.been.initialized=\u53EF\u80FD\u5C1A\u672A\u521D\u59CB\u5316\u53D8\u91CF{0}
-
-# 0: symbol
-compiler.err.var.not.initialized.in.default.constructor=\u53D8\u91CF {0} \u672A\u5728\u9ED8\u8BA4\u6784\u9020\u5668\u4E2D\u521D\u59CB\u5316
-
-# 0: symbol
-compiler.err.var.might.be.assigned.in.loop=\u53EF\u80FD\u5728 loop \u4E2D\u5206\u914D\u4E86\u53D8\u91CF{0}
-
-# 0: symbol, 1: message segment
-compiler.err.varargs.invalid.trustme.anno={0} \u6CE8\u91CA\u65E0\u6548\u3002{1}
-
-# 0: type
-compiler.misc.varargs.trustme.on.reifiable.varargs=Varargs \u5143\u7D20\u7C7B\u578B{0}\u53EF\u5177\u4F53\u5316\u3002
-
-# 0: symbol
-compiler.misc.varargs.trustme.on.non.varargs.meth=\u65B9\u6CD5 {0} \u4E0D\u662F varargs \u65B9\u6CD5\u3002
-
-# 0: symbol
-compiler.misc.varargs.trustme.on.virtual.varargs=\u5B9E\u4F8B\u65B9\u6CD5 {0} \u4E0D\u662F\u6700\u7EC8\u7684\u3002
-
-# 0: type, 1: symbol kind, 2: symbol
-compiler.misc.inaccessible.varargs.type=\u5F62\u5F0F varargs \u5143\u7D20\u7C7B\u578B{0}\u65E0\u6CD5\u4ECE {1} {2} \u8FDB\u884C\u8BBF\u95EE
-
-# In the following string, {1} will always be the detail message from
-# java.io.IOException.
-# 0: symbol, 1: string
-compiler.err.class.cant.write=\u5199\u5165{0}\u65F6\u51FA\u9519: {1}
-
-# In the following string, {0} is the name of the class in the Java source.
-# It really should be used two times..
-# 0: name
-compiler.err.class.public.should.be.in.file=\u7C7B{0}\u662F\u516C\u5171\u7684, \u5E94\u5728\u540D\u4E3A {0}.java \u7684\u6587\u4EF6\u4E2D\u58F0\u660E
-
-## All errors which do not refer to a particular line in the source code are
-## preceded by this string.
-compiler.err.error=\u9519\u8BEF: 
-
-# The following error messages do not refer to a line in the source code.
-compiler.err.cant.read.file=\u65E0\u6CD5\u8BFB\u53D6: {0}
-
-#####
-
-# Fatal Errors
-
-compiler.misc.fatal.err.no.java.lang=\u81F4\u547D\u9519\u8BEF: \u5728\u7C7B\u8DEF\u5F84\u6216\u5F15\u5BFC\u7C7B\u8DEF\u5F84\u4E2D\u627E\u4E0D\u5230\u7A0B\u5E8F\u5305 java.lang
-
-compiler.misc.fatal.err.cant.locate.meth=\u81F4\u547D\u9519\u8BEF: \u627E\u4E0D\u5230\u65B9\u6CD5{0}
-
-compiler.misc.fatal.err.cant.locate.field=\u81F4\u547D\u9519\u8BEF: \u627E\u4E0D\u5230\u5B57\u6BB5{0}
-
-compiler.misc.fatal.err.cant.locate.ctor=\u81F4\u547D\u9519\u8BEF: \u627E\u4E0D\u5230{0}\u7684\u6784\u9020\u5668
-
-compiler.misc.fatal.err.cant.close=\u81F4\u547D\u9519\u8BEF: \u65E0\u6CD5\u5173\u95ED\u7F16\u8BD1\u5668\u8D44\u6E90
-
-#####
-
-##
-## miscellaneous strings
-##
-
-compiler.misc.source.unavailable=(\u6E90\u4E0D\u53EF\u7528)
-
-compiler.misc.base.membership=\u60A8\u7684\u6240\u6709\u57FA\u7C7B\u90FD\u5C5E\u4E8E\u6211\u4EEC
-
-# 0: string, 1: string, 2: boolean
-compiler.misc.x.print.processor.info=\u5904\u7406\u7A0B\u5E8F{0}\u4E0E{1}\u5339\u914D\u5E76\u8FD4\u56DE{2}\u3002
-
-# 0: number, 1: string, 2: set of symbol, 3: boolean
-compiler.misc.x.print.rounds=\u5FAA\u73AF {0}:\n\t\u8F93\u5165\u6587\u4EF6: {1}\n\t\u6CE8\u91CA: {2}\n\t\u6700\u540E\u4E00\u4E2A\u5FAA\u73AF: {3}
-
-#####
-
-## The following string will appear before all messages keyed as:
-## "compiler.note".
-
-compiler.note.compressed.diags=\u67D0\u4E9B\u6D88\u606F\u5DF2\u7ECF\u8FC7\u7B80\u5316; \u8BF7\u4F7F\u7528 -Xdiags:verbose \u91CD\u65B0\u7F16\u8BD1\u4EE5\u83B7\u5F97\u5B8C\u6574\u8F93\u51FA
-
-compiler.note.potential.lambda.found=\u53EF\u5C06\u6B64\u533F\u540D\u5185\u90E8\u7C7B\u521B\u5EFA\u8F6C\u6362\u4E3A lambda \u8868\u8FBE\u5F0F\u3002
-
-# 0: boolean, 1: symbol
-compiler.note.lambda.stat=\u8F6C\u6362 lambda \u8868\u8FBE\u5F0F\n\u66FF\u4EE3 metafactory = {0}\n\u5408\u6210\u65B9\u6CD5 = {1}
-
-# 0: boolean, 1: unused
-compiler.note.mref.stat=\u8F6C\u6362\u65B9\u6CD5\u5F15\u7528\n\u66FF\u4EE3 metafactory = {0}\n
-# 0: boolean, 1: symbol
-compiler.note.mref.stat.1=\u8F6C\u6362\u65B9\u6CD5\u5F15\u7528\n\u66FF\u4EE3 metafactory = {0}\nbridge \u65B9\u6CD5 = {1}
-
-compiler.note.note=\u6CE8: 
-
-# 0: file name
-compiler.note.deprecated.filename={0}\u4F7F\u7528\u6216\u8986\u76D6\u4E86\u5DF2\u8FC7\u65F6\u7684 API\u3002
-
-compiler.note.deprecated.plural=\u67D0\u4E9B\u8F93\u5165\u6587\u4EF6\u4F7F\u7528\u6216\u8986\u76D6\u4E86\u5DF2\u8FC7\u65F6\u7684 API\u3002
-
-# The following string may appear after one of the above deprecation
-# messages.
-compiler.note.deprecated.recompile=\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u4F7F\u7528 -Xlint:deprecation \u91CD\u65B0\u7F16\u8BD1\u3002
-
-# 0: file name
-compiler.note.deprecated.filename.additional={0}\u8FD8\u4F7F\u7528\u6216\u8986\u76D6\u4E86\u5DF2\u8FC7\u65F6\u7684 API\u3002
-
-compiler.note.deprecated.plural.additional=\u67D0\u4E9B\u8F93\u5165\u6587\u4EF6\u8FD8\u4F7F\u7528\u6216\u8986\u76D6\u4E86\u5DF2\u8FC7\u65F6\u7684 API\u3002
-
-# 0: file name
-compiler.note.unchecked.filename={0}\u4F7F\u7528\u4E86\u672A\u7ECF\u68C0\u67E5\u6216\u4E0D\u5B89\u5168\u7684\u64CD\u4F5C\u3002
-
-compiler.note.unchecked.plural=\u67D0\u4E9B\u8F93\u5165\u6587\u4EF6\u4F7F\u7528\u4E86\u672A\u7ECF\u68C0\u67E5\u6216\u4E0D\u5B89\u5168\u7684\u64CD\u4F5C\u3002
-
-# The following string may appear after one of the above deprecation
-# messages.
-compiler.note.unchecked.recompile=\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u4F7F\u7528 -Xlint:unchecked \u91CD\u65B0\u7F16\u8BD1\u3002
-
-# 0: file name
-compiler.note.unchecked.filename.additional={0}\u8FD8\u6709\u672A\u7ECF\u68C0\u67E5\u6216\u4E0D\u5B89\u5168\u7684\u64CD\u4F5C\u3002
-
-compiler.note.unchecked.plural.additional=\u67D0\u4E9B\u8F93\u5165\u6587\u4EF6\u8FD8\u4F7F\u7528\u4E86\u672A\u7ECF\u68C0\u67E5\u6216\u4E0D\u5B89\u5168\u7684\u64CD\u4F5C\u3002
-
-# 0: file name
-compiler.note.sunapi.filename={0}\u4F7F\u7528\u4E86\u53EF\u80FD\u4F1A\u5728\u672A\u6765\u53D1\u884C\u7248\u4E2D\u5220\u9664\u7684\u5185\u90E8\u4E13\u7528 API\u3002
-
-compiler.note.sunapi.plural=\u67D0\u4E9B\u8F93\u5165\u6587\u4EF6\u4F7F\u7528\u4E86\u53EF\u80FD\u4F1A\u5728\u672A\u6765\u53D1\u884C\u7248\u4E2D\u5220\u9664\u7684\u5185\u90E8\u4E13\u7528 API\u3002
-
-# The following string may appear after one of the above sunapi messages.
-compiler.note.sunapi.recompile=\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u4F7F\u7528 -Xlint:sunapi \u91CD\u65B0\u7F16\u8BD1\u3002
-
-# 0: file name
-compiler.note.sunapi.filename.additional={0}\u4F7F\u7528\u4E86\u53EF\u80FD\u4F1A\u5728\u672A\u6765\u53D1\u884C\u7248\u4E2D\u5220\u9664\u7684\u5176\u4ED6\u5185\u90E8\u4E13\u7528 API\u3002
-
-compiler.note.sunapi.plural.additional=\u67D0\u4E9B\u8F93\u5165\u6587\u4EF6\u4F7F\u7528\u4E86\u53EF\u80FD\u4F1A\u5728\u672A\u6765\u53D1\u884C\u7248\u4E2D\u5220\u9664\u7684\u5176\u4ED6\u5185\u90E8\u4E13\u7528 API\u3002
-
-# Notes related to annotation processing
-
-# Print a client-generated note; assumed to be localized, no translation required
-# 0: string
-compiler.note.proc.messager={0}
-
-#####
-
-# 0: number
-compiler.misc.count.error={0} \u4E2A\u9519\u8BEF
-
-# 0: number
-compiler.misc.count.error.plural={0} \u4E2A\u9519\u8BEF
-
-# 0: number
-compiler.misc.count.warn={0} \u4E2A\u8B66\u544A
-
-# 0: number
-compiler.misc.count.warn.plural={0} \u4E2A\u8B66\u544A
-
-compiler.misc.version.not.available=(\u7248\u672C\u4FE1\u606F\u4E0D\u53EF\u7528)
-
-## extra output when using -verbose (JavaCompiler)
-
-# 0: symbol
-compiler.misc.verbose.checking.attribution=[\u6B63\u5728\u68C0\u67E5{0}]
-
-# 0: string
-compiler.misc.verbose.parsing.done=[\u89E3\u6790\u5DF2\u5B8C\u6210, \u7528\u65F6 {0} \u6BEB\u79D2]
-
-# 0: file name
-compiler.misc.verbose.parsing.started=[\u89E3\u6790\u5F00\u59CB\u65F6\u95F4 {0}]
-
-# 0: string
-compiler.misc.verbose.total=[\u5171 {0} \u6BEB\u79D2]
-
-# 0: file name
-compiler.misc.verbose.wrote.file=[\u5DF2\u5199\u5165{0}]
-
-## extra output when using -verbose (Retro)
-compiler.misc.verbose.retro=[\u6B63\u5728\u66F4\u65B0{0}]
-
-compiler.misc.verbose.retro.with=\t\u6B63\u5728\u4F7F\u7528{1}\u66F4\u65B0{0}
-
-compiler.misc.verbose.retro.with.list=\t\u6B63\u5728\u4F7F\u7528\u7C7B\u578B\u53C2\u6570{1}, \u8D85\u7C7B\u578B{2}\u548C\u63A5\u53E3{3}\u66F4\u65B0{0}
-
-## extra output when using -verbose (code/ClassReader)
-# 0: string
-compiler.misc.verbose.loading=[\u6B63\u5728\u52A0\u8F7D{0}]
-
-# 0: string
-compiler.misc.verbose.sourcepath=[\u6E90\u6587\u4EF6\u7684\u641C\u7D22\u8DEF\u5F84: {0}]
-
-# 0: string
-compiler.misc.verbose.classpath=[\u7C7B\u6587\u4EF6\u7684\u641C\u7D22\u8DEF\u5F84: {0}]
-
-## extra output when using -checkclassfile (code/ClassReader)
-compiler.misc.ccf.found.later.version=\u7C7B\u6587\u4EF6\u7684\u7248\u672C\u9AD8\u4E8E\u9884\u671F: {0}
-
-compiler.misc.ccf.unrecognized.attribute=\u65E0\u6CD5\u8BC6\u522B\u7684\u5C5E\u6027: {0}
-
-## extra output when using -prompt (util/Log)
-compiler.misc.resume.abort=\u7EE7\u7EED(R), \u653E\u5F03(A)>
-
-#####
-
-##
-## warnings
-##
-
-## All warning messages are preceded by the following string.
-compiler.warn.warning=\u8B66\u544A: 
-
-## Warning messages may also include the following prefix to identify a
-## lint option
-# 0: option name
-compiler.warn.lintOption=[{0}] 
-
-# 0: symbol
-compiler.warn.constant.SVUID=serialVersionUID \u5728\u7C7B{0}\u4E2D\u5FC5\u987B\u662F\u5E38\u91CF
-
-# 0: file name
-compiler.warn.dir.path.element.not.found=\u9519\u8BEF\u7684\u8DEF\u5F84\u5143\u7D20 "{0}": \u6CA1\u6709\u8FD9\u79CD\u76EE\u5F55
-
-compiler.warn.finally.cannot.complete=finally \u5B50\u53E5\u65E0\u6CD5\u6B63\u5E38\u5B8C\u6210
-
-# 0: symbol, 1: symbol
-compiler.warn.has.been.deprecated={1}\u4E2D\u7684{0}\u5DF2\u8FC7\u65F6
-
-# 0: symbol
-compiler.warn.sun.proprietary={0}\u662F\u5185\u90E8\u4E13\u7528 API, \u53EF\u80FD\u4F1A\u5728\u672A\u6765\u53D1\u884C\u7248\u4E2D\u5220\u9664
-
-compiler.warn.illegal.char.for.encoding=\u7F16\u7801{0}\u7684\u4E0D\u53EF\u6620\u5C04\u5B57\u7B26
-
-# 0: symbol
-compiler.warn.improper.SVUID=\u5FC5\u987B\u5728\u7C7B{0}\u4E2D\u5C06 serialVersionUID \u58F0\u660E\u4E3A static final
-
-# 0: type, 1: type
-compiler.warn.inexact.non-varargs.call=\u6700\u540E\u4E00\u4E2A\u53C2\u6570\u4F7F\u7528\u4E86\u4E0D\u51C6\u786E\u7684\u53D8\u91CF\u7C7B\u578B\u7684 varargs \u65B9\u6CD5\u7684\u975E varargs \u8C03\u7528; \n\u5BF9\u4E8E varargs \u8C03\u7528, \u5E94\u4F7F\u7528 {0}\n\u5BF9\u4E8E\u975E varargs \u8C03\u7528, \u5E94\u4F7F\u7528 {1}, \u8FD9\u6837\u4E5F\u53EF\u4EE5\u6291\u5236\u6B64\u8B66\u544A
-
-# 0: list of type
-compiler.warn.unreachable.catch=catch \u5B50\u53E5\u65E0\u6CD5\u8BBF\u95EE\n\u5DF2\u6355\u83B7\u5230\u629B\u51FA\u7684\u7C7B\u578B{0}
-
-# 0: list of type
-compiler.warn.unreachable.catch.1=catch \u5B50\u53E5\u65E0\u6CD5\u8BBF\u95EE\n\u5DF2\u6355\u83B7\u5230\u629B\u51FA\u7684\u7C7B\u578B{0}
-
-# 0: symbol
-compiler.warn.long.SVUID=serialVersionUID \u5728\u7C7B{0}\u4E2D\u5FC5\u987B\u662F long \u7C7B\u578B
-
-# 0: symbol
-compiler.warn.missing.SVUID=\u53EF\u5E8F\u5217\u5316\u7C7B{0}\u6CA1\u6709 serialVersionUID \u7684\u5B9A\u4E49
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.warn.potentially.ambiguous.overload={1} \u4E2D\u7684 {0} \u53EF\u80FD\u4E0E {3} \u4E2D\u7684 {2} \u6DF7\u6DC6
-
-# 0: message segment
-compiler.warn.override.varargs.missing={0}; \u88AB\u8986\u76D6\u7684\u65B9\u6CD5\u6CA1\u6709 ''...''
-
-# 0: message segment
-compiler.warn.override.varargs.extra={0}; \u8986\u76D6\u7684\u65B9\u6CD5\u7F3A\u5C11 ''...''
-
-compiler.warn.override.bridge={0}; \u88AB\u8986\u76D6\u7684\u65B9\u6CD5\u4E3A bridge \u65B9\u6CD5
-
-# 0: symbol
-compiler.warn.pkg-info.already.seen=\u5DF2\u627E\u5230\u7A0B\u5E8F\u5305{0}\u7684 package-info.java \u6587\u4EF6
-
-# 0: file name
-compiler.warn.path.element.not.found=\u9519\u8BEF\u7684\u8DEF\u5F84\u5143\u7D20 "{0}": \u6CA1\u6709\u8FD9\u79CD\u6587\u4EF6\u6216\u76EE\u5F55
-
-compiler.warn.possible.fall-through.into.case=\u53EF\u80FD\u65E0\u6CD5\u5B9E\u73B0 case
-
-# 0: type
-compiler.warn.redundant.cast=\u51FA\u73B0\u5197\u4F59\u7684\u5230{0}\u7684\u8F6C\u6362
-
-# 0: number
-compiler.warn.position.overflow=\u884C {0} \u5904\u7684\u4F4D\u7F6E\u7F16\u7801\u6EA2\u51FA
-
-# 0: file name, 1: number, 2: number
-compiler.warn.big.major.version={0}: \u4E3B\u7248\u672C {1} \u6BD4 {2} \u65B0, \u6B64\u7F16\u8BD1\u5668\u652F\u6301\u6700\u65B0\u7684\u4E3B\u7248\u672C\u3002\n\u5EFA\u8BAE\u5347\u7EA7\u6B64\u7F16\u8BD1\u5668\u3002
-
-# 0: symbol kind, 1: symbol
-compiler.warn.static.not.qualified.by.type=static {0}\u5E94\u7531\u7C7B\u578B\u540D\u79F0{1}\u800C\u4E0D\u662F\u8868\u8FBE\u5F0F\u9650\u5B9A
-
-# 0: string
-compiler.warn.source.no.bootclasspath=\u672A\u4E0E -source {0} \u4E00\u8D77\u8BBE\u7F6E\u5F15\u5BFC\u7C7B\u8DEF\u5F84
-
-# 0: string
-compiler.warn.option.obsolete.source=\u6E90\u503C{0}\u5DF2\u8FC7\u65F6, \u5C06\u5728\u672A\u6765\u6240\u6709\u53D1\u884C\u7248\u4E2D\u5220\u9664
-
-# 0: string
-compiler.warn.option.obsolete.target=\u76EE\u6807\u503C{0}\u5DF2\u8FC7\u65F6, \u5C06\u5728\u672A\u6765\u6240\u6709\u53D1\u884C\u7248\u4E2D\u5220\u9664
-
-compiler.warn.option.obsolete.suppression=\u8981\u9690\u85CF\u6709\u5173\u5DF2\u8FC7\u65F6\u9009\u9879\u7684\u8B66\u544A, \u8BF7\u4F7F\u7528 -Xlint:-options\u3002
-
-# 0: name, 1: number, 2: number, 3: number, 4: number
-compiler.warn.future.attr={1}.{2} \u7248\u7C7B\u6587\u4EF6\u4E2D\u5F15\u5165\u7684 {0} \u5C5E\u6027\u5728 {3}.{4} \u7248\u7C7B\u6587\u4EF6\u4E2D\u88AB\u5FFD\u7565
-
-# Warnings related to annotation processing
-# 0: name
-compiler.warn.proc.package.does.not.exist=\u7A0B\u5E8F\u5305{0}\u4E0D\u5B58\u5728
-
-# 0: name
-compiler.warn.proc.file.reopening=\u5C1D\u8BD5\u591A\u6B21\u4E3A ''{0}'' \u521B\u5EFA\u6587\u4EF6
-
-# 0: name
-compiler.warn.proc.type.already.exists=\u7C7B\u578B ''{0}'' \u7684\u6587\u4EF6\u5DF2\u7ECF\u5B58\u5728\u4E8E\u6E90\u8DEF\u5F84\u6216\u7C7B\u8DEF\u5F84\u4E2D
-
-# 0: name
-compiler.warn.proc.type.recreate=\u5C1D\u8BD5\u591A\u6B21\u521B\u5EFA\u7C7B\u578B ''{0}'' \u7684\u6587\u4EF6
-
-# 0: string
-compiler.warn.proc.illegal.file.name=\u65E0\u6CD5\u521B\u5EFA\u5E26\u6709\u975E\u6CD5\u540D\u79F0 ''{0}'' \u7684\u6587\u4EF6\u3002
-
-# 0: string, 1: string
-compiler.warn.proc.suspicious.class.name=\u6B63\u5728\u4E3A\u540D\u79F0\u4EE5{1}\u7ED3\u5C3E\u7684\u7C7B\u578B\u521B\u5EFA\u6587\u4EF6: ''{0}''
-
-# 0: name
-compiler.warn.proc.file.create.last.round=\u5C06\u4E0D\u5BF9\u5728\u6700\u540E\u4E00\u4E2A\u5FAA\u73AF\u4E2D\u521B\u5EFA\u7684\u7C7B\u578B\u4E3A ''{0}'' \u7684\u6587\u4EF6\u8FDB\u884C\u6CE8\u91CA\u5904\u7406\u3002
-
-# 0: string, 1: string
-compiler.warn.proc.malformed.supported.string=\u5904\u7406\u7A0B\u5E8F ''{1}'' \u4E3A\u652F\u6301\u7684\u6CE8\u91CA\u7C7B\u578B\u8FD4\u56DE\u683C\u5F0F\u9519\u8BEF\u7684\u5B57\u7B26\u4E32 ''{0}''
-
-# 0: set of string
-compiler.warn.proc.annotations.without.processors=\u6CA1\u6709\u5904\u7406\u7A0B\u5E8F\u8981\u4F7F\u7528\u4EE5\u4E0B\u4EFB\u4F55\u6CE8\u91CA: {0}
-
-# 0: source version, 1: string, 2: string
-compiler.warn.proc.processor.incompatible.source.version=\u6765\u81EA\u6CE8\u91CA\u5904\u7406\u7A0B\u5E8F ''{1}'' \u7684\u53D7\u652F\u6301 source \u7248\u672C ''{0}'' \u4F4E\u4E8E -source ''{2}''
-
-compiler.warn.proc.proc-only.requested.no.procs=\u5728\u672A\u8BF7\u6C42\u7F16\u8BD1\u7684\u60C5\u51B5\u4E0B\u8FDB\u884C\u6CE8\u91CA\u5904\u7406, \u4F46\u627E\u4E0D\u5230\u5904\u7406\u7A0B\u5E8F\u3002
-
-compiler.warn.proc.use.implicit=\u6CE8\u91CA\u5904\u7406\u4E0D\u9002\u7528\u4E8E\u9690\u5F0F\u7F16\u8BD1\u7684\u6587\u4EF6\u3002\n\u4F7F\u7528 -implicit \u6307\u5B9A\u7528\u4E8E\u9690\u5F0F\u7F16\u8BD1\u7684\u7B56\u7565\u3002
-
-compiler.warn.proc.use.proc.or.implicit=\u6CE8\u91CA\u5904\u7406\u4E0D\u9002\u7528\u4E8E\u9690\u5F0F\u7F16\u8BD1\u7684\u6587\u4EF6\u3002\n\u4F7F\u7528 -proc:none \u7981\u7528\u6CE8\u91CA\u5904\u7406\u6216\u4F7F\u7528 -implicit \u6307\u5B9A\u7528\u4E8E\u9690\u5F0F\u7F16\u8BD1\u7684\u7B56\u7565\u3002
-
-# Print a client-generated warning; assumed to be localized, no translation required
-# 0: string
-compiler.warn.proc.messager={0}
-
-# 0: set of name
-compiler.warn.proc.unclosed.type.files=\u7C7B\u578B ''{0}'' \u7684\u6587\u4EF6\u672A\u5173\u95ED; \u5C06\u4E0D\u9488\u5BF9\u8FD9\u4E9B\u7C7B\u578B\u8FDB\u884C\u6CE8\u91CA\u5904\u7406
-
-# 0: string
-compiler.warn.proc.unmatched.processor.options=\u4EE5\u4E0B\u9009\u9879\u672A\u88AB\u4EFB\u4F55\u5904\u7406\u7A0B\u5E8F\u8BC6\u522B: ''{0}''
-
-compiler.warn.try.explicit.close.call=\u5728\u53EF\u81EA\u52A8\u7ED3\u675F\u7684\u8D44\u6E90\u4E0A\u663E\u5F0F\u8C03\u7528 close()
-
-# 0: symbol
-compiler.warn.try.resource.not.referenced=\u4E0D\u80FD\u5728\u76F8\u5E94\u7684 try \u8BED\u53E5\u7684\u6B63\u6587\u4E2D\u5F15\u7528\u53EF\u81EA\u52A8\u7ED3\u675F\u7684\u8D44\u6E90{0}
-
-# 0: type
-compiler.warn.try.resource.throws.interrupted.exc=\u53EF\u81EA\u52A8\u5173\u95ED\u7684\u8D44\u6E90{0}\u5305\u542B\u7684\u6210\u5458\u65B9\u6CD5 close() \u53EF\u80FD\u629B\u51FA InterruptedException
-
-compiler.warn.unchecked.assign=\u672A\u7ECF\u68C0\u67E5\u7684\u5206\u914D: \u5C06{0}\u5206\u914D\u7ED9{1}
-
-# 0: symbol, 1: type
-compiler.warn.unchecked.assign.to.var=\u5BF9\u4F5C\u4E3A\u539F\u59CB\u7C7B\u578B{1}\u7684\u6210\u5458\u7684\u53D8\u91CF{0}\u7684\u5206\u914D\u672A\u7ECF\u8FC7\u68C0\u67E5
-
-# 0: symbol, 1: type
-compiler.warn.unchecked.call.mbr.of.raw.type=\u5BF9\u4F5C\u4E3A\u539F\u59CB\u7C7B\u578B{1}\u7684\u6210\u5458\u7684{0}\u7684\u8C03\u7528\u672A\u7ECF\u8FC7\u68C0\u67E5
-
-compiler.warn.unchecked.cast.to.type=\u5411\u7C7B\u578B{0}\u7684\u8F6C\u6362\u672A\u7ECF\u8FC7\u68C0\u67E5
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list of type, 4: symbol kind, 5: symbol
-compiler.warn.unchecked.meth.invocation.applied=\u65B9\u6CD5\u8C03\u7528\u672A\u7ECF\u8FC7\u68C0\u67E5: \u5C06{4} {5}\u4E2D\u7684{0} {1}\u5E94\u7528\u5230\u7ED9\u5B9A\u7684\u7C7B\u578B\n\u9700\u8981: {2}\n\u627E\u5230: {3}
-
-# 0: type
-compiler.warn.unchecked.generic.array.creation=\u5BF9\u4E8E\u7C7B\u578B\u4E3A{0}\u7684 varargs \u53C2\u6570, \u6CDB\u578B\u6570\u7EC4\u521B\u5EFA\u672A\u7ECF\u8FC7\u68C0\u67E5
-
-# 0: type
-compiler.warn.unchecked.varargs.non.reifiable.type=\u53C2\u6570\u5316 vararg \u7C7B\u578B{0}\u7684\u5806\u53EF\u80FD\u5DF2\u53D7\u6C61\u67D3
-
-# 0: symbol
-compiler.warn.varargs.unsafe.use.varargs.param=Varargs \u65B9\u6CD5\u53EF\u80FD\u5BFC\u81F4\u6765\u81EA\u4E0D\u53EF\u5177\u4F53\u5316 varargs \u53C2\u6570 {0} \u7684\u5806\u6C61\u67D3
-
-compiler.warn.missing.deprecated.annotation=\u672A\u4F7F\u7528 @Deprecated \u5BF9\u5DF2\u8FC7\u65F6\u7684\u9879\u76EE\u8FDB\u884C\u6CE8\u91CA
-
-compiler.warn.invalid.archive.file=\u4EE5\u4E0B\u8DEF\u5F84\u4E2D\u5B58\u5728\u610F\u5916\u7684\u6587\u4EF6: {0}
-
-compiler.warn.unexpected.archive.file=\u4EE5\u4E0B\u6863\u6848\u6587\u4EF6\u5B58\u5728\u610F\u5916\u7684\u6269\u5C55\u540D: {0}
-
-compiler.warn.div.zero=\u9664\u6570\u4E3A\u96F6
-
-compiler.warn.empty.if=if \u4E4B\u540E\u6CA1\u6709\u8BED\u53E5
-
-compiler.warn.annotation.method.not.found=\u65E0\u6CD5\u627E\u5230\u7C7B\u578B ''{0}'' \u7684\u6CE8\u91CA\u65B9\u6CD5 ''{1}()''
-
-compiler.warn.annotation.method.not.found.reason=\u65E0\u6CD5\u627E\u5230\u7C7B\u578B ''{0}'' \u7684\u6CE8\u91CA\u65B9\u6CD5 ''{1}()'': {2}
-
-# 0: symbol, 1: name
-compiler.warn.unknown.enum.constant=\u672A\u77E5\u7684\u679A\u4E3E\u5E38\u91CF {1}.{2}
-
-# 0: symbol, 1: name, 2: message segment
-compiler.warn.unknown.enum.constant.reason=\u672A\u77E5\u7684\u679A\u4E3E\u5E38\u91CF {1}.{2}\n\u539F\u56E0: {3}
-
-# 0: type, 1: type
-compiler.warn.raw.class.use=\u627E\u5230\u539F\u59CB\u7C7B\u578B: {0}\n\u7F3A\u5C11\u6CDB\u578B\u7C7B{1}\u7684\u7C7B\u578B\u53C2\u6570
-
-# 0: unused, 1: unused
-compiler.warn.diamond.redundant.args=\u65B0\u8868\u8FBE\u5F0F\u4E2D\u5B58\u5728\u5197\u4F59\u7C7B\u578B\u53C2\u6570 (\u6539\u7528 diamond \u8FD0\u7B97\u7B26)\u3002
-
-# 0: type, 1: type
-compiler.warn.diamond.redundant.args.1=\u65B0\u8868\u8FBE\u5F0F\u4E2D\u5B58\u5728\u5197\u4F59\u7C7B\u578B\u53C2\u6570 (\u6539\u7528 diamond \u8FD0\u7B97\u7B26)\u3002\n\u663E\u5F0F: {0}\n\u63A8\u65AD: {1}
-
-# 0: symbol, 1: message segment
-compiler.warn.varargs.redundant.trustme.anno=\u5197\u4F59\u7684 {0} \u6CE8\u91CA\u3002{1}
-
-# 0: symbol
-compiler.warn.access.to.sensitive.member.from.serializable.element=\u53EF\u4E32\u884C\u5316\u5143\u7D20\u5BF9\u654F\u611F\u6210\u5458 {0} \u7684\u8BBF\u95EE\u53EF\u4EE5\u7531\u4E0D\u53D7\u4FE1\u4EFB\u7684\u4EE3\u7801\u516C\u5F00\u6267\u884C
-
-#####
-
-## The following are tokens which are non-terminals in the language. They should
-## be named as JLS3 calls them when translated to the appropriate language.
-compiler.misc.token.identifier=<\u6807\u8BC6\u7B26>
-
-compiler.misc.token.character=<\u5B57\u7B26>
-
-compiler.misc.token.string=<\u5B57\u7B26\u4E32>
-
-compiler.misc.token.integer=<\u6574\u578B>
-
-compiler.misc.token.long-integer=<\u957F\u6574\u578B>
-
-compiler.misc.token.float=<\u6D6E\u70B9\u578B>
-
-compiler.misc.token.double=<\u53CC\u7CBE\u5EA6\u578B>
-
-compiler.misc.token.bad-symbol=<\u9519\u8BEF\u7B26\u53F7>
-
-compiler.misc.token.end-of-input=<\u8F93\u5165\u7ED3\u675F>
-
-## The argument to the following string will always be one of the following:
-## 1. one of the above non-terminals
-## 2. a keyword (JLS1.8)
-## 3. a boolean literal (JLS3.10.3)
-## 4. the null literal (JLS3.10.7)
-## 5. a Java separator (JLS3.11)
-## 6. an operator (JLS3.12)
-##
-## This is the only place these tokens will be used.
-# 0: token
-compiler.err.expected=\u9700\u8981{0}
-
-# 0: token, 1: token
-compiler.err.expected2=\u9700\u8981{0}\u6216{1}
-
-# 0: token, 1: token, 2: token
-compiler.err.expected3=\u9700\u8981{0}, {1}\u6216{2}
-
-compiler.err.premature.eof=\u89E3\u6790\u65F6\u5DF2\u5230\u8FBE\u6587\u4EF6\u7ED3\u5C3E
-
-## The following are related in form, but do not easily fit the above paradigm.
-compiler.err.dot.class.expected=\u9700\u8981 ''.class''
-
-## The argument to this string will always be either 'case' or 'default'.
-# 0: token
-compiler.err.orphaned=\u5B64\u7ACB\u7684{0}
-
-# 0: name
-compiler.misc.anonymous.class=<\u533F\u540D{0}>
-
-# 0: name, 1: type
-compiler.misc.type.captureof=capture#{0}, \u5171 {1}
-
-compiler.misc.type.captureof.1=capture#{0}
-
-compiler.misc.type.none=<\u65E0>
-
-compiler.misc.unnamed.package=\u672A\u547D\u540D\u7A0B\u5E8F\u5305
-
-#####
-
-# 0: symbol, 1: message segment
-compiler.err.cant.access=\u65E0\u6CD5\u8BBF\u95EE{0}\n{1}
-
-# 0: file name, 1: expected CP entry type, 2: constant pool index
-compiler.misc.bad.const.pool.entry={0} \u4E2D\u9519\u8BEF\u7684\u5E38\u91CF\u6C60\u6761\u76EE\n\u9884\u671F\u4E3A\u7D22\u5F15 {2} \u5904\u7684 {1}
-
-# 0: file name, 1: message segment
-compiler.misc.bad.class.file.header=\u9519\u8BEF\u7684\u7C7B\u6587\u4EF6: {0}\n{1}\n\u8BF7\u5220\u9664\u8BE5\u6587\u4EF6\u6216\u786E\u4FDD\u8BE5\u6587\u4EF6\u4F4D\u4E8E\u6B63\u786E\u7684\u7C7B\u8DEF\u5F84\u5B50\u76EE\u5F55\u4E2D\u3002
-
-# 0: file name, 1: message segment
-compiler.misc.bad.source.file.header=\u9519\u8BEF\u7684\u6E90\u6587\u4EF6: {0}\n{1}\n\u8BF7\u5220\u9664\u8BE5\u6587\u4EF6\u6216\u786E\u4FDD\u8BE5\u6587\u4EF6\u4F4D\u4E8E\u6B63\u786E\u7684\u6E90\u8DEF\u5F84\u5B50\u76EE\u5F55\u4E2D\u3002
-
-## The following are all possible strings for the second argument ({1}) of the
-## above strings.
-compiler.misc.bad.class.signature=\u9519\u8BEF\u7684\u7C7B\u7B7E\u540D: {0}
-
-#0: symbol, 1: symbol
-compiler.misc.bad.enclosing.class={0}\u7684\u5C01\u95ED\u7C7B\u9519\u8BEF: {1}
-
-# 0: symbol
-compiler.misc.bad.enclosing.method=\u7C7B {0} \u7684\u5C01\u95ED\u65B9\u6CD5\u5C5E\u6027\u9519\u8BEF
-
-compiler.misc.bad.runtime.invisible.param.annotations=\u9519\u8BEF\u7684 RuntimeInvisibleParameterAnnotations \u5C5E\u6027: {0}
-
-compiler.misc.bad.const.pool.tag=\u9519\u8BEF\u7684\u5E38\u91CF\u6C60\u6807\u8BB0: {0}
-
-compiler.misc.bad.const.pool.tag.at=\u9519\u8BEF\u7684\u5E38\u91CF\u6C60\u6807\u8BB0: {0}, \u4F4D\u4E8E{1}
-
-compiler.misc.bad.signature=\u9519\u8BEF\u7684\u7B7E\u540D: {0}
-
-compiler.misc.bad.type.annotation.value=\u9519\u8BEF\u7684\u7C7B\u578B\u6CE8\u91CA\u76EE\u6807\u7C7B\u578B\u503C: {0}
-
-compiler.misc.class.file.wrong.class=\u7C7B\u6587\u4EF6\u5305\u542B\u9519\u8BEF\u7684\u7C7B: {0}
-
-compiler.misc.class.file.not.found=\u627E\u4E0D\u5230{0}\u7684\u7C7B\u6587\u4EF6
-
-# 0: classfile major version, 1: classfile minor version
-compiler.misc.invalid.default.interface=\u5728 {0}.{1} \u7248\u7C7B\u6587\u4EF6\u4E2D\u627E\u5230\u9ED8\u8BA4\u65B9\u6CD5
-
-# 0: classfile major version, 1: classfile minor version
-compiler.misc.invalid.static.interface=\u5728 {0}.{1} \u7248\u7C7B\u6587\u4EF6\u4E2D\u627E\u5230\u9759\u6001\u65B9\u6CD5
-
-# 0: name
-compiler.misc.file.doesnt.contain.class=\u6587\u4EF6\u4E0D\u5305\u542B\u7C7B{0}
-
-compiler.misc.file.does.not.contain.package=\u6587\u4EF6\u4E0D\u5305\u542B\u7A0B\u5E8F\u5305{0}
-
-compiler.misc.illegal.start.of.class.file=\u975E\u6CD5\u7684\u7C7B\u6587\u4EF6\u5F00\u59CB
-
-compiler.misc.unable.to.access.file=\u65E0\u6CD5\u8BBF\u95EE\u6587\u4EF6: {0}
-
-compiler.misc.unicode.str.not.supported=\u4E0D\u652F\u6301\u7C7B\u6587\u4EF6\u4E2D\u7684 Unicode \u5B57\u7B26\u4E32
-
-compiler.misc.undecl.type.var=\u672A\u58F0\u660E\u7684\u7C7B\u578B\u53D8\u91CF: {0}
-
-compiler.misc.wrong.version=\u7C7B\u6587\u4EF6\u5177\u6709\u9519\u8BEF\u7684\u7248\u672C {0}.{1}, \u5E94\u4E3A {2}.{3}
-
-#####
-
-# 0: type, 1: type or symbol
-compiler.err.not.within.bounds=\u7C7B\u578B\u53C2\u6570{0}\u4E0D\u5728\u7C7B\u578B\u53D8\u91CF{1}\u7684\u8303\u56F4\u5185
-
-## The following are all possible strings for the second argument ({1}) of the
-## above string.
-
-## none yet...
-
-#####
-
-# 0: message segment
-compiler.err.prob.found.req=\u4E0D\u517C\u5BB9\u7684\u7C7B\u578B: {0}
-
-# 0: message segment
-compiler.misc.prob.found.req=\u4E0D\u517C\u5BB9\u7684\u7C7B\u578B: {0}
-
-# 0: message segment, 1: type, 2: type
-compiler.warn.prob.found.req={0}\n\u9700\u8981: {2}\n\u627E\u5230:    {1}
-
-# 0: type, 1: type
-compiler.misc.inconvertible.types={0}\u65E0\u6CD5\u8F6C\u6362\u4E3A{1}
-
-# 0: type, 1: type
-compiler.misc.possible.loss.of.precision=\u4ECE{0}\u8F6C\u6362\u5230{1}\u53EF\u80FD\u4F1A\u6709\u635F\u5931
-
-compiler.misc.unchecked.assign=\u672A\u7ECF\u68C0\u67E5\u7684\u8F6C\u6362
-
-# compiler.misc.storecheck=\
-#     assignment might cause later store checks to fail
-# compiler.misc.unchecked=\
-#     assigned array cannot dynamically check its stores
-compiler.misc.unchecked.cast.to.type=\u672A\u7ECF\u68C0\u67E5\u7684\u8F6C\u6362
-
-# compiler.err.star.expected=\
-#     ''*'' expected
-# compiler.err.no.elem.type=\
-#     \[\*\] cannot have a type
-
-# 0: type
-compiler.misc.try.not.applicable.to.type=try-with-resources \u4E0D\u9002\u7528\u4E8E\u53D8\u91CF\u7C7B\u578B\n({0})
-
-#####
-
-# 0: message segment or type, 1: message segment
-compiler.err.type.found.req=\u610F\u5916\u7684\u7C7B\u578B\n\u9700\u8981: {1}\n\u627E\u5230:    {0}
-
-## The following are all possible strings for the first argument ({0}) of the
-## above string.
-compiler.misc.type.req.class=\u7C7B
-
-compiler.misc.type.req.class.array=\u7C7B\u6216\u6570\u7EC4
-
-compiler.misc.type.req.array.or.iterable=\u6570\u7EC4\u6216 java.lang.Iterable
-
-compiler.misc.type.req.ref=\u5F15\u7528
-
-compiler.misc.type.req.exact=\u4E0D\u5E26\u9650\u5236\u8303\u56F4\u7684\u7C7B\u6216\u63A5\u53E3
-
-# 0: type
-compiler.misc.type.parameter=\u7C7B\u578B\u53C2\u6570{0}
-
-#####
-
-## The following are all possible strings for the last argument of all those
-## diagnostics whose key ends in ".1"
-
-# 0: type, 1: list of type
-compiler.misc.no.unique.maximal.instance.exists=\u5BF9\u4E8E\u4E0A\u9650\u4E3A{1}\u7684\u7C7B\u578B\u53D8\u91CF{0}, \u4E0D\u5B58\u5728\u552F\u4E00\u6700\u5927\u5B9E\u4F8B
-
-compiler.misc.no.unique.minimal.instance.exists=\u5BF9\u4E8E\u4E0B\u9650\u4E3A{1}\u7684\u7C7B\u578B\u53D8\u91CF{0}, \u4E0D\u5B58\u5728\u552F\u4E00\u6700\u5C0F\u5B9E\u4F8B
-
-# 0: type, 1: list of type
-compiler.misc.incompatible.upper.bounds=\u63A8\u8BBA\u53D8\u91CF {0} \u5177\u6709\u4E0D\u517C\u5BB9\u7684\u4E0A\u9650 {1}
-
-# 0: type, 1: list of type, 2: list of type
-compiler.misc.incompatible.eq.upper.bounds=\u63A8\u8BBA\u53D8\u91CF {0} \u5177\u6709\u4E0D\u517C\u5BB9\u7684\u9650\u5236\u8303\u56F4\n\u7B49\u5F0F\u7EA6\u675F\u6761\u4EF6: {1}\n\u4E0A\u9650: {2}
-
-# 0: type, 1: list of type, 2: list of type
-compiler.misc.incompatible.eq.lower.bounds=\u63A8\u8BBA\u53D8\u91CF{0}\u5177\u6709\u4E0D\u517C\u5BB9\u7684\u9650\u5236\u8303\u56F4\n\u7B49\u5F0F\u7EA6\u675F\u6761\u4EF6: {1}\n\u4E0B\u9650: {2}
-
-# 0: list of type, 1: type, 2: type
-compiler.misc.infer.no.conforming.instance.exists=\u4E0D\u5B58\u5728\u7C7B\u578B\u53D8\u91CF{0}\u7684\u5B9E\u4F8B, \u4EE5\u4F7F{1}\u4E0E{2}\u4E00\u81F4
-
-# 0: list of type, 1: message segment
-compiler.misc.infer.no.conforming.assignment.exists=\u65E0\u6CD5\u63A8\u65AD\u7C7B\u578B\u53D8\u91CF {0}\n(\u53C2\u6570\u4E0D\u5339\u914D; {1})
-
-# 0: list of type
-compiler.misc.infer.arg.length.mismatch=\u65E0\u6CD5\u63A8\u65AD\u7C7B\u578B\u53D8\u91CF {0}\n(\u5B9E\u9645\u53C2\u6570\u5217\u8868\u548C\u5F62\u5F0F\u53C2\u6570\u5217\u8868\u957F\u5EA6\u4E0D\u540C)
-
-# 0: list of type, 1: message segment
-compiler.misc.infer.varargs.argument.mismatch=\u65E0\u6CD5\u63A8\u65AD\u7C7B\u578B\u53D8\u91CF {0}\n(varargs \u4E0D\u5339\u914D; {1})
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.upper.bounds=\u63A8\u65AD\u7C7B\u578B\u4E0D\u7B26\u5408\u4E0A\u9650\n\u63A8\u65AD: {0}\n\u4E0A\u9650: {1}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.lower.bounds=\u63A8\u65AD\u7C7B\u578B\u4E0D\u7B26\u5408\u4E0B\u9650\n\u63A8\u65AD: {0}\n\u4E0B\u9650: {1}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.eq.bounds=\u63A8\u65AD\u7C7B\u578B\u4E0D\u7B26\u5408\u7B49\u5F0F\u7EA6\u675F\u6761\u4EF6\n\u63A8\u65AD: {0}\n\u7B49\u5F0F\u7EA6\u675F\u6761\u4EF6: {1}
-
-# 0: symbol
-compiler.misc.diamond={0}<>
-
-# 0: type
-compiler.misc.diamond.non.generic=\u65E0\u6CD5\u5C06 ''<>'' \u4E0E\u975E\u6CDB\u578B\u7C7B{0}\u4E00\u8D77\u4F7F\u7528
-
-# 0: unused
-compiler.misc.diamond.and.explicit.params=\u4E0D\u80FD\u5C06 ''<>'' \u4E0E\u6784\u9020\u5668\u7684\u663E\u5F0F\u7C7B\u578B\u53C2\u6570\u4E00\u8D77\u4F7F\u7528
-
-# 0: unused
-compiler.misc.mref.infer.and.explicit.params=\u4E0D\u80FD\u5C06\u539F\u59CB\u6784\u9020\u5668\u5F15\u7528\u4E0E\u6784\u9020\u5668\u7684\u663E\u5F0F\u7C7B\u578B\u53C2\u6570\u4E00\u8D77\u4F7F\u7528
-
-# 0: type, 1: list of type
-compiler.misc.explicit.param.do.not.conform.to.bounds=\u663E\u5F0F\u7C7B\u578B\u53C2\u6570{0}\u4E0D\u7B26\u5408\u58F0\u660E\u7684\u8303\u56F4{1}
-
-compiler.misc.arg.length.mismatch=\u5B9E\u9645\u53C2\u6570\u5217\u8868\u548C\u5F62\u5F0F\u53C2\u6570\u5217\u8868\u957F\u5EA6\u4E0D\u540C
-
-# 0: message segment
-compiler.misc.no.conforming.assignment.exists=\u53C2\u6570\u4E0D\u5339\u914D; {0}
-
-# 0: message segment
-compiler.misc.varargs.argument.mismatch=varargs \u4E0D\u5339\u914D; {0}
-
-#####
-
-# 0: symbol or type, 1: file name
-compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file={1} \u4E2D\u7684\u8F85\u52A9\u7C7B{0}\u4E0D\u5E94\u4ECE\u5176\u81EA\u8EAB\u7684\u6E90\u6587\u4EF6\u4EE5\u5916\u8BBF\u95EE
-
-## The first argument ({0}) is a "kindname".
-# 0: symbol kind, 1: symbol, 2: symbol
-compiler.err.abstract.cant.be.accessed.directly=\u65E0\u6CD5\u76F4\u63A5\u8BBF\u95EE{2}\u4E2D\u7684\u62BD\u8C61{0} {1}
-
-## The first argument ({0}) is a "kindname".
-# 0: symbol kind, 1: symbol
-compiler.err.non-static.cant.be.ref=\u65E0\u6CD5\u4ECE\u9759\u6001\u4E0A\u4E0B\u6587\u4E2D\u5F15\u7528\u975E\u9759\u6001 {0} {1}
-
-# 0: symbol kind, 1: symbol
-compiler.misc.non-static.cant.be.ref=\u65E0\u6CD5\u4ECE\u9759\u6001\u4E0A\u4E0B\u6587\u4E2D\u5F15\u7528\u975E\u9759\u6001 {0} {1}
-
-# 0: symbol kind, 1: symbol
-compiler.misc.static.method.in.unbound.lookup=\u5728\u672A\u7ED1\u5B9A\u67E5\u627E\u4E2D\u627E\u5230\u9759\u6001{0} {1}
-
-## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
-## of kindnames (the list should be identical to that provided in source.
-compiler.err.unexpected.type=\u610F\u5916\u7684\u7C7B\u578B\n\u9700\u8981: {0}\n\u627E\u5230:    {1}
-
-compiler.err.unexpected.lambda=\u6B64\u5904\u4E0D\u5E94\u4E3A lambda \u8868\u8FBE\u5F0F
-
-compiler.err.unexpected.mref=\u6B64\u5904\u4E0D\u5E94\u4E3A\u65B9\u6CD5\u5F15\u7528
-
-## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
-## The second argument {1} is the non-resolved symbol
-## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
-## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
-# 0: symbol kind, 1: name, 2: unused, 3: unused
-compiler.err.cant.resolve=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7: {0} {1}
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type
-compiler.err.cant.resolve.args=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7: {0} {1}({3})
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list of type
-compiler.err.cant.resolve.args.params=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7: {0} <{2}>{1}({3})
-
-## arguments from {0} to {3} have the same meaning as above
-## The fifth argument {4} is a location subdiagnostic (see below)
-# 0: symbol kind, 1: name, 2: unused, 3: unused, 4: message segment
-compiler.err.cant.resolve.location=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7:   {0} {1}\n\u4F4D\u7F6E: {4}
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
-compiler.err.cant.resolve.location.args=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7:   {0} {1}({3})\n\u4F4D\u7F6E: {4}
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
-compiler.err.cant.resolve.location.args.params=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7:   {0} <{2}>{1}({3})\n\u4F4D\u7F6E: {4}
-
-### Following are replicated/used for method reference diagnostics
-
-# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
-compiler.misc.cant.resolve.location.args=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7:   {0} {1}({3})\n\u4F4D\u7F6E: {4}
-
-# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
-compiler.misc.cant.resolve.location.args.params=\u627E\u4E0D\u5230\u7B26\u53F7\n\u7B26\u53F7:   {0} <{2}>{1}({3})\n\u4F4D\u7F6E: {4}
-
-##a location subdiagnostic is composed as follows:
-## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
-## The second argument {1} is the location name
-## The third argument {2} is the location type (only when {1} is a variable name)
-
-# 0: symbol kind, 1: type or symbol, 2: unused
-compiler.misc.location={0} {1}
-
-# 0: symbol kind, 1: symbol, 2: type
-compiler.misc.location.1=\u7C7B\u578B\u4E3A{2}\u7684{0} {1}
-
-## The following are all possible string for "kindname".
-## They should be called whatever the JLS calls them after it been translated
-## to the appropriate language.
-# compiler.misc.kindname.constructor=\
-#     static member
-compiler.misc.kindname.annotation=@interface
-
-compiler.misc.kindname.constructor=\u6784\u9020\u5668
-
-compiler.misc.kindname.enum=\u679A\u4E3E
-
-compiler.misc.kindname.interface=\u63A5\u53E3
-
-compiler.misc.kindname.static=\u9759\u6001
-
-compiler.misc.kindname.type.variable=\u7C7B\u578B\u53D8\u91CF
-
-compiler.misc.kindname.type.variable.bound=\u7C7B\u578B\u53D8\u91CF\u7684\u9650\u5236\u8303\u56F4
-
-compiler.misc.kindname.variable=\u53D8\u91CF
-
-compiler.misc.kindname.value=\u503C
-
-compiler.misc.kindname.method=\u65B9\u6CD5
-
-compiler.misc.kindname.class=\u7C7B
-
-compiler.misc.kindname.package=\u7A0B\u5E8F\u5305
-
-compiler.misc.kindname.static.init=\u9759\u6001\u521D\u59CB\u5316\u7A0B\u5E8F
-
-compiler.misc.kindname.instance.init=\u5B9E\u4F8B\u521D\u59CB\u5316\u7A0B\u5E8F
-
-#####
-
-compiler.misc.no.args=\u6CA1\u6709\u53C2\u6570
-
-# 0: message segment
-compiler.err.override.static={0}\n\u8986\u76D6\u7684\u65B9\u6CD5\u4E3A static
-
-# 0: message segment, 1: set of modifier
-compiler.err.override.meth={0}\n\u88AB\u8986\u76D6\u7684\u65B9\u6CD5\u4E3A{1}
-
-# 0: message segment, 1: type
-compiler.err.override.meth.doesnt.throw={0}\n\u88AB\u8986\u76D6\u7684\u65B9\u6CD5\u672A\u629B\u51FA{1}
-
-# In the following string {1} is a space separated list of Java Keywords, as
-# they would have been declared in the source code
-# 0: message segment, 1: set of modifier
-compiler.err.override.weaker.access={0}\n\u6B63\u5728\u5C1D\u8BD5\u5206\u914D\u66F4\u4F4E\u7684\u8BBF\u95EE\u6743\u9650; \u4EE5\u524D\u4E3A{1}
-
-# 0: message segment, 1: type, 2: type
-compiler.err.override.incompatible.ret={0}\n\u8FD4\u56DE\u7C7B\u578B{1}\u4E0E{2}\u4E0D\u517C\u5BB9
-
-# 0: message segment, 1: type, 2: type
-compiler.warn.override.unchecked.ret={0}\n\u8FD4\u56DE\u7C7B\u578B\u9700\u8981\u4ECE{1}\u5230{2}\u7684\u672A\u7ECF\u68C0\u67E5\u7684\u8F6C\u6362
-
-# 0: message segment, 1: type
-compiler.warn.override.unchecked.thrown={0}\n\u88AB\u8986\u76D6\u7684\u65B9\u6CD5\u672A\u629B\u51FA{1}
-
-# 0: symbol
-compiler.warn.override.equals.but.not.hashcode=\u7C7B{0}\u8986\u76D6\u4E86 equals, \u4F46\u8BE5\u7C7B\u6216\u4EFB\u4F55\u8D85\u7C7B\u90FD\u672A\u8986\u76D6 hashCode \u65B9\u6CD5
-
-## The following are all possible strings for the first argument ({0}) of the
-## above strings.
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.cant.override={1}\u4E2D\u7684{0}\u65E0\u6CD5\u8986\u76D6{3}\u4E2D\u7684{2}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.cant.implement={1}\u4E2D\u7684{0}\u65E0\u6CD5\u5B9E\u73B0{3}\u4E2D\u7684{2}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.clashes.with={1}\u4E2D\u7684{0}\u4E0E{3}\u4E2D\u7684{2}\u51B2\u7A81
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.override={1}\u4E2D\u7684{0}\u8986\u76D6\u4E86{3}\u4E2D\u7684{2}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.implement={1}\u4E2D\u7684{0}\u5B9E\u73B0\u4E86{3}\u4E2D\u7684{2}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.unchecked.clash.with={1}\u4E2D\u7684{0}\u8986\u76D6\u4E86{3}\u4E2D\u7684{2}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.override={1}\u4E2D\u7684{0}\u8986\u76D6\u4E86{3}\u4E2D\u7684{2}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.implement={1}\u4E2D\u7684{0}\u5B9E\u73B0\u4E86{3}\u4E2D\u7684{2}
-
-# 0: symbol, 1: symbol, 2: symbol, 3: symbol
-compiler.misc.varargs.clash.with={1}\u4E2D\u7684{0}\u8986\u76D6\u4E86{3}\u4E2D\u7684{2}
-
-# 0: unused
-compiler.misc.diamond.and.anon.class=\u65E0\u6CD5\u5C06 ''<>'' \u4E0E\u533F\u540D\u5185\u90E8\u7C7B\u4E00\u8D77\u4F7F\u7528
-
-# 0: symbol kind, 1: symbol, 2: symbol, 3: message segment
-compiler.misc.inapplicable.method={0} {1}.{2}\u4E0D\u9002\u7528\n({3})
-
-########################################
-# Diagnostics for language feature changes
-########################################
-# 0: string
-compiler.err.unsupported.fp.lit=-source {0} \u4E2D\u4E0D\u652F\u6301\u5341\u516D\u8FDB\u5236\u6D6E\u70B9\u6587\u5B57\n(\u8BF7\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u5341\u516D\u8FDB\u5236\u6D6E\u70B9\u6587\u5B57)
-
-# 0: string
-compiler.err.unsupported.binary.lit=-source {0} \u4E2D\u4E0D\u652F\u6301\u4E8C\u8FDB\u5236\u6587\u5B57\n(\u8BF7\u4F7F\u7528 -source 7 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u4E8C\u8FDB\u5236\u6587\u5B57)
-
-# 0: string
-compiler.err.unsupported.underscore.lit=-source {0} \u4E2D\u4E0D\u652F\u6301\u6587\u5B57\u4E2D\u5B58\u5728\u4E0B\u5212\u7EBF\n(\u8BF7\u4F7F\u7528 -source 7 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u5141\u8BB8\u6587\u5B57\u4E2D\u5B58\u5728\u4E0B\u5212\u7EBF)
-
-# 0: string
-compiler.err.try.with.resources.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301 try-with-resources\n(\u8BF7\u4F7F\u7528 -source 7 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528 try-with-resources)
-
-compiler.warn.enum.as.identifier=\u4ECE\u53D1\u884C\u7248 5 \u5F00\u59CB, ''enum'' \u4E3A\u5173\u952E\u5B57, \u800C\u4E0D\u7528\u4F5C\u6807\u8BC6\u7B26\n(\u8BF7\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u5C06 ''enum'' \u7528\u4F5C\u5173\u952E\u5B57)
-
-compiler.warn.assert.as.identifier=\u4ECE\u53D1\u884C\u7248 1.4 \u5F00\u59CB, ''assert'' \u662F\u4E00\u4E2A\u5173\u952E\u5B57, \u4F46\u4E0D\u80FD\u7528\u4F5C\u6807\u8BC6\u7B26\n(\u8BF7\u4F7F\u7528 -source 1.4 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u5C06 ''assert'' \u7528\u4F5C\u5173\u952E\u5B57)
-
-compiler.warn.underscore.as.identifier=''_'' \u7528\u4F5C\u6807\u8BC6\u7B26\n(Java SE 8 \u4E4B\u540E\u7684\u53D1\u884C\u7248\u4E2D\u53EF\u80FD\u4E0D\u652F\u6301\u4F7F\u7528 ''_'' \u4F5C\u4E3A\u6807\u8BC6\u7B26)
-
-compiler.err.underscore.as.identifier.in.lambda=''_'' \u7528\u4F5C\u6807\u8BC6\u7B26\n(\u5BF9\u4E8E lambda \u53C2\u6570, \u7981\u6B62\u5C06 ''_'' \u7528\u4F5C\u6807\u8BC6\u7B26)
-
-compiler.err.enum.as.identifier=\u4ECE\u53D1\u884C\u7248 5 \u5F00\u59CB, ''enum'' \u4E3A\u5173\u952E\u5B57, \u800C\u4E0D\u7528\u4F5C\u6807\u8BC6\u7B26\n(\u8BF7\u4F7F\u7528 -source 1.4 \u6216\u66F4\u4F4E\u7248\u672C\u4EE5\u5C06 ''enum'' \u7528\u4F5C\u6807\u8BC6\u7B26)
-
-compiler.err.assert.as.identifier=\u4ECE\u53D1\u884C\u7248 1.4 \u5F00\u59CB, ''assert'' \u662F\u4E00\u4E2A\u5173\u952E\u5B57, \u4F46\u4E0D\u80FD\u7528\u4F5C\u6807\u8BC6\u7B26\n(\u8BF7\u4F7F\u7528 -source 1.3 \u6216\u66F4\u4F4E\u7248\u672C\u4EE5\u5C06 ''assert'' \u7528\u4F5C\u6807\u8BC6\u7B26)
-
-# TODO 308: make a better error message
-compiler.err.this.as.identifier=\u4ECE\u53D1\u884C\u7248 8 \u5F00\u59CB, ''this'' \u53EA\u80FD\u4F5C\u4E3A\u63A5\u6536\u65B9\u7C7B\u578B\u7684\u53C2\u6570\u540D, \u8BE5\u53C2\u6570\u5FC5\u987B\u4E3A\u7B2C\u4E00\u4E2A\u53C2\u6570
-
-# 0: symbol
-compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=\u63A5\u6536\u65B9\u53C2\u6570\u4E0D\u9002\u7528\u4E8E\u9876\u5C42\u7C7B\u7684\u6784\u9020\u5668
-
-# TODO 308: make a better error message
-# 0: symbol
-compiler.err.cant.type.annotate.scoping.1=\u65E0\u6CD5\u4F7F\u7528 type-use \u6CE8\u91CA {0} \u6765\u6CE8\u91CA\u786E\u5B9A\u4F5C\u7528\u57DF\u7ED3\u6784
-
-# TODO 308: make a better error message
-# 0: list of symbol
-compiler.err.cant.type.annotate.scoping=\u65E0\u6CD5\u4F7F\u7528 type-use \u6CE8\u91CA {0} \u6765\u6CE8\u91CA\u786E\u5B9A\u4F5C\u7528\u57DF\u7ED3\u6784
-
-# 0: type, 1: type
-compiler.err.incorrect.receiver.name=\u63A5\u6536\u65B9\u540D\u79F0\u4E0E\u5C01\u95ED\u7C7B\u7C7B\u578B\u4E0D\u5339\u914D\n\u9700\u8981: {0}\n\u627E\u5230: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.receiver.type=\u63A5\u6536\u65B9\u7C7B\u578B\u4E0E\u5C01\u95ED\u7C7B\u7C7B\u578B\u4E0D\u5339\u914D\n\u9700\u8981: {0}\n\u627E\u5230: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.constructor.receiver.type=\u63A5\u6536\u65B9\u7C7B\u578B\u4E0E\u5916\u90E8\u5C01\u95ED\u7C7B\u7C7B\u578B\u4E0D\u5339\u914D\n\u9700\u8981: {0}\n\u627E\u5230: {1}
-
-# 0: type, 1: type
-compiler.err.incorrect.constructor.receiver.name=\u63A5\u6536\u65B9\u540D\u79F0\u4E0E\u5916\u90E8\u5C01\u95ED\u7C7B\u7C7B\u578B\u4E0D\u5339\u914D\n\u9700\u8981: {0}\n\u627E\u5230: {1}
-
-compiler.err.no.annotations.on.dot.class=\u7C7B\u6587\u5B57\u7C7B\u578B\u4E2D\u4E0D\u5141\u8BB8\u4F7F\u7528\u4EFB\u4F55\u6CE8\u91CA
-
-# 0: string
-compiler.err.generics.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u6CDB\u578B\n(\u8BF7\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u6CDB\u578B)
-
-# 0: string
-compiler.err.varargs.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301 variable-arity \u65B9\u6CD5\n(\u8BF7\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528 variable-arity \u65B9\u6CD5)
-
-# 0: string
-compiler.err.annotations.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u6CE8\u91CA\n(\u8BF7\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u6CE8\u91CA)
-
-# 0: string
-compiler.err.type.annotations.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u7C7B\u578B\u6CE8\u91CA\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u7C7B\u578B\u6CE8\u91CA)
-
-# 0: string
-compiler.err.annotations.after.type.params.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u65B9\u6CD5\u7C7B\u578B\u53C2\u6570\u540E\u7684\u6CE8\u91CA\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u65B9\u6CD5\u7C7B\u578B\u53C2\u6570\u540E\u7684\u6CE8\u91CA)
-
-# 0: string
-compiler.err.repeatable.annotations.not.supported.in.source=-source {0}\u4E2D\u4E0D\u652F\u6301\u91CD\u590D\u6CE8\u91CA\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u91CD\u590D\u6CE8\u91CA)
-
-# 0: string
-compiler.err.foreach.not.supported.in.source=-source {0}\u4E2D\u4E0D\u652F\u6301\u589E\u5F3A\u578B for \u5FAA\u73AF\n(\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528 for-each \u5FAA\u73AF)
-
-# 0: string
-compiler.err.static.import.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u9759\u6001\u5BFC\u5165\u58F0\u660E\n(\u8BF7\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u9759\u6001\u5BFC\u5165\u58F0\u660E)
-
-# 0: string
-compiler.err.enums.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u679A\u4E3E\n(\u8BF7\u4F7F\u7528 -source 5 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u679A\u4E3E)
-
-# 0: string
-compiler.err.diamond.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301 diamond \u8FD0\u7B97\u7B26\n(\u8BF7\u4F7F\u7528 -source 7 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528 diamond \u8FD0\u7B97\u7B26)
-
-# 0: string
-compiler.err.multicatch.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301 multi-catch \u8BED\u53E5\n(\u8BF7\u4F7F\u7528 -source 7 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528 multi-catch \u8BED\u53E5)
-
-# 0: string
-compiler.err.string.switch.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301 switch \u4E2D\u5B58\u5728\u5B57\u7B26\u4E32\n(\u8BF7\u4F7F\u7528 -source 7 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u5141\u8BB8 switch \u4E2D\u5B58\u5728\u5B57\u7B26\u4E32)
-
-# 0: string
-compiler.err.lambda.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301 lambda \u8868\u8FBE\u5F0F\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528 lambda \u8868\u8FBE\u5F0F)
-
-# 0: string
-compiler.err.method.references.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u65B9\u6CD5\u5F15\u7528\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u65B9\u6CD5\u5F15\u7528)
-
-# 0: string
-compiler.err.default.methods.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u9ED8\u8BA4\u65B9\u6CD5\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u9ED8\u8BA4\u65B9\u6CD5)
-
-# 0: string
-compiler.err.intersection.types.in.cast.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u8F6C\u6362\u4E2D\u7684\u4EA4\u53C9\u7C7B\u578B\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u9ED8\u8BA4\u65B9\u6CD5)
-
-# 0: string
-compiler.err.static.intf.methods.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u9759\u6001\u63A5\u53E3\u65B9\u6CD5\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u9759\u6001\u63A5\u53E3\u65B9\u6CD5)
-
-# 0: string
-compiler.err.static.intf.method.invoke.not.supported.in.source=-source {0} \u4E2D\u4E0D\u652F\u6301\u9759\u6001\u63A5\u53E3\u65B9\u6CD5\u8C03\u7528\n(\u8BF7\u4F7F\u7528 -source 8 \u6216\u66F4\u9AD8\u7248\u672C\u4EE5\u542F\u7528\u9759\u6001\u63A5\u53E3\u65B9\u6CD5\u8C03\u7528)
-
-########################################
-# Diagnostics for verbose resolution
-# used by Resolve (debug only)
-########################################
-
-# 0: number, 1: symbol, 2: unused
-compiler.misc.applicable.method.found=\u627E\u5230\u7B2C {0} \u4E2A\u9002\u7528\u65B9\u6CD5: {1}
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.applicable.method.found.1=\u627E\u5230\u7B2C {0} \u4E2A\u9002\u7528\u65B9\u6CD5: {1}\n({2})
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.not.applicable.method.found=\u627E\u5230\u7B2C {0} \u4E2A\u4E0D\u9002\u7528\u7684\u65B9\u6CD5: {1}\n({2})
-
-# 0: type
-compiler.misc.partial.inst.sig=\u90E8\u5206\u5B9E\u4F8B\u5316\u4E3A: {0}
-
-# 0: name, 1: symbol, 2: number, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi=\u5C06\u7C7B\u578B {1} \u7684\u65B9\u6CD5 {0} \u89E3\u6790\u4E3A\u5019\u9009\u9879 {2}\n\u9636\u6BB5: {3}\n\u5177\u6709\u5B9E\u9645\u503C: {4}\n\u5177\u6709\u7C7B\u578B\u53C2\u6570: {5}\n\u5019\u9009\u9879:
-
-# 0: name, 1: symbol, 2: unused, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi.1=\u7C7B\u578B {1} \u7684\u65B9\u6CD5 {0} \u89E3\u6790\u9519\u8BEF\n\u9636\u6BB5: {3}\n\u5177\u6709\u5B9E\u9645\u503C: {4}\n\u5177\u6709\u7C7B\u578B\u53C2\u6570: {5}\n\u5019\u9009\u9879:
-
-# 0: symbol, 1: type, 2: type
-compiler.note.deferred.method.inst=\u65B9\u6CD5 {0} \u7684\u5EF6\u8FDF\u5B9E\u4F8B\u5316\n\u5B9E\u4F8B\u5316\u7B7E\u540D: {1}\n\u76EE\u6807\u7C7B\u578B: {2}
-
-########################################
-# Diagnostics for where clause implementation
-# used by the RichDiagnosticFormatter.
-########################################
-
-compiler.misc.type.null=<\u7A7A\u503C>
-
-# X#n (where n is an int id) is disambiguated tvar name
-# 0: name, 1: number
-compiler.misc.type.var={0}#{1}
-
-# CAP#n (where n is an int id) is an abbreviation for 'captured type'
-# 0: number
-compiler.misc.captured.type=CAP#{0}
-
-# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
-# 0: number
-compiler.misc.intersection.type=INT#{0}
-
-# where clause for captured type: contains upper ('extends {1}') and lower
-# ('super {2}') bound along with the wildcard that generated this captured type ({3})
-# 0: type, 1: type, 2: type, 3: type
-compiler.misc.where.captured={0}\u4ECE{3}\u7684\u6355\u83B7\u6269\u5C55{1} \u8D85 {2}
-
-# compact where clause for captured type: contains upper ('extends {1}') along
-# with the wildcard that generated this captured type ({3})
-# 0: type, 1: type, 2: unused, 3: type
-compiler.misc.where.captured.1={0}\u4ECE{3}\u7684\u6355\u83B7\u6269\u5C55{1}
-
-# where clause for type variable: contains upper bound(s) ('extends {1}') along with
-# the kindname ({2}) and location ({3}) in which the typevar has been declared
-# 0: type, 1: list of type, 2: symbol kind, 3: symbol
-compiler.misc.where.typevar={0}\u6269\u5C55\u5DF2\u5728{2} {3}\u4E2D\u58F0\u660E\u7684{1}
-
-# compact where clause for type variable: contains the kindname ({2}) and location ({3})
-# in which the typevar has been declared
-# 0: type, 1: list of type, 2: symbol kind, 3: symbol
-compiler.misc.where.typevar.1={0}\u5DF2\u5728{2} {3}\u4E2D\u58F0\u660E
-
-# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
-# Since a fresh type-variable is synthetic - there's no location/kindname here.
-# 0: type, 1: list of type
-compiler.misc.where.fresh.typevar={0}\u6269\u5C55{1}
-
-# where clause for type variable: contains all the upper bound(s) ('extends {1}')
-# of this intersection type
-# 0: type, 1: list of type
-compiler.misc.where.intersection={0}\u6269\u5C55{1}
-
-### Where clause headers ###
-compiler.misc.where.description.captured=\u5176\u4E2D, {0}\u662F\u65B0\u7C7B\u578B\u53D8\u91CF:
-
-# 0: set of type
-compiler.misc.where.description.typevar=\u5176\u4E2D, {0}\u662F\u7C7B\u578B\u53D8\u91CF:
-
-# 0: set of type
-compiler.misc.where.description.intersection=\u5176\u4E2D, {0}\u662F\u4EA4\u53C9\u7C7B\u578B:
-
-# 0: set of type
-compiler.misc.where.description.captured.1=\u5176\u4E2D, {0}\u662F\u65B0\u7C7B\u578B\u53D8\u91CF:
-
-# 0: set of type
-compiler.misc.where.description.typevar.1=\u5176\u4E2D, {0}\u662F\u7C7B\u578B\u53D8\u91CF:
-
-compiler.misc.where.description.intersection.1=\u5176\u4E2D, {0}\u662F\u4EA4\u53C9\u7C7B\u578B:
-
-###
-# errors related to doc comments
-
-compiler.err.dc.bad.entity=HTML \u5B9E\u4F53\u9519\u8BEF
-
-compiler.err.dc.bad.gt=''>'' \u7684\u7528\u6CD5\u9519\u8BEF
-
-compiler.err.dc.bad.inline.tag=\u5185\u5D4C\u6807\u8BB0\u7684\u7528\u6CD5\u4E0D\u6B63\u786E
-
-compiler.err.dc.identifier.expected=\u9700\u8981\u6807\u8BC6\u7B26
-
-compiler.err.dc.malformed.html=\u683C\u5F0F\u9519\u8BEF\u7684 HTML
-
-compiler.err.dc.missing.semicolon=\u7F3A\u5C11\u5206\u53F7
-
-compiler.err.dc.no.content=\u65E0\u5185\u5BB9
-
-compiler.err.dc.no.tag.name='@' \u540E\u6CA1\u6709\u6807\u8BB0\u540D
-
-compiler.err.dc.gt.expected=\u9700\u8981 ''>''
-
-compiler.err.dc.ref.bad.parens=\u5F15\u7528\u4E2D\u7F3A\u5C11 '')''
-
-compiler.err.dc.ref.syntax.error=\u5F15\u7528\u4E2D\u51FA\u73B0\u8BED\u6CD5\u9519\u8BEF
-
-compiler.err.dc.ref.unexpected.input=\u610F\u5916\u7684\u6587\u672C
-
-compiler.err.dc.unexpected.content=\u610F\u5916\u7684\u5185\u5BB9
-
-compiler.err.dc.unterminated.inline.tag=\u672A\u7EC8\u6B62\u7684\u5185\u5D4C\u6807\u8BB0
-
-compiler.err.dc.unterminated.signature=\u672A\u7EC8\u6B62\u7684\u7B7E\u540D
-
-compiler.err.dc.unterminated.string=\u672A\u7EC8\u6B62\u7684\u5B57\u7B26\u4E32
-
-
Index: Build/src/main/resources/com.sun.tools/javac/resources/version.properties-template
===================================================================
diff --git a/Build/src/main/resources/com.sun.tools/javac/resources/version.properties-template b/Build/src/main/resources/com.sun.tools/javac/resources/version.properties-template
deleted file mode 100644
--- a/Build/src/main/resources/com.sun.tools/javac/resources/version.properties-template	(date 0)
+++ /dev/null	(date 0)
@@ -1,28 +0,0 @@
-#
-# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Oracle designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Oracle in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-jdk=$(JDK_VERSION)
-full=$(FULL_VERSION)
-release=$(RELEASE)
Index: Build/src/main/AndroidManifest.xml
===================================================================
diff --git a/Build/src/main/AndroidManifest.xml b/Build/src/main/AndroidManifest.xml
deleted file mode 100644
--- a/Build/src/main/AndroidManifest.xml	(date 0)
+++ /dev/null	(date 0)
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.tyron.build">
-
-</manifest>
\ No newline at end of file
Index: Build/src/test/java/com/tyron/build/ExampleUnitTest.java
===================================================================
diff --git a/Build/src/test/java/com/tyron/build/ExampleUnitTest.java b/Build/src/test/java/com/tyron/build/ExampleUnitTest.java
deleted file mode 100644
--- a/Build/src/test/java/com/tyron/build/ExampleUnitTest.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,17 +0,0 @@
-package com.tyron.build;
-
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-/**
- * Example local unit test, which will execute on the development machine (host).
- *
- * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
- */
-public class ExampleUnitTest {
-    @Test
-    public void addition_isCorrect() {
-        assertEquals(4, 2 + 2);
-    }
-}
\ No newline at end of file
Index: Build/src/androidTest/java/com/tyron/build/ExampleInstrumentedTest.java
===================================================================
diff --git a/Build/src/androidTest/java/com/tyron/build/ExampleInstrumentedTest.java b/Build/src/androidTest/java/com/tyron/build/ExampleInstrumentedTest.java
deleted file mode 100644
--- a/Build/src/androidTest/java/com/tyron/build/ExampleInstrumentedTest.java	(date 0)
+++ /dev/null	(date 0)
@@ -1,26 +0,0 @@
-package com.tyron.build;
-
-import android.content.Context;
-
-import androidx.test.platform.app.InstrumentationRegistry;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.junit.Assert.*;
-
-/**
- * Instrumented test, which will execute on an Android device.
- *
- * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
- */
-@RunWith(AndroidJUnit4.class)
-public class ExampleInstrumentedTest {
-    @Test
-    public void useAppContext() {
-        // Context of the app under test.
-        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
-        assertEquals("com.tyron.build.test", appContext.getPackageName());
-    }
-}
\ No newline at end of file
Index: Build/build.gradle
===================================================================
diff --git a/Build/build.gradle b/Build/build.gradle
deleted file mode 100644
--- a/Build/build.gradle	(date 0)
+++ /dev/null	(date 0)
@@ -1,46 +0,0 @@
-plugins {
-    id 'com.android.library'
-}
-
-android {
-    compileSdk 31
-
-    defaultConfig {
-        minSdk 26
-        targetSdk 31
-        versionCode 1
-        versionName "1.0"
-
-        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
-        consumerProguardFiles "consumer-rules.pro"
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
-        }
-    }
-    compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_8
-        targetCompatibility JavaVersion.VERSION_1_8
-    }
-}
-
-dependencies {
-    implementation 'androidx.annotation:annotation:1.2.0'
-    implementation project(path: ':common')
-    implementation 'androidx.lifecycle:lifecycle-livedata-core:2.3.1'
-    implementation 'androidx.lifecycle:lifecycle-viewmodel:2.3.1'
-    testImplementation 'junit:junit:4.+'
-    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
-    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
-
-    implementation 'com.android.tools:sdklib:25.3.0'
-    implementation 'com.android.tools:r8:2.2.64'
-
-    api files (
-            'libs/javac-new.jar',
-            'libs/apksigner.jar'
-    )
-}
\ No newline at end of file
Index: Build/.gitignore
===================================================================
diff --git a/Build/.gitignore b/Build/.gitignore
deleted file mode 100644
--- a/Build/.gitignore	(date 0)
+++ /dev/null	(date 0)
@@ -1,1 +0,0 @@
-/build
\ No newline at end of file
Index: Build/proguard-rules.pro
===================================================================
diff --git a/Build/proguard-rules.pro b/Build/proguard-rules.pro
deleted file mode 100644
--- a/Build/proguard-rules.pro	(date 0)
+++ /dev/null	(date 0)
@@ -1,21 +0,0 @@
-# Add project specific ProGuard rules here.
-# You can control the set of applied configuration files using the
-# proguardFiles setting in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
-#-renamesourcefileattribute SourceFile
\ No newline at end of file
diff --git a/Build/consumer-rules.pro b/Build/consumer-rules.pro
deleted file mode 100644
diff --git a/Build/libs/apksigner.jar b/Build/libs/apksigner.jar
deleted file mode 100644
diff --git a/Build/libs/javac-new.jar b/Build/libs/javac-new.jar
deleted file mode 100644
